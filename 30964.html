<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16-next.png"><link rel="mask-icon" href="/images/favicon/safari-pinned-tab.svg" color="#222"><meta name="msapplication-config" content="/images/favicon/browserconfig.xml"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="z8FZsD3BLa5a48lA2pIVAyEG_a7yS8KId63-e8zvJKI"><meta name="msvalidate.01" content="0804A62A89E386620E5C2AC212435A3C"><meta name="yandex-verification" content="66b23ce89136e07b"><meta name="baidu-site-verification" content="codeva-hf40ye2Gtf"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"paynewu-blog.github.io",root:"/",scheme:"Mist",version:"7.8.0",exturl:!0,sidebar:{position:"right",width:380,display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!0,lazyload:!0,pangu:!0,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null,activeClass:"valine"},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:5,unescape:!1,preload:!0},motion:{enable:!0,async:!0,transition:{post_block:"bounceDownIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="keywords" content="GC"><meta name="robots" content="index,follow"><meta name="GOOGLEBOT" content="index,follow"><meta name="author" content="Payne的个人小屋"><meta name="description" content="如何判断对象是垃圾  经典判断方法 1：引用计数法   思路很简单，但是如果出现循环引用，即 A 引用 B，B 又引用 A，这种情况下就不好办了。所以一般还使用了另一种称为“可达性分析”的判断方法。   经典判断方法 2：可达性分析   如果 A 引用 B，B 又引用 A（发生了循环引用问题），这 2 个对象是否能被 GC回收？  关键不是在于 A、B 之间是否有引用，而是 A、B 是否可以一直向"><meta property="og:type" content="article"><meta property="og:title" content="GC垃圾回收原理"><meta property="og:url" content="https://paynewu-blog.github.io/30964.html"><meta property="og:site_name" content="Payne的个人小屋"><meta property="og:description" content="如何判断对象是垃圾  经典判断方法 1：引用计数法   思路很简单，但是如果出现循环引用，即 A 引用 B，B 又引用 A，这种情况下就不好办了。所以一般还使用了另一种称为“可达性分析”的判断方法。   经典判断方法 2：可达性分析   如果 A 引用 B，B 又引用 A（发生了循环引用问题），这 2 个对象是否能被 GC回收？  关键不是在于 A、B 之间是否有引用，而是 A、B 是否可以一直向"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxyvrbqaj20ev07ymxp.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxyyymz2j20hj084mxt.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxz0rom5j20g405sjrs.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxz5gnwtj20m80ccab1.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxz88d9ej20iu0adjrm.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry2t0q3mj20iu0adjrm.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxzb2sivj20j90aoq37.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxzdg4ivj20j90aoq37.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxzfpp7mj20j30akweq.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxzjx0woj20km0e9dge.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry01acb0j20ns0723z4.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry02qg80j20u00jnjsq.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry0lve2fj20ky0cw74z.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry3fxogzj20jm0cqgmc.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry0nc0w7j20m60bq3zi.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry0rz9rhj20ly0dcdgv.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry0woahuj20li0dg3zk.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry0xlvk2j20ke0eujsh.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry0zgme5j20de0ew74o.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry11sat4j20jm0g8gmj.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry13l204j20j90hg0ty.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry16k2irj219a0mijt1.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1b60glj20u00jbjsz.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1bnt2nj20u00afq3t.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry3j8ripj20k007oaan.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1efxdfj20k007eaak.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1gs145j20gf0a1aae.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1iktitj20dh09aaa9.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1mixvuj20dm0983yt.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1nh65sj20dc09574h.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1o63q3j20di097jrs.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry3mdckmj20dc097aa8.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1poir8j208w07caa0.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1rjw8kj20u0080gm0.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1y8q9zj20u0080aai.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry20tepej20u00aj74t.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry22szyaj20u00ajq3l.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry24pjryj20gp07ujrr.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry28bcsjj20ii0b5jry.jpg"><meta property="article:published_time" content="2022-04-30T11:05:41.000Z"><meta property="article:modified_time" content="2025-01-06T03:07:07.074Z"><meta property="article:author" content="Payne Wu"><meta property="article:tag" content="GC"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxyvrbqaj20ev07ymxp.jpg"><link rel="canonical" href="https://paynewu-blog.github.io/30964.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>GC垃圾回收原理 | Payne的个人小屋</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Payne的个人小屋" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Payne的个人小屋</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">Every day</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section">首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section">文章归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section">文章标签</a></li><li class="menu-item menu-item-message"><a href="/message/" rel="section">留言于我</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger">文章搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://paynewu-blog.github.io/30964.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/favicon/android-chrome-512x512.png"><meta itemprop="name" content="Payne Wu"><meta itemprop="description" content="格物致知，知行合一，致良知"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Payne的个人小屋"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">GC垃圾回收原理</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-04-30 19:05:41" itemprop="dateCreated datePublished" datetime="2022-04-30T19:05:41+08:00">2022-04-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-01-06 11:07:07" itemprop="dateModified" datetime="2025-01-06T11:07:07+08:00">2025-01-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/GC/" itemprop="url" rel="index"><span itemprop="name">GC</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/GC/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" itemprop="url" rel="index"><span itemprop="name">垃圾回收</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/30964.html#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/30964.html" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>5.8k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>5 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="如何判断对象是垃圾"><a class="markdownIt-Anchor" href="#如何判断对象是垃圾"></a> 如何判断对象是垃圾</h2><h3 id="经典判断方法-1引用计数法"><a class="markdownIt-Anchor" href="#经典判断方法-1引用计数法"></a> 经典判断方法 1：引用计数法</h3><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxyvrbqaj20ev07ymxp.jpg" alt=""></p><p>思路很简单，但是如果出现循环引用，即 A 引用 B，B 又引用 A，这种情况下就不好办了。所以一般还使用了另一种称为“可达性分析”的判断方法。</p><h3 id="经典判断方法-2可达性分析"><a class="markdownIt-Anchor" href="#经典判断方法-2可达性分析"></a> 经典判断方法 2：可达性分析</h3><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxyyymz2j20hj084mxt.jpg" alt=""></p><p>如果 A 引用 B，B 又引用 A（发生了循环引用问题），这 2 个对象是否能被 GC回收？</p><p>关键不是在于 A、B 之间是否有引用，而是 A、B 是否可以一直向上追溯到 GC Roots。如果与 GC Roots<br>没有关联，则会被回收；否则，将继续存活。</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxz0rom5j20g405sjrs.jpg" alt=""></p><p>上图是一个用“可达性分析”标记垃圾对象的示例图，灰色的对象表示不可达对象，将等待回收</p><h2 id="哪些内存区域需要-gc"><a class="markdownIt-Anchor" href="#哪些内存区域需要-gc"></a> 哪些内存区域需要 GC</h2><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxz5gnwtj20m80ccab1.jpg" alt=""></p><h2 id="常用的-4-种-gc-算法"><a class="markdownIt-Anchor" href="#常用的-4-种-gc-算法"></a> 常用的 4 种 GC 算法</h2><h3 id="mark-sweep-标记清除法"><a class="markdownIt-Anchor" href="#mark-sweep-标记清除法"></a> mark-sweep 标记清除法</h3><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxz88d9ej20iu0adjrm.jpg" alt=""></p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry2t0q3mj20iu0adjrm.jpg" alt=""></p><p>黑色区域表示待清理的垃圾对象，标记出来后直接清空。</p><p>优：简单快速；</p><p>缺：产生很多内存碎片。</p><h3 id="mark-copy-标记复制法"><a class="markdownIt-Anchor" href="#mark-copy-标记复制法"></a> mark-copy 标记复制法</h3><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxzb2sivj20j90aoq37.jpg" alt=""></p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxzdg4ivj20j90aoq37.jpg" alt=""></p><p>思路也很简单，将内存对半分，总是保留一块空着（上图中的右侧），将左侧存活的对象（浅灰色区域）复制到右侧，然后左侧全部清空。</p><p>优：避免了内存碎片问题；</p><p>缺：内存浪费很严重，相当于只能使用 50% 的内存。</p><h3 id="mark-compact-标记-整理也称标记-压缩法"><a class="markdownIt-Anchor" href="#mark-compact-标记-整理也称标记-压缩法"></a> mark-compact 标记-整理（也称标记-压缩）法</h3><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxzfpp7mj20j30akweq.jpg" alt=""></p><p>将垃圾对象清理掉后，同时将剩下的存活对象进行整理挪动（类似于 windows 的磁盘碎片整理），保证它们占用的空间连续。</p><p>优：节约了内存，并避免了内存碎片问题。</p><p>缺：整理过程会降低 GC 的效率。</p><p>上述三种算法，每种都有各自的优缺点，都不完美；在现代 JVM 中，往往是综合使用的。经过大量实际分析，发现内存中的对象，大致可以分为两类：</p><p>有些生命周期很短，比如一些局部变量/临时对象；</p><p>而另一些则会存活很久，典型的比如 websocket 长连接中的 connection 对象。如下图，纵向 y 轴可以理解分配内存的字节数，横向<br>x 轴理解为随着时间流逝（伴随着 GC）。</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxzjx0woj20km0e9dge.jpg" alt=""></p><p>可以发现大部分对象其实相当短命，很少有对象能在 GC 后活下来，因此诞生了分代的思想。</p><h3 id="generation-collect-分代收集算法"><a class="markdownIt-Anchor" href="#generation-collect-分代收集算法"></a> generation-collect 分代收集算法</h3><p>如下图所示，可以将内存分成了三大块：年青代（Young Genaration）、老年代（Old Generation）、永久代（Permanent<br>Generation）。其中 Young Genaration 更是又细为分<br>eden、S0、S1 三个区。</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry01acb0j20ns0723z4.jpg" alt=""></p><p>结合我们经常使用的一些 jvm 调优参数后，一些参数能影响的各区域内存大小值，示意图如下：</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry02qg80j20u00jnjsq.jpg" alt=""></p><h2 id="gc-的主要过程"><a class="markdownIt-Anchor" href="#gc-的主要过程"></a> GC 的主要过程</h2><p>刚开始时，对象分配在 eden 区，s0（即：from）及 s1（即：to）区几乎是空着。</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry0lve2fj20ky0cw74z.jpg" alt=""></p><p>随着应用的运行，越来越多的对象被分配到 eden 区。</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry3fxogzj20jm0cqgmc.jpg" alt=""></p><p>当 eden 区放不下时，就会发生 minor GC（也被称为 young GC）。</p><p>首先当然是要先标识出不可达垃圾对象（即下图中的黄色块）；</p><p>然后将可达对象，移动到 s0 区（即：4个淡蓝色的方块挪到s0区）；</p><p>然后将黄色的垃圾块清理掉，这一轮后 eden 区就成空的了。</p><p>注：这里其实已经综合运用了“【标记-清理eden】+【标记-复制 eden-&gt;s0】”算法。</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry0nc0w7j20m60bq3zi.jpg" alt=""></p><p>随着时间推移，eden 如果又满了，再次触发 minor GC，同样还是先做标记，这时 eden 和 s0 区可能都有垃圾对象了（下图中的黄色块）。</p><p>这时 s1（即：to）区是空的，s0 区和 eden 区的存活对象，将直接搬到 s1 区。</p><p>然后将 eden 和 s0 区的垃圾清理掉，这一轮 minor GC 后，eden 和 s0 区就变成了空的了。</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry0rz9rhj20ly0dcdgv.jpg" alt=""></p><p>继续随着对象的不断分配，eden 空可能又满了，这时会重复刚才的 minor GC 过程。不过要注意的是：</p><p>这时候 s0 是空的，所以 s0 与 s1 的角色其实会互换。即存活的对象，会从 eden 和 s1 区，向 s0 区移动。</p><p>然后再把 eden 和 s1 区中的垃圾清除，这一轮完成后，eden 与 s1 区变成空的，如下图。</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry0woahuj20li0dg3zk.jpg" alt=""></p><h3 id="代龄与晋升"><a class="markdownIt-Anchor" href="#代龄与晋升"></a> 代龄与晋升</h3><p>对于那些比较“长寿”的对象一直在 s0 与 s1 中挪来挪去，一来很占地方，而且也会造成一定开销，降低 gc<br>效率，于是有了“代龄(age)”及“晋升”。</p><p>对象在年青代的 3 个区（edge,s0,s1）之间，每次从一个区移到另一区，年龄 +1，在 young 区达到一定的年龄阈值后，将晋升到老年代。</p><p>下图中是 8，即挪动 8 次后，如果还活着，下次 minor GC 时，将移动到 Tenured 区。</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry0xlvk2j20ke0eujsh.jpg" alt=""></p><h3 id="晋升的主要过程"><a class="markdownIt-Anchor" href="#晋升的主要过程"></a> 晋升的主要过程</h3><p>下图是晋升的主要过程：对象先分配在年青代，经过多次 Young GC 后，如果对象还活着，晋升到老年代。</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry0zgme5j20de0ew74o.jpg" alt=""></p><p>如果老年代，最终也放满了，就会发生 major GC（即 Full<br>GC）。由于老年代的的对象通常会比较多，标记-清理-整理（压缩）的耗时通常也会比较长，会让应用出现卡顿的现象。这也就是为什么很多应用要优化，尽量避免或减少<br>Full GC<br>的原因。</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry11sat4j20jm0g8gmj.jpg" alt=""></p><p>注：上面的过程主要来自 oracle 官网的资料，但是有一个细节官网没有提到：如果分配的新对象比较大，eden<br>区放不下，但是 old 区可以放下时，会直接分配到 old 区。</p><p>即没有晋升这一过程，直接到老年代了。</p><h3 id="gc-流程图"><a class="markdownIt-Anchor" href="#gc-流程图"></a> GC 流程图</h3><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry13l204j20j90hg0ty.jpg" alt=""></p><h2 id="8-种垃圾回收器"><a class="markdownIt-Anchor" href="#8-种垃圾回收器"></a> 8 种垃圾回收器</h2><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry16k2irj219a0mijt1.jpg" alt=""></p><p>这些回收器都是基于分代的，把 G1 除外，按回收的分代划分如下。</p><p>横线以上的 3 种：Serial、ParNew、Parellel Scavenge 都是回收年青代的；</p><p>横线以下的 3 种：CMS、Serial Old、Parallel Old 都是回收老年代的。</p><p>接下来，我们将以上提到的 8 种垃圾回收器逐一讲解，其中 CMS、G1、ZGC 这三种收集器是面试考试重点，我也会着重讲解。</p><h3 id="serial-收集器"><a class="markdownIt-Anchor" href="#serial-收集器"></a> Serial 收集器</h3><p>单线程用标记-复制算法，快刀斩乱麻，单线程的好处避免上下文切换，早期的机器，大多是单核，也比较实用。但执行期间会发生<br>STW（Stop The World）。</p><h3 id="parnew-收集器"><a class="markdownIt-Anchor" href="#parnew-收集器"></a> ParNew 收集器</h3><p>Serial 的多线程版本，也同样会 STW，在多核机器上会更适用。</p><h3 id="parallel-scavenge-收集器"><a class="markdownIt-Anchor" href="#parallel-scavenge-收集器"></a> Parallel Scavenge 收集器</h3><p>ParNew 的升级版本，主要区别在于提供了两个参数：</p><p>-XX:MaxGCPauseMillis 最大垃圾回收停顿时间；</p><p>-XX:GCTimeRatio 垃圾回收时间与总时间占比。</p><p>通过这 2 个参数，可以适当控制回收的节奏，更关注于吞吐率，即总时间与垃圾回收时间的比例。</p><h3 id="serial-old-收集器"><a class="markdownIt-Anchor" href="#serial-old-收集器"></a> Serial Old 收集器</h3><p>因为老年代的对象通常比较多，占用的空间通常也会更大。如果采用复制算法，得留 50%<br>的空间用于复制，相当不划算；而且因为对象多，从一个区，复制到另一个区，耗时也会比较长。</p><p>所以老年代的收集，通常会采用“标记-整理”法。从名字就可以看出来，这是单线程（串行）的， 依然会有 STW。</p><h3 id="parallel-old-收集器"><a class="markdownIt-Anchor" href="#parallel-old-收集器"></a> Parallel Old 收集器</h3><p>一句话：Serial Old 的多线程版本。</p><h3 id="cms-收集器"><a class="markdownIt-Anchor" href="#cms-收集器"></a> CMS 收集器</h3><p>Concurrent Mark Sweep，从名字上看，就能猜出它是并发多线程的。这是 JDK 7 中广泛使用的收集器，有必要多说一下。</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1b60glj20u00jbjsz.jpg" alt=""></p><h3 id="g1-收集器"><a class="markdownIt-Anchor" href="#g1-收集器"></a> G1 收集器</h3><p>鉴于 CMS 的一些不足之外，比如：老年代内存碎片化，STW 时间虽然已经改善了很多，但是仍然有提升空间。G1<br>就横空出世了，它对于 heap 区的内存划思路很新颖，有点算法中分治法“分而治之”的味道。</p><blockquote><p>G1 的全称是 Garbage-First</p></blockquote><h4 id="g1-垃圾收集器的原理"><a class="markdownIt-Anchor" href="#g1-垃圾收集器的原理"></a> G1 垃圾收集器的原理</h4><p>如下图，G1 将 heap 内存区，划分为一个个大小相等（1-32M，2的 n 次方）、内存连续的 Region 区域，每个 region<br>都对应 Eden、Survivor 、Old、Humongous 四种角色之一，但是 region<br>与 region 之间不要求连续。</p><blockquote><p>注：Humongous，简称 H 区是专用于存放超大对象的区域，通常 &gt;= 1/2 Region Size，且只有 Full GC 阶段，才会回收<br>H 区，避免了频繁扫描、复制/移动大对象。</p></blockquote><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1bnt2nj20u00afq3t.jpg" alt=""></p><p>所有的垃圾回收，都是基于 1 个个 region 的。JVM 内部知道，哪些 region 的对象最少（即该区域最空），总是会优先收集这些<br>region（因为对象少，内存相对较空，肯定快）。这就是 Garbage-First 得名的由来，G<br>即是 Garbage 的缩写，1 即 First。</p><ol><li>G1 Young GC young GC 前：</li></ol><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry3j8ripj20k007oaan.jpg" alt=""></p><p>young GC 后：</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1efxdfj20k007eaak.jpg" alt=""></p><p>理论上讲，只要有一个 Empty Region（空区域），就可以进行垃圾回收。</p><p>由于 region 与 region 之间并不要求连续，而使用 G1 的场景通常是大内存，比如 64G 甚至更大，为了提高扫描根对象和标记的效率，G1<br>使用了二个新的辅助存储结构：</p><ul><li><p>Remembered Sets：简称 RSets，用于根据每个 region 里的对象，是从哪指向过来的（即谁引用了我），每个 Region<br>都有独立的 RSets（Other Region -&gt; Self Region）。</p></li><li><p>Collection Sets ：简称 CSets，记录了等待回收的 Region 集合，GC 时这些 Region 中的对象会被回收（copied<br>or moved）。</p></li></ul><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1gs145j20gf0a1aae.jpg" alt=""></p><p>RSets 的引入，在 YGC 时，将年青代 Region 的 RSets 做为根对象，可以避免扫描老年代的 region，能大大减轻 GC<br>的负担。</p><blockquote><p>注：在老年代收集 Mixed GC 时，RSets 记录了 Old-&gt;Old 的引用，也可以避免扫描所有 Old 区。</p></blockquote><p>Old Generation Collection（也称为 Mixed GC）</p><p>按 oracle 官网文档描述，分为 5 个阶段：Initial Mark(STW) -&gt; Root Region Scan -&gt; Cocurrent Marking -&gt;<br>Remark(STW) -&gt; Copying/Cleanup(<br>STW &amp;&amp; Concurrent)</p><blockquote><p>注：也有很多文章会把 Root Region Scan 省略掉，合并到 Initial Mark 里，变成 4 个阶段。</p></blockquote><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1iktitj20dh09aaa9.jpg" alt=""></p><p>阶段 1：存活对象的“初始标记”依赖于 Young GC，GC 日志中会记录成 young 字样。</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1mixvuj20dm0983yt.jpg" alt=""></p><p>阶段 2：并发标记过程中，如果发现某些 region 全是空的，会被直接清除。</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1nh65sj20dc09574h.jpg" alt=""></p><p>阶段 3：进入重新标记阶段。</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1o63q3j20di097jrs.jpg" alt=""></p><p>阶段 4：并发复制/清查阶段。这个阶段，Young 区和 Old 区的对象有可能会被同时清理。GC 日志中，会记录为 mixed<br>字段，这也是 G1 的老年代收集，也称为 Mixed GC 的原因。</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry3mdckmj20dc097aa8.jpg" alt=""></p><p>上图是，老年代收集完后的示意图。</p><p>通过这几个阶段的分析，虽然看上去很多阶段仍然会发生 STW，但是 G1 提供了一个预测模型，通过统计方法，根据历史数据来预测本次收集，需要选择多少个<br>Region 来回收，尽量满足用户的预期停顿值（-XX:MaxGCPauseMillis<br>参数可指定预期停顿值）。</p><blockquote><p>注：如果 Mixed GC 仍然效果不理想，跟不上新对象分配内存的需求，会使用 Serial Old GC（Full GC）强制收集整个<br>Heap。</p></blockquote><p>小结：与 CMS 相比，G1 有内存整理过程（标记-压缩），避免了内存碎片；STW 时间可控（能预测 GC 停顿时间）。</p><h3 id="zgc截止目前史上最好的-gc-收集器"><a class="markdownIt-Anchor" href="#zgc截止目前史上最好的-gc-收集器"></a> ZGC（截止目前史上最好的 GC 收集器）</h3><p>在 G1 的基础上，它做了如下 7 点改进</p><p><strong>动态调整大小的 Region</strong><br>G1 中每个 Region 的大小是固定的，创建和销毁 Region，可以动态调整大小，内存使用更高效。</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1poir8j208w07caa0.jpg" alt=""></p><p><strong>不分代，干掉了 RSets</strong><br>G1 中每个 Region 需要借助额外的 RSets 来记录“谁引用了我”，占用了额外的内存空间，每次对象移动时，RSets<br>也需要更新，会产生开销。</p><p><strong>带颜色的指针 Colored Pointer</strong></p><p>这里的指针类似 Java 中的引用，意为对某块虚拟内存的引用。ZGC 采用了64位指针（注：目前只支持 linux 64<br>位系统），将 42-45 这 4 个 bit 位置赋予了不同含义，即所谓的颜色标志位，也换为指针的 metadata。</p><ul><li><p>finalizable 位：仅 finalizer（类比 C++ 中的析构函数）可访问；</p></li><li><p>remap 位：指向对象当前（最新）的内存地址，参考下面提到的relocation；</p></li><li><p>marked0 &amp;&amp; marked1 位：用于标志可达对象。</p></li></ul><p>这 4 个标志位，同一时刻只会有 1 个位置是 1。每当指针对应的内存数据发生变化，比如内存被移动，颜色会发生变化。</p><p><strong>读屏障 Load Barrier</strong></p><p>传统 GC 做标记时，为了防止其他线程在标记期间修改对象，通常会简单的 STW。而 ZGC 有了 Colored Pointer<br>后，引入了所谓的“读屏障”。</p><p>当指针引用的内存正被移动时，指针上的颜色就会变化，ZGC 会先把指针更新成最新状态，然后再返回（你可以回想下<br>Java 中的 volatile 关键字，有异曲同工之妙）。这样仅读取该指针时，可能会略有开销，而不用将整个 heap STW。</p><p><strong>重定位 Relocation</strong></p><p>如下图，在标记过程中，先从 Roots 对象找到了直接关联的下级对象 1，2，4。</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1rjw8kj20u0080gm0.jpg" alt=""></p><p>然后继续向下层标记，找到了 5，8 对象， 此时已经可以判定 3，6，7 为垃圾对象。</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1y8q9zj20u0080aai.jpg" alt=""></p><p>如果按常规思路，一般会将 8 从最右侧的 Region，移动或复制到中间的 Region，然后再将中间 Region 的 3<br>干掉，最后再对中间 Region 做压缩 compact 整理。</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry20tepej20u00aj74t.jpg" alt=""></p><p>但 ZGC 做得更高明，它直接将 4，5 复制到了一个空的新 Region 就完事了，然后中间的 2 个 Region<br>直接废弃，或理解为“释放”，作为下次回收的“新” Region。这样的好处是避免了中间 Region 的 compact<br>整理过程。</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry22szyaj20u00ajq3l.jpg" alt=""></p><p>最后，指针重新调整为正确的指向（即：remap），而且上一阶段的 remap 与下一阶段的mark是混在一起处理的，相对更高效。</p><p><strong>多重映射 Multi-Mapping</strong></p><p>这个优化，说实话没完全看懂，只能谈下自己的理解（如果有误，欢迎指正)。虚拟内存与实际物理内存，OS<br>会维护一个映射关系，才能正常使用，如下图：</p><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry24pjryj20gp07ujrr.jpg" alt=""></p><p>zgc 的 64 位颜色指针，在解除映射关系时，代价较高（需要屏蔽额外的 42-45 的颜色标志位）。考虑到这 4 个标志位，同<br>1 时刻，只会有 1 位置成 1（如下图），另外 finalizable<br>标志位，永远不希望被解除映射绑定（可不用考虑映射问题）。</p><p>所以剩下 3 种颜色的虚拟内存，可以都映射到同1段物理内存。即映射复用，或者更通俗点讲，本来 3 种不同颜色的指针，哪怕<br>0-41 位完全相同，也需要映射到 3 段不同的物理内存，现在只需要映射到同 1 段物理内存即可。</p><p>支持 <span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9OVU1BLzY5MDYwMjU/ZnI9YWxhZGRpbg==">NUMA 架构<i class="fa fa-external-link-alt"></i></span></p><p>NUMA 是一种多核服务器的架构，简单来讲，一个多核服务器（比如 2core），每个 cpu<br>都有属于自己的存储器，会比访问另一个核的存储器会慢很多（类似于就近访问更快）。</p><p>相对之前的 GC 算法，ZGC 首次支持了 NUMA 架构，申请堆内存时，判断当前线程属是哪个CPU在执行，然后就近申请该<br>CPU 能使用的内存。</p><p>小结：革命性的 ZGC 经过上述一堆优化后，每次 GC 总体卡顿时间按官方说法&lt;10ms。</p><blockquote><p>注：启用 zgc，需要设置 -XX:+UnlockExperimentalVMOptions -XX:+UseZGC。</p></blockquote><h4 id="remap-的流程图"><a class="markdownIt-Anchor" href="#remap-的流程图"></a> Remap 的流程图</h4><p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry28bcsjj20ii0b5jry.jpg" alt=""></p></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Payne</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://paynewu-blog.github.io/30964.html" title="GC垃圾回收原理">https://paynewu-blog.github.io/30964.html</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/GC/" rel="tag"><i class="fa fa-tag"></i> GC</a></div><div class="post-nav"><div class="post-nav-item"><a href="/37065.html" rel="prev" title="雷电模拟器抓包配置"><i class="fa fa-chevron-left"></i> 雷电模拟器抓包配置</a></div><div class="post-nav-item"><a href="/58816.html" rel="next" title="少有人走的路">少有人走的路 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%9E%83%E5%9C%BE"><span class="nav-number">1.</span> <span class="nav-text">如何判断对象是垃圾</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95-1%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="nav-number">1.1.</span> <span class="nav-text">经典判断方法 1：引用计数法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95-2%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90"><span class="nav-number">1.2.</span> <span class="nav-text">经典判断方法 2：可达性分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E9%9C%80%E8%A6%81-gc"><span class="nav-number">2.</span> <span class="nav-text">哪些内存区域需要 GC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84-4-%E7%A7%8D-gc-%E7%AE%97%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">常用的 4 种 GC 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mark-sweep-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E6%B3%95"><span class="nav-number">3.1.</span> <span class="nav-text">mark-sweep 标记清除法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mark-copy-%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">mark-copy 标记复制法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mark-compact-%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E4%B9%9F%E7%A7%B0%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%E6%B3%95"><span class="nav-number">3.3.</span> <span class="nav-text">mark-compact 标记-整理（也称标记-压缩）法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#generation-collect-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.</span> <span class="nav-text">generation-collect 分代收集算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gc-%E7%9A%84%E4%B8%BB%E8%A6%81%E8%BF%87%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">GC 的主要过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E9%BE%84%E4%B8%8E%E6%99%8B%E5%8D%87"><span class="nav-number">4.1.</span> <span class="nav-text">代龄与晋升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%8B%E5%8D%87%E7%9A%84%E4%B8%BB%E8%A6%81%E8%BF%87%E7%A8%8B"><span class="nav-number">4.2.</span> <span class="nav-text">晋升的主要过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gc-%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-number">4.3.</span> <span class="nav-text">GC 流程图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text">8 种垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#serial-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">5.1.</span> <span class="nav-text">Serial 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#parnew-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">5.2.</span> <span class="nav-text">ParNew 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#parallel-scavenge-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">5.3.</span> <span class="nav-text">Parallel Scavenge 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#serial-old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">5.4.</span> <span class="nav-text">Serial Old 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#parallel-old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">5.5.</span> <span class="nav-text">Parallel Old 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cms-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">5.6.</span> <span class="nav-text">CMS 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#g1-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">5.7.</span> <span class="nav-text">G1 收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#g1-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">5.7.1.</span> <span class="nav-text">G1 垃圾收集器的原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zgc%E6%88%AA%E6%AD%A2%E7%9B%AE%E5%89%8D%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%A5%BD%E7%9A%84-gc-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">5.8.</span> <span class="nav-text">ZGC（截止目前史上最好的 GC 收集器）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#remap-%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-number">5.8.1.</span> <span class="nav-text">Remap 的流程图</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Payne Wu" src="/images/favicon/android-chrome-512x512.png"><p class="site-author-name" itemprop="name">Payne Wu</p><div class="site-description" itemprop="description">格物致知，知行合一，致良知</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">146</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">140</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">62</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2F6d3BheW5l" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;azwpayne"><i class="fab fa-github fa-fw"></i>GitHub</span> </span><span class="links-of-author-item"><span class="exturl" data-url="bWFpbHRvOnBheW5ld3UwNzE5QGdtYWlsLmNvbQ==" title="E-Mail → mailto:paynewu0719@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS93dS16aGktcGVuZy03Mi03OA==" title="ZhiHu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;wu-zhi-peng-72-78"><i class="fa fa-magic fa-fw"></i>ZhiHu</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly93ZWliby5jb20vdS82OTg3MjM0NDgz" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;6987234483"><i class="fab fa-weibo fa-fw"></i>Weibo</span></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><span class="exturl" data-url="aHR0cHM6Ly9iZWlhbi5taWl0Lmdvdi5jbg==">湘ICP备2021019893号-1</span></div><div class="copyright">&copy; <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Payne Wu</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">277k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">4:12</span></div><div style="display:none"><script src="//s95.cnzz.com/z_stat.php?id=true&web_id=true"></script></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/gh/paynewu-blog/paynewu-blog.github.io@master/js/utils.js"></script><script src="https://cdn.jsdelivr.net/gh/paynewu-blog/paynewu-blog.github.io@master/js/motion.js"></script><script src="https://cdn.jsdelivr.net/gh/paynewu-blog/paynewu-blog.github.io@master/js/schemes/muse.js"></script><script src="https://cdn.jsdelivr.net/gh/paynewu-blog/paynewu-blog.github.io@master/js/next-boot.js"></script><script defer src="/lib/three/three.min.js"></script><script defer src="/lib/three/three-waves.min.js"></script><script defer src="/lib/three/canvas_lines.min.js"></script><script defer src="/lib/three/canvas_sphere.min.js"></script><script>!function(){var e,t,o,n,r,a=document.getElementsByTagName("link");if(0<a.length)for(i=0;i<a.length;i++)"canonical"==a[i].rel.toLowerCase()&&a[i].href&&(e=a[i].href);t=e?e.split(":")[0]:window.location.protocol.split(":")[0],e=e||window.location.href,window,n=e,r=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(n)||(o="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",r?(o+="?r="+encodeURIComponent(document.referrer),n&&(o+="&l="+n)):n&&(o+="?l="+n),(new Image).src=o)}()</script><script src="https://cdn.jsdelivr.net/gh/paynewu-blog/paynewu-blog.github.io@master/js/local-search.js"></script><script>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script><script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script><script>window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://paynewu-blog.github.io/30964.html',]
      });
      });</script><script>NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : true,
      appId      : 'v5yI1sEaxpTl6gCkO0dApNOH-gzGzoHsz',
      appKey     : 'ugl27izkUCvh7RIyvo7kcFCv',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});</script></body></html>