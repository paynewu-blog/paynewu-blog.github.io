<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16-next.png"><link rel="mask-icon" href="/images/favicon/safari-pinned-tab.svg" color="#222"><meta name="msapplication-config" content="/images/favicon/browserconfig.xml"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="z8FZsD3BLa5a48lA2pIVAyEG_a7yS8KId63-e8zvJKI"><meta name="msvalidate.01" content="0804A62A89E386620E5C2AC212435A3C"><meta name="yandex-verification" content="66b23ce89136e07b"><meta name="baidu-site-verification" content="codeva-hf40ye2Gtf"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"paynewu-blog.github.io",root:"/",scheme:"Mist",version:"7.8.0",exturl:!0,sidebar:{position:"right",width:380,display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!0,lazyload:!0,pangu:!0,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null,activeClass:"valine"},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:5,unescape:!1,preload:!0},motion:{enable:!0,async:!0,transition:{post_block:"bounceDownIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="keywords" content="go"><meta name="robots" content="index,follow"><meta name="GOOGLEBOT" content="index,follow"><meta name="author" content="Payne的个人小屋"><meta name="description" content="在了解golang的测试之前，先了解一下go语言自带的测试工具-go test   go test工具 Go语言中的测试依赖go test命令。编写测试代码和编写普通的Go代码过程是类似的，并不需要学习新的语法、规则或工具。  go test命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以_test.go 为后缀名的源代码文件都是go test测试的一部分，不会被go buil"><meta property="og:type" content="article"><meta property="og:title" content="go代码测试与调优"><meta property="og:url" content="https://paynewu-blog.github.io/65092.html"><meta property="og:site_name" content="Payne的个人小屋"><meta property="og:description" content="在了解golang的测试之前，先了解一下go语言自带的测试工具-go test   go test工具 Go语言中的测试依赖go test命令。编写测试代码和编写普通的Go代码过程是类似的，并不需要学习新的语法、规则或工具。  go test命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以_test.go 为后缀名的源代码文件都是go test测试的一部分，不会被go buil"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEgy1gnrolzdwnuj318y0dq3z2.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEgy1gnropdatxhj30oa0bg0t4.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEgy1gnrw3i5yuej312k07adg0.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEgy1gnrx800j18j314g07gjrk.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEgy1gpih7cgmhxj30hu0jwmy0.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEgy1gpihc6efdzj310a0q676g.jpg"><meta property="article:published_time" content="2021-04-13T16:54:33.000Z"><meta property="article:modified_time" content="2025-01-06T03:07:07.080Z"><meta property="article:author" content="Payne Wu"><meta property="article:tag" content="go"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://tva1.sinaimg.cn/large/008eGmZEgy1gnrolzdwnuj318y0dq3z2.jpg"><link rel="canonical" href="https://paynewu-blog.github.io/65092.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>go代码测试与调优 | Payne的个人小屋</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Payne的个人小屋" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Payne的个人小屋</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">Every day</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section">首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section">文章归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section">文章标签</a></li><li class="menu-item menu-item-message"><a href="/message/" rel="section">留言于我</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger">文章搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://paynewu-blog.github.io/65092.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/favicon/android-chrome-512x512.png"><meta itemprop="name" content="Payne Wu"><meta itemprop="description" content="格物致知，知行合一，致良知"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Payne的个人小屋"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">go代码测试与调优</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-04-14 00:54:33" itemprop="dateCreated datePublished" datetime="2021-04-14T00:54:33+08:00">2021-04-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-01-06 11:07:07" itemprop="dateModified" datetime="2025-01-06T11:07:07+08:00">2025-01-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/65092.html#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/65092.html" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>7.7k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>7 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>在了解golang的测试之前，先了解一下go语言自带的测试工具-go test</p><h2 id="go-test工具"><a class="markdownIt-Anchor" href="#go-test工具"></a> go test工具</h2><p>Go语言中的测试依赖<code>go test</code>命令。编写测试代码和编写普通的Go代码过程是类似的，并不需要学习新的语法、规则或工具。</p><span id="more"></span><p>go test命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以<code>_test.go</code><br>为后缀名的源代码文件都是<code>go test</code>测试的一部分，不会被<code>go build</code>编译到最终的可执行文件中。</p><p>在<code>*_test.go</code>文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">格式</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">测试函数</td><td style="text-align:center">函数名前缀为Test</td><td style="text-align:center">测试程序的一些逻辑行为是否正确</td></tr><tr><td style="text-align:center">基准函数</td><td style="text-align:center">函数名前缀为Benchmark</td><td style="text-align:center">测试函数的性能</td></tr><tr><td style="text-align:center">示例函数</td><td style="text-align:center">函数名前缀为Example</td><td style="text-align:center">为文档提供示例文档</td></tr></tbody></table><h4 id="运行流程"><a class="markdownIt-Anchor" href="#运行流程"></a> 运行流程</h4><p><code>go test</code>命令会遍历所有的<code>*_test.go</code><br>文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。</p><h3 id="使用详解"><a class="markdownIt-Anchor" href="#使用详解"></a> 使用详解</h3><p>上次对于<code>go test</code> 并没有详细的阐述，这次补上。</p><p>go test 的使用语法如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> [build/test flags] [packages] [build/test flags &amp; <span class="built_in">test</span> binary flags]</span><br><span class="line"><span class="comment"># 可以直接 go test 直接运行，那么它将运行本目录下的所有*_test.go的基准测试。</span></span><br><span class="line"><span class="comment"># 还可以进行编译后测试例如 go test build </span></span><br></pre></td></tr></table></figure><blockquote><p>更多请查看 <code>go help testfunc</code>。</p><p><code>go test</code> 命令还会忽略 <code>testdata</code> 目录，该目录用来保存测试需要用到的辅助数据。</p><p>go test 有两种运行模式：</p><p>1、本地目录模式，在没有包参数（例如 <code>go test</code> 或 <code>go test -v</code>）调用时发生。在此模式下，<code>go test</code><br>编译当前目录中找到的包和测试，然后运行测试二进制文件。在这种模式下，caching<br>是禁用的。在包测试完成后，<code>go test</code> 打印一个概要行，显示测试状态、包名和运行时间。</p><p>2、包列表模式，在使用显示包参数调用 <code>go test</code> 时发生（例如 <code>go test math</code>，<code>go test ./...</code><br>甚至是 <code>go test .</code>）。在此模式下，go 测试编译并测试在命令上列出的每个包。如果一个包测试通过，<code>go test</code><br>只打印最终的 <code>ok</code> 总结行。如果一个包测试失败，<code>go test</code> 将输出完整的测试输出。如果使用 <code>-bench</code><br>或 <code>-v</code><br>标志，则 <code>go test</code> 会输出完整的输出，甚至是通过包测试，以显示所请求的基准测试结果或详细日志记录。</p><p>下面详细说明下 <code>go test</code> 的具体用法，flag 的作用及一些相关例子。需要说明的是：一些 flag<br>支持 <code>go test</code> 命令和编译后的二进制测试文件。它们都能识别加 <code>-test.</code> 前缀的<br>flag，如 <code>go test -test.v</code><br>，但编译后的二进制文件必须加前缀 <code>./sum.test -test.bench=.</code>。</p></blockquote><p>参数详解</p><h3 id="test-flag"><a class="markdownIt-Anchor" href="#test-flag"></a> test flag</h3><p>以下 flag 可以跟被 <code>go test</code> 命令使用：</p><ul><li><code>-args</code>：传递命令行参数，该标志会将 -args 之后的参数作为命令行参数传递，最好作为最后一个标志。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -args -p=true</span><br></pre></td></tr></table></figure><ul><li><code>-c</code>：编译测试二进制文件为 [pkg].test，不运行测试。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -c &amp;&amp; ./sum.test -p=true</span><br></pre></td></tr></table></figure><ul><li><code>-exec xprog</code>：使用 xprog 运行测试，行为同 <code>go run</code> 一样，查看 <code>go help run</code>。</li><li><code>-i</code>：安装与测试相关的包，不运行测试。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -i</span><br></pre></td></tr></table></figure><ul><li><code>-o file</code>：编译测试二进制文件并指定文件，同时运行测试。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -o filename</span><br></pre></td></tr></table></figure><h3 id="testbinary-flag"><a class="markdownIt-Anchor" href="#testbinary-flag"></a> test/binary flag</h3><p>以下标志同时支持测试二进制文件和 <code>go test</code> 命令。</p><ul><li><code>-bench regexp</code>：通过正则表达式执行基准测试，默认不执行基准测试。可以使用 <code>-bench .</code>或<code>-bench=.</code><br>执行所有基准测试。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go test -bench=.</span><br><span class="line">go test -c</span><br><span class="line">./sum.test -test.bench=.</span><br></pre></td></tr></table></figure><ul><li><code>-benchtime t</code>：每个基准测试运行足够迭代消耗的时间，time.Duration（如 -benchtime 1h30s），默认 1s。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go test -bench=. -benchtime 0.1s</span><br><span class="line">./sum.test -test.bench=. -test.benchtime=1s</span><br></pre></td></tr></table></figure><ul><li><code>-count n</code>：运行每个测试和基准测试的次数（默认 1），如果 -cpu 指定了，则每个 GOMAXPROCS 值执行 n<br>次，Examples 总是运行一次。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go test -bench=. -count=2</span><br><span class="line">./sum.test -test.bench=. -test.count=2</span><br></pre></td></tr></table></figure><ul><li><code>-cover</code>：开启覆盖分析，开启覆盖分析可能会在编译或测试失败时，代码行数不对。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -bench=. -cover</span><br></pre></td></tr></table></figure><ul><li><pre class="highlight"><code>-covermode set,count,atomic
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：覆盖分析的模式，默认是 set，如果设置 -race，将会变为 atomic。</span><br><span class="line"></span><br><span class="line">  - set，bool，这个语句运行吗？</span><br><span class="line">  - count，int，该语句运行多少次？</span><br><span class="line">  - atomic，int，数量，在多线程正确使用，但是耗资源的。</span><br><span class="line"></span><br><span class="line">- `-coverpkg pkg1,pkg2,pkg3`：指定分析哪个包，默认值只分析被测试的包，包为导入的路径。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
# sum -&gt; $GOPATH/src/test/sum
$ go test -coverpkg test/sum
</code></pre></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `-cpu 1,2,4`：指定测试或基准测试的 GOMAXPROCS 值。默认为 GOMAXPROCS 的当前值。</span><br><span class="line">- `-list regexp`：列出与正则表达式匹配的测试、基准测试或 Examples。只列出顶级测试（不列出子测试），不运行测试。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>go test -list Sum</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `-parallel n`：允许并行执行通过调用 t.Parallel 的测试函数的最大次数。默认值为 GOMAXPROCS</span><br><span class="line">  的值。-parallel 仅适用于单个二进制测试文件，但`go test`命令可以通过指定 -p</span><br><span class="line">  并行测试不同的包。查看 `go help build`。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>go test -run=TestSumParallel -parallel=2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `-run regexp`：只运行与正则表达式匹配的测试和Examples。可以通过 / 来指定测试子函数。`go test Foo/A=`</span><br><span class="line">  ，会先去匹配并执行 Foo 函数，再查找子函数。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>go test -v -run TestSumSubTest/1+</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `-short`：缩短长时间运行的测试的测试时间。默认关闭。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>go test -short</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `-timeout d`：如果二进制测试文件执行时间过长，panic。默认10分钟（10m）。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>go test -run TestSumLongTime -timeout 1s</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `-v`：详细输出，运行期间所有测试的日志。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>go test -v</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### analyze flag</span><br><span class="line"></span><br><span class="line">以下测试适用于 `go test` 和测试二进制文件：</span><br><span class="line"></span><br><span class="line">- `-benchmem`：打印用于基准的内存分配统计数据。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>go test -bench=. -benchmem<br>./sum.test -test.bench -test.benchmem</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `-blockprofile block.out`：当所有的测试都完成时，在指定的文件中写入一个 goroutine 阻塞概要文件。指定</span><br><span class="line">  -c，将写入测试二进制文件。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>go test -v -cpuprofile=prof.out<br>go tool pprof prof.out</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `-blockprofilerate n`：goroutine 阻塞时候打点的纳秒数。默认不设置就相当于</span><br><span class="line">  -test.blockprofilerate=1，每一纳秒都打点记录一下。</span><br><span class="line">- `-coverprofile cover.out`：在所有测试通过后，将覆盖概要文件写到文件中。设置过 -cover。</span><br><span class="line">- `-cpuprofile cpu.out`：在退出之前，将一个 CPU 概要文件写入指定的文件。</span><br><span class="line">- `-memprofile mem.out`：在所有测试通过后，将内存概要文件写到文件中。</span><br><span class="line">- `-memprofilerate n`：开启更精确的内存配置。如果为 1，将会记录所有内存分配到 profile。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>go test -memprofile mem.out -memprofilerate 1<br>go tool pprof mem.out</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `-mutexprofile mutex.out`：当所有的测试都完成时，在指定的文件中写入一个互斥锁争用概要文件。指定</span><br><span class="line">  -c，将写入测试二进制文件。</span><br><span class="line">- `-mutexprofilefraction n`：样本 1 在 n 个堆栈中，goroutines 持有 a，争用互斥锁。</span><br><span class="line">- `-outputdir directory`：在指定的目录中放置输出文件，默认情况下，`go test` 正在运行的目录。</span><br><span class="line">- `-trace trace.out`：在退出之前，将执行跟踪写入指定文件。</span><br><span class="line"></span><br><span class="line">## 单元测试</span><br><span class="line"></span><br><span class="line">&gt; 以下是来自wiki对于单元测试的定义</span><br><span class="line"></span><br><span class="line">在[计算机编程](https://zh.wikipedia.org/wiki/计算机编程)中，**单元测试**（英语：Unit Testing）又称为*</span><br><span class="line">*模块测试**</span><br><span class="line">，是针对[程序模块](https://zh.wikipedia.org/wiki/模組_(程式設計))（[软件设计](https://zh.wikipedia.org/wiki/软件设计)</span><br><span class="line">的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在[过程化编程](https://zh.wikipedia.org/wiki/過程化編程)</span><br><span class="line">中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</span><br><span class="line"></span><br><span class="line">通常来说，程序员每修改一次程序就会进行最少一次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到[软件规格书](https://zh.wikipedia.org/wiki/規格_(技術標準))</span><br><span class="line">要求的工作目标，没有[程序错误](https://zh.wikipedia.org/wiki/Bug)</span><br><span class="line">；虽然单元测试不是必须的，但也不坏，这牵涉到[项目管理](https://zh.wikipedia.org/wiki/專案管理)的政策决定。</span><br><span class="line"></span><br><span class="line">每个理想的[测试案例](https://zh.wikipedia.org/wiki/测试案例)</span><br><span class="line">独立于其它案例；为测试时隔离模块，经常使用stubs、mock[[1\]](https://zh.wikipedia.org/wiki/单元测试#cite_note-mocksarentstubs-1)</span><br><span class="line">或fake等测试[马甲程序](https://zh.wikipedia.org/w/index.php?title=马甲程序&amp;action=edit&amp;redlink=1)</span><br><span class="line">。单元测试通常由[软件开发人员](https://zh.wikipedia.org/w/index.php?title=软件开发人员&amp;action=edit&amp;redlink=1)</span><br><span class="line">编写，用于确保他们所写的代码符合软件需求和遵循[开发目标](https://zh.wikipedia.org/w/index.php?title=开发目标&amp;action=edit&amp;redlink=1)</span><br><span class="line">。它的实施方式可以是非常手动的（透过纸笔），或者是做成[构建自动化](https://zh.wikipedia.org/wiki/構建自動化)</span><br><span class="line">的一部分。</span><br><span class="line"></span><br><span class="line">简单来说，单元测试就是程序员自己对于自己的代码进行测试，而一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</span><br><span class="line"></span><br><span class="line">更有一种开发手法，那就是TDD（Test Driven Development）,测试驱动开发。期望局部最优到全局最优，这个是一种非常不错的好习惯</span><br><span class="line"></span><br><span class="line">&gt; 请注意这里的局部最优的，局部，并不是函数内的详细。而是整个函数。甚至是一个类，等等。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 因为有些函数内部的最优，并非这个函数的最优。这点需要格外的注意。若有兴趣，可了解一下有点关系的贪心算法</span><br><span class="line"></span><br><span class="line">### 测试函数格式</span><br><span class="line"></span><br><span class="line">其中参数`t`用于报告测试失败和附加的日志信息。 `testing.T`的拥有的方法如下：</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">func (c *T) Error(args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) Errorf(format string, args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) Fail()</span><br><span class="line">func (c *T) FailNow()</span><br><span class="line">func (c *T) Failed() bool</span><br><span class="line">func (c *T) Fatal(args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) Fatalf(format string, args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) Log(args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) Logf(format string, args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) Name() string</span><br><span class="line">func (t *T) Parallel()</span><br><span class="line">func (t *T) Run(name string, f func(t *T)) bool</span><br><span class="line">func (c *T) Skip(args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) SkipNow()</span><br><span class="line">func (c *T) Skipf(format string, args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) Skipped() bool</span><br></pre></td></tr></table></figure><p>说了这么多，来实现一个<code>简单的</code>string中的Split函数，并对他进行单元测试，然后在剖析代码。了解单元测试的相关规范</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// splits.go</span></span><br><span class="line"><span class="keyword">package</span> splitStr</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// split package with a single split function.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Split slices s into all substrings separated by sep and</span></span><br><span class="line"><span class="comment">// returns a slice of the substrings between those separators.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="type">string</span>)</span></span> (result []<span class="type">string</span>) &#123;</span><br><span class="line"> i := strings.Index(s, sep)</span><br><span class="line"> <span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">  result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">  s = s[i+<span class="number">1</span>:]</span><br><span class="line">  i = strings.Index(s, sep)</span><br><span class="line"> &#125;</span><br><span class="line"> result = <span class="built_in">append</span>(result, s)</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// split_test.go</span></span><br><span class="line"><span class="keyword">package</span> splitStr</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;reflect&quot;</span></span><br><span class="line"> <span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestSplit 单元测试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123; <span class="comment">// 测试函数名必须以Test开头，必须接收一个*testing.T类型参数</span></span><br><span class="line"> got := Split(<span class="string">&quot;a:b:c&quot;</span>, <span class="string">&quot;:&quot;</span>)         <span class="comment">// 程序输出的结果</span></span><br><span class="line"> want := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;    <span class="comment">// 期望的结果</span></span><br><span class="line"> <span class="keyword">if</span> !reflect.DeepEqual(want, got) &#123; <span class="comment">// 因为slice不能直接比较，借助反射包中的方法比较</span></span><br><span class="line">  t.Errorf(<span class="string">&quot;excepted:%v, got:%#v&quot;</span>, want, got) <span class="comment">// 测试失败输出错误提示</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestSplit2 单元测试组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"> <span class="comment">// 定义一个测试用例类型</span></span><br><span class="line"> <span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">  input <span class="type">string</span></span><br><span class="line">  sep   <span class="type">string</span></span><br><span class="line">  want  []<span class="type">string</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 定义一个存储测试用例的切片</span></span><br><span class="line"> tests := []test&#123;</span><br><span class="line">  &#123;input: <span class="string">&quot;a:b:c&quot;</span>, sep: <span class="string">&quot;:&quot;</span>, want: []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;&#125;,</span><br><span class="line">  &#123;input: <span class="string">&quot;a:b:c&quot;</span>, sep: <span class="string">&quot;,&quot;</span>, want: []<span class="type">string</span>&#123;<span class="string">&quot;a:b:c&quot;</span>&#125;&#125;,</span><br><span class="line">  &#123;input: <span class="string">&quot;abcd&quot;</span>, sep: <span class="string">&quot;bc&quot;</span>, want: []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 遍历切片，逐一执行测试用例</span></span><br><span class="line"> <span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">  got := Split(tc.input, tc.sep)</span><br><span class="line">  <span class="keyword">if</span> !reflect.DeepEqual(got, tc.want) &#123;</span><br><span class="line">   t.Errorf(<span class="string">&quot;excepted:%v, got:%#v&quot;</span>, tc.want, got)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnrolzdwnuj318y0dq3z2.jpg" alt=""></p><p>说明测试成功，本次通过。当然你也可以在<code>Terminal</code>里面直接运行<code>go test</code>，命令，如下所示</p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnropdatxhj30oa0bg0t4.jpg" style="zoom:70%"><blockquote><p>温馨提示：关于可能造成运行test不成功原因</p><p>直接在<code>split_test.go</code>,运行。</p><ul><li>或许知道，go是以文件夹的方法来区分项目。所以当前文件，并不能跑到旁边文件中去找到<code>Split</code><br>,以至于测试失败。或未达到预期效果</li></ul><p>那么正确的打开方式应该是？</p><p>在goland中，鼠标右键点击run测试文件所在的文件夹，选择后面第二个 <code>go test projectFileName</code></p><p>在<code>Terminal</code>中，应在<code>测试文件所在的文件夹</code>的路径中，进行<code>go test [arge...]</code></p></blockquote><p>示例看完了，那么进行简单的剖析。先从函数文件说起，(也就是这里的<code>splits.go</code>)</p><ol><li>不在是<code>package main</code>,而是<code>packge projectFileName</code></li><li>函数名大写，大写意味着公有函数，可支持外部调用</li></ol><p>测试文件</p><ol><li>文件名为’*_test.go’</li><li>不在是<code>package main</code>,而是<code>packge projectFileName</code></li><li>函数名为TestFuncName</li></ol><h2 id="基准测试"><a class="markdownIt-Anchor" href="#基准测试"></a> 基准测试</h2><h3 id="基准测试函数格式"><a class="markdownIt-Anchor" href="#基准测试函数格式"></a> 基准测试函数格式</h3><p>基准测试就是在一定的工作负载之下检测程序性能的一种方法。基准测试的基本格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkName</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基准测试以<code>Benchmark</code>为前缀，需要一个<code>*testing.B</code>类型的参数b，基准测试必须要执行<code>b.N</code><br>次，这样的测试才有对照性，<code>b.N</code>的值是系统根据实际情况去调整的，从而保证测试的稳定性。 <code>testing.B</code><br>拥有的方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Error(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Errorf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Fail()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> FailNow()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Failed() <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Fatal(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Fatalf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Log(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Logf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Name() <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> ReportAllocs()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> ResetTimer()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> Run(name <span class="type">string</span>, f <span class="function"><span class="keyword">func</span><span class="params">(b *B)</span></span>) <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> RunParallel(body <span class="function"><span class="keyword">func</span><span class="params">(*PB)</span></span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> SetBytes(n <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> SetParallelism(p <span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Skip(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> SkipNow()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Skipf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Skipped() <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> StartTimer()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> StopTimer()</span><br></pre></td></tr></table></figure><h3 id="基准测试示例"><a class="markdownIt-Anchor" href="#基准测试示例"></a> 基准测试示例</h3><p>为自己写的<code>Split</code>函数编写基准测试如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BenchmarkSplit 基准测试(性能测试)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplit</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;b.N ; i++ &#123;</span><br><span class="line">  Split(<span class="string">&quot;abcdebdae&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果如下</span></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: Gp/part5/splitStr</span><br><span class="line">BenchmarkSplit</span><br><span class="line">BenchmarkSplit<span class="number">-8</span>     <span class="number">5740642</span>        <span class="number">209</span> ns/op</span><br><span class="line">PASS</span><br><span class="line">ok   Gp/part5/splitStr <span class="number">1.963</span>s</span><br></pre></td></tr></table></figure><blockquote><p>其中</p><p>BenchmarkSplit：表示对Split函数进行基准测试</p><p>BenchmarkSplit-8：数字<code>8</code>表示<code>GOMAXPROCS</code>的值，这个对于并发基准测试很重要</p><p>5188407和206 ns/op：表示每次调用<code>Split</code>函数耗时<code>203ns</code></p></blockquote><p>还可以为基准测试添加<code>-benchmem</code>参数，来获得内存分配的统计数据。</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnrw3i5yuej312k07adg0.jpg" alt=""></p><blockquote><p>112 B/op：表示每次操作内存分配了112字节</p><p><code>3 allocs/op</code>：则表示每次操作进行了3次内存分配！！！</p></blockquote><p>优化后代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// split.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="type">string</span>)</span></span> (result []<span class="type">string</span>) &#123;</span><br><span class="line"> i := strings.Index(s, sep)</span><br><span class="line">  <span class="comment">// 手动分配固定内存，避免多次创建</span></span><br><span class="line"> result = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, strings.Count(s, sep)+<span class="number">1</span>)</span><br><span class="line"> <span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">  result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">  s = s[i+<span class="built_in">len</span>(sep):] <span class="comment">// 这里使用len(sep)获取sep的长度</span></span><br><span class="line">  i = strings.Index(s, sep)</span><br><span class="line"> &#125;</span><br><span class="line"> result = <span class="built_in">append</span>(result, s)</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后代码如下</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnrx800j18j314g07gjrk.jpg" alt=""></p><blockquote><p>这个使用make函数提前分配内存的改动，减少了2/3的内存分配次数，并且减少了一半的内存分配。</p><p>仅仅小小的一处改动，就引起如此大的性能改变。so good</p><p>量变产生质变</p></blockquote><h3 id="性能比较函数"><a class="markdownIt-Anchor" href="#性能比较函数"></a> 性能比较函数</h3><p>上面的基准测试只能得到给定操作的绝对耗时，但是在很多性能问题是发生在两个不同操作之间的相对耗时，比如同一个函数处理1000个元素的耗时与处理1万甚至100万个元素的耗时的差别是多少？再或者对于同一个任务究竟使用哪种算法性能最佳？通常需要对两个不同算法的实现使用相同的输入来进行基准比较测试。</p><p>性能比较函数通常是一个带有参数的函数，被多个不同的Benchmark函数传入不同的值来调用。举个例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmark</span><span class="params">(b *testing.B, size <span class="type">int</span>)</span></span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark10</span><span class="params">(b *testing.B)</span></span>&#123; benchmark(b, <span class="number">10</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark100</span><span class="params">(b *testing.B)</span></span>&#123; benchmark(b, <span class="number">100</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark1000</span><span class="params">(b *testing.B)</span></span>&#123; benchmark(b, <span class="number">1000</span>) &#125;</span><br></pre></td></tr></table></figure><p>例如编写了一个计算斐波那契数列的函数如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fib.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fib 是一个计算第n个斐波那契数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> n</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> Fib(n<span class="number">-1</span>) + Fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写的性能比较函数如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fib_test.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmarkFib</span><span class="params">(b *testing.B, n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  Fib(n)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib1</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(b, <span class="number">1</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib2</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(b, <span class="number">2</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib3</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(b, <span class="number">3</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib10</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(b, <span class="number">10</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib20</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(b, <span class="number">20</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib40</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(b, <span class="number">40</span>) &#125;</span><br></pre></td></tr></table></figure><p>运行基准测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span> $ go <span class="built_in">test</span> -bench=.</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/payne/Gp/code_demo/test_demo/fib</span><br><span class="line">BenchmarkFib1-8         1000000000               2.03 ns/op</span><br><span class="line">BenchmarkFib2-8         300000000                5.39 ns/op</span><br><span class="line">BenchmarkFib3-8         200000000                9.71 ns/op</span><br><span class="line">BenchmarkFib10-8         5000000               325 ns/op</span><br><span class="line">BenchmarkFib20-8           30000             42460 ns/op</span><br><span class="line">BenchmarkFib40-8               2         638524980 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/payne/Gp/code_demo/test_demo/fib 12.944s</span><br></pre></td></tr></table></figure><p>这里需要注意的是，默认情况下，每个基准测试至少运行1秒。如果在Benchmark函数返回时没有到1秒，则b.N的值会按1,2,5,10,20,50，…增加，并且函数再次运行。</p><p>最终的BenchmarkFib40只运行了两次，每次运行的平均值只有不到一秒。像这种情况下应该可以使用<code>-benchtime</code><br>标志增加最小基准时间，以产生更准确的结果。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span> $ go <span class="built_in">test</span> -bench=Fib40 -benchtime=20s</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/payne/Gp/code_demo/test_demo/fib</span><br><span class="line">BenchmarkFib40-8              50         663205114 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/payne/Gp/code_demo/test_demo/fib 33.849s</span><br></pre></td></tr></table></figure><p>这一次<code>BenchmarkFib40</code>函数运行了50次，结果就会更准确一些了。</p><p>使用性能比较函数做测试的时候一个容易犯的错误就是把<code>b.N</code>作为输入的大小，例如以下两个例子都是错误的示范：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFibWrong</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">  Fib(n)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示范2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFibWrong2</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"> Fib(b.N)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重置时间"><a class="markdownIt-Anchor" href="#重置时间"></a> 重置时间</h2><p><code>b.ResetTimer</code>之前的处理不会放到执行时间里，也不会输出到报告中，所以可以在之前做一些不计划作为测试报告的操作。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplit</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"> time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">// 假设需要做一些耗时的无关操作</span></span><br><span class="line"> b.ResetTimer()              <span class="comment">// 重置计时器</span></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  strings.Split(<span class="string">&quot;山河和河山&quot;</span>, <span class="string">&quot;和&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并行测试"><a class="markdownIt-Anchor" href="#并行测试"></a> 并行测试</h2><p><code>func (b *B) RunParallel(body func(*PB))</code>会以并行的方式执行给定的基准测试。</p><p><code>RunParallel</code>会创建出多个<code>goroutine</code>，并将<code>b.N</code>分配给这些<code>goroutine</code>执行， 其中<code>goroutine</code><br>数量的默认值为<code>GOMAXPROCS</code><br>。用户如果想要增加非CPU受限（non-CPU-bound）基准测试的并行性， 那么可以在<code>RunParallel</code><br>之前调用<code>SetParallelism</code> 。<code>RunParallel</code>通常会与<code>-cpu</code>标志一同使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplitParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"> <span class="comment">// b.SetParallelism(1) // 设置使用的CPU数</span></span><br><span class="line"> b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">   Split(<span class="string">&quot;山河和河山&quot;</span>, <span class="string">&quot;和&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行一下基准测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span> $ go <span class="built_in">test</span> -bench=.</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/payne/Gp/code_demo/test_demo/split</span><br><span class="line">BenchmarkSplit-8                10000000               131 ns/op</span><br><span class="line">BenchmarkSplitParallel-8        50000000                36.1 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/payne/Gp/code_demo/test_demo/split       3.308s</span><br></pre></td></tr></table></figure><p>还可以通过在测试命令后添加<code>-cpu</code>参数如<code>go test -bench=. -cpu 1</code>来指定使用的CPU数量。</p><h2 id="setup与teardown"><a class="markdownIt-Anchor" href="#setup与teardown"></a> Setup与TearDown</h2><p>测试程序有时需要在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）。</p><h2 id="go性能优化"><a class="markdownIt-Anchor" href="#go性能优化"></a> Go性能优化</h2><p>做了这么多的测试最终的目的是测试代码有没有写对，性能是否可以优化。接下来进行性能优化与调优</p><p>在计算机性能调试领域里，profiling 是指对应用程序的画像，画像就是应用程序使用 CPU 和内存的情况。<br>Go语言是一个对性能特别看重的语言，因此语言中自带了 profiling 的库。</p><p>Go语言项目中的性能优化主要有以下几个方面：</p><ul><li>CPU profile：报告程序的 CPU 使用情况，按照一定频率去采集应用程序在 CPU 和寄存器上面的数据</li><li>Memory Profile（Heap Profile）：报告程序的内存的使用情况</li><li>Block Profiling：报告 goroutine 不在运行状态的情况，可以用来分析与查找死锁等性能瓶颈</li><li>Goroutine Profiling：报告 goroutines 的使用情况，有哪些 goroutine，它们的调用关系是怎样的</li></ul><h3 id="采集性能数据"><a class="markdownIt-Anchor" href="#采集性能数据"></a> 采集性能数据</h3><p>Go语言内置了获取程序的运行数据的工具，包括以下两个标准库：</p><ul><li><code>runtime/pprof</code>：采集工具型应用运行数据进行分析</li><li><code>net/http/pprof</code>：采集服务型应用运行时数据进行分析</li></ul><p>pprof开启后，每隔一段时间（10ms）就会收集下当前的堆栈信息，获取各个函数占用的CPU以及内存资源；最后通过对这些采样数据进行分析，形成一个性能分析报告。</p><h3 id="pprof应用"><a class="markdownIt-Anchor" href="#pprof应用"></a> pprof应用</h3><p>如果你的应用程序是运行一段时间就结束退出类型。那么最好的办法是在应用退出的时候把 profiling<br>的报告保存到文件中，进行分析。对于这种情况，可以使用<code>runtime/pprof</code>库。 首先在代码中导入<code>runtime/pprof</code><br>工具：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;runtime/pprof&quot;</span></span><br></pre></td></tr></table></figure><h3 id="cpu性能分析"><a class="markdownIt-Anchor" href="#cpu性能分析"></a> CPU性能分析</h3><p>开启CPU性能分析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pprof.StartCPUProfile(w io.Writer)</span><br></pre></td></tr></table></figure><p>停止CPU性能分析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pprof.StopCPUProfile()</span><br></pre></td></tr></table></figure><p>应用执行结束后，就会生成一个文件，保存了 CPU profiling 数据。得到采样数据之后，使用<code>go tool pprof</code><br>工具进行CPU性能分析。</p><h3 id="内存性能优化"><a class="markdownIt-Anchor" href="#内存性能优化"></a> 内存性能优化</h3><p>记录程序的堆栈信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pprof.WriteHeapProfile(w io.Writer)</span><br></pre></td></tr></table></figure><p>得到采样数据之后，使用<code>go tool pprof</code>工具进行内存性能分析。</p><p><code>go tool pprof</code>默认是使用<code>-inuse_space</code>进行统计，还可以使用<code>-inuse-objects</code>查看分配对象的数量。</p><h2 id="服务型应用"><a class="markdownIt-Anchor" href="#服务型应用"></a> 服务型应用</h2><p>如果你的应用程序是一直运行的，比如 web 应用，那么可以使用<code>net/http/pprof</code>库，它能够在提供 HTTP 服务进行分析。</p><p>如果使用了默认的<code>http.DefaultServeMux</code>（通常是代码直接使用 http.ListenAndServe(“0.0.0.0:8000”, nil)<br>），只需要在你的web<br>server端代码中按如下方式导入<code>net/http/pprof</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;net/http/pprof&quot;</span></span><br></pre></td></tr></table></figure><p>如果你使用自定义的 Mux，则需要手动注册一些路由规则：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r.HandleFunc(<span class="string">&quot;/debug/pprof/&quot;</span>, pprof.Index)</span><br><span class="line">r.HandleFunc(<span class="string">&quot;/debug/pprof/cmdline&quot;</span>, pprof.Cmdline)</span><br><span class="line">r.HandleFunc(<span class="string">&quot;/debug/pprof/profile&quot;</span>, pprof.Profile)</span><br><span class="line">r.HandleFunc(<span class="string">&quot;/debug/pprof/symbol&quot;</span>, pprof.Symbol)</span><br><span class="line">r.HandleFunc(<span class="string">&quot;/debug/pprof/trace&quot;</span>, pprof.Trace)</span><br></pre></td></tr></table></figure><p>如果你使用的是gin框架，推荐使用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpbi1jb250cmliL3Bwcm9m">github.com/gin-contrib/pprof<i class="fa fa-external-link-alt"></i></span><br>，在代码中通过以下命令注册pprof相关路由。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pprof.Register(router)</span><br></pre></td></tr></table></figure><p>不管哪种方式，你的 HTTP 服务都会多出<code>/debug/pprof</code> endpoint，访问它会得到类似下面的内容：</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpih7cgmhxj30hu0jwmy0.jpg" alt=""></p><p>这个路径下还有几个子页面：</p><ul><li><p>/debug/pprof/profile：访问这个链接会自动进行 CPU profiling，并生成一个文件供下载</p></li><li><p>/debug/pprof/heap： Memory Profiling 的路径，访问这个链接会得到一个内存 Profiling 结果的文件</p></li><li><p>/debug/pprof/block：block Profiling 的路径</p></li><li><p>/debug/pprof/goroutines：运行的 goroutines 列表，以及调用关系</p></li><li><p>。。。 。。。</p></li></ul><h3 id="go-tool-pprof命令"><a class="markdownIt-Anchor" href="#go-tool-pprof命令"></a> go tool pprof命令</h3><p>不管是工具型应用还是服务型应用，我们使用相应的pprof库获取数据之后，下一步的都要对这些数据进行分析，我们可以使用<code>go tool pprof</code><br>命令行工具。</p><p><code>go tool pprof</code>最简单的使用方式为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof [binary] [<span class="built_in">source</span>]</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>binary 是应用的二进制文件，用来解析各种符号；</li><li>source 表示 profile 数据的来源，可以是本地的文件，也可以是 http 地址。</li></ul><p><strong>注意事项：</strong> 获取的 Profiling<br>数据是动态的，要想获得有效的数据，请保证应用处于较大的负载（比如正在生成中运行的服务，或者通过其他工具模拟访问压力）。否则如果应用处于空闲状态，得到的结果可能没有任何意义。</p><h3 id="命令行交互界面"><a class="markdownIt-Anchor" href="#命令行交互界面"></a> 命令行交互界面</h3><p>我们使用go工具链里的<code>pprof</code>来分析一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof cpu.pprof</span><br></pre></td></tr></table></figure><p>执行上面的代码会进入交互界面如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">runtime_pprof $ go tool pprof cpu.pprof</span><br><span class="line">Type: cpu</span><br><span class="line">Time: Jun 28, 2020 at 11:28am (CST)</span><br><span class="line">Duration: 20.13s, Total samples = 1.91mins (538.60%)</span><br><span class="line">Entering interactive mode (<span class="built_in">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)  </span><br></pre></td></tr></table></figure><p>我们可以在交互界面输入<code>top3</code>来查看程序中占用CPU前3位的函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(pprof) top3</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> 100.37s, 87.68% of 114.47s total</span><br><span class="line">Dropped 17 nodes (cum &lt;= 0.57s)</span><br><span class="line">Showing top 3 nodes out of 4</span><br><span class="line">      flat  flat%   <span class="built_in">sum</span>%        cum   cum%</span><br><span class="line">    42.52s 37.15% 37.15%     91.73s 80.13%  runtime.selectnbrecv</span><br><span class="line">    35.21s 30.76% 67.90%     39.49s 34.50%  runtime.chanrecv</span><br><span class="line">    22.64s 19.78% 87.68%    114.37s 99.91%  main.logicCode</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>flat：当前函数占用CPU的耗时</li><li>flat：:当前函数占用CPU的耗时百分比</li><li>sun%：函数占用CPU的耗时累计百分比</li><li>cum：当前函数加上调用当前函数的函数占用CPU的总耗时</li><li>cum%：当前函数加上调用当前函数的函数占用CPU的总耗时百分比</li><li>最后一列：函数名称</li></ul><p>在大多数的情况下，我们可以通过分析这五列得出一个应用程序的运行情况，并对程序进行优化。</p><p>还可以使用<code>list 函数名</code>命令查看具体的函数分析，例如执行<code>list logicCode</code>查看我们编写的函数的详细分析。</p><h3 id="图形化"><a class="markdownIt-Anchor" href="#图形化"></a> 图形化</h3><p>或者可以直接输入web，通过svg图的方式查看程序中详细的CPU占用情况。<br>想要查看图形化的界面首先需要安装<span class="exturl" data-url="aHR0cHM6Ly9ncmFwaHZpei5naXRsYWIuaW8v">graphviz<i class="fa fa-external-link-alt"></i></span>图形化工具。</p><p>Mac：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install graphviz</span><br></pre></td></tr></table></figure><p>Windows: 下载<span class="exturl" data-url="aHR0cHM6Ly9ncmFwaHZpei5naXRsYWIuaW8vX3BhZ2VzL0Rvd25sb2FkL0Rvd25sb2FkX3dpbmRvd3MuaHRtbA==">graphviz<i class="fa fa-external-link-alt"></i></span><br>将<code>graphviz</code><br>安装目录下的bin文件夹添加到Path环境变量中。 在终端输入<code>dot -version</code>查看是否安装成功。</p><p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpihc6efdzj310a0q676g.jpg" alt=""></p><p>关于图形的说明： 每个框代表一个函数，理论上框的越大表示占用的CPU资源越多。 方框之间的线条代表函数之间的调用关系。<br>线条上的数字表示函数调用的次数。<br>方框中的第一行数字表示当前函数占用CPU的百分比，第二行数字表示当前函数累计占用CPU的百分比。</p><p>除了分析CPU性能数据，pprof也支持分析内存性能数据。比如，使用下面的命令分析http服务的heap性能数据，查看当前程序的内存占用以及热点内存对象使用的情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看内存占用数据</span></span><br><span class="line">go tool pprof -inuse_space http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line">go tool pprof -inuse_objects http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line"><span class="comment"># 查看临时内存分配数据</span></span><br><span class="line">go tool pprof -alloc_space http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line">go tool pprof -alloc_objects http://127.0.0.1:8080/debug/pprof/heap</span><br></pre></td></tr></table></figure><h2 id="go-torch和火焰图"><a class="markdownIt-Anchor" href="#go-torch和火焰图"></a> go-torch和火焰图</h2><p>火焰图（Flame Graph）是 Bredan Gregg 创建的一种性能分析图表，因为它的样子近似 🔥而得名。上面的 profiling<br>结果也转换成火焰图，如果对火焰图比较了解可以手动来操作，不过这里我们要介绍一个工具：<code>go-torch</code>。这是<br>uber 开源的一个工具，可以直接读取 golang profiling 数据，并生成一个火焰图的 svg 文件。</p><h3 id="安装go-torch"><a class="markdownIt-Anchor" href="#安装go-torch"></a> 安装go-torch</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -v github.com/uber/go-torch</span><br></pre></td></tr></table></figure><p>火焰图 svg 文件可以通过浏览器打开，它对于调用图的最优点是它是动态的：可以通过点击每个方块来 zoom in<br>分析它上面的内容。</p><p>火焰图的调用顺序从下到上，每个方块代表一个函数，它上面一层表示这个函数会调用哪些函数，方块的大小代表了占用<br>CPU 使用的长短。火焰图的配色并没有特殊的意义，默认的红、黄配色是为了更像火焰而已。</p><p>go-torch 工具的使用非常简单，没有任何参数的话，它会尝试从<code>http://localhost:8080/debug/pprof/profile</code>获取<br>profiling 数据。它有三个常用的参数可以调整：</p><ul><li>-u –url：要访问的 URL，这里只是主机和端口部分</li><li>-s –suffix：pprof profile 的路径，默认为 /debug/pprof/profile</li><li>–seconds：要执行 profiling 的时间长度，默认为 30s</li></ul><h3 id="安装-flamegraph"><a class="markdownIt-Anchor" href="#安装-flamegraph"></a> 安装 FlameGraph</h3><p>要生成火焰图，需要事先安装 FlameGraph工具，这个工具的安装很简单（需要perl环境支持），只要把对应的可执行文件加入到环境变量中即可。</p><ol><li>下载安装perl：<span class="exturl" data-url="aHR0cHM6Ly93d3cucGVybC5vcmcvZ2V0Lmh0bWw=">https://www.perl.org/get.html<i class="fa fa-external-link-alt"></i></span></li><li>下载FlameGraph：<code>git clone https://github.com/brendangregg/FlameGraph.git</code></li><li>将<code>FlameGraph</code>目录加入到操作系统的环境变量中。</li><li>Windows平台，需要把<code>go-torch/render/flamegraph.go</code>文件中的<code>GenerateFlameGraph</code><br>按如下方式修改，然后在<code>go-torch</code>目录下执行<code>go install</code>即可。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GenerateFlameGraph runs the flamegraph script to generate a flame graph SVG. func GenerateFlameGraph(graphInput []byte, args ...string) ([]byte, error) &#123;</span></span><br><span class="line">flameGraph := findInPath(flameGraphScripts)</span><br><span class="line"><span class="keyword">if</span> flameGraph == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">nil</span>, errNoPerlScript</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> runtime.GOOS == <span class="string">&quot;windows&quot;</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> runScript(<span class="string">&quot;perl&quot;</span>, <span class="built_in">append</span>([]<span class="type">string</span>&#123;flameGraph&#125;, args...), graphInput)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> runScript(flameGraph, args, graphInput)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压测工具wrk"><a class="markdownIt-Anchor" href="#压测工具wrk"></a> 压测工具wrk</h3><p>推荐使用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dnL3dyaw==">https://github.com/wg/wrk<i class="fa fa-external-link-alt"></i></span> 或 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FkanVzdC9nby13cms=">https://github.com/adjust/go-wrk<i class="fa fa-external-link-alt"></i></span></p><h3 id="使用go-torch"><a class="markdownIt-Anchor" href="#使用go-torch"></a> 使用go-torch</h3><p>使用wrk进行压测:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-wrk -n 50000 http://127.0.0.1:8080/book/list</span><br></pre></td></tr></table></figure><p>在上面压测进行的同时，打开另一个终端执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-torch -u http://127.0.0.1:8080 -t 30</span><br></pre></td></tr></table></figure><p>30秒之后终端会出现如下提示：<code>Writing svg to torch.svg</code></p><p>然后我们使用浏览器打开<code>torch.svg</code>就能看到如下火焰图了。</p><p>火焰图的y轴表示cpu调用方法的先后，x轴表示在每个采样调用时间内，方法所占的时间百分比，越宽代表占据cpu时间越多。通过火焰图我们就可以更清楚的找出耗时长的函数调用，然后不断的修正代码，重新采样，不断优化。</p><p>此外还可以借助火焰图分析内存性能数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go-torch -inuse_space http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line">go-torch -inuse_objects http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line">go-torch -alloc_space http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line">go-torch -alloc_objects http://127.0.0.1:8080/debug/pprof/heap</span><br></pre></td></tr></table></figure><h2 id="pprof与性能测试结合"><a class="markdownIt-Anchor" href="#pprof与性能测试结合"></a> pprof与性能测试结合</h2><p><code>go test</code>命令有两个参数和 pprof 相关，它们分别指定生成的 CPU 和 Memory profiling 保存的文件：</p><ul><li>-cpuprofile：cpu profiling 数据要保存的文件地址</li><li>-memprofile：memory profiling 数据要报文的文件地址</li></ul><p>我们还可以选择将pprof与性能测试相结合，比如：</p><p>比如下面执行测试的同时，也会执行 CPU profiling，并把结果保存在 cpu.prof 文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench . -cpuprofile=cpu.prof</span><br></pre></td></tr></table></figure><p>比如下面执行测试的同时，也会执行 Mem profiling，并把结果保存在 cpu.prof 文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench . -memprofile=./mem.prof</span><br></pre></td></tr></table></figure><p>需要注意的是，Profiling 一般和性能测试一起使用，这个原因在前文也提到过，只有应用在负载高的情况下<br>Profiling 才有意义。</p><h2 id="referce"><a class="markdownIt-Anchor" href="#referce"></a> referce</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubGl3ZW56aG91LmNvbS9wb3N0cy9Hby9wZXJmb3JtYW5jZV9vcHRpbWlzYXRpb24v">李文周-Go性能优化<i class="fa fa-external-link-alt"></i></span></p></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/62372.html" rel="bookmark">Golang-Array</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/17571.html" rel="bookmark">Golang-Defer详解</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/3744.html" rel="bookmark">Golang-Map</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/45903.html" rel="bookmark">Golang-匿名函数与闭包</a></div></li><li class="popular-posts-item"><div class="popular-posts-title"><a href="/1962.html" rel="bookmark">Golang-接口(interface)</a></div></li></ul><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Payne</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://paynewu-blog.github.io/65092.html" title="go代码测试与调优">https://paynewu-blog.github.io/65092.html</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/go/" rel="tag"><i class="fa fa-tag"></i> go</a></div><div class="post-nav"><div class="post-nav-item"><a href="/16882.html" rel="prev" title="golang第三方包发布详细流程"><i class="fa fa-chevron-left"></i> golang第三方包发布详细流程</a></div><div class="post-nav-item"><a href="/34489.html" rel="next" title="新mac使用技巧入门指北">新mac使用技巧入门指北 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#go-test%E5%B7%A5%E5%85%B7"><span class="nav-number">1.</span> <span class="nav-text">go test工具</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.0.1.</span> <span class="nav-text">运行流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.1.</span> <span class="nav-text">使用详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#test-flag"><span class="nav-number">1.2.</span> <span class="nav-text">test flag</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#testbinary-flag"><span class="nav-number">1.3.</span> <span class="nav-text">test&#x2F;binary flag</span></a></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="nav-number">2.</span> <span class="nav-text">基准测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text">基准测试函数格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.2.</span> <span class="nav-text">基准测试示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.</span> <span class="nav-text">性能比较函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E7%BD%AE%E6%97%B6%E9%97%B4"><span class="nav-number">3.</span> <span class="nav-text">重置时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="nav-number">4.</span> <span class="nav-text">并行测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setup%E4%B8%8Eteardown"><span class="nav-number">5.</span> <span class="nav-text">Setup与TearDown</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#go%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">6.</span> <span class="nav-text">Go性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%87%E9%9B%86%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE"><span class="nav-number">6.1.</span> <span class="nav-text">采集性能数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pprof%E5%BA%94%E7%94%A8"><span class="nav-number">6.2.</span> <span class="nav-text">pprof应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cpu%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-number">6.3.</span> <span class="nav-text">CPU性能分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">6.4.</span> <span class="nav-text">内存性能优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%9E%8B%E5%BA%94%E7%94%A8"><span class="nav-number">7.</span> <span class="nav-text">服务型应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#go-tool-pprof%E5%91%BD%E4%BB%A4"><span class="nav-number">7.1.</span> <span class="nav-text">go tool pprof命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BA%A4%E4%BA%92%E7%95%8C%E9%9D%A2"><span class="nav-number">7.2.</span> <span class="nav-text">命令行交互界面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%BD%A2%E5%8C%96"><span class="nav-number">7.3.</span> <span class="nav-text">图形化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#go-torch%E5%92%8C%E7%81%AB%E7%84%B0%E5%9B%BE"><span class="nav-number">8.</span> <span class="nav-text">go-torch和火焰图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85go-torch"><span class="nav-number">8.1.</span> <span class="nav-text">安装go-torch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85-flamegraph"><span class="nav-number">8.2.</span> <span class="nav-text">安装 FlameGraph</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7wrk"><span class="nav-number">8.3.</span> <span class="nav-text">压测工具wrk</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8go-torch"><span class="nav-number">8.4.</span> <span class="nav-text">使用go-torch</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pprof%E4%B8%8E%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%BB%93%E5%90%88"><span class="nav-number">9.</span> <span class="nav-text">pprof与性能测试结合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#referce"><span class="nav-number">10.</span> <span class="nav-text">referce</span></a></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Payne Wu" src="/images/favicon/android-chrome-512x512.png"><p class="site-author-name" itemprop="name">Payne Wu</p><div class="site-description" itemprop="description">格物致知，知行合一，致良知</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">146</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">140</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">62</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2F6d3BheW5l" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;azwpayne"><i class="fab fa-github fa-fw"></i>GitHub</span> </span><span class="links-of-author-item"><span class="exturl" data-url="bWFpbHRvOnBheW5ld3UwNzE5QGdtYWlsLmNvbQ==" title="E-Mail → mailto:paynewu0719@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS93dS16aGktcGVuZy03Mi03OA==" title="ZhiHu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;wu-zhi-peng-72-78"><i class="fa fa-magic fa-fw"></i>ZhiHu</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly93ZWliby5jb20vdS82OTg3MjM0NDgz" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;6987234483"><i class="fab fa-weibo fa-fw"></i>Weibo</span></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><span class="exturl" data-url="aHR0cHM6Ly9iZWlhbi5taWl0Lmdvdi5jbg==">湘ICP备2021019893号-1</span></div><div class="copyright">&copy; <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Payne Wu</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">277k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">4:12</span></div><div style="display:none"><script src="//s95.cnzz.com/z_stat.php?id=true&web_id=true"></script></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/gh/paynewu-blog/paynewu-blog.github.io@master/js/utils.js"></script><script src="https://cdn.jsdelivr.net/gh/paynewu-blog/paynewu-blog.github.io@master/js/motion.js"></script><script src="https://cdn.jsdelivr.net/gh/paynewu-blog/paynewu-blog.github.io@master/js/schemes/muse.js"></script><script src="https://cdn.jsdelivr.net/gh/paynewu-blog/paynewu-blog.github.io@master/js/next-boot.js"></script><script defer src="/lib/three/three.min.js"></script><script defer src="/lib/three/three-waves.min.js"></script><script defer src="/lib/three/canvas_lines.min.js"></script><script defer src="/lib/three/canvas_sphere.min.js"></script><script>!function(){var e,t,o,n,r,a=document.getElementsByTagName("link");if(0<a.length)for(i=0;i<a.length;i++)"canonical"==a[i].rel.toLowerCase()&&a[i].href&&(e=a[i].href);t=e?e.split(":")[0]:window.location.protocol.split(":")[0],e=e||window.location.href,window,n=e,r=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(n)||(o="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",r?(o+="?r="+encodeURIComponent(document.referrer),n&&(o+="&l="+n)):n&&(o+="?l="+n),(new Image).src=o)}()</script><script src="https://cdn.jsdelivr.net/gh/paynewu-blog/paynewu-blog.github.io@master/js/local-search.js"></script><script>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script><script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script><script>window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://paynewu-blog.github.io/65092.html',]
      });
      });</script><script>NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : true,
      appId      : 'v5yI1sEaxpTl6gCkO0dApNOH-gzGzoHsz',
      appKey     : 'ugl27izkUCvh7RIyvo7kcFCv',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});</script></body></html>