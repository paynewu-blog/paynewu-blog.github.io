<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Payne的个人小屋</title>
  
  <subtitle>Every day</subtitle>
  <link href="https://paynewu-blog.github.io/atom.xml" rel="self"/>
  
  <link href="https://paynewu-blog.github.io/"/>
  <updated>2025-01-06T03:07:07.078Z</updated>
  <id>https://paynewu-blog.github.io/</id>
  
  <author>
    <name>Payne Wu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python之GIL</title>
    <link href="https://paynewu-blog.github.io/4170211.html"/>
    <id>https://paynewu-blog.github.io/4170211.html</id>
    <published>2024-01-07T17:49:26.000Z</published>
    <updated>2025-01-06T03:07:07.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是gil"><a class="markdownIt-Anchor" href="#1-什么是gil"></a> 1 什么是GIL</h2><p>GIL（Global Interpreter Lock，即全局解释器锁），是最流行的 Python 解释器 CPython 中的一个技术术语。它的意思是全局解释器锁，本质上是<br /><strong>类似操作系统的 Mutex</strong>，它可以帮助CPython解决其在内存管理中存在的线程不安全问题。</p><p>每一个 Python 线程，在 CPython 解释器中执行时，都会先锁住自己的线程，阻止别的线程执行。</p><p>简而言之就是<strong>任意时刻，Python 只有一个线程在同时运行</strong>。</p><h2 id="2-为什么需要gil"><a class="markdownIt-Anchor" href="#2-为什么需要gil"></a> 2 为什么需要GIL</h2><p>在CPython中，<strong>全局解释器锁</strong>（GIL）是一个互斥体，用于保护对Python对象的访问，防止多个线程同时执行Python bytecodes。GIL的存在可<br /><strong>防止竞争确保线程安全</strong>。</p><p>所以说，CPython 引进 GIL 主要原因:</p><ul><li>设计者为了规避类似于内存管理这样的复杂的竞争风险问题（race condition）；</li><li>因为 CPython 大量使用 C 语言库，但大部分 C 语言库都不是原生线程安全的（线程安全会降低性能和增加复杂度）。</li></ul><p>为什么 CPython 需要 GIL 呢？这其实和 CPython 的实现有关。Python 的内存管理机制，<br />CPython 使用引用计数来管理内存，所有 Python 脚本中创建的实例，都会有一个引用计数，来记录有多少个指针指向它。当引用计数只有 0<br />时，则会自动释放内存。</p><h2 id="3-gil工作原理"><a class="markdownIt-Anchor" href="#3-gil工作原理"></a> 3 GIL工作原理</h2><ol><li>某个线程拿到GIL</li><li>该线程执行代码，直到达到了check_interval*</li><li>解释器让当前线程释放GIL</li><li>所有的线程开始竞争GIL</li><li>竞争到GIL锁的线程又从第1步开始执行</li></ol><blockquote><p>Python2中，check_interavl是当前线程遇见IO操作或者ticks计数达到100 <em>。</em><br />在Python3中是执行时间达到阈值（默认为15毫秒）</p></blockquote><h2 id="4-gil存在的利弊"><a class="markdownIt-Anchor" href="#4-gil存在的利弊"></a> 4 GIL存在的利弊</h2><h3 id="41-利"><a class="markdownIt-Anchor" href="#41-利"></a> 4.1 利</h3><p>GIL 的设计，主要是为了方便 CPython 解释器层面的编写者</p><ul><li>在单线程任务中更快；</li><li>在多线程任务中，对于I/O密集型程序运行更快；</li><li>在多线程任务中，对于用C语言包来实现CPU密集型任务的程序运行更快；</li><li>在写C扩展的时候更加容易，因为除非你在扩展中允许，否则Python解释器不会切换线程；</li><li>在打包C库时更加容易。我们不用担心线程安全性。，因为如果该库不是线程安全的，则只需在调用GIL时将其锁定即可。</li></ul><h3 id="42-弊"><a class="markdownIt-Anchor" href="#42-弊"></a> 4.2 弊</h3><p>这种 GIL 锁的设计对于只使用单线程运行的code来说其实没有什么影响。但是对于计算密集型的程序（CPU-bound）和基于多线程的程序来说，Python<br />的 GIL 设计<strong>很有可能会</strong>造成性能瓶颈。</p><p>例子：</p><p>因为有GIL的存在，由CPython做解释器（虚拟机）的多线程Python程序只能利用多核处理器的一个核来运行。</p><p>例如，我们将一个8线程的JAVA程序运行在4核的处理器上，那么每个核会运行1个线程，然后利用时间片轮转，轮流运行每一个线程。</p><p>但是，我们将一个8线程的Python程序（由CPython作解释器）运行在一个4核处理器上，那么总共只会有1个核在工作，8个线程都要在这一个核上面时间片轮转。</p><h2 id="5-python-的线程安全"><a class="markdownIt-Anchor" href="#5-python-的线程安全"></a> 5 Python 的线程安全</h2><p>有了 GIL，并不意味着我们 Python 编程者就不用去考虑线程安全了。即使我们知道，GIL 仅允许一个 Python 线程执行，但前面我也讲到了，Python<br />还有 <strong>check interval</strong> 这样的抢占机制。</p><p>所以有了 GIL 并不意味着你的Python程序就可以高枕无忧了，我们仍然需要去注意线程安全。</p><p>GIL 的设计，主要是为了方便 CPython 解释器层面的编写者，而不是 Python 应用层面的程序员。作为 Python 的使用者，我们还是需要<br />lock 等锁，来确保线程安全。</p><h2 id="6-python多线程"><a class="markdownIt-Anchor" href="#6-python多线程"></a> 6 Python多线程</h2><p>Cython 会做一些<strong>小把戏</strong>，轮流执行 Python 线程。这样一来，用户看到的就是“伪并行”——Python 线程在交错执行，来模拟真正并行的线程。<br /><strong>所以说Python的多线程是伪多线程</strong></p><h3 id="61-gil-到底锁的是什么"><a class="markdownIt-Anchor" href="#61-gil-到底锁的是什么"></a> 6.1 GIL 到底锁的是什么？</h3><p>GIL 的全称是 Global Interpreter Lock, 全局解释器锁。它锁的是解释器而不是你的 Python 代码。它防止多线程同时执行 Python<br />的字节码(bytecodes)，防止多线程同时访问 Python 的对象。</p><p>在 Python 官方文档Releasing the GIL from extension code<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>中，有这样一段话：</p><p>Here is how these functions work: <strong>the global interpreter lock is used to protect the pointer to the current thread<br />state.</strong> When releasing the lock and saving the thread state, the current thread state pointer must be retrieved before<br />the lock is released (since another thread could immediately acquire the lock and store its own thread state in the<br />global variable). Conversely, when acquiring the lock and restoring the thread state, the lock must be acquired before<br />storing the thread state pointer.</p><p>其中加黑的这一句话是说：GIL 锁用来保护指向当前进程<strong>状态的指针</strong>。</p><p>再看文档Thread State and the Global Interpreter Lock<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>中提到的这样一句话：</p><p>Without the lock, even the simplest operations could cause problems in a multi-threaded program: for example, when two<br />threads simultaneously increment the <strong>reference count</strong> of the same object, the reference count could end up being<br />incremented only once instead of twice.</p><p>当两个线程同时提高同一个对象的引用计数时，（如果没有 GIL 锁）那么引用计数只会被提高了 1 次而不是 2 次。</p><p>大家注意这两段应用中的<code>指针</code>和<code>引用计数</code>。其中指针是 C 语言的概念，Python 没有指针；引用计数是 Python 底层的概念。你平时写的<br />Python 代码，引用计数是在你调用变量的时候自动增加的，不需要你去手动加 1.</p><p>所以 GIL 锁住的东西，都是不需要你的代码直接交互的东西。</p><p>Python 的解释器通过切换线程来模拟多线程并发的情况，如上面举的例子，虽然同一个时间只有一个线程在活动，但仍然可以导致并发冲突。</p><h2 id="7-gil-对-python-多线程开发的影响"><a class="markdownIt-Anchor" href="#7-gil-对-python-多线程开发的影响"></a> 7 GIL 对 Python 多线程开发的影响</h2><p>在提到开发性能瓶颈的时候，我们经常把对资源的限制分为两类，</p><ul><li>一类是计算密集型（CPU-bound）</li><li>一类是 I/O 密集型（I/O-bound）。</li></ul><p>计算密集型的程序是指的是把 CPU 资源耗尽的程序，也就是说想要提高性能速度，就需要提供更多更强的 CPU，比如矩阵运算，图片处理这类程序。</p><p>I/O 密集型的程序只的是那些花费大量时间在等待 I/O 运行结束的程序，比如从用户指定的文件中读取数据，从数据库或者从网络中读取数据，I/O<br />密集型的程序对 CPU 的资源需求不是很高。</p><h3 id="71-如何加速"><a class="markdownIt-Anchor" href="#71-如何加速"></a> 7.1 如何加速？</h3><p>一般来说 IO 密集型用muti-Thread、协程来加速，CPU 密集型用muti-Process来加速。</p><p>结合来看IO密集型使用协程 + 多进程 不失为“最佳”方案：</p><p>aiomultiprocess：<span class="exturl" data-url="aHR0cHM6Ly9weXBpLm9yZy9wcm9qZWN0L2Fpb211bHRpcHJvY2Vzcy8=">https://pypi.org/project/aiomultiprocess/<i class="fa fa-external-link-alt"></i></span></p><p><strong>如何绕过GIL？</strong></p><p>你并不需要过多考虑 GIL。因为如果多线程计算成为性能瓶颈，往往已经有 Python 库来解决这个问题了。</p><p>绕过 GIL 的大致思路有这么两种：</p><ul><li>绕过 CPython，使用 JPython（Java 实现的 Python 解释器）等别的实现；</li><li>把关键性能代码，放到别的语言（一般是 C++）中实现。</li></ul><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Releasing the GIL from extension<br />code: <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9jLWFwaS9pbml0Lmh0bWwjcmVsZWFzaW5nLXRoZS1naWwtZnJvbS1leHRlbnNpb24tY29kZQ==">https://docs.python.org/3/c-api/init.html#releasing-the-gil-from-extension-code<i class="fa fa-external-link-alt"></i></span> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>Thread State and the Global Interpreter<br />Lock: <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9jLWFwaS9pbml0Lmh0bWwjdGhyZWFkLXN0YXRlLWFuZC10aGUtZ2xvYmFsLWludGVycHJldGVyLWxvY2s=">https://docs.python.org/3/c-api/init.html#thread-state-and-the-global-interpreter-lock<i class="fa fa-external-link-alt"></i></span> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">1 什么是GIL
GIL（Global Interpreter Lock，即全局解释器锁），是最流行的 Python 解释器 CPython 中的一个技术术语。它的意思是全局解释器锁，本质上是
类似操作系统的 Mutex，它可以帮助CPython解决其在内存管理中存在的线程不安全问题。

每一个 Python 线程，在 CPython 解释器中执行时，都会先锁住自己的线程，阻止别的线程执行。

简而言之就是任意时刻，Python 只有一个线程在同时运行。

 2 为什么需要GIL
在CPython中，全局解释器锁（GIL）是一个互斥体，用于保护对Python对象的访问，防止多个线程同时执行Py</summary>
    
    
    
    <category term="GIL" scheme="https://paynewu-blog.github.io/categories/GIL/"/>
    
    <category term="thread" scheme="https://paynewu-blog.github.io/categories/GIL/thread/"/>
    
    
    <category term="python" scheme="https://paynewu-blog.github.io/tags/python/"/>
    
    <category term="Python" scheme="https://paynewu-blog.github.io/tags/Python/"/>
    
    <category term="py" scheme="https://paynewu-blog.github.io/tags/py/"/>
    
    <category term="GIL" scheme="https://paynewu-blog.github.io/tags/GIL/"/>
    
    <category term="thread" scheme="https://paynewu-blog.github.io/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>聊聊工程化</title>
    <link href="https://paynewu-blog.github.io/41701.html"/>
    <id>https://paynewu-blog.github.io/41701.html</id>
    <published>2023-12-22T14:51:33.000Z</published>
    <updated>2025-01-06T03:07:07.087Z</updated>
    
    <content type="html"><![CDATA[<p>在聊工程化之前，对于“工程”我们进行再一次剖析。</p><p>首先，何为工程化。 我个人认为即为了适应纷繁复杂的软件变化和演进而提出的相关方式方法，其目的是为了更好的排兵布阵、分工协作。</p><blockquote><p>工程过程中也意味着取舍</p></blockquote><p>软件工程，将工程化的概念左移，在软件设计之初就引入工程化的思想，囊括住软件的全生命周期。</p><h2 id="研发效能"><a class="markdownIt-Anchor" href="#研发效能"></a> 研发效能</h2><p>当我们在谈”工程化“，我们究竟在谈什么？<br />有人讨论，是因为存在问题，而问题就在于实际的研发效率，已经远远低于预期了。<br />企业初创期，一个idea从形成到上线，也许只需要1~2小时，而随着企业的发展，类似的事情的执行与落地往往需要多个团队协同，花费数周甚至是数月才能完成。 这便造成了鲜明的对比，而这一对比，对于没有深入理解软件工程的人来说，显得难以理解，可有往往无计可施。</p><ul><li>效能：衡量产品的经济效应</li><li>效率：提升业务的响应能力，提高吞吐，降低成本</li></ul><h2 id="本质复杂度与偶然复杂度"><a class="markdownIt-Anchor" href="#本质复杂度与偶然复杂度"></a> 本质复杂度与偶然复杂度</h2><p>21世纪初，早期的互联网从业者开发简易的网站只需要学会使用Linux、Apache、MySQL、PHP（Perl）即可。可如今，在大型互联网公司工作的开发者，，需要学习理解的技术栈早就不知道上升了几个量基本别。如开发框架、分布式、微服务、云原生等等。</p><p>如果仅仅是这些复杂度还好，毕竟都是行业的标准技术，以开发者的学习能力，很快就能掌握。令人生畏的是，大型公司中都有一套或多套软件系统，这些软件系统的代码规模往往在百万行以上，质量有好坏而开发者必须基于这些系统开展工作。因此研发效率大幅度降低，其中一个核心的因素——软件复杂度的指数级上升。</p><p>Fred Brooks 在其经典著作《人月神话》的【没有饮弹】一文中对于软件的复杂度有着精彩的论述，他将软件复杂度分为本质复杂度与偶然复杂度。</p><blockquote><p>本质复杂度与偶然复杂度这2个词来源于亚里士多德的《形而上学》，在亚里士多德那里，本质属性是一个物体必然拥有的属性，而偶然属性是一个物体可以（也可以不）拥有的属性。</p></blockquote><ul><li>例1、一个电商系统必然会包含交易、支付、商品等业务复杂度，而这个复杂度是天然就有的，故称之为本质复杂度。</li><li>例2、一个电商软件可以是基于容器技术进行管理部署，技术体系选型为Java。而这些间接引入的复杂度，称之为偶然复杂度。</li></ul><p>Fred Brooks 所描述的本质复杂度，指的是来自问题域本身的复杂度，除非缩小问题域的范围。 否则是无法消除本质复杂度的，而偶然复杂度是由于解决方案带来的。</p><p>我们还可以从所谓的问题空间（Problem Space）和方案空间（Solution Space）来理解这2个复杂度，问题空间就是现实的初始状态和期望状态，以及一系列约束规则（我们通常称之为业务），方案空间就是工程师设计实现的，一些从初始状态达到期望状态的步骤。缺乏经验的工程师往往在还没理解清楚问题的情况下就急于写代码，就是缺乏对于问题空间和方案空间的理解，而近年来领域驱动设计为那么多工程师所推崇，其核心原因就是它指导了大家重视问题空间，去直面本质复杂度。</p><p>《人月神话》写于1975年，距今已有47了，Brooks认为软件的复杂度是无法得到本质上的降低的，同时认为随着高级变成语言的演进，开发环境的发展，偶然复杂度会得到本质的降低。</p><h2 id="如何进行高效的工程化实践"><a class="markdownIt-Anchor" href="#如何进行高效的工程化实践"></a> 如何进行高效的工程化实践</h2><ol><li>统一概念</li><li>树立指导思想与标准</li><li>沉淀最佳实践（软件设计,代码风格,安全编码）</li><li>工具\平台以及自动化</li><li>方式方法与规律</li></ol>]]></content>
    
    
    <summary type="html">在聊工程化之前，对于“工程”我们进行再一次剖析。

首先，何为工程化。 我个人认为即为了适应纷繁复杂的软件变化和演进而提出的相关方式方法，其目的是为了更好的排兵布阵、分工协作。

工程过程中也意味着取舍

软件工程，将工程化的概念左移，在软件设计之初就引入工程化的思想，囊括住软件的全生命周期。

 研发效能
当我们在谈”工程化“，我们究竟在谈什么？
有人讨论，是因为存在问题，而问题就在于实际的研发效率，已经远远低于预期了。
企业初创期，一个idea从形成到上线，也许只需要1~2小时，而随着企业的发展，类似的事情的执行与落地往往需要多个团队协同，花费数周甚至是数月才能完成。 这便造成了鲜明的对比</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>逻辑与思维</title>
    <link href="https://paynewu-blog.github.io/7487.html"/>
    <id>https://paynewu-blog.github.io/7487.html</id>
    <published>2023-04-19T08:17:31.000Z</published>
    <updated>2025-01-06T03:07:07.088Z</updated>
    
    <content type="html"><![CDATA[<ul><li>“你讲话要有逻辑！”</li><li>“你这逻辑不对！”</li><li>“你的底层逻辑是什么？”</li><li>“说说你的逻辑思维能力体现在哪儿？”</li></ul><p>见字如面, 我是Payne。在日常交流中，我们会频繁的使用“逻辑”这个词。但能够清晰的说出逻辑的定义（逻辑是什么）却少之又少，能够正确的掌握逻辑推理的人就更少了。<br />对于大部分人来说，逻辑更像是一个“熟悉的陌生人”。</p><p>不得不说，逻辑学是一门非常复杂的学科，光《逻辑学导论》就有近千页，系统的介绍逻辑学并不是本次的目的，本次的主要目的是逻辑知识科普，旨在唤起大家的理性意识，<br />能够掌握一些逻辑学的基本知识，具备一些逻辑思维能力。</p><ul><li>在面对“杠精”的时候，能发现对方的逻辑谬误</li><li>在思考问题的时候，能尽量做到逻辑完整</li><li>在沟通表达的时候，能尽量做到逻辑清晰</li><li>在获取信息的时候，能尽量做到去伪存真</li></ul><h2 id="逻辑的定义"><a class="markdownIt-Anchor" href="#逻辑的定义"></a> 逻辑的定义</h2><p>逻辑（logic），源自古典希腊语逻各斯（logos），最初的意思是“词语”或“言语”，（引申出意思“思维”或“推理”）。逻各斯，是古希腊哲学家赫拉克利特最早引入的<br />哲学概念，古希腊哲学从探求世界本原问题开始，从泰勒斯的水本原（具象），认为水是万物之源，到赫拉克利特的逻各斯（抽象），再到柏拉图的理念论，完成了自然哲学到形而上学的发展。</p><p>简而言之，逻各斯是指可理解的一切规律，<strong>逻辑是指思维的规律和规则</strong>。</p><p>逻辑除了指思维规律，狭义上，也有逻辑学的含义，按照《逻辑学导论》中的定义，逻辑学是研究用于区分正确推理（inference）与不正确推理的方法和原理的学问。</p><p>相比较上面的教科书定义，我觉得芝本秀德在《深度思考法》中对逻辑的定义要更容易理解，书中这样写道“逻辑就是关系”。</p><p>我们说某人逻辑性太差，其实正是因为他们没有在想<strong>表达东西之间建立关系</strong><br />。例如，对方说“今天的天气真不错。”我们认为，诸如“是啊，天气太好了”或者“天气让人心情都变好了”这样的回答是有逻辑性的。<br />可是如果回答是“我肚子好饿啊”，那么这种答非所问，就完全不符合逻辑。</p><p><strong>所以说无逻辑就是没有建立起事物之间的正确关系，换句话说有逻辑就是能建立事物之间的正确关系。</strong></p><p>这个表述有一定的道理，因为逻辑学就是研究多个语句（sentence）之间推理是否正确的学问，所以从这个意义上来说，逻辑学就是研究语句之间关系的学问。不过，<br />这个“关系”并不是都像“天气好”和“心情好”这样的显而易见，有些关系很复杂，有些关系很隐蔽，这就要借助更多逻辑学的知识来分析他们的有效性了。</p><p>不管怎样，从理解的角度来说，记住“逻辑就是关系”还是很有用的。</p><h3 id="古典逻辑"><a class="markdownIt-Anchor" href="#古典逻辑"></a> 古典逻辑</h3><p>古典逻辑（亚里斯多德逻辑）主要处理的是不同对象的类之间关系的论证。类是指共有某种特定属性的对象的汇集。 类与类之间的三种关联方式：</p><ul><li>全包含（wholly included）例如狗的类和哺乳动物的类。</li><li>部分包含（partially included）例如运动员的类和女人的类。</li><li>互斥（exclude），例如三角形的类和圆形的类。</li></ul><p>基于类和类之间的关系，有四种直言命题：</p><ul><li>全称肯定命题。所有S是P。例如所有政客都是说谎者。也叫A命题。</li><li>全称否定命题。没有S是P。例如没有政客是说谎者。叫E命题。</li><li>特称肯定命题。有S是P。例如有政客是说谎者。叫I命题。</li><li>特称否定命题。有S不是P。例如有政客不是说谎者。叫O命题。</li></ul><p>基于这些命题和谓项，组成了很多形式。古典逻辑学家很细致的研究了这些形式，总结出15个有效的三段论形式。</p><p>例如下面的论证：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">没有富人是游民，（E命题）</span><br><span class="line">所有律师都是富人，（A命题）</span><br><span class="line">所以，没有律师是游民。（E命题）</span><br></pre></td></tr></table></figure><p>因为这个论证形式是EAE-1，而EAE-1是15个有效论证形式之一，所以是一个有效论证。又因为其前提是真的，所以结论也是真的。</p><h3 id="符号逻辑"><a class="markdownIt-Anchor" href="#符号逻辑"></a> 符号逻辑</h3><p><strong>符号逻辑就是利用符号来表示逻辑中的各种概念与关系</strong>。1847年，英国数学家布尔发表了《逻辑的数学分析》，建立了“布尔代数”，并创造一套符号系统。布尔建立了<br />一系列的运算法则，利用代数的方法研究逻辑问题，初步奠定了数理逻辑的基础。</p><p>目前，符号逻辑已经超出逻辑学的范畴，成为数学的一个分支，同时也是计算机科学的基础。</p><p>逻辑代数也叫做开关代数，它的基本运算是逻辑加、逻辑乘和逻辑非，也就是命题演算中的“或”、“与”、“非”，运算对象只有两个数 0和<br />1，相当于命题演算中的“真”和“假”。逻辑代数的运算特点如同电路分析中的开和关、高电位和低电位、导电和截止等现象完全一样，都只有两种不同的状态，因此，它在电路分析中得到广泛的应用。</p><p>通过符号化和公式化，我们就可以对逻辑命题进行数学演算，比如符号~代表否定，因此 p=q 和 p=~~q<br />是等价的，即双重否定等于肯定。同样，我们在计算机中的逻辑运算（与、或、非）也是完全符合符号逻辑的。</p><h2 id="逻辑思维"><a class="markdownIt-Anchor" href="#逻辑思维"></a> 逻辑思维</h2><p>逻辑思维包含基础三要素：</p><ul><li>概念</li><li>判断（在逻辑学中，也叫命题，英文是proposition）</li><li>推理（在逻辑学中，也叫论证，英文是argument）</li></ul><p>概念是思维的基本单位；通过概念对事物是否具有某种属性进行肯定或否定的回答，这就是判断；由一个或几个判断推出另一判断的思维形式，就是推理。</p><p>实际上一本书的逻辑也是包含这三个要素，如果你看过《如何阅读一本书》，里面提到的分析阅读，说的就是如何通过提炼一本书的关键字词（概念），关键句子（判断），<br />以及关键论述（推理）来分析一本书的主旨。</p><p>所以逻辑思维的要义，就在于正确运用概念、判断、推理的思维形式。想要正确掌握逻辑思维，就必须从这三方面学起。</p><h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3><blockquote><p>概念是思维的基本单位，是反映事物本质属性或特有属性的思维形式。</p></blockquote><p>这个世界有很多事物，都是通过我们的思维去赋予它们意思或意义的，然后通过语言符号呈现出来。所以说，*<br /><em>这些意思或意义，就是概念的思维内显形式。语言是概念的外显形式</em>*。</p><p>明晰概念可以说是我们了解事物的第一步。是我们学习、研究和讨论的基础。可以说认知水平越高的人，越能认识到概念的重要性。</p><p>在《批判性思维》中作者说学习一门课程应该从理解课程的最<strong>基本概念</strong>开始。<br />比如在经济学中，“稀缺”是经济学中的基本概念，其它经济学概念都与这一中心概念有关：稀缺意味着我们任何一个人都不可能拥有所有想要的资源（稀缺的事实），我们<br />想要得到一些东西必须先放弃另一些东西。</p><p>同样，在2016年11月9日下午，在北京举办的“朗润·格政”国家发展研究院论坛上，两位著名经济学家林毅夫和张维迎在北京大学朗润园进行了一场可以写入历史的辩论。</p><p>他们辩论的主题是“产业政策”。在辩论的开始很有意味，林毅夫首先开讲，在说完客套话后接着说：<br />“在准备这个报告的时候，他们给我一个任务，**你在讲你的看法之前先定义一下什么是产业政策，我想定义是非常重要的，不然会各说各话，谈论过程当中就没有激情<br />**”</p><blockquote><p>所以，提高我们的逻辑思维能力，要从懂清楚每一个概念所表达的具体内容（内涵和外延）开始。</p></blockquote><h3 id="判断"><a class="markdownIt-Anchor" href="#判断"></a> 判断</h3><blockquote><p>判断（也叫命题）是推理的建筑基块，一个判断就是一个断言（Assert），它断定了一个事情是这样或者不是这样。因此，每一个判断都是或真或假的。</p></blockquote><p>一个问题没有断言任何东西，就不是判断。“你知道下象棋吗？”这的确是一个句子，但没有做出关于这个世界的断定。一个命令（“快点！”）或者感叹（“我的天哪！”）也<br />不是判断。 因为这些问题、命令和感叹都是非真且非假的。</p><p>判断一般都是用陈述句作为表达的，如“世界上的所有人都是善良的”。这是一句肯定判定。只要该判断符合对象的实际情况，这就是真的，反之就是假的。</p><p>判断是概念的展开，没有判断，就不能揭示和说明概念。同时，判断也是推理的前提，是正确运用各种推理的必要条件。</p><p>试想一下，“世界上的所有人都是善良的”这个判断，我们都知道是假的，否则这个世界就没有违法犯罪的人了。</p><p>由此，我们可以得出判断的两个重要特征：</p><ul><li>判断有肯定或者否定之分，可以有肯定判断和否定判断；</li><li>判断有真假之分，一个判断要么真要么假，不能非真非假；</li></ul><p>准确的运用判断，我们才能够进行正确的思考。而思考的形式，就是推理了。</p><h3 id="逻辑推理"><a class="markdownIt-Anchor" href="#逻辑推理"></a> 逻辑推理</h3><p>逻辑就是关系。所谓的推理，就是研究语句、判断、命题之间相互关系的学问</p><h2 id="逻辑推理方法"><a class="markdownIt-Anchor" href="#逻辑推理方法"></a> 逻辑推理方法</h2><p>逻辑推理方式多种多样，但也万变不离。简单可以分为演绎推理、归纳推理、溯因推理、类比推理、统计推理、因果推理、模拟推理等，这些推理方法各有特点，适用于不同的情境。</p><h3 id="演绎推理"><a class="markdownIt-Anchor" href="#演绎推理"></a> 演绎推理</h3><p>演绎推理旨在阐明前提和结论之间的关系，为评估演绎论证是否有效提供方法。 演绎推理是从一般原则出发，推导出特殊结论的过程。<br />例如三段论、数学归纳法、反证法等。演绎推理属于必然性推理，即前提真且推理形式正确，则结论必然真。</p><p>例如，根据三段论，我们可以得出以下推理：所有人都会死亡（前提一），苏格拉底是人（前提二），因此苏格拉底会死亡（结论）。这个推理过程就是演绎推理。</p><h4 id="演绎推理局限性"><a class="markdownIt-Anchor" href="#演绎推理局限性"></a> 演绎推理局限性</h4><p>演绎推理的局限性在于它所依赖的前提必须是真实的。演绎推理是从一般原则出发，推导出特殊结论的过程。**如果前提是真实的，且推理形式正确，则结论必然真<br />**。但是，如果前提不真实，那么演绎推理所得出的结论就可能不正确。</p><p>例如，根据三段论，我们可以得出以下推理：所有人都会死亡（前提一），苏格拉底是人（前提二），因此苏格拉底会死亡（结论）。这个推理过程是正确的，因为它<br />所依赖的前提都是真实的。但是，如果我们改变前提一为“所有人都不会正常死亡”，那么演绎推理所得出的结论就不正确了。</p><p>因此，演绎推理所得出的结论的正确性取决于它所依赖的前提是否真实。</p><h4 id="提高演绎推理可靠性"><a class="markdownIt-Anchor" href="#提高演绎推理可靠性"></a> 提高演绎推理可靠性</h4><p>要提高演绎推理的可靠性，首先需要确保演绎推理所依赖的前提是真实的。可以通过观察、实验、查阅资料等方式来验证前提的真实性。<br />其次，需要确保推理形式正确。可以使用逻辑学中的推理规则来检查推理形式是否正确。如果不确定推理形式是否正确，可以寻求专业人士的帮助。</p><p>此外，可以多做练习来提高演绎推理能力。通过不断练习，可以更好地掌握演绎推理的方法和技巧，从而提高演绎推理的可靠性。</p><p>总之，要提高演绎推理的可靠性，需要确保<strong>前提真实、推理形式正确，并且不断练习</strong>。</p><h4 id="演绎推理适用场景"><a class="markdownIt-Anchor" href="#演绎推理适用场景"></a> 演绎推理适用场景</h4><p>演绎推理适用于从一般原则推导出特殊结论的场景。它常用于数学、逻辑学、哲学等领域，也可以用于日常生活中的推理。<br />例如，在数学中，我们可以使用演绎推理来证明定理。我们先假设定理的前提成立，然后根据已知的公理和定理，通过演绎推理推导出定理的结论。</p><p>在日常生活中，我们也可以使用演绎推理来解决问题。例如，如果我们知道所有的苹果都是水果（前提一），并且红富士是一种苹果（前提二），那么我们就可以通过演绎推理得出结论：红富士是一种水果。</p><p>总之，演绎推理适用于从一般原则推导出特殊结论的场景，可以帮助我们更好地理解和解决问题。</p><h3 id="归纳推理"><a class="markdownIt-Anchor" href="#归纳推理"></a> 归纳推理</h3><p>归纳推理是从特殊事实出发，总结出一般原则的过程。归纳是从特殊到一般的过程，属于合情推理。例如经验公式、物理学原理等。归纳推理属于或然性推理，即<br /><strong>前提真且推理形式正确，但结论未必真</strong>。</p><p>例如，如果我们观察到许多只乌鸦都是黑色的，我们就可以通过归纳推理得出结论：所有的乌鸦都是黑色的。但是这个结论并不一定正确，因为我们并没有观察到所有的乌鸦，也许存在一只不是黑色的乌鸦。</p><h4 id="归纳推理的局限性"><a class="markdownIt-Anchor" href="#归纳推理的局限性"></a> 归纳推理的局限性</h4><p>归纳推理的局限性在于它所得出的结论并不一定正确。归纳推理是从特殊事实出发，总结出一般原则的过程。但是，由于我们无法观察到所有的特殊事实，所以归纳推理所得出的结论并不一定正确。</p><p>例如，如果我们观察到许多只乌鸦都是黑色的，我们就可以通过归纳推理得出结论：所有的乌鸦都是黑色的。但是这个结论并不一定正确，因为我们并没有观察到所有的乌鸦，也许存在一只不是黑色的乌鸦。</p><p>因此，归纳推理所得出的结论只能作为一个假设，需要进一步验证。归纳推理属于或然性推理，即前提真且推理形式正确，但结论未必真。</p><h4 id="提高归纳推理的可靠性"><a class="markdownIt-Anchor" href="#提高归纳推理的可靠性"></a> 提高归纳推理的可靠性</h4><p>要提高归纳推理的可靠性，可以采取以下几种方法：</p><ul><li>增加观察样本数量：归纳推理是从特殊事实出发，总结出一般原则的过程。因此，观察样本数量越多，归纳推理所得出的结论就越可靠。</li><li>确保观察样本具有代表性：观察样本应该具有代表性，能够反映整体情况。如果观察样本不具有代表性，那么归纳推理所得出的结论就可能不正确。</li><li>排除干扰因素：在进行归纳推理时，应该排除干扰因素的影响。如果存在干扰因素，那么归纳推理所得出的结论就可能不正确。</li><li>多角度观察：可以从多个角度进行观察，以获得更全面、更准确的信息。这样可以提高归纳推理的可靠性。</li></ul><p>总之，要提高归纳推理的可靠性，需要增加观察样本数量、确保观察样本具有代表性、排除干扰因素并且多角度观察。</p><h4 id="归纳推理适用场景"><a class="markdownIt-Anchor" href="#归纳推理适用场景"></a> 归纳推理适用场景</h4><p>归纳推理适用于从特殊事实总结出一般原则的场景。它常用于科学研究、统计分析、市场调查等领域，也可以用于日常生活中的推理。</p><p>例如，在科学研究中，我们可以通过观察大量的实验数据，使用归纳推理来总结出一般性规律。在统计分析中，我们可以通过分析大量的数据，使用归纳推理来总结出统计规律。</p><p>在日常生活中，我们也可以使用归纳推理来解决问题。例如，如果我们观察到许多只乌鸦都是黑色的，我们就可以通过归纳推理得出结论：所有的乌鸦都是黑色的。</p><p>总之，归纳推理适用于从特殊事实总结出一般原则的场景，可以帮助我们更好地理解和解决问题。</p><h3 id="溯因推理"><a class="markdownIt-Anchor" href="#溯因推理"></a> 溯因推理</h3><p>溯因推理是一种推理，涉及形成假设或解释来解释一组观察结果或事实。 它是为一组给定的数据生成可能的最佳解释的过程，即使该解释不一定被证明是正确的。<br />与从一般原理或理论开始并从中得出特定结论的演绎和从特定观察开始并从中得出一般原理或理论的归纳相反，溯因推理从不完整或模棱两可的数据开始并试图填补空白<br />通过构建一个合理的解释。</p><p>溯因推理常用于科学研究和调查，它可以帮助科学家根据有限或不完整的数据产生新的假设和理论。<br />它还用于执法等领域，在这些领域中，调查人员可以根据现有证据使用绑架来生成有关犯罪的理论。</p><p>总的来说，溯因推理在帮助我们理解世界方面发挥着重要作用，它使我们能够对我们遇到的观察结果和事实做出合理的解释。</p><p>例如，当你早晨起来发现马路变湿了，你就会去寻找马路湿的原因。可能是昨晚下雨了，也可能是被洒水车淋湿的，这就是溯因推理。然后你会想到如果是下雨，那么房<br />顶也会湿，然后观察房顶果然湿了，所以认为是下雨导致马路湿了。</p><blockquote><p>溯因推理是一种从事实推理到最佳解释的过程，可以帮助我们更好地理解和解决问题。</p></blockquote><h4 id="溯因推理局限性"><a class="markdownIt-Anchor" href="#溯因推理局限性"></a> 溯因推理局限性</h4><p>溯因推理的局限性在于它所得出的结论并不一定正确。溯因推理是从事实推理到最佳解释的过程，但是这个最佳解释并不一定是正确的。因为可能存在多种解释，而我们<br />只能根据现有的信息选择最合适的解释。</p><p>例如，当你早晨起来发现马路变湿了，你就会去寻找马路湿的原因。可能是昨晚下雨了，也可能是被洒水车淋湿的，这就是溯因推理。然后你会想到如果是下雨，那么房<br />顶也会湿，然后观察房顶果然湿了，所以认为是下雨导致马路湿了。但是这个结论并不一定正确，因为也许房顶湿是由于其他原因造成的。</p><p>因此，溯因推理所得出的结论只能作为一个假设，需要进一步验证。溯因推理属于或然性推理，即前提真且推理形式正确，但结论未必真。</p><h4 id="溯因推理适用场景"><a class="markdownIt-Anchor" href="#溯因推理适用场景"></a> 溯因推理适用场景</h4><p>溯因推理适用于从事实推理到最佳解释的场景。它常用于科学研究、医学诊断、刑侦推理等领域，也可以用于日常生活中的推理。</p><p>例如，在科学研究中，我们可以通过观察实验现象，使用溯因推理来推导出最佳解释。在医学诊断中，医生可以根据病人的症状，使用溯因推理来推断病因。</p><p>在日常生活中，我们也可以使用溯因推理来解决问题。例如，当你早晨起来发现马路变湿了，你就会去寻找马路湿的原因。可能是昨晚下雨了，也可能是被洒水车淋湿的，这就是溯因推理。</p><p>总之，溯因推理适用于从事实推理到最佳解释的场景，可以帮助我们更好地理解和解决问题。</p><h4 id="提高溯因推理的可靠性"><a class="markdownIt-Anchor" href="#提高溯因推理的可靠性"></a> 提高溯因推理的可靠性</h4><p>提高溯因推理的可靠性，可以采取以下措施：</p><ul><li>确保所分析的事件之间确实存在因果关系。</li><li>确保分析过程严谨，遵循逻辑规则。</li><li>检查推断出的原因是否与已知事实相符。</li></ul><h3 id="演绎推理与归纳推理的区别与联系"><a class="markdownIt-Anchor" href="#演绎推理与归纳推理的区别与联系"></a> 演绎推理与归纳推理的区别与联系</h3><p>归纳推理和演绎推理是两种不同的推理方法，它们之间既有区别又有联系。</p><ul><li>归纳推理是从特殊事实出发，总结出一般原则的过程。它属于或然性推理，即前提真且推理形式正确，但结论未必真。归纳推理常用于科学研究、统计分析、市场调查等领域。</li><li>演绎推理是从一般原则出发，推导出特殊结论的过程。它属于必然性推理，即前提真且推理形式正确，则结论必然真。演绎推理常用于数学、逻辑学、哲学等领域。</li></ul><p>归纳推理和演绎推理之间既有区别又有联系。它们都是推理方法，都可以帮助我们更好地理解和解决问题。但是它们的推理过程不同，适用于不同的情境。在实际应用中，归纳推理和演绎推理往往相辅相成，共同帮助我们更好地解决问题。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>无论是演绎推理还是归纳推理,亦或者溯因分析。将其放在结构化思维中体现形式无非是自顶向下亦或者自顶向上。从简至繁，由繁入简。</p><p>非常感谢你的阅读，更多精彩内容，欢迎我的公众号「积跬Coder」与我一起成长。</p>]]></content>
    
    
    <summary type="html">* “你讲话要有逻辑！”
 * “你这逻辑不对！”
 * “你的底层逻辑是什么？”
 * “说说你的逻辑思维能力体现在哪儿？”

见字如面, 我是Payne。在日常交流中，我们会频繁的使用“逻辑”这个词。但能够清晰的说出逻辑的定义（逻辑是什么）却少之又少，能够正确的掌握逻辑推理的人就更少了。
对于大部分人来说，逻辑更像是一个“熟悉的陌生人”。

不得不说，逻辑学是一门非常复杂的学科，光《逻辑学导论》就有近千页，系统的介绍逻辑学并不是本次的目的，本次的主要目的是逻辑知识科普，旨在唤起大家的理性意识，
能够掌握一些逻辑学的基本知识，具备一些逻辑思维能力。

 * 在面对“杠精”的时候，能发现对方的</summary>
    
    
    
    <category term="逻辑" scheme="https://paynewu-blog.github.io/categories/%E9%80%BB%E8%BE%91/"/>
    
    <category term="思维" scheme="https://paynewu-blog.github.io/categories/%E9%80%BB%E8%BE%91/%E6%80%9D%E7%BB%B4/"/>
    
    <category term="推理" scheme="https://paynewu-blog.github.io/categories/%E9%80%BB%E8%BE%91/%E6%80%9D%E7%BB%B4/%E6%8E%A8%E7%90%86/"/>
    
    
    <category term="逻辑" scheme="https://paynewu-blog.github.io/tags/%E9%80%BB%E8%BE%91/"/>
    
    <category term="思维" scheme="https://paynewu-blog.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
    <category term="推理" scheme="https://paynewu-blog.github.io/tags/%E6%8E%A8%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>搜索引擎使用技巧</title>
    <link href="https://paynewu-blog.github.io/27205.html"/>
    <id>https://paynewu-blog.github.io/27205.html</id>
    <published>2023-04-11T17:28:37.000Z</published>
    <updated>2025-01-06T03:07:07.084Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>大多数人以非常低效且通常无效的方式使用谷歌。如果您所做的只是输入几个关键字并单击搜索按钮，那么您就是那些无法从Google中获得尽可能多的资源的用户之一。——《谷歌百科》</p></blockquote><p>Hi,见字如面，我是裴恩。</p><p>在信息爆炸的如今，我们经常借助搜索引擎来获取信息，譬如baidu、google、bing等各搜索引擎。对，它真的非常的强大。只需将想知道的相关问题输入给它，他就会返回给我们“琳琅满目”的信息（当然这其中也包含答案）。<br />但通常直接搜索已经无法满足我们的需求，尤其是开发中。例如我们需要查寻一个bug如何处理、如何写某某代码。这之间夹杂了许多无用的信息、广告、相似却无关的信息。这非常消耗我们的精力！</p><p>那么我们该如何高效精确的使用搜索引擎进行搜索？</p><h2 id="使用搜索"><a class="markdownIt-Anchor" href="#使用搜索"></a> 使用搜索</h2><p>由于搜索引擎，核心的显示就是一个搜索框。在此便不在对此进行过多赘述。<br />无论我们是使用搜索引擎简单或是高级的搜索功能，在此之前我们都需要有效可靠的搜索方法和流程。遵循这些原则和使用这些方法就可以获取到对应更精准，更明确的结果。</p><ol><li>确定此次的目的与范围，（什么是一定不要的信息、什么又是可要可不要的信息、什么是一定要的信息。这些如果足够清晰，那么就可以更高效精准的找到答案）<ol><li>此次的搜索是为了寻找什么（请始终保持该“初心”！）</li><li>精确、清晰简洁的描述需要寻找的信息（毕竟less is more！）</li><li>那些词可以帮助搜索进行排除，亦或者更好的定义问题</li></ol></li><li>构建搜索需求<ol><li>使用尽可能清晰明确的关键词</li><li>尝试使用适当的搜索运算符来优化的搜索</li><li>使用搜索的筛选功能或“高级搜索”功能</li></ol></li><li>进行搜索</li><li>根据返回的结果，优化查询并再次搜索——或者通过切换到更合适的搜索站点来优化搜索</li></ol><blockquote><p>换言之，这需要你在搜索之前思考清楚，接着在获得最初结果后精炼你的搜索。这些多做的努力都是轻微的，但确实很值得。</p></blockquote><h2 id="高级搜索技巧"><a class="markdownIt-Anchor" href="#高级搜索技巧"></a> 高级搜索技巧</h2><p>高级搜索技巧主要包含两部分，其一就是操作符的使用， 搜索关键字按照什么<strong>逻辑关系</strong>如何<br />排列组合。其二便是过滤搜索，搜索指定类型的内容。具体内容如下</p><h3 id="操作符"><a class="markdownIt-Anchor" href="#操作符"></a> 操作符</h3><h4 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符"></a> 逻辑运算符</h4><ul><li><code>AND</code>：与运算</li><li><code>OR</code>：或运算</li><li><code>NOT</code>: 非运算</li></ul><h4 id="逻辑符"><a class="markdownIt-Anchor" href="#逻辑符"></a> 逻辑符</h4><ul><li><code>+</code>: 包含</li><li><code>-</code>：排除</li><li><code>~</code>：近义词</li><li><code>()</code>:在需要需要查询的字词前后用()括起来。这个运算符的作用是提升运算顺序，跟数学中的()<br />是一个用法。跟AND一样，单独比较少用，一般也是与其他的运算符组合使用。</li></ul><h4 id="正则表达式"><a class="markdownIt-Anchor" href="#正则表达式"></a> 正则表达式</h4><ul><li><code>.</code></li><li><code>*</code>：通配符，与在正则表达是含义一致</li></ul><h4 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h4><ul><li><code>&quot;&quot;</code>：以双引号内的句子作为搜索条件，而非split后的词。</li><li><code>@</code>：指定源</li></ul><blockquote><p>注意：搜索栏中的符号均为英文字符，英文字母必须为大写。否则可能会被搜素引擎忽略</p></blockquote><h3 id="指定搜索"><a class="markdownIt-Anchor" href="#指定搜索"></a> 指定搜索</h3><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9zdXBwb3J0Lmdvb2dsZS5jb20vd2Vic2VhcmNoL2Fuc3dlci8yNDY2NDMz">https://support.google.com/websearch/answer/2466433<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>指定搜索的语法<code>指定范围：搜索内容</code>， 譬如baidu的咨询信息<code>info:baidu</code>。常见的搜素范围有如下</p><h4 id="指定词"><a class="markdownIt-Anchor" href="#指定词"></a> 指定词</h4><ul><li>filetype: 限制所搜索的文件一个特定的格式 filetype:extension</li><li>site: 限制所进行的搜索在指定的域名或网站内 site:domain</li><li>link:返回所有链接到某个URL地址的网页</li><li>info: 返回所有相关的咨询信息</li></ul><h4 id="指定词范围"><a class="markdownIt-Anchor" href="#指定词范围"></a> 指定词范围</h4><table><thead><tr><th>简介</th><th>单数</th><th>复数</th></tr></thead><tbody><tr><td>限制搜索的词语是网页中链接内包含的关键词</td><td>inanchor</td><td>allinanchor</td></tr><tr><td>限制搜索的词语是网页内文包含的关键词</td><td>intext</td><td>allintext</td></tr><tr><td>限制搜索的词语是网页网址中包含的关键词</td><td>inurl</td><td>allinurl</td></tr><tr><td>限制搜索的词语是网页标题中包含的关键词</td><td>intiitle</td><td>allintitle</td></tr></tbody></table><h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2><p>本文对于搜索引擎使用方式方法进行了探讨，同时还阐述了一些高级的搜索技巧的基础语法。希望这些技巧能够帮助你在工作中、生活中高效精确使用搜索引擎。</p><p>注意：虽然搜索引擎极大的降低了我们获取知识、答案的门槛，但是同时我们也要在使用搜索引擎中不断的完善我们自身。Google永远无法搜索到认知之外的事物！</p><h2 id="相关链接"><a class="markdownIt-Anchor" href="#相关链接"></a> 相关链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9hZHZhbmNlZF9zZWFyY2g=">Google 高级搜索<i class="fa fa-external-link-alt"></i></span><br /><span class="exturl" data-url="aHR0cHM6Ly9zdXBwb3J0Lmdvb2dsZS5jb20vd2Vic2VhcmNoL2Fuc3dlci8xMzQ0Nzk/aGw9ZW4=">How to search on Google<i class="fa fa-external-link-alt"></i></span><br /><span class="exturl" data-url="aHR0cHM6Ly9zaXRlcy5nb29nbGUuY29tL3NpdGUvaG9wZWFud2FuZy9nb29nbGUlRTYlQTMlODAlRTclQjQlQTIlRTYlOEElODAlRTUlQjclQTclRTUlQTQlQTclRTUlODUlQTg=">Google检索技巧大全<i class="fa fa-external-link-alt"></i></span><br /><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3JtaXQuY29tL2FydGljbGVzL2FydGljbGUuYXNweD9wPTY3NTI3NA==">Ten Tips for Smarter Google Searches<i class="fa fa-external-link-alt"></i></span></p><p>非常感谢你的阅读，更多精彩内容，欢迎关注我的公众号「积跬Coder」一起成长。</p>]]></content>
    
    
    <summary type="html">大多数人以非常低效且通常无效的方式使用谷歌。如果您所做的只是输入几个关键字并单击搜索按钮，那么您就是那些无法从Google中获得尽可能多的资源的用户之一。——《谷歌百科》

Hi,见字如面，我是裴恩。

在信息爆炸的如今，我们经常借助搜索引擎来获取信息，譬如baidu、google、bing等各搜索引擎。对，它真的非常的强大。只需将想知道的相关问题输入给它，他就会返回给我们“琳琅满目”的信息（当然这其中也包含答案）。
但通常直接搜索已经无法满足我们的需求，尤其是开发中。例如我们需要查寻一个bug如何处理、如何写某某代码。这之间夹杂了许多无用的信息、广告、相似却无关的信息。这非常消耗我们的精力！</summary>
    
    
    
    <category term="搜索引擎" scheme="https://paynewu-blog.github.io/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="搜索引擎" scheme="https://paynewu-blog.github.io/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
    <category term="Google" scheme="https://paynewu-blog.github.io/tags/Google/"/>
    
    <category term="Baidu" scheme="https://paynewu-blog.github.io/tags/Baidu/"/>
    
    <category term="Bing" scheme="https://paynewu-blog.github.io/tags/Bing/"/>
    
    <category term="Yandex" scheme="https://paynewu-blog.github.io/tags/Yandex/"/>
    
  </entry>
  
  <entry>
    <title>思维与思维模式</title>
    <link href="https://paynewu-blog.github.io/49563.html"/>
    <id>https://paynewu-blog.github.io/49563.html</id>
    <published>2023-02-18T14:13:58.000Z</published>
    <updated>2025-01-06T03:07:07.084Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在众多的思维方式中，首选结构化思维。其他的思维方式，如<strong>逻辑思维、批判性思维、创造性思维、战略思维、</strong><br />等也很重要，更多影响你自己如何看待问题。</p></blockquote><p>逻辑思维和结构化思维核心影响你与他人的关系，影响信息传递效率，影响你的个人影响力，是非常显性化的两种思维方式，是其他思维方式的基础。<br />显性化是你只要刻意练习，你便能习得这项能力，并且很快在工作中应用得到正反馈，提高你的工作效率、加强你的沟通表达能力。</p><p>思考和表达没有逻辑与结构，是种灾难。<strong>核心不是让自己怎样，而是非常浪费别人的时间</strong><br />。大家的时间都很宝贵，你浪费了别人的时间，别人怎么还会有耐心信任你。尤其是对领导，你应该常常想几分钟内还没把事情讲清楚，他就没了耐心。<br />同事之间沟通也如此，你讲了几分钟，对方还听不懂，那么他下次就不再想跟你沟通。</p><p><strong>同样一件事情，能有逻辑地结构化思考和表达，可以节省双方更多时间，提高效率</strong><br />。逻辑与结构化思维可以让接受信息的人快速明白你要讲什么，也可以把你想表达的重点传递给到对方，它让我们在沟通交流中提高自身说服力。</p><h2 id="结构化思维"><a class="markdownIt-Anchor" href="#结构化思维"></a> 结构化思维</h2><p>同样沟通事情，有的人三句话就能说清楚，而你可能说了10分钟也说不到核心；同样是做汇报，有的人用5页PPT就能说服对方，而你可能写了20多页还要被反问想表达什么；</p><p>同样是阐述解决方案，有的人清晰讲出背景、问题、原因、影响和举措，而你挤牙膏式的回答一句紧接着再被问一句。</p><p>如果说一个人沟通表达能力差，情商是一个因素，但还有一个更关键点：结构化思维。如果对方听了半天都不知道你在表达什么，情商再高也失去色彩。</p><p>人类大脑在处理信息的时候，有两个规律：</p><ol><li><strong>不能一次太多，太多信息会让我们的大脑觉得负荷过大</strong></li><li><strong>喜欢有规律的信息</strong></li></ol><p>人的大脑最多仅记忆7个思想，当处理过多思想的时候需要建立逻辑关系，形成立体结构，完整、清晰地看到每一面和每个点。</p><p>表达能力强的人，不是比你更聪明，而是知道大脑这个特点，更懂得通过有效的结构化思维，快速对信息进行归纳和整理进行传递。</p><p>大脑容易记住有规律的东西，那么你在信息传递时尽量使用规律的东西来传递。把无序变得有规律的过程即结构化思维。</p><h3 id="结构化思维概述"><a class="markdownIt-Anchor" href="#结构化思维概述"></a> 结构化思维概述</h3><p>结构化思维是一种从整体到局部、从框架到细节的思维方式。它要求思考者不先入为主，不会过快地陷入细节，而要经常留意事物的整体框架，在框架的基础上去拓展细节。</p><p>先看能够解决问题的关键方面，然后再往下分析，从而实现从总体到局部的鸟瞰，最典型的就是金字塔结构图。</p><p><img data-src="https://p.ipic.vip/1vl919.jpg" alt="" /></p><p>结构化思维渗透在工作的方方面面，是建立在逻辑思维之上的另一种显性化思维方式，不可或缺。结构化思维可以带来显著的工作效率提升，尤其是在沟通中。</p><p>为什么在沟通中结构化思维可以发挥巨大作用？</p><p>因为人和人之间信息差。结构的越上层，彼此之间信息差越小；结构的越下层，彼此之间信息差越大。如果一上来陷入到最下层的细节之中，对方大概率听不懂时沟通出现低效。</p><h3 id="提升结构化思维"><a class="markdownIt-Anchor" href="#提升结构化思维"></a> 提升结构化思维</h3><p>如果说逻辑思维一定程度上跟人天生智力水平有关，即我们常说的一个人聪不聪明，那么结构化思维则可以通过刻意训练习得。</p><p>结构化思维完全由自己从0到1主动规划所得，就如同有些人可以做出好看的PPT，其实也是懂得了PPT背后的套路。</p><p><img data-src="https://p.ipic.vip/0hxnu6.jpg" alt="" /></p><ul><li>论：结论先行</li><li>证：以上统下</li><li>类：归类分组</li><li>比：逻辑递进</li></ul><p>结构化思维有2种方法：自下向上组结构和自上向下套框架。</p><ul><li>纵向逻辑关系<ul><li>演绎逻辑，自上而下「使用演绎法」设计结构</li><li>归纳逻辑，自下而上「使用归纳法」提炼结构</li></ul></li><li>横向逻辑关系<ul><li>时间顺序</li><li>空间顺序</li><li>程度顺序</li></ul></li></ul><h4 id="自下而上"><a class="markdownIt-Anchor" href="#自下而上"></a> 自下而上</h4><p>自下向上组结构核心在于这个结构是你自创的。根据你自己对接收到信息的理解，把信息重新组装的过程。比如我写这篇文章的框架结构，你日常整理会议纪要的结构。没有统一标准，你按照一定逻辑重新组合信息。</p><p>比如我给领导讲业务数据的PPT，首先会介绍我分析数据的整体框架，其次再给一个实际的数据分析的概览，再往下去细看每块的细分数据，针对每块的数据给出结论和TODO。</p><ul><li>整体数据指标体系（理论）——一页PPT</li><li>总体数据指标概览（实际数据）——一页PPT</li><li>分模块1数据指标——一页PPT</li><li>分模块2数据指标——一页PPT</li><li>分模块3数据指标——一页PPT</li><li>每页PPT里的结论和TODO</li><li>总结——一页PPT</li></ul><p>先框架后细节，先总结后具体，先结论后原因，先观点后建议，先重要后次要。这样，才能让对方第一时间抓住重点信息，知道我们要传递的核心内容。</p><p>站在自己视角时，先把所有零散的点穷举，再看点与点之间的关联性连接成面，面最终再成体。概括起来大致分为以下4步：</p><ul><li>尽可能列出所有思考的要点</li><li>找出关系，进行分类（找出要点间的逻辑关系，利用 MECE 原则归类分组）</li><li>总结概括要点，提炼观点</li><li>观点补充，完善思路</li></ul><h4 id="自上而下"><a class="markdownIt-Anchor" href="#自上而下"></a> 自上而下</h4><p>如果你是做已存领域的问题解决方案，那通过自上而下找结构：思考一个框架，然后将信息或解决方案放入框架。</p><p>比如，提到规划，可以使用五看三定框架；提到制定目标，可以使用SMART原则；提到制定任务计划，可以使用WBS任务拆解。</p><p>自上向下套框架依赖我们自身积累了多少种框架，在实际场景中可以随时被调用。</p><h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9rLnNpbmEuY29tLmNuL2FydGljbGVfMzE4MTc0NTk5N19iZGE1OTc0ZDAxOTAxNzFpZy5odG1s">最重要的两种思维：逻辑思维与结构化思维<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuMTYzLmNvbS9keS9hcnRpY2xlL0hEUjk2REhFMDU1MkdFWjUuaHRtbA==">7种鲜为人知的思维模式，帮助你更好地处理问题<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
    
    
    <summary type="html">在众多的思维方式中，首选结构化思维。其他的思维方式，如逻辑思维、批判性思维、创造性思维、战略思维、
等也很重要，更多影响你自己如何看待问题。

逻辑思维和结构化思维核心影响你与他人的关系，影响信息传递效率，影响你的个人影响力，是非常显性化的两种思维方式，是其他思维方式的基础。
显性化是你只要刻意练习，你便能习得这项能力，并且很快在工作中应用得到正反馈，提高你的工作效率、加强你的沟通表达能力。

思考和表达没有逻辑与结构，是种灾难。核心不是让自己怎样，而是非常浪费别人的时间
。大家的时间都很宝贵，你浪费了别人的时间，别人怎么还会有耐心信任你。尤其是对领导，你应该常常想几分钟内还没把事情讲清楚，他</summary>
    
    
    
    <category term="思考" scheme="https://paynewu-blog.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    <category term="结构化思维" scheme="https://paynewu-blog.github.io/categories/%E6%80%9D%E8%80%83/%E7%BB%93%E6%9E%84%E5%8C%96%E6%80%9D%E7%BB%B4/"/>
    
    <category term="逻辑思维" scheme="https://paynewu-blog.github.io/categories/%E6%80%9D%E8%80%83/%E7%BB%93%E6%9E%84%E5%8C%96%E6%80%9D%E7%BB%B4/%E9%80%BB%E8%BE%91%E6%80%9D%E7%BB%B4/"/>
    
    
    <category term="思考" scheme="https://paynewu-blog.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>风控概要</title>
    <link href="https://paynewu-blog.github.io/26693.html"/>
    <id>https://paynewu-blog.github.io/26693.html</id>
    <published>2023-02-14T02:50:07.000Z</published>
    <updated>2025-01-06T03:07:07.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="风控由来"><a class="markdownIt-Anchor" href="#风控由来"></a> 风控由来</h2><p>风险控制(简称&quot;风控&quot;)是个抽象的概念。风控最开始由趋利避害的需求主导，是为了规避不确定的风险而诞生得一种经验。这种经验通过和<br />科学知识结合逐渐形成标准化、体系化的方法。</p><h2 id="何为风控"><a class="markdownIt-Anchor" href="#何为风控"></a> 何为风控</h2><p>在了解风控之前，非常有必要先了解风险。 从具体表现来看，风险又分为&quot;狭义风险&quot;和&quot;广义风险&quot;。</p><ul><li>狭义风险：损失的不确定性，说明风险只能表现出损失，没有从风控中获利得可能性</li><li>广义风险：成本或代价不确定，最终风险结果会出现损失、盈利、盈亏的可能</li></ul><p>风控则是指风险管理者采取各种措施和方法，减少或者消灭<strong>风险事件发生</strong>的各种可能性，减少风险事件发生时造成的损失。<br />有效的风险控制，可以通过清晰地识别风险类型，采取多维的控制措施和方法，尽可能地避免风险的发生,并且减少风险发生造成的损失。</p><h2 id="风控目标"><a class="markdownIt-Anchor" href="#风控目标"></a> 风控目标</h2><p>风险控制是风险管理的一个流程，也是一种方法。任何风控行为都有一个特定的目标。很多时候风控目标都是以结果去定量的，认为能够减少损失的风控就是优秀的风控，显然这样的理解是狭隘的。<br />风控的效力可以通过风控结果去定量，但是并不是减少损失的风控就是优秀的风控。风险和收益是紧密相关的，风控如果只考虑控制风险，忽略了权衡收益，最终可能本末倒置。很多投资、金融风险的控制就是如此，</p><h2 id="风控主要流程"><a class="markdownIt-Anchor" href="#风控主要流程"></a> 风控主要流程</h2><p>常用风险控制流程主要包括：风险识别、风险分析、风险决策、风险监控、风险优化</p><h3 id="风险识别"><a class="markdownIt-Anchor" href="#风险识别"></a> 风险识别</h3><p>在风险控制之前，必须先识别出风险事件才能对风险进行控制。识别风险就是对风险进行收集，需要明确风险的类型，风险在什么时候、什么地点发生，风险发生的机制，风险发生的条件等要素。</p><h3 id="风险分析"><a class="markdownIt-Anchor" href="#风险分析"></a> 风险分析</h3><p>风险识别完成之后，可以进行风险分析。风险分析是对未知风险事件的定位、可能性判断以及风险结果的确认。风险分析方法主要包括定性分析和定量分析，涉及两个维度：一是风险发生概率的分析，二是风险结果的分析。</p><ul><li>按照风险发生概率的高低，对风险发生可能性进行等级划分，可分为很易发生、较易发生、可能发生、较不易发生、不易发生。</li><li></li></ul><p>按照风险影响的大小，对风险结果进行等级划分，可分为影响特别大、影响大、影响较大、影响一般、影响小。结合风险发生概率、风险结果影响，运用风险的定性和定量分析，通过矩阵分析确认风险等级。表1-1是风险等级矩阵分析表。</p><p><img data-src="https://p.ipic.vip/n5gvaq.jpg" alt="图1-1 风险等级矩阵" /></p><h3 id="风险决策"><a class="markdownIt-Anchor" href="#风险决策"></a> 风险决策</h3><p>风险决策是指在将风险识别出来并且分析评估后，制定风险预防和缓解方案，发起风险降低行动。风险决策是风险控制的关键，优秀的风险预防、缓解方案可以很好地减少风险带来的损失。</p><h3 id="风险监控"><a class="markdownIt-Anchor" href="#风险监控"></a> 风险监控</h3><p>把风险决策投入降低风险行动中，就能够控制风险吗？风险控制的效果到底怎么样呢？为了评估风险控制的效果需要引入风险监控。风险监控是指对风险决策的能效和作用结果进行回溯，提炼出能够评估风险决策稳定性和作用质量的指标。例如在信贷风控业务中，对风控模型的监控是通过“首期逾期比例”“连续逾期超过90天”等指标进行判断的。</p><h3 id="风险优化"><a class="markdownIt-Anchor" href="#风险优化"></a> 风险优化</h3><p>风控优化是在成熟风险控制的前提下，对通过风险监控反馈出来的风控决策效果进行风控决策方案的优化调整，实现风险控制的循环迭代和持续优化。</p><h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2><p>在本文中，分别对风控得概念、目的、流程进行一一阐述。相信你对风控也有所了解了吧。虽说落地在实际中那就是另外的工作了，但万变不离其宗。</p><p>以终为始，方得始终。</p>]]></content>
    
    
    <summary type="html">风控由来
风险控制(简称&quot;风控&quot;)是个抽象的概念。风控最开始由趋利避害的需求主导，是为了规避不确定的风险而诞生得一种经验。这种经验通过和
科学知识结合逐渐形成标准化、体系化的方法。

 何为风控
在了解风控之前，非常有必要先了解风险。 从具体表现来看，风险又分为&quot;狭义风险&quot;和&quot;广义风险&quot;。

 * 狭义风险：损失的不确定性，说明风险只能表现出损失，没有从风控中获利得可能性
 * 广义风险：成本或代价不确定，最终风险结果会出现损失、盈利、盈亏的可能

风控则是指风险管理者采取各种措施和方法，减少或者消灭风险事件发生的各种可能性，减少风险事件发生时造成的损失。
有效的风险控制，可以通过清晰地识别风</summary>
    
    
    
    <category term="sec" scheme="https://paynewu-blog.github.io/categories/sec/"/>
    
    
    <category term="sec" scheme="https://paynewu-blog.github.io/tags/sec/"/>
    
  </entry>
  
  <entry>
    <title>说透数据分析-DataAnalysis</title>
    <link href="https://paynewu-blog.github.io/39365.html"/>
    <id>https://paynewu-blog.github.io/39365.html</id>
    <published>2023-02-09T10:18:44.000Z</published>
    <updated>2025-01-06T03:07:07.088Z</updated>
    
    <content type="html"><![CDATA[<p>数据分析是一种研究数据的方法，它涉及到从数据中提取有用信息从而支持决策见解的过程。它包括*<br /><em>数据收集、数据清洗、数据分析、数据可视化和结果报告</em>*。</p><blockquote><p>所有这些不同的方法主要基于两个核心思路：定量和定性分析。</p></blockquote><h2 id="数据分析的重要性"><a class="markdownIt-Anchor" href="#数据分析的重要性"></a> 数据分析的重要性</h2><p>明智的决策：从管理的角度来看，可以从分析数据中受益，因为它可以根据事实而不是简单的直觉做出决策。例如，您可以了解在哪里投资资金，检测增长机会，预测收入或在不常见的情况成为问题之前解决它们。<br /><br />降本增效:<br />借助预测分析等先进技术，企业可以发现数据中的改进机会、趋势和模式，并相应地规划策略。随着时间的推移，这将节省实施错误策略的资金和资源。不仅如此，通过预测销售和需求等不同场景，可以预测生产和供应。<br /><br />更好的解决问题的方法：明智的决策更有可能成为成功的决策。数据为企业提供信息。可以看到这种进展正在走向何方。数据分析可帮助企业做出正确的选择并避免代价高昂的陷阱。<br /><br />更准确的数据：如果您想做出明智的决策，需要数据，但还有更多。相关数据必须准确。数据分析可帮助企业获取相关、准确的信息，适合制定未来的营销策略、业务计划以及重新调整公司的愿景或使命。</p><h2 id="数据分析的对象"><a class="markdownIt-Anchor" href="#数据分析的对象"></a> 数据分析的对象</h2><p>按照数据的类型划分：文字、图片、音频、视频、元数据<br />按照数据的体量划分：大数据与小数据<br /><br />按照数据的时间划分：实时数据与离线数据<br />按照数据的来源划分：机器数据与生物数据</p><h2 id="数据分析的类型"><a class="markdownIt-Anchor" href="#数据分析的类型"></a> 数据分析的类型</h2><h3 id="诊断分析"><a class="markdownIt-Anchor" href="#诊断分析"></a> 诊断分析</h3><blockquote><p>诊断分析回答“为什么会发生这种情况？”</p></blockquote><p>利用从统计分析中获得的见解，分析师使用诊断分析来识别数据中的模式。理想情况下，分析师会发现过去存在的类似模式，因此，使用这些解决方案有望解决当前的挑战。</p><h3 id="预测分析"><a class="markdownIt-Anchor" href="#预测分析"></a> 预测分析</h3><blockquote><p>预测分析回答“最有可能发生什么？”</p></blockquote><p>通过使用在旧数据和当前事件中发现的模式，分析师可以预测未来事件。虽然没有100%准确的预测，但如果分析师拥有大量详细信息和彻底研究它的纪律，那么几率就会提高。</p><h3 id="统计分析"><a class="markdownIt-Anchor" href="#统计分析"></a> 统计分析</h3><blockquote><p>统计分析回答“发生了什么？”</p></blockquote><p>此分析涵盖使用仪表板的数据收集、分析、建模、解释和演示。统计分析分为两个子类别：</p><ul><li>描述性：描述性统计分析适用于汇总数值数据的完整或精选。它说明了连续数据中的均值和偏差以及分类数据中的百分比和频率。</li><li>推理：推理分析适用于从完整数据派生的样本。分析师只需选择不同的抽样，就可以从相同的综合数据集中得</li><li>出不同的结论</li></ul><h3 id="文本分析"><a class="markdownIt-Anchor" href="#文本分析"></a> 文本分析</h3><p>它将原始数据转换为有用的业务信息。文本分析可以说是最直接、最直接的数据分析方法。</p><h3 id="规范性分析"><a class="markdownIt-Anchor" href="#规范性分析"></a> 规范性分析</h3><p>混合从其他数据分析类型中获得的所有见解，即可进行规范性分析。有时，仅使用一种分析类型无法解决问题，而是需要多个见解。</p><h2 id="数据分析的过程"><a class="markdownIt-Anchor" href="#数据分析的过程"></a> 数据分析的过程</h2><h3 id="提出与界限问题"><a class="markdownIt-Anchor" href="#提出与界限问题"></a> 提出与界限问题</h3><blockquote><p>问问自己为什么要进行此分析，要使用到的数据种类以及计划分析的数据。</p></blockquote><p>在数据分析之始，首先需要确定为什么需要它，需要它做什么。例如，客户对我们品牌的看法如何？或者哪种类型的包装对我们的潜在客户更具吸引力？概述问题后，您就可以进行下一步了。</p><h3 id="收集与采集数据"><a class="markdownIt-Anchor" href="#收集与采集数据"></a> 收集与采集数据</h3><blockquote><p>这里需要注意的是，在定量和定性方案中，您收集信息的方式会有所不同。</p></blockquote><p>收集来源包括案例研究、调查、访谈、问卷、直接观察和焦点小组。确保组织收集的数据进行分析。</p><h3 id="数据分析"><a class="markdownIt-Anchor" href="#数据分析"></a> 数据分析</h3><p>使用数据分析软件和其他工具来帮助您解释和理解数据并得出结论</p><ul><li>分析数据与验证数据</li><li>提出假设与验证假设</li><li>提出结论</li></ul><h3 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h3><p>解析数据分析结果，并提出最佳行动方案</p><h2 id="数据分析方法"><a class="markdownIt-Anchor" href="#数据分析方法"></a> 数据分析方法</h2><p>尽管有许多可用的数据分析方法，但它们都属于两种主要类型之一：定性分析与定量分析</p><h3 id="定性数据分析"><a class="markdownIt-Anchor" href="#定性数据分析"></a> 定性数据分析</h3><blockquote><p>通过文字、符号、图片和观察来获取数据。此方法不使用统计信息。最常见的定性方法包括：</p></blockquote><ul><li>内容分析，用于分析行为和语言数据。</li><li>叙事分析，用于处理从访谈、日记、调查中挑选的数据。</li><li>扎根理论，通过研究和推断一个或多个过去的案例来发展给定事件的因果解释。</li></ul><blockquote><p>演绎法。这种分析方法被已经对样本总体的可能输入有理论或预定想法的工程师师使用。演绎方法旨在收集能够有条不紊地准确地支持理论或假设的数据。<br />归纳方法。在这种方法中，对样本总体结果知之甚少的工程师师收集有关感兴趣主题的适当和适当数量的数据。然后调查数据以寻找模式。目的是发展一种理论来解释数据中发现的模式。</p></blockquote><h3 id="定量数据分析"><a class="markdownIt-Anchor" href="#定量数据分析"></a> 定量数据分析</h3><blockquote><p>统计数据分析方法收集原始数据并将其处理成数值数据。定量分析方法包括：</p></blockquote><ul><li>假设检验，用于评估数据集或人口统计的给定假设或理论的真实性。</li><li>平均值或平均值通过将数字列表的总和除以列表中的项目数来确定主题的整体趋势。</li><li>样本量测定使用从较大人群中抽取并进行分析的小样本。所获得的结果被认为代表了整个机构。</li></ul><h3 id="常用数据分析方法"><a class="markdownIt-Anchor" href="#常用数据分析方法"></a> 常用数据分析方法</h3><p>聚类分析、同期群分析、回归分析、因子分析、神经网络<br />数据挖掘、文本分析、时间序列分析、决策树、联合分析</p><h2 id="数据分析质量标准"><a class="markdownIt-Anchor" href="#数据分析质量标准"></a> 数据分析质量标准</h2><blockquote><p>如何衡量结果的质量和有效性呢？</p></blockquote><h3 id="内部有效性"><a class="markdownIt-Anchor" href="#内部有效性"></a> 内部有效性</h3><p>如果调查结果衡量了他们应该衡量的内容，从而提供可信的结果，那么调查结果在内部是有效的。换句话说，内部有效性衡量结果的可信度，以及它们如何受到研究设计、操作定义、变量测量方式等因素的影响。例如，假设您正在接受采访，询问人们是否每天刷牙两次。虽然他们中的大多数人会回答是肯定的，但您仍然可以注意到他们的答案与社会可接受的答案相对应，即每天至少刷牙两次。在这种情况下，你不能100%确定受访者是否真的每天刷牙两次，或者他们只是说他们刷牙，因此，这次采访的内部有效性非常低。</p><h3 id="外部有效性"><a class="markdownIt-Anchor" href="#外部有效性"></a> 外部有效性</h3><p>从本质上讲，外部有效性是指研究结果可以应用于更广泛背景的程度。它基本上旨在证明研究结果可以应用于现实世界。如果研究可以应用于其他环境、个人和时代，那么外部有效性就很高。</p><h3 id="可靠性"><a class="markdownIt-Anchor" href="#可靠性"></a> 可靠性</h3><p>如果研究是可靠的，这意味着它可以被复制。如果在相同条件下重复测量，则会产生类似的结果。这意味着测量仪器始终如一地产生可靠的结果。</p><p>例如，假设医生构建了一份症状问卷来检测患者的特定疾病。然后，其他各种医生使用此问卷，但最终诊断出患有不同病情的同一患者。这意味着问卷对于检测初始疾病并不可靠。这里另一个重要的注意事项是，为了使您的研究可靠，它还需要客观。如果研究结果相同，与评估或解释它们的人无关，该研究可以被认为是可靠的。现在让我们更详细地了解客观性标准。</p><h3 id="客观性"><a class="markdownIt-Anchor" href="#客观性"></a> 客观性</h3><p>在数据科学中，客观性意味着研究人员在分析时需要保持完全客观。研究结果需要受到客观标准的影响，而不是受研究人员的信仰、个性或价值观的影响。当您收集数据时，需要确保客观性<br /></p><p>例如，在采访个人时，需要以不影响结果的方式提出问题。除此之外，在解释数据时还需要考虑客观性。如果不同的研究人员得出相同的结论，那么这项研究是客观的。对于最后一点，您可以设置预定义的标准来解释结果，以确保所有研究人员都遵循相同的步骤。</p><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><p>质量标准主要涵盖定量背景下的潜在影响。定性研究中的分析默认具有额外的主观影响，必须以不同的方式进行控制。因此，这类研究还有其他质量标准，例如可信度、可转移性、可靠性和可确认性。</p><h2 id="数据分析的限制与障碍"><a class="markdownIt-Anchor" href="#数据分析的限制与障碍"></a> 数据分析的限制与障碍</h2><blockquote><p>分析数据并非易事。需要应用许多步骤和技术才能从研究中提取有用的信息。虽然执行良好的分析可以为您的组织带来各种好处，但它并非没有限制。</p></blockquote><h3 id="客观性-2"><a class="markdownIt-Anchor" href="#客观性-2"></a> 客观性</h3><p>在研究中进行数据分析的最大障碍之一是保持客观。当试图证明一个假设时，研究人员可能会发现自己有意或无意地将结果引向他们想要的结果。为避免这种情况，请始终质疑假设，避免将事实与观点混淆。还可以向研究合作伙伴或外部人员展示您的发现，以确认结果是客观的</p><h3 id="有缺陷的相关性"><a class="markdownIt-Anchor" href="#有缺陷的相关性"></a> 有缺陷的相关性</h3><p>误导性的统计数据会严重损害研究。当两个变量看起来彼此相关但事实并非如此时，就会发生有缺陷的相关性。将相关性与因果关系混淆会导致对结果的错误解释，从而导致制定错误的策略和资源损失，因此，识别不同的解释错误并避免它们非常重要。</p><h3 id="隐私问题"><a class="markdownIt-Anchor" href="#隐私问题"></a> 隐私问题</h3><p>在某些情况下，数据收集可能受到隐私法规的约束。企业从客户那里收集各种信息，从购买行为到地址和电话号码。如果由于违规行为而落入坏人之手，则可能会影响客户的安全性和机密性。为避免此问题，只需收集研究所需的数据，如果您使用的是敏感事实，请将其匿名，以便保护客户。滥用客户数据会严重损害企业的声誉，因此密切关注隐私非常重要。</p><h3 id="团队之间缺乏沟通"><a class="markdownIt-Anchor" href="#团队之间缺乏沟通"></a> 团队之间缺乏沟通</h3><p>在业务层面进行数据分析时，每个部门和团队很可能会有不同的目标和策略。但是，他们都在为同一个共同目标而努力，即帮助业务顺利运行并保持增长。当团队没有联系和相互沟通时，它会直接影响一般策略的构建方式。为了避免这些问题，数据仪表板等工具使团队能够以视觉上吸引人的方式通过数据保持联系。</p><h2 id="附录数据分析工具"><a class="markdownIt-Anchor" href="#附录数据分析工具"></a> 附录：数据分析工具</h2><p>Excel、Python、R、Spark、SAS、SPSS、Sequentum<br />Enterprise、Datapine、Looker、KNIME、Lexalytics、RapidMiner、OpenRefine、Talend、NodeXL</p><blockquote><p>未说但重要，数据提取工具，譬如SQL</p></blockquote><h2 id="refer"><a class="markdownIt-Anchor" href="#refer"></a> Refer</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2ltcGxpbGVhcm4uY29tL2RhdGEtYW5hbHlzaXMtbWV0aG9kcy1wcm9jZXNzLXR5cGVzLWFydGljbGU=">What is Data Analysis? Methods, Process and Types Explained<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGF0YXBpbmUuY29tL2Jsb2cvZGF0YS1hbmFseXNpcy1tZXRob2RzLWFuZC10ZWNobmlxdWVz">Your Modern Business Guide To Data Analysis Methods And Techniques<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
    
    
    <summary type="html">数据分析是一种研究数据的方法，它涉及到从数据中提取有用信息从而支持决策见解的过程。它包括*
数据收集、数据清洗、数据分析、数据可视化和结果报告*。

所有这些不同的方法主要基于两个核心思路：定量和定性分析。

 数据分析的重要性
明智的决策：从管理的角度来看，可以从分析数据中受益，因为它可以根据事实而不是简单的直觉做出决策。例如，您可以了解在哪里投资资金，检测增长机会，预测收入或在不常见的情况成为问题之前解决它们。

降本增效:
借助预测分析等先进技术，企业可以发现数据中的改进机会、趋势和模式，并相应地规划策略。随着时间的推移，这将节省实施错误策略的资金和资源。不仅如此，通过预测销售和需求等不</summary>
    
    
    
    <category term="数据分析" scheme="https://paynewu-blog.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="数据科学" scheme="https://paynewu-blog.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    <category term="Data-Analysis" scheme="https://paynewu-blog.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/Data-Analysis/"/>
    
    <category term="Data-Science" scheme="https://paynewu-blog.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/Data-Analysis/Data-Science/"/>
    
    
    <category term="数据科学" scheme="https://paynewu-blog.github.io/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>yaml语法详解</title>
    <link href="https://paynewu-blog.github.io/56655.html"/>
    <id>https://paynewu-blog.github.io/56655.html</id>
    <published>2023-02-08T15:13:35.000Z</published>
    <updated>2025-01-06T03:07:07.083Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>YAML Ain’t Markup Language™<br />YAML is a human-friendly data serialization language for all programming languages.</p></blockquote><p>YAML 语言（发音 /ˈjæməl/ ）的设计目标，就是方便人类读写。它实质上是一种通用的数据串行化格式。</p><h2 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h2><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进时不允许使用Tab键，只允许使用空格。</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li></ul><h2 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h2><ul><li><p>对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</p></li><li><p>数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）</p></li><li><p>纯量（scalars）：单个的、不可再分的值。</p><ul><li>string</li><li>number<ul><li>int</li><li>float</li></ul></li><li>Null</li><li>time</li><li>data</li></ul></li><li><p>注释: <code>#</code>表示注释，从这个字符一直到行尾，都会被解析器忽略。</p></li><li><p>锚点<code>&amp;</code>和别名<code>*</code>，可以用来引用。</p></li><li><p><code>|</code>: 保留换行符</p><ul><li><code>+</code>:保留文字块末尾的换行</li><li><code>-</code>:删除字符串末尾的换行</li></ul></li><li><p><code>&lt;&lt;</code>: 合并内容</p></li></ul><h2 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://www.json2yaml.com/</span></span><br><span class="line"><span class="comment"># https://nodeca.github.io/js-yaml/</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="attr">json:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">rigid</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">better</span> <span class="string">for</span> <span class="string">data</span> <span class="string">interchange</span></span><br><span class="line"><span class="attr">yaml:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">slim</span> <span class="string">and</span> <span class="string">flexible</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">better</span> <span class="string">for</span> <span class="string">configuration</span></span><br><span class="line"><span class="attr">object:</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">value</span></span><br><span class="line">  <span class="attr">array:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">null_value:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">boolean:</span> <span class="literal">true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">integer:</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># 锚点&amp;和别名*，可以用来引用。</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">alias:</span> <span class="string">&amp;example</span> <span class="string">aliases</span> <span class="string">are</span> <span class="string">like</span> <span class="string">variables</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">alias:</span> <span class="meta">*example</span></span><br><span class="line"><span class="comment"># 多行字符串可以使用|保留换行符，也可以使用&gt;折叠换行。</span></span><br><span class="line"><span class="attr">paragraph:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">  Blank lines denote</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">  <span class="string">paragraph</span> <span class="string">breaks</span></span><br><span class="line"><span class="comment"># +表示保留文字块末尾的换行，-表示删除字符串末尾的换行。</span></span><br><span class="line"><span class="attr">content:</span> <span class="string">|-</span></span><br><span class="line"><span class="string">  Or we</span></span><br><span class="line"><span class="string">  can auto</span></span><br><span class="line"><span class="string">  convert line breaks</span></span><br><span class="line"><span class="string">  to save space</span></span><br><span class="line"><span class="string"></span><span class="attr">alias:</span> <span class="meta">&amp;foo</span></span><br><span class="line">  <span class="attr">bar:</span> <span class="string">baz</span></span><br><span class="line"><span class="attr">alias_reuse:</span> <span class="meta">*foo</span></span><br><span class="line"><span class="comment"># &lt;&lt; 表示合并到当前数据</span></span><br><span class="line"><span class="string">&lt;&lt;:</span> <span class="meta">*foo</span></span><br></pre></td></tr></table></figure><h2 id="refer"><a class="markdownIt-Anchor" href="#refer"></a> refer</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly95YW1sLm9yZy8=">https://yaml.org/<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDE2LzA3L3lhbWwuaHRtbA==">https://www.ruanyifeng.com/blog/2016/07/yaml.html<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
    
    
    <summary type="html">YAML Ain’t Markup Language™
YAML is a human-friendly data serialization language for all programming languages.

YAML 语言（发音 /ˈjæməl/ ）的设计目标，就是方便人类读写。它实质上是一种通用的数据串行化格式。

 特性
 * 大小写敏感
 * 使用缩进表示层级关系
 * 缩进时不允许使用Tab键，只允许使用空格。
 * 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可

 语法
 * 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典</summary>
    
    
    
    <category term="yaml" scheme="https://paynewu-blog.github.io/categories/yaml/"/>
    
    <category term="config" scheme="https://paynewu-blog.github.io/categories/yaml/config/"/>
    
    
    <category term="tags" scheme="https://paynewu-blog.github.io/tags/tags/"/>
    
  </entry>
  
  <entry>
    <title>结构化思考</title>
    <link href="https://paynewu-blog.github.io/52045.html"/>
    <id>https://paynewu-blog.github.io/52045.html</id>
    <published>2023-02-07T09:50:29.000Z</published>
    <updated>2025-01-06T03:07:07.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一步明确目的找到分解角度"><a class="markdownIt-Anchor" href="#第一步明确目的找到分解角度"></a> 第一步，明确目的，找到分解角度</h2><p>先弄清楚分解的目的是什么，然后根据目的进行拆解与结构化</p><h2 id="第二步按照mece原则组成结构"><a class="markdownIt-Anchor" href="#第二步按照mece原则组成结构"></a> 第二步，按照MECE原则，组成结构</h2><h3 id="方法1金字塔原理"><a class="markdownIt-Anchor" href="#方法1金字塔原理"></a> 方法1：金字塔原理</h3><ul><li>自上而下「使用演绎法」设计结构</li><li>自下而上「使用归纳法」提炼结构</li></ul><h3 id="方法二切割法"><a class="markdownIt-Anchor" href="#方法二切割法"></a> 方法二：切割法</h3><p>二维</p><ul><li>时间管理矩阵：重要/不重要；紧急/不紧急</li><li>乔韩窗口理论：自己知道/不知道；别人知道/不知道</li><li>波斯顿矩阵：市场份额高/低；市场增长率快/慢</li><li>SWOT分析：内部优/劣势；外部威胁/机遇</li></ul><p>三维</p><ul><li>增加过度状态：黑灰白；好/一般/差；事前/事中/事后</li></ul><h3 id="方法三组合使用"><a class="markdownIt-Anchor" href="#方法三组合使用"></a> 方法三：组合使用</h3><p>比如，让你思维更加缜密的「5W2H结构」<br />比如，让你快速理清商业模式的「商业模式画布」<br />比如，让你能全面分析企业发展问题的「麦肯锡7S」</p><h2 id="第三步调整结构给出方案"><a class="markdownIt-Anchor" href="#第三步调整结构给出方案"></a> 第三步，调整结构，给出方案</h2><p>PREP法则：Point结论，Reason理由，Example理由，Ponit重复结论</p><h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2><p>先 split, 在排列组合(套路或任意), merge.</p>]]></content>
    
    
    <summary type="html">第一步，明确目的，找到分解角度
先弄清楚分解的目的是什么，然后根据目的进行拆解与结构化

 第二步，按照MECE原则，组成结构
 方法1：金字塔原理
 * 自上而下「使用演绎法」设计结构
 * 自下而上「使用归纳法」提炼结构

 方法二：切割法
二维

 * 时间管理矩阵：重要/不重要；紧急/不紧急
 * 乔韩窗口理论：自己知道/不知道；别人知道/不知道
 * 波斯顿矩阵：市场份额高/低；市场增长率快/慢
 * SWOT分析：内部优/劣势；外部威胁/机遇

三维

 * 增加过度状态：黑灰白；好/一般/差；事前/事中/事后

 方法三：组合使用
比如，让你思维更加缜密的「5W2H结构」
比如，</summary>
    
    
    
    <category term="思考" scheme="https://paynewu-blog.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    <category term="结构化" scheme="https://paynewu-blog.github.io/categories/%E6%80%9D%E8%80%83/%E7%BB%93%E6%9E%84%E5%8C%96/"/>
    
    <category term="结构化思考" scheme="https://paynewu-blog.github.io/categories/%E6%80%9D%E8%80%83/%E7%BB%93%E6%9E%84%E5%8C%96/%E7%BB%93%E6%9E%84%E5%8C%96%E6%80%9D%E8%80%83/"/>
    
    
    <category term="思考" scheme="https://paynewu-blog.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>我对思考的思考</title>
    <link href="https://paynewu-blog.github.io/43605.html"/>
    <id>https://paynewu-blog.github.io/43605.html</id>
    <published>2023-02-07T05:43:30.000Z</published>
    <updated>2025-01-06T03:07:07.084Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>思考， 简单却有困难的词。它离我们“近在咫尺”却又似乎“远在天涯”。那究竟什么叫思考？什么是思考？那么该如何思考？</p></blockquote><h2 id="思考的定义"><a class="markdownIt-Anchor" href="#思考的定义"></a> 思考的定义</h2><p>说到思考， 那咱们也不得不对其进行追本溯源， 去揪一下它的细节。什么是<strong>思、<strong>什么是</strong>考、<strong>什么是</strong>思考</strong><br />思，汉语一级字，读作sāi或sī，在指“心情”等时旧读为sì，最早见于金文，其本义是深想、考虑，由此引申出怀念、悲伤、意念、创作的构想等。《说文解字》认为是“容也”。<br />考（拼音：kǎo）是汉语通用规范一级字（常用字）。在甲骨文和金文中，考和老是同一个字，均像一老人举杖之形。考字用为年老之义，从商代经西周一直延用至于春秋战国时代。<br />先秦时“考”常用作对父亲的称呼，可以指在世的，也可以指去世的。<br />现代汉语的“考”多用于考察、考核，又表示研究、推求。这些都是后来出现的假借义，与考的本义无关。<br />那什么是思考呢？由上可知思就是深想，考虑就是验证， 二者形成闭环故为思考。那么思考就是，就是<br /><strong>思考就是考虑与验证的过程！</strong><br />btw</p><ul><li>考虑在此的意思是检索，检索已有的知识。</li><li>验证在此的意思是过滤，过滤检索的知识。</li></ul><p>先split再merge，那就是答案啊</p><p>思考是思维的一种探索活动，思考力则是在思维过程中产生的一种具有<strong>积极性和创造性</strong>的作用力。<br />思考源于主体对<strong>意向信息</strong>的加工。人之思考是<strong>自己心智对意向——信息内容的加工过程</strong>。任何思考的进行都是在<br /><strong>联想—连锁反映中进行的推理与演算</strong>——信息内容的加工。如：相似联想、接近联想、对比联想、因果联想等理解来进行思考是必然的。</p><h2 id="思考流程"><a class="markdownIt-Anchor" href="#思考流程"></a> 思考流程</h2><p>由上可知， 思考流程是检索 -&gt; 验证 -&gt; 加工(排列组合) =&gt; 结果。需要注意的是检索与验证并不是仅是单次的，也可以是多次。</p><h3 id="论3-4的思考过程"><a class="markdownIt-Anchor" href="#论3-4的思考过程"></a> 论3 * 4的思考过程</h3><p><img data-src="https://cdn.nlark.com/yuque/__latex/3e90b256052522b05fd06968b19b78a3.svg#card=math&amp;code=3%20%2A%204%0A&amp;id=PQFP9" alt="3 * 4" /><br />是如何计算出来的呢？ 当然，各位早就知晓了答案， 不就是12嘛。 浪费表情，so easy, 摊手🤷</p><p><img data-src="https://cdn.nlark.com/yuque/__latex/3e90b256052522b05fd06968b19b78a3.svg#card=math&amp;code=3%20%2A%204%0A&amp;id=SYVLR" alt="" /><br />思考过程如下三种情况所示</p><ol><li>无法理解数字3、乘以✖️、数字4的含义。 思考失败</li><li>理解数字3、乘以✖️、数字4的含义，回归原始。点阵图数数来解决<ol><li>建立横竖轴（x、y）</li><li>x轴放三个点点·,y轴放四个点点·(见代码片段-1)</li><li>一个一个数， 是12诶！</li></ol></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">· · ·</span><br><span class="line">· · ·</span><br><span class="line">· · ·</span><br><span class="line">· · ·</span><br></pre></td></tr></table></figure><ol start="3"><li>学会乘法， 知道乘法表（嘿嘿，回来。你已经会背乘法口诀表啦！）。直接三四一十二，perfect</li></ol><h4 id="复盘-3-4"><a class="markdownIt-Anchor" href="#复盘-3-4"></a> 复盘 3 * 4</h4><p>在上面对<img data-src="https://cdn.nlark.com/yuque/__latex/be1f45951ef7d08436b379402ebfa9ec.svg#card=math&amp;code=3%20%2A4&amp;id=GOAXB" alt="" /><br />的各种假设的可能性进行了推延生与证明。相信在此时你也和笔者一样又有新的疑问了， 3* 4 不是我们数(算)<br />出来的嘛？不是，在这之前存在一些“可选”项<br />对， 是思考出来的。 流程如下<br /><img data-src="https://cdn.nlark.com/yuque/0/2023/jpeg/22806252/1675183092904-cf89b109-6773-4bab-b538-5e0a9870f8c1.jpeg" alt="" /></p><h4 id="拓展计算机思考过程"><a class="markdownIt-Anchor" href="#拓展计算机思考过程"></a> 拓展：计算机“思考”过程</h4><ol><li>书写代码（在此省略代码编写的种种）</li><li>计算机进行“思考”<ol><li>思：编译(将代码转化成计算机可理解的“知识”)。（编译过程，在此不过多赘述），</li><li>考：验证编译</li></ol></li><li>加工(位运算)</li><li>得到结果</li></ol><h4 id="题外话人与计算机的思维差异"><a class="markdownIt-Anchor" href="#题外话人与计算机的思维差异"></a> 题外话：人与计算机的思维差异</h4><p>人：“聪明”，但<strong>加工</strong>慢<br />计算机：“愚昧”， 但加工快。快速的准确的yes or no， for loop</p><blockquote><p>所以，该如何写出“多快好省”的代码呢？尝试二者结合试试</p></blockquote><h3 id="谈谈想象力或创造力"><a class="markdownIt-Anchor" href="#谈谈想象力或创造力"></a> 谈谈想象力或创造力</h3><p>其本质还是思考</p><ol><li>检索</li><li>验证</li><li>加工(排列组合)</li></ol><h4 id="例子钢铁侠"><a class="markdownIt-Anchor" href="#例子钢铁侠"></a> 例子：钢铁侠</h4><p>这世界本没有钢铁侠，只是有人给他创造，想象了出来，并赋予其名。<br />zoom out(宏观角度):  钢铁(科技与狠活) + 人(侠)<br />zoom in(微观角度)：类似于计算机，譬如ACR核反应堆(类似于电脑的电)  、贾维斯(人工智能) 等等</p><h2 id="提高思考力"><a class="markdownIt-Anchor" href="#提高思考力"></a> 提高思考力？</h2><blockquote><p>思考力：即思考的能力</p></blockquote><p>由上可知，思考能力的强弱取决于两部分。</p><ol><li>已有背景知识的存量</li><li>梳理加工过滤的能力</li></ol><p>那么对此，我们可以得出。得出提高思考力的方法</p><ul><li>增加知识的存量质与量<ul><li>量： 拥有更多的知识<ul><li>输入-&gt; 学习、思考 -&gt; 化为己用</li></ul></li><li>质<ul><li>建立连接：学习并非单纯的记忆，而是连接。旧知识 + 新知识 =&gt; 新认知</li><li>点-线-面-体-势，知识结构化，建立有关联的<strong>强链接</strong><br />，让提取的知识不在是点而是线、是面、是体、甚至是势。不在有知识孤岛，也让思考更加开阔不在局限</li></ul></li></ul></li><li>增强梳理“过滤”能力<ul><li>随意搭配-&gt; 创造力<ul><li>加减乘除，排列组合</li></ul></li><li>套路搭配 -&gt; 方法论<ul><li>怎么切、怎么分 流程与关键节点</li></ul></li></ul></li></ul><h3 id="case-by-case-构建思考框架"><a class="markdownIt-Anchor" href="#case-by-case-构建思考框架"></a> case by case: 构建思考框架</h3><p>经过对于其的整合梳理，我们不难得到可复用的方法论。常见的方法如下</p><p>逻辑推理：三段论<br />高效沟通：PREP法则<br />工作总结：AEAP<br />创业计划：商业模式画布<br />工作规划：SMART原则<br />质量管理：PDCA原则</p><h3 id="学习能力"><a class="markdownIt-Anchor" href="#学习能力"></a> 学习能力</h3><ul><li>学习金字塔</li><li>费曼学习法</li><li>刻意练习</li><li>RIA阅读法</li><li>二八定律</li></ul><h3 id="思考能力"><a class="markdownIt-Anchor" href="#思考能力"></a> 思考能力</h3><ul><li>黄金圈法则</li><li>八何分析法（5w3h、6w2h）</li><li>思维导图</li><li>策略选择：SWOT分析</li><li>梳理信息：MECE法则</li><li>10/10/10法则</li><li>冰山模型</li></ul><h3 id="创造能力"><a class="markdownIt-Anchor" href="#创造能力"></a> 创造能力</h3><ul><li>六顶思考帽</li><li>头脑风暴</li><li>逆向思维</li><li>类比思维</li><li>SCAMPER创新思维</li></ul><h3 id="设计能力"><a class="markdownIt-Anchor" href="#设计能力"></a> 设计能力</h3><ul><li>设计思维</li><li>最小可行性产品（MVP）</li><li>峰终定律</li><li>AARRR漏斗模型</li><li>上瘾（HOOK）模型</li></ul><h3 id="共情能力"><a class="markdownIt-Anchor" href="#共情能力"></a> 共情能力</h3><ul><li>五大圈层模型</li><li>高效倾听模型</li><li>情绪ABC模型</li><li>乔哈里视窗</li><li>冰山模型</li></ul><h3 id="演讲能力"><a class="markdownIt-Anchor" href="#演讲能力"></a> 演讲能力</h3><ul><li>故事五要素</li><li>结构表达: SCQA原则</li><li>结构阐述：STAR原则</li><li>SRAR模型</li><li>STORY模型</li><li>“英雄之旅”模型</li></ul><h3 id="领导能力"><a class="markdownIt-Anchor" href="#领导能力"></a> 领导能力</h3><ul><li>领导力梯队</li><li>情景领导力模型</li><li>GROW教练模型</li><li>管理4C模型</li><li>TOPIC模型</li></ul><h3 id="整合能力"><a class="markdownIt-Anchor" href="#整合能力"></a> 整合能力</h3><ul><li>杠杆思维</li><li>POA行动</li><li>系统思维</li><li>整合思维模型</li><li>多元思维模型</li></ul><h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2><p><strong>既要有“底层逻辑”也要有“顶层设计”。</strong></p><p>事物间的共同点，就是底层逻辑。只有不同之中的相同之处、变化背后不变的东西，才是底层逻辑。<br />只有底层逻辑，才是有生命力的。只有底层逻辑，在我们面临环境变化时，才能被应用到新的变化中，从而产生适应新环境的方法论。所以我们说“底层逻辑+环境变量=方法论”</p><p><strong>以终为始，目标导向。</strong><br />如论是如何思考，何种方法论。最终都是为“问题”所服务的， 切勿**拿着锤子看什么都是钉子！**这并非此文的本意。<br />上述关于“如何思考” 阐述是微观，那么也希望你也能站在更顶层层次看待anythings</p><h2 id="referer"><a class="markdownIt-Anchor" href="#referer"></a> Referer</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlODAlOUQvNTM2NDQ=">https://baike.baidu.com/item/思/53644<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglODAlODM=">https://baike.baidu.com/item/考<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlODAlOUQlRTglODAlODM=">https://baike.baidu.com/item/思考<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3p2aWRlby8xNDQxNDI1NTE2NTMyNzQ4Mjg4">如何才有高效的思考能力<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNzk4MzI4NTE=">人人都能变聪明的四个“核武器”<i class="fa fa-external-link-alt"></i></span></li><li>《底层逻辑》</li><li>《麻省理工深度思考法》</li></ul>]]></content>
    
    
    <summary type="html">思考， 简单却有困难的词。它离我们“近在咫尺”却又似乎“远在天涯”。那究竟什么叫思考？什么是思考？那么该如何思考？

 思考的定义
说到思考， 那咱们也不得不对其进行追本溯源， 去揪一下它的细节。什么是思、什么是考、什么是思考
思，汉语一级字，读作sāi或sī，在指“心情”等时旧读为sì，最早见于金文，其本义是深想、考虑，由此引申出怀念、悲伤、意念、创作的构想等。《说文解字》认为是“容也”。
考（拼音：kǎo）是汉语通用规范一级字（常用字）。在甲骨文和金文中，考和老是同一个字，均像一老人举杖之形。考字用为年老之义，从商代经西周一直延用至于春秋战国时代。
先秦时“考”常用作对父亲的称呼，可以指在</summary>
    
    
    
    <category term="个人随笔" scheme="https://paynewu-blog.github.io/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="思考" scheme="https://paynewu-blog.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>gitbook的使用</title>
    <link href="https://paynewu-blog.github.io/62778.html"/>
    <id>https://paynewu-blog.github.io/62778.html</id>
    <published>2023-02-02T06:57:31.000Z</published>
    <updated>2025-01-06T03:07:07.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><blockquote><p>前置条件：node版本必须为12.x</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g gitbook-cli@latest</span><br></pre></td></tr></table></figure><p><strong>handle error</strong></p><p>执行gitbook -V的时候出现如下错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/data/soft/nodejs/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287</span><br><span class="line">      <span class="keyword">if</span> (cb) cb.apply(this, arguments)</span><br><span class="line">                 ^</span><br><span class="line"></span><br><span class="line">TypeError: cb.apply is not a <span class="keyword">function</span></span><br><span class="line">    at /data/soft/nodejs/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18</span><br><span class="line">    at FSReqCallback.oncomplete (fs.js:169:5)</span><br></pre></td></tr></table></figure><p>遇到<code>TypeError: cb.apply is not a function</code>, 这个错误直接打开如下链接中的js文件</p><p><code>/data/soft/nodejs/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js</code></p><p>将<strong>在第62-64行如下代码进行注释即可</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="property">stat</span> = <span class="title function_">statFix</span>(fs.<span class="property">stat</span>)</span><br><span class="line">fs.<span class="property">fstat</span> = <span class="title function_">statFix</span>(fs.<span class="property">fstat</span>)</span><br><span class="line">fs.<span class="property">lstat</span> = <span class="title function_">statFix</span>(fs.<span class="property">lstat</span>)</span><br></pre></td></tr></table></figure><p>btw,<br />需要说明的是<code>/data/soft/nodejs/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js</code><br />这<br />个路径并不是绝对的，会因为Node.js安装路径的不同而改变。 所以，视具体的报错进行修改即可</p>]]></content>
    
    
    <summary type="html">安装
前置条件：node版本必须为12.x

1


npm install -g gitbook-cli@latest


handle error

执行gitbook -V的时候出现如下错误

1
2
3
4
5
6
7


/data/soft/nodejs/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287
      if (cb) cb.apply(this, arguments)
                 ^

TypeError: cb.appl</summary>
    
    
    
    <category term="gitbook" scheme="https://paynewu-blog.github.io/categories/gitbook/"/>
    
    <category term="github-pages" scheme="https://paynewu-blog.github.io/categories/gitbook/github-pages/"/>
    
    
    <category term="gitbook" scheme="https://paynewu-blog.github.io/tags/gitbook/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向之smail剖析</title>
    <link href="https://paynewu-blog.github.io/10131.html"/>
    <id>https://paynewu-blog.github.io/10131.html</id>
    <published>2023-02-01T16:40:47.000Z</published>
    <updated>2025-01-06T03:07:07.073Z</updated>
    
    <content type="html"><![CDATA[<h2 id="smali"><a class="markdownIt-Anchor" href="#smali"></a> Smali</h2><p><strong>smail是Android虚拟机的反汇编语言</strong></p><p>Android代码一般是用JVM语言编写，执行Androdi程序一般需要用到JVM，在Android平台上也不例外，但是出于性能上的考虑，并没有使用标准的JVM，而是使用专门的Android虚拟机（5.0以下为Dalvik，5.0以上为ART）。Android虚拟机的可执行文件并不是普通的class文件，而是再重新整合打包后生成的dex文件。smail是dex格式的文件的汇编器<br />反汇编器\ 其语法是一种宽松的jasmin/dedexer 语法,实现了.dex格式的所有功能(注解/调试信息/线路信息等)</p><h2 id="学习smail必要性"><a class="markdownIt-Anchor" href="#学习smail必要性"></a> 学习smail必要性</h2><ol><li>动态调试与修改APK, 当静态分析已经无法满足时,此时便需要对Android进行动态调试, 而动态调试便是调试smail</li><li>修改APK运行逻辑, 通过修改smail代码,在重新打包.便可对app进行持久化的修改.(<br />常用的注入均在外部而不是app内部)</li></ol><blockquote><p>插件: java2smail</p></blockquote><h2 id="smail基本语法"><a class="markdownIt-Anchor" href="#smail基本语法"></a> smail基本语法</h2><h3 id="关键字"><a class="markdownIt-Anchor" href="#关键字"></a> 关键字</h3><p><strong>关键字</strong></p><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>.class</td><td>定义类名</td></tr><tr><td>.super</td><td>定义父类名</td></tr><tr><td>.source</td><td>定义源文件名</td></tr><tr><td>.filed</td><td>定义字段</td></tr><tr><td>.method</td><td>定义方法开始</td></tr><tr><td>.end method</td><td>定义方法结束</td></tr><tr><td>.annotation</td><td>定义注解开始</td></tr><tr><td>.end annotation</td><td>定义注解结束</td></tr><tr><td>.implements</td><td>定义接口指令</td></tr><tr><td>.local</td><td>指定了方法内局部变量的个数</td></tr><tr><td>.registers</td><td>指定方法内使用寄存器的总数</td></tr><tr><td>.prologue</td><td>表示方法中代码的开始处</td></tr><tr><td>.line</td><td>表示java源文件中指定行</td></tr><tr><td>.paramter</td><td>指定方法的参数</td></tr><tr><td>.param</td><td>和.paramter含义一致,但是表达格式不同</td></tr></tbody></table><h3 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h3><table><thead><tr><th>smail</th><th>Java</th><th>备注</th></tr></thead><tbody><tr><td>v</td><td>void</td><td>只能用于返回值类型</td></tr><tr><td>Z</td><td>boolean</td><td></td></tr><tr><td>B</td><td>byte</td><td></td></tr><tr><td>S</td><td>short</td><td></td></tr><tr><td>C</td><td>char</td><td></td></tr><tr><td>I</td><td>int</td><td></td></tr><tr><td>J</td><td>long</td><td></td></tr><tr><td>F</td><td>float</td><td></td></tr><tr><td>D</td><td>double</td><td></td></tr><tr><td>Lpackage/name;</td><td>对象类型</td><td>L表示这是一个对象类型，package表示该对象所在的包，；表示对象名称的结束</td></tr><tr><td>[类型</td><td>数组</td><td>[I表示一个int型数据，[Ljava/lang/String 表示一个String的对象数组</td></tr></tbody></table><p><strong>类声明</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.class + 修饰符 + 类名</span><br></pre></td></tr></table></figure><p><strong>构造函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.method 权限修饰符 constructor &lt;init&gt;(参数类型) V</span><br><span class="line"># 方法体</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure><p><strong>成员变量定义格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.field <span class="keyword">public</span>/<span class="keyword">private</span> [<span class="keyword">static</span>][<span class="keyword">final</span>] varName:&lt;类型&gt;</span><br><span class="line">.field 访问权限修饰符 类型修饰符 变量名:类名路径</span><br></pre></td></tr></table></figure><p><strong>返回值关键字</strong></p><table><thead><tr><th>返回关键字</th><th>Java数据类型</th></tr></thead><tbody><tr><td>return</td><td>byte short float char boolean</td></tr><tr><td>return-void</td><td>void</td></tr><tr><td>return-wide</td><td>long double</td></tr><tr><td>return-object</td><td>数组 object</td></tr></tbody></table><p><strong>获取指令</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iget, sget, iget-<span class="type">boolean</span>, sget-<span class="type">boolean</span>, iget-object, sget-object</span><br></pre></td></tr></table></figure><p><strong>操作指令</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iput, sput, iput-<span class="type">boolean</span>, sput-<span class="type">boolean</span>, iput-object, sput-object</span><br><span class="line">array的操作是aget和aput</span><br></pre></td></tr></table></figure><p><strong>指令解析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sget-object v0,Lcom/aaa;-&gt;ID:Ljava/lang/String;</span><br><span class="line">获取ID这个String类型的成员变量并放到v0这个寄存器中</span><br><span class="line">iget-object v0,p0,Lcom/aaa;-&gt;view:Lcom/aaa/view;</span><br><span class="line">iget-object比sget-object多一个参数p0，这个参数代表变量所在类的实例。这里p0就是<span class="built_in">this</span></span><br></pre></td></tr></table></figure><p>example</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example 1 相当于java代码：this.timer = null;</span></span><br><span class="line">const/<span class="number">4</span> v3, <span class="number">0x0</span></span><br><span class="line">sput-object v3, Lcom/aaa;-&gt;timer:Lcom/aaa/timer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example 2</span></span><br><span class="line">.local v0, args:Landroid/os/Message;</span><br><span class="line">const/<span class="number">4</span> v1, <span class="number">0x12</span></span><br><span class="line">iput v1,v0,Landroid/os/Message;-&gt;what:I</span><br><span class="line"><span class="comment">// 相当于java代码：args.what = 18; 其中args为Message的实例</span></span><br></pre></td></tr></table></figure><p><strong>调用指令</strong></p><table><thead><tr><th>调用关键字</th><th>作用</th></tr></thead><tbody><tr><td>invoke-virtual</td><td>非私有实例方法调用</td></tr><tr><td>invoke-direct</td><td>构造方法以及私有方法的调用</td></tr><tr><td>invoke-static</td><td>静态方法的调用</td></tr><tr><td>invoke-super</td><td>父类方法的调用</td></tr><tr><td>invoke-interface</td><td>接口方法调用</td></tr></tbody></table><p>调用格式： invoke-指令类型 {参数1, 参数2,…}, L类名;-&gt;方法名 如果不是是静态方法，参数1代表调用该方法的实例。</p><h2 id="寄存器"><a class="markdownIt-Anchor" href="#寄存器"></a> 寄存器</h2><p>Java中变量都是存放在内存中的，Android为了提高性能，变量都是存放在寄存器中的，寄存器为32位，可以支持任何类型。64位类型(<br />Long/ Double) 用2个格式的寄存器表示; Dalvik字节码有两种类型: 原始类型和引用类型(<br />包括对象和数组)</p><p>寄存器分为如下两类： 1、本地寄存器: 用v开头数字结尾的符号来表示，v0, v1, v2,… 2、参数寄存器:<br />用p开头数字结尾的符号来表示，p0,p1,p2,…<br /><em>注意：</em><br /><strong>在非static方法中，p0代指this，p1为方法的第一个参数。</strong><br /><strong>在static方法中，p0为方法的第一个参数。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const/4 v0, 0x1 //把值0x1存到v0本地寄存器</span><br><span class="line">iput-boolean v0,p0,Lcom/aaa;-&gt;IsRegisterd:Z //把v0中的值赋给com.aaa.IsRegistered，p0代表this，相当于this.Isregistered=true</span><br></pre></td></tr></table></figure><h2 id="tip"><a class="markdownIt-Anchor" href="#tip"></a> tip</h2><p>查看smail代码时可以和java代码结合来看</p><h2 id="referer"><a class="markdownIt-Anchor" href="#referer"></a> referer</h2><p><span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2UuYW5kcm9pZC5jb20vZGV2aWNlcy90ZWNoL2RhbHZpay9kYWx2aWstYnl0ZWNvZGU=">Dalvik 字节码<i class="fa fa-external-link-alt"></i></span></p><p>[Android逆向基础：Smail语法]<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85OTMxYTFlNzcwNjY=">https://www.jianshu.com/p/9931a1e77066<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">Smali
smail是Android虚拟机的反汇编语言

Android代码一般是用JVM语言编写，执行Androdi程序一般需要用到JVM，在Android平台上也不例外，但是出于性能上的考虑，并没有使用标准的JVM，而是使用专门的Android虚拟机（5.0以下为Dalvik，5.0以上为ART）。Android虚拟机的可执行文件并不是普通的class文件，而是再重新整合打包后生成的dex文件。smail是dex格式的文件的汇编器
反汇编器&#92; 其语法是一种宽松的jasmin/dedexer 语法,实现了.dex格式的所有功能(注解/调试信息/线路信息等)

 学习smail必要性
 1.</summary>
    
    
    
    <category term="smail" scheme="https://paynewu-blog.github.io/categories/smail/"/>
    
    <category term="Android" scheme="https://paynewu-blog.github.io/categories/smail/Android/"/>
    
    
    <category term="smail" scheme="https://paynewu-blog.github.io/tags/smail/"/>
    
  </entry>
  
  <entry>
    <title>工程化衍生落地</title>
    <link href="https://paynewu-blog.github.io/41708.html"/>
    <id>https://paynewu-blog.github.io/41708.html</id>
    <published>2022-07-17T14:15:13.000Z</published>
    <updated>2025-01-06T03:07:07.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="agenda"><a class="markdownIt-Anchor" href="#agenda"></a> Agenda</h2><h3 id="提出需求"><a class="markdownIt-Anchor" href="#提出需求"></a> 提出需求</h3><h3 id="调研方案"><a class="markdownIt-Anchor" href="#调研方案"></a> 调研方案</h3><h3 id="研读资料"><a class="markdownIt-Anchor" href="#研读资料"></a> 研读资料</h3><h3 id="构建工程"><a class="markdownIt-Anchor" href="#构建工程"></a> 构建工程</h3><ul><li>工程设计<ul><li>项目布局设计</li><li>功能设计</li></ul></li><li>代码设计<ul><li>方法、接口设计</li></ul></li><li>实现代码</li></ul>]]></content>
    
    
    <summary type="html">Agenda
 提出需求
 调研方案
 研读资料
 构建工程
 * 工程设计 * 项目布局设计
    * 功能设计
   
   
 * 代码设计 * 方法、接口设计
   
   
 * 实现代码</summary>
    
    
    
    <category term="技术杂谈" scheme="https://paynewu-blog.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
    <category term="软件工程" scheme="https://paynewu-blog.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="工程化" scheme="https://paynewu-blog.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
    <category term="技术杂谈" scheme="https://paynewu-blog.github.io/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>爬虫架构</title>
    <link href="https://paynewu-blog.github.io/33887.html"/>
    <id>https://paynewu-blog.github.io/33887.html</id>
    <published>2022-07-13T07:10:13.000Z</published>
    <updated>2025-01-06T03:07:07.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="爬虫架构"><a class="markdownIt-Anchor" href="#爬虫架构"></a> 爬虫架构</h2><blockquote><p>技术的本质就是<strong>结构与组合</strong>。今天在谈技术架构，有时候我们也会谈产品架构，再往前走，我们会谈商业架构，它中间都是一个结构的问题。</p></blockquote><h3 id="爬虫开发流程"><a class="markdownIt-Anchor" href="#爬虫开发流程"></a> 爬虫开发流程</h3><p>在聊爬虫架构的时候，非常有必要将爬虫的流程梳理清楚。毕竟万变不离其宗，对于爬虫流程的掌握可以更好的理解、设计、组合爬虫，<br />爬虫基本步骤如下</p><ol><li>网络包捕获，确定URL</li><li>模拟发送网络请求，获取响应</li><li>解析响应， 获取数据</li><li>解析数据，数据持久化</li></ol><h2 id="分布式爬虫架构"><a class="markdownIt-Anchor" href="#分布式爬虫架构"></a> 分布式爬虫架构</h2><h3 id="均衡分布式"><a class="markdownIt-Anchor" href="#均衡分布式"></a> 均衡分布式</h3><h3 id="对等分布式"><a class="markdownIt-Anchor" href="#对等分布式"></a> 对等分布式</h3><h2 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h2><p>不要过度优化、不要过度预留扩展点、不要过度设计</p>]]></content>
    
    
    <summary type="html">爬虫架构
技术的本质就是结构与组合。今天在谈技术架构，有时候我们也会谈产品架构，再往前走，我们会谈商业架构，它中间都是一个结构的问题。

 爬虫开发流程
在聊爬虫架构的时候，非常有必要将爬虫的流程梳理清楚。毕竟万变不离其宗，对于爬虫流程的掌握可以更好的理解、设计、组合爬虫，
爬虫基本步骤如下

 1. 网络包捕获，确定URL
 2. 模拟发送网络请求，获取响应
 3. 解析响应， 获取数据
 4. 解析数据，数据持久化

 分布式爬虫架构
 均衡分布式
 对等分布式
 注意
不要过度优化、不要过度预留扩展点、不要过度设计</summary>
    
    
    
    <category term="spider" scheme="https://paynewu-blog.github.io/categories/spider/"/>
    
    <category term="crawler" scheme="https://paynewu-blog.github.io/categories/spider/crawler/"/>
    
    
    <category term="data-acquisition" scheme="https://paynewu-blog.github.io/tags/data-acquisition/"/>
    
  </entry>
  
  <entry>
    <title>go-concurrency</title>
    <link href="https://paynewu-blog.github.io/60799.html"/>
    <id>https://paynewu-blog.github.io/60799.html</id>
    <published>2022-07-03T03:25:25.000Z</published>
    <updated>2025-01-06T03:07:07.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="process-and-thread"><a class="markdownIt-Anchor" href="#process-and-thread"></a> Process And Thread</h2><p>操作系统会为应用程序创建一个进程, 作为应用程序. 它是一个为应用程序所有资源而运行的容器,<br />这些资源包含内存地址, 文件句柄, 设备和线程. 每个进程中都包含了一个主进程</p><p>线程是操作系统调度的一种执行路径, 用于在处理器中执行我们编写的代码.</p><p>一个进程从一个线程开始, 即主线程, 当该线程终止时，进程终止。这是因为主线程是应用程序的原点。然后，主线程可以依次启动更多的线程，而这些线程可以启动更多的线程。</p><blockquote><p>无论线程属于哪个进程，操作系统都会安排线程在可用处理器上运行。每个操作系统都有自己的算法来做出这些决定。</p></blockquote><h2 id="goroutines-and-parallelism"><a class="markdownIt-Anchor" href="#goroutines-and-parallelism"></a> Goroutines and Parallelism</h2><p>Go 语言层面支持的 go 关键字，可以快速的让一个函数创建为 goroutine，我们可以认为 main 函数就是作为<br />goroutine 执行的。操作系统调度线程在可用处理器上运行，Go运行时调度 goroutine<br />在绑定到单个操作系统线程的逻辑处理器中运行（P）。即使使用这个单一的逻辑处理器和操作系统线程，也可以调度数十万<br />goroutine 以惊人的效率和性能并发运行。</p><blockquote><p>Concurrency is not Parallelism.</p></blockquote><p>​ 并发不是并行。并行是指两个或多个线程同时在不同的处理器执行代码。如果将运行时配置为使用多个逻辑处理器，则调度程序将在这些逻辑处理器之间分配<br />goroutine，这将导致 goroutine 在不同的操作系统线程上运行。但是，要获得真正的并行性，您需要在具有多个物理处理器的计算机上运行程序。否则，goroutine<br />将针对单个物理处理器并发运行，即使 Go 运行时使用多个逻辑处理器。</p><p><strong>Keep yourself busy or do the work yourself</strong></p><p><strong>Leave concurrency to the caller</strong></p><p><strong>Never start a goroutine without knowning when it will stop</strong></p><p>Any time you start a Goroutine you must ask yourself:</p><ul><li><p>When will it terminate?</p></li><li><p>What could prevent it from terminating?</p></li></ul><p>小结: 由开发者管理goroutine的生命周期, 将并发性交给调用方</p>]]></content>
    
    
    <summary type="html">Process And Thread
操作系统会为应用程序创建一个进程, 作为应用程序. 它是一个为应用程序所有资源而运行的容器,
这些资源包含内存地址, 文件句柄, 设备和线程. 每个进程中都包含了一个主进程

线程是操作系统调度的一种执行路径, 用于在处理器中执行我们编写的代码.

一个进程从一个线程开始, 即主线程, 当该线程终止时，进程终止。这是因为主线程是应用程序的原点。然后，主线程可以依次启动更多的线程，而这些线程可以启动更多的线程。

无论线程属于哪个进程，操作系统都会安排线程在可用处理器上运行。每个操作系统都有自己的算法来做出这些决定。

 Goroutines and Par</summary>
    
    
    
    <category term="go" scheme="https://paynewu-blog.github.io/categories/go/"/>
    
    <category term="concurrency" scheme="https://paynewu-blog.github.io/categories/go/concurrency/"/>
    
    
    <category term="go" scheme="https://paynewu-blog.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go异常处理</title>
    <link href="https://paynewu-blog.github.io/36452.html"/>
    <id>https://paynewu-blog.github.io/36452.html</id>
    <published>2022-07-01T05:02:22.000Z</published>
    <updated>2025-01-06T03:07:07.081Z</updated>
    
    <content type="html"><![CDATA[<p>在了解go异常处理的时候,有必要先了解为什么需要做异常处理,异常处理主要在哪几个方面,区分异常和错误的区别等等.</p><h2 id="qa"><a class="markdownIt-Anchor" href="#qa"></a> QA</h2><h3 id="为什么需要做异常处理"><a class="markdownIt-Anchor" href="#为什么需要做异常处理"></a> 为什么需要做异常处理?</h3><p>我个人认为有一下几点</p><ol><li>从程序设计的角度来看, 保证程序的鲁棒性,健壮性</li><li>从开发的角度来看, 快速定位问题,解决问题,预防问题</li></ol><h3 id="异常处理主要在哪几个方面"><a class="markdownIt-Anchor" href="#异常处理主要在哪几个方面"></a> 异常处理主要在哪几个方面</h3><p>异常处理主要在实践上可以区分为</p><ul><li>业务层面: 保证业务的稳定性, 逻辑性</li><li>基础库: 保证代码逻辑正常</li></ul><h3 id="异常与错误的区别"><a class="markdownIt-Anchor" href="#异常与错误的区别"></a> 异常与错误的区别</h3><p>编程语言中的异常和错误是两个相似但不相同的概念。异常和错误都可以引起程序执行错误而退出，他们属于程序没有考虑到的例外情况(<br />exception)。</p><p>便于理解举个例子:</p><p>一个网络请求, 没有网络-错误</p><p>一个网络请求过程中,对方服务器处理超时(注意是对方服务器正常) - 异常</p><h2 id="error-和-exception"><a class="markdownIt-Anchor" href="#error-和-exception"></a> Error 和 Exception</h2><h3 id="go-error"><a class="markdownIt-Anchor" href="#go-error"></a> go error</h3><blockquote><p>go error 就是一个普通的接口, 普通的值.</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://golang.org/pkg/builtin/#error</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经常使用 <code>errors.New()</code> 来返回一个 <code>error</code> 对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://go.dev/src/errors/errors.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> errors</span><br><span class="line"></span><br><span class="line"><span class="comment">// New returns an error that formats as the given text.</span></span><br><span class="line"><span class="comment">// Each call to New returns a distinct error value even if the text is identical.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// errorString is a trivial implementation of error.</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line"> s <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>New() 返回的是 errorString对象的指针</p><p>为什么返回的是指针?</p><ul><li>避免创建的error的值一致</li></ul></blockquote><p>基础库中大量定义的error</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://go.dev/src/bufio/bufio.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"> ErrInvalidUnreadByte = errors.New(<span class="string">&quot;bufio: invalid use of UnreadByte&quot;</span>)</span><br><span class="line"> ErrInvalidUnreadRune = errors.New(<span class="string">&quot;bufio: invalid use of UnreadRune&quot;</span>)</span><br><span class="line"> ErrBufferFull        = errors.New(<span class="string">&quot;bufio: buffer full&quot;</span>)</span><br><span class="line"> ErrNegativeCount     = errors.New(<span class="string">&quot;bufio: negative count&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>tip: 在定义错误的时候带上包名,便于区分.<br />如<code>ErrInvalidUnreadByte = errors.New(&quot;bufio: invalid use of UnreadByte&quot;)</code> 中的<code>bufio:</code></p><h3 id="error-vs-exception"><a class="markdownIt-Anchor" href="#error-vs-exception"></a> Error VS Exception</h3><p>各语言的演进历史</p><p>C: 但返回值, 入参通过传递指针作为入参, 返回int 表示成功还是失败, 以及如果失败的状态码是什么</p><p>C++: 引入了Exception,但无法知道被调用者抛出什么异常</p><p>Java: 引入了checked exception,方法的所有者必须申明, 调用者必须处理.</p><p>go: 支持多参数返回, 所以很容易在函数签名上实现了error interface的对象,交由调用者处理</p><blockquote><p>如果一个函数返回了 <code>(value,error)</code>, 不能对这个<code>value</code>做任何假设, 必须先判定<code>error</code></p></blockquote><p>补充: go中<code>panic</code>机制,意味着 fatal all, 不能假设调用者来解决<code>panic</code> 意味着代码down了</p><p><strong>记录单一清晰的错误, 并处理!!!</strong></p><p>注意二值性</p><h3 id="go特征"><a class="markdownIt-Anchor" href="#go特征"></a> go特征</h3><ul><li>简单</li><li>考虑失败而不是成功</li><li>没有隐藏的控制流</li><li>完全交给开发者来处理</li><li><strong>Error are values</strong></li></ul><p>对于真正的错误, 表示不可恢复的程序错误,例如索引越界, 不可恢复的环境问题, 堆栈溢出,才使用<code>panic</code><br />,对于其他的错误情况,应该是情况我使用error来进行判定</p><h2 id="go-error-type"><a class="markdownIt-Anchor" href="#go-error-type"></a> go error type</h2><h3 id="sentinel-error"><a class="markdownIt-Anchor" href="#sentinel-error"></a> Sentinel Error</h3><p>预定义的特定错误,称之为 Sentinel Error. 这个名字起源于计算机编程中使用一个表示不可能进一步处理的做法.<br />使用特定值来表示错误.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err == ErrorSomething &#123; ....&#125;</span><br><span class="line"><span class="comment">// 类似于 io.EOF 更底层的syscall.ENOENT</span></span><br></pre></td></tr></table></figure><p>使用 Sentinel Error 值是最不灵活的错误处理策略, 因为调用方法 必须使用<code>==</code></p><p>将结果与预先声明的值进行比较. 当需要提供更多的上下文时,就会出现一个因为反返回一个不同的错误将被破坏相等性检查.</p><p>例如一些有意义的<code>fmt.Errorf</code> 携带一些上下文,也会破坏调用者的<code>==</code> ,调用者将被迫查看<code>error.Error()</code><br />方法的输出,以查看它是否与特定的字符串匹配</p><p><strong>tips:</strong></p><ul><li>不依赖检查<code>error.Error</code>的输出.</li></ul><blockquote><p>不应该以来检测<code>error.Error</code>的输出, Error方法存在于error接口主要用于方便开发者使用,而不是程序(<br />编写测试会依赖这个返回). 这个输出的字符串用于记录日志,输出到stdout</p></blockquote><ul><li>Sentient errors 成为你API公共部分</li></ul><blockquote><p>如果公共函数或方法返回一个特定的值,那么该值必须是公共的,当然要有文档记录,这会增加API的表面积</p><p>如果API定义了以恶搞返回特定错误的<code>Interface</code> ,则该接口的所有实现都将被限制为仅返回该错误,<br />即使他们可以提供更具有描述性错误</p><p>比如: io.Reader. 像io.Copy这类函数需要reader的实现者比如返回 io.EOF 来告诉调用者没有更多数据量,但这又不是错误</p></blockquote><ul><li>Sentient errors 在这个两个包之间创建依赖</li></ul><blockquote><p>Sentinel errors 最糟糕的问题是他们在两个包之间创建了源码依赖关系</p><p>例如检查错误是否等于io.EOF, 代码就必须要导入io包,<br />虽然听起来似乎不那么糟糕,但想象一下,当项目中的许多包到处错误值时,存在耦合,项目中的其他包必须要导入这些错误值才能校验特定的错误条件</p></blockquote><p><strong>建议:尽可能的避免使用 sentinel errors</strong></p><h3 id="error-types"><a class="markdownIt-Anchor" href="#error-types"></a> Error Types</h3><p>Error type 实现了error接口自定义类型.例如<code>ExampleError</code> 类型记录了文件和行号以及展示发生了什么.<br />如下代码所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ExampleError <span class="keyword">struct</span> &#123;</span><br><span class="line"> Msg      <span class="type">string</span></span><br><span class="line"> FileName <span class="type">string</span></span><br><span class="line"> Line     <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *ExampleError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> fmt.Sprintf(<span class="string">`%s:%d %s`</span>, e.FileName, e.Line, e.Msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> &amp;ExampleError&#123;<span class="string">`something happened`</span>, <span class="string">`example.go`</span>, <span class="number">33</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> err := test()</span><br><span class="line"> <span class="keyword">switch</span> err := err.(<span class="keyword">type</span>) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line"> <span class="comment">// call succeeded, nothing to do</span></span><br><span class="line"> <span class="keyword">case</span> *ExampleError:</span><br><span class="line">  fmt.Println(<span class="string">`Error occurred on call:`</span>, err)</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line">  <span class="comment">// unknown error</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与错误值相比, 错误类型的优点是他们能够包装底层错误以提供更多上下文.</p><p>官方实例 os.PathError:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line"> Op      <span class="type">string</span></span><br><span class="line"> Path    <span class="type">string</span></span><br><span class="line"> Err     <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用者要使用类型断言和switch,就要让自定义的error变为公共的, 这种模型会导致和调用者产生强耦合,从而导致API非常脆弱</p><p>结论: 尽量避免使用error types,或者说尽量避免其成为公共API的一部分</p><p>虽然错误类型比sentinel error更完善,提供更多的上下文信息, 但error types 共享error value许多相同的问题.</p><h3 id="opaque-errors"><a class="markdownIt-Anchor" href="#opaque-errors"></a> Opaque errors</h3><blockquote><p>不透明的错误处理</p></blockquote><p>直接返回错误而不假设其内容</p><ul><li>Assert errors for behaviour, not type</li></ul><blockquote><p>在某些情况下,这种二分错误处理方法是不够的, 例如与外界交互(网络), 需要调用方法查错误的性质,以确定重试是否合理.<br />在这种情况下,可以使用断言错误实现了<strong>特定的行为</strong>.</p></blockquote><h2 id="handle-error"><a class="markdownIt-Anchor" href="#handle-error"></a> Handle Error</h2><h3 id="indented-flow-is-for-errors"><a class="markdownIt-Anchor" href="#indented-flow-is-for-errors"></a> Indented flow is for errors</h3><blockquote><p>缩进流用于错误</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无错误的正常流程代码应为一条直线</span></span><br><span class="line">f, err := os.Open(filePath)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do stuff</span></span><br></pre></td></tr></table></figure><h3 id="eliminate-error-handing-by-eliminating-errors"><a class="markdownIt-Anchor" href="#eliminate-error-handing-by-eliminating-errors"></a> Eliminate error handing by eliminating errors</h3><blockquote><p>通过消除错误来消除错误处理</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthenticateRequest</span><span class="params">(r *Requests)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    err := authenticate(r.user)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthenticateRequest</span><span class="params">(r *Requests)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> authenticate(r.user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="io-reader-example"><a class="markdownIt-Anchor" href="#io-reader-example"></a> io Reader Example</h4><p><strong>统计 <code>io.Reader</code> 读取内容的行数代码实例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountLines</span><span class="params">(r io.Reader)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> (</span><br><span class="line">  br    = bufio.NewReader(r)</span><br><span class="line">  lines <span class="type">int</span></span><br><span class="line">  err   <span class="type">error</span></span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">  _, err := br.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">  lines++</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> err != io.EOF &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> lines, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进-使用<code>bufio.scanner</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountLines1</span><span class="params">(r io.Reader)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> lines <span class="type">int</span></span><br><span class="line"> sc := bufio.NewScanner(r)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> sc.Scan() &#123;</span><br><span class="line">  lines++</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> lines, sc.Err()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="http-example"><a class="markdownIt-Anchor" href="#http-example"></a> Http Example</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line"> Key, Value <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">struct</span> &#123;</span><br><span class="line"> Code   <span class="type">int</span></span><br><span class="line"> Reason <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResponse</span><span class="params">(w io.Writer, s Status, headers []Header, body io.Reader)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"> _, err := fmt.Fprintf(w, <span class="string">&quot;HTTP/1.1 %d %s\r\n&quot;</span>, s.Code, s.Reason)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">  _, err := fmt.Fprintf(w, <span class="string">&quot;%s:%s\r\n&quot;</span>, h.Key, h.Value)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> _, err := fmt.Fprintf(w, <span class="string">&quot;\r\n&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> _, err = io.Copy(w, body)</span><br><span class="line"> <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;io&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line"> Key, Value <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">struct</span> &#123;</span><br><span class="line"> Code   <span class="type">int</span></span><br><span class="line"> Reason <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> errWrite <span class="keyword">struct</span> &#123;</span><br><span class="line"> io.Writer</span><br><span class="line"> err <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errWrite)</span></span> Write(buf []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line"> <span class="keyword">if</span> e.err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> n, e.err = e.Writer.Write(buf)</span><br><span class="line"> <span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResponse</span><span class="params">(w io.Writer, s Status, headers []Header, body io.Reader)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"> ew := &amp;errWrite&#123;Writer: w&#125;</span><br><span class="line"> fmt.Fprintf(ew, <span class="string">&quot;HTTP/1.1 %d %s\r\n&quot;</span>, s.Code, s.Reason)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">  fmt.Fprintf(ew, <span class="string">&quot;%s:%s\r\n&quot;</span>, h.Key, h.Value)</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Fprint(ew, <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line"> io.Copy(ew, body)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> ew.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="wrap-errors"><a class="markdownIt-Anchor" href="#wrap-errors"></a> Wrap errors</h3><p>you should only handle errors once. Handing an error means inspecting the error value, and make a<br />single decision</p><p>日志与错误无关且对调试没有帮助的信息都应视为噪声, 应予以质疑. 记录的原因是应为某些东西失败了,而包含了答案</p><ul><li>错误要被日志记录</li><li>应用程序处理错误,保证百分百完整性</li><li>之后不在报当前错误</li></ul><p><span class="exturl" data-url="aHR0cDovL2dpdGh1Yi5jb20vcGtnL2Vycm9ycw==">pkg-errors<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9wa2cuZ28uZGV2L2Vycm9ycw==">dev-pkg-errors<i class="fa fa-external-link-alt"></i></span></p><h4 id="pkg-errors"><a class="markdownIt-Anchor" href="#pkg-errors"></a> pkg-errors</h4><ul><li>在应用代码中,使用<code>pkg/errors</code>中的<code>errors.New</code> 或者 <code>error.Errorf</code>返回错误</li><li>如果调用其他包内的函数,通常简单的直接返回</li><li>如果与其他库协作, 考虑使用<code>pkg/errors</code>中的<code>errors.New</code> 或者 <code>error.Errorf</code>返回错误保持堆栈信息</li><li>直接放回错误, 而不是每个错误产生的地方打日志</li><li>在程序的顶部或者是工作的 goroutine顶部(请求入口), 使用<code>%+v</code>保存堆栈详情记录</li><li>使用<code>errors.Cause</code>获取<code>root error</code> 在进行sentinel error判定</li></ul><p><strong>小结</strong></p><p>Packages that are reusable across many projects only return root error values.</p><blockquote><p>选择 wrap error 是只有 applications 可以选择应用的策略。具有最高可重用性的包只能返回根错误值。此机制与<br />Go 标准库中使用的相同**（<strong>kit</strong>库的<strong>sql.ErrNoRows</strong>）**。</p></blockquote><p>If the error is not going to be handled, wrap and return up the call stack.</p><blockquote><p>这是关于函数/方法调用返回的每个错误的基本问题。如果函数/方法不打算处理错误，那么用足够的上下文 wrap<br />errors 并将其返回到调用堆栈中。例如，额外的上下文可以是使用的<strong>输入参数</strong>或失败的查询<strong>语句</strong><br />。确定您记录的上下文是足够多还是太多的一个好方法是检查日志并验证它们在开发期间是否为您工作。</p></blockquote><p>Once an error is handled, it is not allowed to be passed up the call stack any longer.</p><blockquote></blockquote><p><em>一旦确定函数/方法将处理错误，错误就不再是错误。如果函数/方法仍然需要发出返回，则它不能返回错误值。它应该只返回零</em>*<br />（比如降级处理中，你返回了降级数据，然后需要* <em>return nil</em>*）**。*</p>]]></content>
    
    
    <summary type="html">在了解go异常处理的时候,有必要先了解为什么需要做异常处理,异常处理主要在哪几个方面,区分异常和错误的区别等等.

 QA
 为什么需要做异常处理?
我个人认为有一下几点

 1. 从程序设计的角度来看, 保证程序的鲁棒性,健壮性
 2. 从开发的角度来看, 快速定位问题,解决问题,预防问题

 异常处理主要在哪几个方面
异常处理主要在实践上可以区分为

 * 业务层面: 保证业务的稳定性, 逻辑性
 * 基础库: 保证代码逻辑正常

 异常与错误的区别
编程语言中的异常和错误是两个相似但不相同的概念。异常和错误都可以引起程序执行错误而退出，他们属于程序没有考虑到的例外情况(
exceptio</summary>
    
    
    
    <category term="go" scheme="https://paynewu-blog.github.io/categories/go/"/>
    
    
    <category term="go" scheme="https://paynewu-blog.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>爬虫对抗相关总结</title>
    <link href="https://paynewu-blog.github.io/13971.html"/>
    <id>https://paynewu-blog.github.io/13971.html</id>
    <published>2022-06-28T11:13:41.000Z</published>
    <updated>2025-01-06T03:07:07.085Z</updated>
    
    <content type="html"><![CDATA[<p>又双叒叕 一篇相关于爬虫对抗的总结. 一般来说对于爬虫的对抗主要体现在如下几个方面</p><ul><li><p>反调: 反抓包\反调试\代码混淆与防护</p></li><li><p>反(欺诈)模拟: 网络协议校验\TLS\请求头(字段\字段顺序\反盗链)校验</p></li><li><p>数据防护\验证码\风控对抗等</p></li></ul><p>反爬虫(风险策略)工程师预防以及防止爬虫工程师对数据的抓取, 一方要&quot;守&quot;一方要&quot;攻&quot;,各为其主各司其职你来我往谁也多呈不让.</p><h2 id="反抓包"><a class="markdownIt-Anchor" href="#反抓包"></a> 反抓包</h2><p>反抓包的目的多种多样,简而言之便是让爬虫工作者无法捕获网络数据包</p><p>如: 不走http\不走代理\请求分离\SSLping单(双)向校验\网络协议定制等</p><h2 id="反调试"><a class="markdownIt-Anchor" href="#反调试"></a> 反调试</h2><p>反调试的策略诸多, 主要体现方面有思路为 预防调试\ 阻断调试\ 破坏调试,让爬虫逆向者无法有效进行调试</p><h3 id="预防调试"><a class="markdownIt-Anchor" href="#预防调试"></a> 预防调试</h3><p>预防调试的手段也多种多样, 简而言之便是预防开发者调试从而阻断分析无法进入下一步,主要体现在环境检测\动态代码</p><p>譬如:</p><ul><li><p>web端: 控制台检测\动态js\wasm\代码防护与混淆\hook检测\堆栈顺序检测</p></li><li><p>Android:  运行环境检测(root\签名校验\hook检测\模拟器检测)\进程检测与调试工具检检测(<br />jadx\apktool\jeb\xposed\frida\ida)\壳\so\</p></li><li><p>web:</p><ul><li>分辨率检测</li><li>控制台检测</li><li>动态js</li><li>wasm</li></ul></li><li><p>Android:</p><ul><li>运行环境检测<ul><li>root检测</li><li>设备检测</li><li>签名校验</li></ul></li><li>调试器工具检查<ul><li>工具特性检测<ul><li>jadx</li><li>apktool</li><li>jeb</li><li>xposed</li><li>frida</li><li>ida</li></ul></li></ul></li><li>代码防护<ul><li>壳</li><li>so</li><li>代码隐写</li></ul></li></ul></li><li><p>代码混淆</p><ul><li>布局混淆</li><li>数据混淆</li><li>数字混淆</li><li>字符串混淆</li><li>控制流平坦化</li></ul></li></ul><h3 id="阻断调试"><a class="markdownIt-Anchor" href="#阻断调试"></a> 阻断调试</h3><p>阻断调试, 顾名思义便是阻止调试.或着说将你引入错误的逻辑中,无法正常的调试</p><p>譬如代码中的环境检测\设备指纹</p><h3 id="破坏调试"><a class="markdownIt-Anchor" href="#破坏调试"></a> 破坏调试</h3><p>相对于阻断调试更加极端的手段，一方面对调试者信息进行采集、攻击调试者。例如删除文件、重置电脑、甚至释放病毒等</p><p><strong>小结</strong></p><p>做反调试主要有两个方面一方面是特征区分预防\阻断\破坏调试, 另一方面是对代码进行保护与混淆</p><h2 id="反欺诈模拟"><a class="markdownIt-Anchor" href="#反欺诈模拟"></a> 反(欺诈)模拟</h2><p>如果说反调试是为了防止逆向工作者,那么反模拟便是针对爬虫工程师.</p><p>简而言之,防止模拟请求. 那么对于此.我们只需要区分开这个请求,<br />亦或者将结果数据进行处理这样就可以让开发者无法拿到正常有价值的数据,从而实现反爬虫的效果.</p><blockquote><p>因为我们知道爬虫简单来说就是模拟用户请求的代码实现</p></blockquote><p>反模拟主要在对于爬虫的请求进行甄别,常见的关键点有</p><p>请求库特征,譬如tls指纹</p><p>请求协议的区分: 譬如强制指定http2或quic等\使用自研的协议</p><p>参数校验: 校验的思路有 参数字段的校验如cookie等, 参数顺序的校验</p><p>加密与编码算法的定制修改,</p><ul><li>位运算\ 在特殊的头\尾部加入字符</li><li>魔改hash算法\base(16\32\64)等</li><li>对称加密与非对称加密算法</li></ul><blockquote><p>校验的字段通常使用到加密算法或编码算法</p></blockquote><h2 id="数据防护"><a class="markdownIt-Anchor" href="#数据防护"></a> 数据防护</h2><p>当我们完成了以上的种种, 便将&quot;战场&quot;迁移到最后的数据保护上,</p><p>常见的方式有数据加密(从服务端返回的数据进行加密或编码)</p><p>数据隐写</p><blockquote><p>无法轻松直接的从返回的数据包中获取到数据, 只需要保证界面展示上正常的即可</p></blockquote><h2 id="验证码"><a class="markdownIt-Anchor" href="#验证码"></a> 验证码</h2><p>验证码不必多说, 譬如常见的如下几种类型</p><ul><li>滑动型</li><li>计算型</li><li>点选型(图像: 一维\二维\三维)</li><li>短信或语音验证型</li></ul><p>通常验证码还会对对应的譬如图片进行安全处理, 如图片重排\模糊化等等干扰识别以及防止图像被还原</p><p>还有就是检测运行环境</p><h2 id="风控"><a class="markdownIt-Anchor" href="#风控"></a> 风控</h2><h3 id="ip风控"><a class="markdownIt-Anchor" href="#ip风控"></a> IP风控</h3><h3 id="设备风控"><a class="markdownIt-Anchor" href="#设备风控"></a> 设备风控</h3><h3 id="账号风控"><a class="markdownIt-Anchor" href="#账号风控"></a> 账号风控</h3><p>风控其核心的对抗 个人认为有两点</p><ol><li>特征</li><li>逻辑</li></ol><p>写的比较散,但实现起来却并不是唯一, 仅按个人认为的进行的区分, 大多情况都不可能单独出现.</p><h2 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h2><p>无论是爬虫工程师还是反爬虫亦或者风险策略工程师. 攻与守并非是一成不变的. ,掌握底层逻辑,不断的成长向上吧.<br />瑞斯拜~</p>]]></content>
    
    
    <summary type="html">又双叒叕 一篇相关于爬虫对抗的总结. 一般来说对于爬虫的对抗主要体现在如下几个方面

 * 反调: 反抓包&#92;反调试&#92;代码混淆与防护
   
   
 * 反(欺诈)模拟: 网络协议校验&#92;TLS&#92;请求头(字段&#92;字段顺序&#92;反盗链)校验
   
   
 * 数据防护&#92;验证码&#92;风控对抗等
   
   

反爬虫(风险策略)工程师预防以及防止爬虫工程师对数据的抓取, 一方要&quot;守&quot;一方要&quot;攻&quot;,各为其主各司其职你来我往谁也多呈不让.

 反抓包
反抓包的目的多种多样,简而言之便是让爬虫工作者无法捕获网络数据包

如: 不走http&#92;不走代理&#92;请求分离&#92;SSLping单(双)向校验&#92;网络协议定制等

 </summary>
    
    
    
    <category term="spider" scheme="https://paynewu-blog.github.io/categories/spider/"/>
    
    <category term="crawler" scheme="https://paynewu-blog.github.io/categories/spider/crawler/"/>
    
    
    <category term="data-acquisition" scheme="https://paynewu-blog.github.io/tags/data-acquisition/"/>
    
  </entry>
  
  <entry>
    <title>frida-rpc</title>
    <link href="https://paynewu-blog.github.io/11141.html"/>
    <id>https://paynewu-blog.github.io/11141.html</id>
    <published>2022-06-26T06:40:16.000Z</published>
    <updated>2025-01-06T03:07:07.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="frida-主动调用"><a class="markdownIt-Anchor" href="#frida-主动调用"></a> frida 主动调用</h2><p>主动调用: 强制去调用函数执行</p><p>被动调用: 由app主导,按照正常的执行顺序执行函数. 函数执行完全依靠与用户交互完成从而间接的调用到关键函数</p><p>在Java中,类的函数可以分为两种: 类函数与实例方法, 也可以称之为静态方法和动态方法.</p><p>类函数使用关键字<code>static</code> 修饰,与对应的类绑定, 当然如果该类函数还被<code>public</code> 修饰,则在外部就可以直接通过类去调用</p><p>实例方法没有被 <code>staic</code> 修饰,在外部只能通过实例化对应的类,在通过该实例调用对应的方法.</p><p>在frida中主动调用的类型会根据方法的类型区分开来, 类函数的直接调用使用<code>Java.use</code><br />即可,实例方法则需要先找到对应的实例后对方法进行调用, 通常使用<code>Java.choose</code>.</p><p>示例代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setImmediate</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Script loaded successfully, start hook...&#x27;</span>);</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Inside java perform function...&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态(类)函数 主动调用</span></span><br><span class="line">    <span class="keyword">let</span> class_name = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.xxx.xxx.xxx&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> result1 = class_name.<span class="title function_">method</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态(实例)方法 主动调用</span></span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&#x27;com.xxx.xxx.xxx&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">onMatch</span>: <span class="keyword">function</span> (<span class="params">instance</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;instance found &#x27;</span>, instance);</span><br><span class="line">        <span class="keyword">let</span> result2 = instance.<span class="title function_">method</span>();</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">onComplete</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;search complete&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="frida-rpc"><a class="markdownIt-Anchor" href="#frida-rpc"></a> frida-rpc</h2><p>通过exports 将结果导出,以便于python 结合frida模块直接调用.</p><p>js脚本与hook脚本写法基本一致,示例代码如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rpc.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Script loaded successfully, start hook...&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> xxx_result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Inside java perform function...&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> class_name = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.xxx.xxx.xxx&#x27;</span>);</span><br><span class="line">    xxx_result = class_name.<span class="title function_">method_name</span>(<span class="string">&#x27;参数&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> xxx_result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Script loaded successfully, start hook...&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> xxx_result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Inside java perform function...&#x27;</span>);</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&#x27;com.xxx.xxx&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">onMatch</span>: <span class="keyword">function</span> (<span class="params">instance</span>) &#123;</span><br><span class="line">        xxx_result = class_name.<span class="title function_">method_name</span>(<span class="string">&#x27;参数&#x27;</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">onComplete</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;search complete&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> xxx_result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rpc.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">rpc_func1</span>: func1,</span><br><span class="line">  <span class="attr">rpc_func2</span>: func2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpc.py</span></span><br><span class="line"><span class="comment"># File: proc.py</span></span><br><span class="line"><span class="comment"># User: Payne-Wu</span></span><br><span class="line"><span class="comment"># Date: 2022/6/26 17:33</span></span><br><span class="line"><span class="comment"># Desc:</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"></span><br><span class="line">device = frida.get_usb_device()</span><br><span class="line">script_path = <span class="string">&quot;HookScript/example.js&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">message_call_back</span>(<span class="params">message, data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    message call back</span></span><br><span class="line"><span class="string">    :param message:</span></span><br><span class="line"><span class="string">    :param data:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    logger.info(message)</span><br><span class="line">    logger.info(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">attach_hook</span>(<span class="params">app_name</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param app_name:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    process = device.attach(app_name)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(script_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        script = process.create_script(f.read())</span><br><span class="line">    script.on(<span class="string">&#x27;message&#x27;</span>, message_call_back)</span><br><span class="line">    script.load()</span><br><span class="line">    sys.stdin.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spawn</span>(<span class="params">package_name</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param package_name:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    pid = device.spawn(package_name)</span><br><span class="line">    process = device.attach(pid)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(script_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        script = process.create_script(f.read())</span><br><span class="line">    script.on(<span class="string">&#x27;message&#x27;</span>, message_call_back)</span><br><span class="line">    script.load()</span><br><span class="line">    <span class="comment"># rpc </span></span><br><span class="line">    <span class="comment"># script.exports.func_name</span></span><br><span class="line">    device.resume(pid)</span><br><span class="line">    sys.stdin.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    spawn(<span class="string">&#x27;com.xxx.xxx&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">frida 主动调用
主动调用: 强制去调用函数执行

被动调用: 由app主导,按照正常的执行顺序执行函数. 函数执行完全依靠与用户交互完成从而间接的调用到关键函数

在Java中,类的函数可以分为两种: 类函数与实例方法, 也可以称之为静态方法和动态方法.

类函数使用关键字static 修饰,与对应的类绑定, 当然如果该类函数还被public 修饰,则在外部就可以直接通过类去调用

实例方法没有被 staic 修饰,在外部只能通过实例化对应的类,在通过该实例调用对应的方法.

在frida中主动调用的类型会根据方法的类型区分开来, 类函数的直接调用使用Java.use
即可,实例方法则需</summary>
    
    
    
    <category term="frida" scheme="https://paynewu-blog.github.io/categories/frida/"/>
    
    <category term="hook" scheme="https://paynewu-blog.github.io/categories/frida/hook/"/>
    
    <category term="sec" scheme="https://paynewu-blog.github.io/categories/frida/hook/sec/"/>
    
    
    <category term="frida" scheme="https://paynewu-blog.github.io/tags/frida/"/>
    
  </entry>
  
  <entry>
    <title>frida hook</title>
    <link href="https://paynewu-blog.github.io/21429.html"/>
    <id>https://paynewu-blog.github.io/21429.html</id>
    <published>2022-06-18T13:17:21.000Z</published>
    <updated>2025-01-06T03:07:07.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="frida启动方式"><a class="markdownIt-Anchor" href="#frida启动方式"></a> frida启动方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frida -h</span></span><br><span class="line">usage: frida [options] target</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  args                  extra arguments and/or target</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>            show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">  -D ID, --device ID    connect to device with the given ID</span><br><span class="line">  -U, --usb             connect to USB device</span><br><span class="line">  -R, --remote          connect to remote frida-server</span><br><span class="line">  -H HOST, --host HOST  connect to remote frida-server on HOST</span><br><span class="line">  --certificate CERTIFICATE</span><br><span class="line">                        speak TLS with HOST, expecting CERTIFICATE</span><br><span class="line">  --origin ORIGIN       connect to remote server with “Origin” header <span class="built_in">set</span> to ORIGIN</span><br><span class="line">  --token TOKEN         authenticate with HOST using TOKEN</span><br><span class="line">  --keepalive-interval INTERVAL</span><br><span class="line">                        <span class="built_in">set</span> keepalive interval <span class="keyword">in</span> seconds, or 0 to <span class="built_in">disable</span> (defaults to -1 to auto-select based on transport)</span><br><span class="line">  --p2p                 establish a peer-to-peer connection with target</span><br><span class="line">  --stun-server ADDRESS</span><br><span class="line">                        <span class="built_in">set</span> STUN server ADDRESS to use with --p2p</span><br><span class="line">  --relay address,username,password,turn-&#123;udp,tcp,tls&#125;</span><br><span class="line">                        add relay to use with --p2p</span><br><span class="line">  -f TARGET, --file TARGET</span><br><span class="line">                        spawn FILE</span><br><span class="line">  -F, --attach-frontmost</span><br><span class="line">                        attach to frontmost application</span><br><span class="line">  -n NAME, --attach-name NAME</span><br><span class="line">                        attach to NAME</span><br><span class="line">  -p PID, --attach-pid PID</span><br><span class="line">                        attach to PID</span><br><span class="line">  -W PATTERN, --await PATTERN</span><br><span class="line">                        await spawn matching PATTERN</span><br><span class="line">  --stdio &#123;inherit,pipe&#125;</span><br><span class="line">                        stdio behavior when spawning (defaults to “inherit”)</span><br><span class="line">  --aux option          <span class="built_in">set</span> aux option when spawning, such as “uid=(int)42” (supported types are: string, bool, int)</span><br><span class="line">  --realm &#123;native,emulated&#125;</span><br><span class="line">                        realm to attach <span class="keyword">in</span></span><br><span class="line">  --runtime &#123;qjs,v8&#125;    script runtime to use</span><br><span class="line">  --debug               <span class="built_in">enable</span> the Node.js compatible script debugger</span><br><span class="line">  --squelch-crash       <span class="keyword">if</span> enabled, will not dump crash report to console</span><br><span class="line">  -O FILE, --options-file FILE</span><br><span class="line">                        text file containing additional <span class="built_in">command</span> line options</span><br><span class="line">  --version             show program<span class="string">&#x27;s version number and exit</span></span><br><span class="line"><span class="string">  -l SCRIPT, --load SCRIPT</span></span><br><span class="line"><span class="string">                        load SCRIPT</span></span><br><span class="line"><span class="string">  -P PARAMETERS_JSON, --parameters PARAMETERS_JSON</span></span><br><span class="line"><span class="string">                        parameters as JSON, same as Gadget</span></span><br><span class="line"><span class="string">  -C USER_CMODULE, --cmodule USER_CMODULE</span></span><br><span class="line"><span class="string">                        load CMODULE</span></span><br><span class="line"><span class="string">  --toolchain &#123;any,internal,external&#125;</span></span><br><span class="line"><span class="string">                        CModule toolchain to use when compiling from source code</span></span><br><span class="line"><span class="string">  -c CODESHARE_URI, --codeshare CODESHARE_URI</span></span><br><span class="line"><span class="string">                        load CODESHARE_URI</span></span><br><span class="line"><span class="string">  -e CODE, --eval CODE  evaluate CODE</span></span><br><span class="line"><span class="string">  -q                    quiet mode (no prompt) and quit after -l and -e</span></span><br><span class="line"><span class="string">  -t TIMEOUT, --timeout TIMEOUT</span></span><br><span class="line"><span class="string">                        seconds to wait before terminating in quiet mode</span></span><br><span class="line"><span class="string">  --no-pause            automatically start main thread after startup</span></span><br><span class="line"><span class="string">  -o LOGFILE, --output LOGFILE</span></span><br><span class="line"><span class="string">                        output to log file</span></span><br><span class="line"><span class="string">  --eternalize          eternalize the script before exit</span></span><br><span class="line"><span class="string">  --exit-on-error       exit with code 1 after encountering any exception in the SCRIPT</span></span><br><span class="line"><span class="string">  --auto-perform        wrap entered code with Java.perform</span></span><br><span class="line"><span class="string">  --auto-reload         Enable auto reload of provided scripts and c module (on by default, will be required in the future)</span></span><br><span class="line"><span class="string">  --no-auto-reload      Disable auto reload of provided scripts and c module</span></span><br></pre></td></tr></table></figure><h2 id="injection"><a class="markdownIt-Anchor" href="#injection"></a> Injection</h2><blockquote><p>attach hook: 这种模式建立在app已经启动的情况下，frida利用ptrace的原理注入app进而完成Hook<br />spawn hook： 将app启动权限交与frida 来控制。使用spawn实现hook时会由frida将app重启在进行hook<br />注意：由于attach hook 基于ptrace原理进行完成，因此无法在IDA正在调试的目标app以attach注入进程中，当然若先用frida<br />attach注入<br />在使用IDA进行调试则正常</p></blockquote><h3 id="shell"><a class="markdownIt-Anchor" href="#shell"></a> Shell</h3><h4 id="attach"><a class="markdownIt-Anchor" href="#attach"></a> attach</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frida -Ul script_hook.js [-n] app_name</span><br><span class="line">frida -Ul script_hook.js -p pid</span><br></pre></td></tr></table></figure><h4 id="spawn"><a class="markdownIt-Anchor" href="#spawn"></a> spawn</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -Ul script_hook.js -f Identifier(package name) --no-pause</span><br></pre></td></tr></table></figure><h3 id="python-script"><a class="markdownIt-Anchor" href="#python-script"></a> Python script</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">from</span> pptrint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">message_callback</span>(<span class="params">message, data</span>):</span><br><span class="line">    logger.info(<span class="string">f&quot;[*] <span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">device = frida.get_use_device(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># attach</span></span><br><span class="line">process = device.attach(<span class="string">&#x27;className&#x27;</span>)</span><br><span class="line">script = process.create_script(<span class="string">&#x27;hook_script&#x27;</span>)</span><br><span class="line">script.on(<span class="string">&#x27;message&#x27;</span>, message_callback)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># spawn</span></span><br><span class="line">device = frida.get_use_device(-<span class="number">1</span>)</span><br><span class="line">pid = devices.spawn([<span class="string">&#x27;packageName&#x27;</span>])</span><br><span class="line">process = device.attach(pid)</span><br><span class="line">script = process.create_script(<span class="string">&#x27;hook_script&#x27;</span>)</span><br><span class="line">script.on(<span class="string">&#x27;message&#x27;</span>, message_callback)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><h2 id="frida-api"><a class="markdownIt-Anchor" href="#frida-api"></a> frida api</h2><p>JavaScript-api : <span class="exturl" data-url="aHR0cHM6Ly9mcmlkYS5yZS9kb2NzL2phdmFzY3JpcHQtYXBp">https://frida.re/docs/javascript-api<i class="fa fa-external-link-alt"></i></span></p><p>JavaScript-api-java: <span class="exturl" data-url="aHR0cHM6Ly9mcmlkYS5yZS9kb2NzL2phdmFzY3JpcHQtYXBpLyNqYXZh">https://frida.re/docs/javascript-api/#java<i class="fa fa-external-link-alt"></i></span></p><p>JavaScript-api-module: <span class="exturl" data-url="aHR0cHM6Ly9mcmlkYS5yZS9kb2NzL2phdmFzY3JpcHQtYXBpLyNtb2R1bGU=">https://frida.re/docs/javascript-api/#module<i class="fa fa-external-link-alt"></i></span></p><h2 id="hook"><a class="markdownIt-Anchor" href="#hook"></a> Hook</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perfrom</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script successfully loaded, start hook...&#x27;</span>);</span><br><span class="line">  <span class="comment">// hook script</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="hook-类方法"><a class="markdownIt-Anchor" href="#hook-类方法"></a> Hook 类方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perfrom</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script successfully loaded, start hook...&#x27;</span>);</span><br><span class="line">  <span class="comment">// hook class script</span></span><br><span class="line">  <span class="keyword">let</span> class_name = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.xxx.xxx.class_name&#x27;</span>);</span><br><span class="line">  class_name.<span class="property">method</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// this.xx</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>this.成员变量名.value</p></blockquote><h3 id="hook-内部匿名类方法"><a class="markdownIt-Anchor" href="#hook-内部匿名类方法"></a> Hook 内部(匿名)类方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perfrom</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script successfully loaded, start hook...&#x27;</span>);</span><br><span class="line">  <span class="comment">// hook class script</span></span><br><span class="line">  <span class="comment">// 类路径$内部类名 在smail找</span></span><br><span class="line">  <span class="keyword">let</span> class_name = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.xxx.xxx.class_name$xx&#x27;</span>);</span><br><span class="line">  class_name.<span class="property">method</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// this.xx</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>从匿名类/内部类访问外部类的属性写法： this.this$0.value.外部类的属性名.value</p></blockquote><h2 id="hook-重载方法"><a class="markdownIt-Anchor" href="#hook-重载方法"></a> Hook 重载方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perfrom</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script successfully loaded, start hook...&#x27;</span>);</span><br><span class="line">  <span class="comment">// hook class script</span></span><br><span class="line">  <span class="comment">// 类路径$内部类名 在smail找</span></span><br><span class="line">  <span class="keyword">let</span> class_name = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.xxx.xxx.class_name&#x27;</span>);</span><br><span class="line">  class_name.<span class="property">method</span>.<span class="title function_">overload</span>(参数<span class="number">1</span>, 参数<span class="number">2</span></span><br><span class="line">...).</span><br><span class="line">  implementation = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// this.xx</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// overload(参数1，参数2...) 可以根据报错来确定</span></span><br></pre></td></tr></table></figure><h2 id="hook-构造方法"><a class="markdownIt-Anchor" href="#hook-构造方法"></a> Hook 构造方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perfrom</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script successfully loaded, start hook...&#x27;</span>);</span><br><span class="line">  <span class="comment">// hook class script</span></span><br><span class="line">  <span class="comment">// 类路径$内部类名 在smail找</span></span><br><span class="line">  <span class="keyword">let</span> class_name = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.xxx.xxx.class_name&#x27;</span>);</span><br><span class="line">  class_name.$init().<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// this.xx</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="hook-实例"><a class="markdownIt-Anchor" href="#hook-实例"></a> Hook 实例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perfrom</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script successfully loaded, start hook...&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> variable = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.xxx.xxx.class_name&#x27;</span>).$new(参数);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">frida启动方式
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66


# frida -h
usage: frida [options] target

positional arguments:
  args                  extra argum</summary>
    
    
    
    <category term="frida" scheme="https://paynewu-blog.github.io/categories/frida/"/>
    
    <category term="hook" scheme="https://paynewu-blog.github.io/categories/frida/hook/"/>
    
    <category term="sec" scheme="https://paynewu-blog.github.io/categories/frida/hook/sec/"/>
    
    
    <category term="frida" scheme="https://paynewu-blog.github.io/tags/frida/"/>
    
  </entry>
  
  <entry>
    <title>一些工作上的思考</title>
    <link href="https://paynewu-blog.github.io/20884.html"/>
    <id>https://paynewu-blog.github.io/20884.html</id>
    <published>2022-06-12T13:58:59.000Z</published>
    <updated>2025-01-06T03:07:07.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h2><p><strong>规范的</strong> 、<strong>结构的</strong>构造端到端</p><h2 id="计算机"><a class="markdownIt-Anchor" href="#计算机"></a> 计算机</h2><p><span class="exturl" data-url="aHR0cHM6Ly9iYWlqaWFoYW8uYmFpZHUuY29tL3M/aWQ9MTY5ODM1NDgwOTY1MDc4MTM1OA==">《我对计算的理解· 吴瀚清》<i class="fa fa-external-link-alt"></i></span></p><p>技术的本质就是<strong>结构与组合</strong>。</p><p>今天我们在谈技术架构，有时候我们也会谈产品架构，再往前走，我们会谈商业架构，它中间都是一个结构的问题。</p><p><strong>技术最重要的目标是开始追求生产效率，带来产能上的巨大提升</strong><br />，当产能得到一个巨大提升之后，就能够创造出越来越多的产品，进而实现规模化。技术要通过架构师或者工程师的工作才能完成这个过程。</p><p><strong>技术要走向的就是规模化</strong></p><blockquote><p><strong>计算机真正在做的事情是模拟</strong></p><p>创造</p></blockquote><h2 id="闭环"><a class="markdownIt-Anchor" href="#闭环"></a> 闭环</h2><p>在职场中,在领导口中.口口声声说 “闭环”,但 究竟什么是闭环?</p><p>闭环思维是一种<strong>有始有终</strong>的思维，它是一份生活的智慧。</p><p>比如拖延症导致的熬夜。由于有拖延症，导致无法及时完成任务，最后不得不熬夜，第二天精神萎靡，工作效率下降，于是不得不继续熬夜。这就是一个恶性闭环。</p><p>要想改变这个闭环，我们需要找到一个突破点，对上一个阶段的效果进行总结，把控改进方向。</p><p>工作效率就是一个突破点，我们可以提升工作效率，原本需要2个小时完成的任务，火力全开用1个小时做完，那么晚上就不需要再熬夜了。有了充足的睡眠，第二天精力充沛，就可以保证工作效率，于是形成了一个正向的闭环。</p><h3 id="什么是闭环思维"><a class="markdownIt-Anchor" href="#什么是闭环思维"></a> 什么是闭环思维</h3><p>闭环思维实际上被称为反馈控制系统，它将系统输出的测量值与预期和定值进行比较，由此造成一个偏差信号，然后运用偏差去做调整，便于输出值尽可能接近期望值。</p><p>PDCA循环将管理分为计划（Plan）、执行（Do）、检查（Check）、行动（Act）<br />四个阶段，这四个阶段不是独立存在的，而是周而复始的循环。这也是我们在企业中经常听到的“商业闭环”“闭环管理”<br />等概念。</p><p>我们这里提到的闭环思维是指在一定的基础上，对于他人发起的活动或者工作，无论我们完成的程度如何，都要在要求的时间之内认真地反馈给发起人，并且每个活动或者工作都要贯穿这个思维。</p><h2 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">你需要有体系结构化思维的能力 -- 5w3h<span class="keyword">\ </span>6why</span><br><span class="line">你做的事情它有什么独特的优势,价值点在哪里 </span><br><span class="line">你是否做出了壁垒,形成核心竞争力</span><br><span class="line">你做的事情差异化在哪里</span><br><span class="line">你的事情是否沉淀了一套可复用的物理资料与方法论</span><br><span class="line">为什么是你来做,其他人是否可以?</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最终交付价值是什么</span><br><span class="line">顶层设计在哪里, 底层逻辑是什么</span><br><span class="line">过程中的抓手在哪里</span><br><span class="line">如何保证效果闭环</span><br><span class="line">优势在哪,亮点在哪</span><br></pre></td></tr></table></figure><p>理解业务</p><p>技术 + 产品 + 运营</p><h2 id="referer"><a class="markdownIt-Anchor" href="#referer"></a> Referer</h2><p><span class="exturl" data-url="aHR0cHM6Ly9iYWlqaWFoYW8uYmFpZHUuY29tL3M/aWQ9MTcxMjQ3MDA2MzE3Mjc5OTQ1Mw==">闭环<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">流程
规范的 、结构的构造端到端

 计算机
《我对计算的理解· 吴瀚清》

技术的本质就是结构与组合。

今天我们在谈技术架构，有时候我们也会谈产品架构，再往前走，我们会谈商业架构，它中间都是一个结构的问题。

技术最重要的目标是开始追求生产效率，带来产能上的巨大提升
，当产能得到一个巨大提升之后，就能够创造出越来越多的产品，进而实现规模化。技术要通过架构师或者工程师的工作才能完成这个过程。

技术要走向的就是规模化

计算机真正在做的事情是模拟

创造

 闭环
在职场中,在领导口中.口口声声说 “闭环”,但 究竟什么是闭环?

闭环思维是一种有始有终的思维，它是一份生活的智慧。

比如拖</summary>
    
    
    
    <category term="work" scheme="https://paynewu-blog.github.io/categories/work/"/>
    
    <category term="工作" scheme="https://paynewu-blog.github.io/categories/work/%E5%B7%A5%E4%BD%9C/"/>
    
    <category term="思考" scheme="https://paynewu-blog.github.io/categories/work/%E5%B7%A5%E4%BD%9C/%E6%80%9D%E8%80%83/"/>
    
    
    <category term="work" scheme="https://paynewu-blog.github.io/tags/work/"/>
    
  </entry>
  
</feed>
