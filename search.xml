<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android逆向之smail剖析</title>
    <url>/10131.html</url>
    <content><![CDATA[<h2 id="smali"><a class="markdownIt-Anchor" href="#smali"></a> Smali</h2>
<p><strong>smail是Android虚拟机的反汇编语言</strong></p>
<p>Android代码一般是用JVM语言编写，执行Androdi程序一般需要用到JVM，在Android平台上也不例外，但是出于性能上的考虑，并没有使用标准的JVM，而是使用专门的Android虚拟机（5.0以下为Dalvik，5.0以上为ART）。Android虚拟机的可执行文件并不是普通的class文件，而是再重新整合打包后生成的dex文件。smail是dex格式的文件的汇编器<br />
反汇编器\ 其语法是一种宽松的jasmin/dedexer 语法,实现了.dex格式的所有功能(注解/调试信息/线路信息等)</p>
<h2 id="学习smail必要性"><a class="markdownIt-Anchor" href="#学习smail必要性"></a> 学习smail必要性</h2>
<ol>
<li>动态调试与修改APK, 当静态分析已经无法满足时,此时便需要对Android进行动态调试, 而动态调试便是调试smail</li>
<li>修改APK运行逻辑, 通过修改smail代码,在重新打包.便可对app进行持久化的修改.(<br />
常用的注入均在外部而不是app内部)</li>
</ol>
<blockquote>
<p>插件: java2smail</p>
</blockquote>
<h2 id="smail基本语法"><a class="markdownIt-Anchor" href="#smail基本语法"></a> smail基本语法</h2>
<h3 id="关键字"><a class="markdownIt-Anchor" href="#关键字"></a> 关键字</h3>
<p><strong>关键字</strong></p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>.class</td>
<td>定义类名</td>
</tr>
<tr>
<td>.super</td>
<td>定义父类名</td>
</tr>
<tr>
<td>.source</td>
<td>定义源文件名</td>
</tr>
<tr>
<td>.filed</td>
<td>定义字段</td>
</tr>
<tr>
<td>.method</td>
<td>定义方法开始</td>
</tr>
<tr>
<td>.end method</td>
<td>定义方法结束</td>
</tr>
<tr>
<td>.annotation</td>
<td>定义注解开始</td>
</tr>
<tr>
<td>.end annotation</td>
<td>定义注解结束</td>
</tr>
<tr>
<td>.implements</td>
<td>定义接口指令</td>
</tr>
<tr>
<td>.local</td>
<td>指定了方法内局部变量的个数</td>
</tr>
<tr>
<td>.registers</td>
<td>指定方法内使用寄存器的总数</td>
</tr>
<tr>
<td>.prologue</td>
<td>表示方法中代码的开始处</td>
</tr>
<tr>
<td>.line</td>
<td>表示java源文件中指定行</td>
</tr>
<tr>
<td>.paramter</td>
<td>指定方法的参数</td>
</tr>
<tr>
<td>.param</td>
<td>和.paramter含义一致,但是表达格式不同</td>
</tr>
</tbody>
</table>
<h3 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h3>
<table>
<thead>
<tr>
<th>smail</th>
<th>Java</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>v</td>
<td>void</td>
<td>只能用于返回值类型</td>
</tr>
<tr>
<td>Z</td>
<td>boolean</td>
<td></td>
</tr>
<tr>
<td>B</td>
<td>byte</td>
<td></td>
</tr>
<tr>
<td>S</td>
<td>short</td>
<td></td>
</tr>
<tr>
<td>C</td>
<td>char</td>
<td></td>
</tr>
<tr>
<td>I</td>
<td>int</td>
<td></td>
</tr>
<tr>
<td>J</td>
<td>long</td>
<td></td>
</tr>
<tr>
<td>F</td>
<td>float</td>
<td></td>
</tr>
<tr>
<td>D</td>
<td>double</td>
<td></td>
</tr>
<tr>
<td>Lpackage/name;</td>
<td>对象类型</td>
<td>L表示这是一个对象类型，package表示该对象所在的包，；表示对象名称的结束</td>
</tr>
<tr>
<td>[类型</td>
<td>数组</td>
<td>[I表示一个int型数据，[Ljava/lang/String 表示一个String的对象数组</td>
</tr>
</tbody>
</table>
<p><strong>类声明</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.class + 修饰符 + 类名</span><br></pre></td></tr></table></figure>
<p><strong>构造函数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.method 权限修饰符 constructor &lt;init&gt;(参数类型) V</span><br><span class="line"># 方法体</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>
<p><strong>成员变量定义格式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.field <span class="keyword">public</span>/<span class="keyword">private</span> [<span class="keyword">static</span>][<span class="keyword">final</span>] varName:&lt;类型&gt;</span><br><span class="line">.field 访问权限修饰符 类型修饰符 变量名:类名路径</span><br></pre></td></tr></table></figure>
<p><strong>返回值关键字</strong></p>
<table>
<thead>
<tr>
<th>返回关键字</th>
<th>Java数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>return</td>
<td>byte short float char boolean</td>
</tr>
<tr>
<td>return-void</td>
<td>void</td>
</tr>
<tr>
<td>return-wide</td>
<td>long double</td>
</tr>
<tr>
<td>return-object</td>
<td>数组 object</td>
</tr>
</tbody>
</table>
<p><strong>获取指令</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">iget, sget, iget-<span class="type">boolean</span>, sget-<span class="type">boolean</span>, iget-object, sget-object</span><br></pre></td></tr></table></figure>
<p><strong>操作指令</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">iput, sput, iput-<span class="type">boolean</span>, sput-<span class="type">boolean</span>, iput-object, sput-object</span><br><span class="line">array的操作是aget和aput</span><br></pre></td></tr></table></figure>
<p><strong>指令解析</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sget-object v0,Lcom/aaa;-&gt;ID:Ljava/lang/String;</span><br><span class="line">获取ID这个String类型的成员变量并放到v0这个寄存器中</span><br><span class="line">iget-object v0,p0,Lcom/aaa;-&gt;view:Lcom/aaa/view;</span><br><span class="line">iget-object比sget-object多一个参数p0，这个参数代表变量所在类的实例。这里p0就是<span class="built_in">this</span></span><br></pre></td></tr></table></figure>
<p>example</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example 1 相当于java代码：this.timer = null;</span></span><br><span class="line">const/<span class="number">4</span> v3, <span class="number">0x0</span></span><br><span class="line">sput-object v3, Lcom/aaa;-&gt;timer:Lcom/aaa/timer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example 2</span></span><br><span class="line">.local v0, args:Landroid/os/Message;</span><br><span class="line">const/<span class="number">4</span> v1, <span class="number">0x12</span></span><br><span class="line">iput v1,v0,Landroid/os/Message;-&gt;what:I</span><br><span class="line"><span class="comment">// 相当于java代码：args.what = 18; 其中args为Message的实例</span></span><br></pre></td></tr></table></figure>
<p><strong>调用指令</strong></p>
<table>
<thead>
<tr>
<th>调用关键字</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>invoke-virtual</td>
<td>非私有实例方法调用</td>
</tr>
<tr>
<td>invoke-direct</td>
<td>构造方法以及私有方法的调用</td>
</tr>
<tr>
<td>invoke-static</td>
<td>静态方法的调用</td>
</tr>
<tr>
<td>invoke-super</td>
<td>父类方法的调用</td>
</tr>
<tr>
<td>invoke-interface</td>
<td>接口方法调用</td>
</tr>
</tbody>
</table>
<p>调用格式： invoke-指令类型 {参数1, 参数2,…}, L类名;-&gt;方法名 如果不是是静态方法，参数1代表调用该方法的实例。</p>
<h2 id="寄存器"><a class="markdownIt-Anchor" href="#寄存器"></a> 寄存器</h2>
<p>Java中变量都是存放在内存中的，Android为了提高性能，变量都是存放在寄存器中的，寄存器为32位，可以支持任何类型。64位类型(<br />
Long/ Double) 用2个格式的寄存器表示; Dalvik字节码有两种类型: 原始类型和引用类型(<br />
包括对象和数组)</p>
<p>寄存器分为如下两类： 1、本地寄存器: 用v开头数字结尾的符号来表示，v0, v1, v2,… 2、参数寄存器:<br />
用p开头数字结尾的符号来表示，p0,p1,p2,…<br />
<em>注意：</em><br />
<strong>在非static方法中，p0代指this，p1为方法的第一个参数。</strong><br />
<strong>在static方法中，p0为方法的第一个参数。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const/4 v0, 0x1 //把值0x1存到v0本地寄存器</span><br><span class="line">iput-boolean v0,p0,Lcom/aaa;-&gt;IsRegisterd:Z //把v0中的值赋给com.aaa.IsRegistered，p0代表this，相当于this.Isregistered=true</span><br></pre></td></tr></table></figure>
<h2 id="tip"><a class="markdownIt-Anchor" href="#tip"></a> tip</h2>
<p>查看smail代码时可以和java代码结合来看</p>
<h2 id="referer"><a class="markdownIt-Anchor" href="#referer"></a> referer</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2UuYW5kcm9pZC5jb20vZGV2aWNlcy90ZWNoL2RhbHZpay9kYWx2aWstYnl0ZWNvZGU=">Dalvik 字节码<i class="fa fa-external-link-alt"></i></span></p>
<p>[Android逆向基础：Smail语法]<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85OTMxYTFlNzcwNjY=">https://www.jianshu.com/p/9931a1e77066<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>smail</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>smail</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache Kafka认识</title>
    <url>/6137.html</url>
    <content><![CDATA[<p>官方网址：<span class="exturl" data-url="aHR0cHM6Ly9rYWZrYS5hcGFjaGUub3JnLw==">kafka.apache.org<i class="fa fa-external-link-alt"></i></span></p>
<p>Mirror of Apache Kafka github: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9rYWZrYQ==">https://github.com/apache/kafka<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="什么是kafka"><a class="markdownIt-Anchor" href="#什么是kafka"></a> 什么是Kafka</h2>
<p>Apache Kafka 是一款开源的<strong>消息引擎</strong>系统, 也是一个分布式流处理平台（Distributed Streaming Platform）</p>
<ul>
<li>处理实时数据提供一个统一、高吞吐、低延迟的平台。</li>
<li>它使用的是纯二进制的字节序列, 以时间复杂度为 O(1) 的方式提供消息持久化能力，即使对 TB<br />
级以上数据也能保证常数时间复杂度的访问性能。</li>
<li>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒 100K 条以上消息的传输。</li>
<li>支持 Kafka Server 间的消息分区，及分布式消费，同时保证每个 Partition 内的消息顺序传输。</li>
<li>同时支持离线数据处理和实时数据处理。</li>
<li>Scale out：支持在线水平扩展。</li>
</ul>
<h2 id="kafka功能"><a class="markdownIt-Anchor" href="#kafka功能"></a> Kafka功能</h2>
<blockquote>
<p>削峰填谷解耦合</p>
</blockquote>
<h2 id="kafka传输模型"><a class="markdownIt-Anchor" href="#kafka传输模型"></a> KafKa传输模型</h2>
<p>Kfaka有两种传输模型，分别是基于一对一、多对多的思想。</p>
<p>一对一：一般也称之为消息队列模型，系统 A 发送的消息只能被系统 B 接收，其他任何系统都不能读取 A 发送的消息。</p>
<p>多对多：一般称之为发布订阅模型。与上面不同的是，它有一个<strong>主题（Topic）</strong><br />
的概念，该模型也有发送方和接收方，只不过提法不同。发送方也称为发布者（Publisher）接收方称为订阅者（Subscriber）。和点对点模型不同的是，这个模型可能存在多个发布者向相同的主题发送消息，而订阅者也可能存在多个，它们都能接收到**<br />
相同主题**的消息。</p>
<h2 id="kafka术语"><a class="markdownIt-Anchor" href="#kafka术语"></a> Kafka术语</h2>
<h3 id="message"><a class="markdownIt-Anchor" href="#message"></a> message</h3>
<p>主题（Topic）：在 Kafka 中，发布订阅的对象是主题（Topic），你可以为每个业务、每个应用甚至是每类数据都创建专属的主题。</p>
<p>分区（Partitioning）：将每个主题划分成多个分区（Partition），每个分区是一组有序的消息日志。生产者生产的每条消息只会被发送到一个分区中</p>
<p>消息（Record）：Kafka 是消息引擎，这里的消息就是指 Kafka 处理的主要对象。</p>
<h3 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h3>
<p><strong>生产者（Producer）</strong></p>
<p>向主题发布消息的客户端应用程序，生产者程序通常持续不断地向一个或多个主题发送消息。</p>
<p><strong>消费者（Consumer）</strong></p>
<p>订阅这些主题消息的客户端应用程序。和生产者类似，消费者也能够同时订阅多个主题的消息。</p>
<p><strong>消费者组（Consumer Group）</strong></p>
<p>多个消费者实例共同组成的一个组，同时消费多个分区以实现高吞吐。</p>
<p><strong>消费者实例（Consumer Instance）</strong></p>
<p>运行消费者应用的进程，也可以是一个线程。</p>
<h3 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h3>
<p><strong>Broker</strong></p>
<p>Kafka 的服务器端由被称为 Broker 的服务进程构成，即一个 Kafka 集群由多个 Broker 组成，Broker<br />
负责接收和处理客户端发送过来的请求，以及对消息进行持久化。虽然多个 Broker<br />
进程能够运行在同一台机器上，但更常见的做法是将不同的 Broker 分散运行在不同的机器上，这样如果集群中某一台机器宕机，即使在它上面运行的所有<br />
Broker 进程都挂掉了，其他机器上的 Broker 也依然能够对外提供服务。</p>
<p><strong>Replication</strong></p>
<p>把相同的数据拷贝到多台机器上，而这些相同的数据拷贝在 Kafka 中被称为副本（Replica）</p>
<p>副本的数量是可以配置的，这些副本保存着相同的数据，但却有不同的角色和作用。</p>
<p>Kafka 定义了两类副本：</p>
<ul>
<li>领导者副本（Leader Replica）：对外提供服务，这里的对外指的是与客户端程序进行交互；</li>
<li>追随者副本（Follower Replica）：被动地追随领导者副本，不能与外界进行交互。</li>
</ul>
<p><strong>重平衡（Rebalance）</strong></p>
<p>消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalance 是 Kafka<br />
消费者端实现高可用的重要手段。</p>
<p><strong>消费者位移（Consumer Offset）</strong></p>
<p>表征消费者消费进度，每个消费者都有自己的消费者位移。</p>
<p><img data-src="https://static001.geekbang.org/resource/image/58/91/58c35d3ab0921bf0476e3ba14069d291.jpg" alt="" /></p>
<p><img data-src="https://upload.wikimedia.org/wikipedia/commons/6/64/Overview_of_Apache_Kafka.svg" alt="" /></p>
<h2 id="为什么需要使用消息系统"><a class="markdownIt-Anchor" href="#为什么需要使用消息系统"></a> 为什么需要使用消息系统</h2>
<p>解耦: 消息系统在处理过程中插入了一个隐含的,基于数据接口, 两边的处理过程都要实现这一接口.这允许独立拓展或修改两边的处理过程.<br />
只要确保他们遵循同样的接口约束</p>
<p>而基于消息发布订阅的机制, 可以联动多个业务下流子系统,能够不侵入的情况下的情况下分布编排和开发,来保证数据一致性</p>
<p>冗余:</p>
<p>有些情况下,处理数据的过程中会失败.除非数据被持久化,否则将造成丢失.消息队列吧数据进行持久化直到已经完全被处理,<br />
通过这一方式可规避数据丢失,许多消息队列所采用的&quot;插入-获取-删除&quot;<br />
的范式,把一个消息从队列中删除之前,需要处理系统明确指出该消息已经被完全处理完毕, 从而确保你的数据被安全的保存直到使用完毕</p>
<p>拓展:</p>
<p>消息解耦了处理过程, 所以增大消息入队和处理的频率是简单的,只需要在对应的端加速处理即可.<br />
无需修改代码,修改参数,扩展非常简单</p>
<p>灵活 &amp; 峰值处理能力</p>
<p>在访问量剧增的情况下, 应用仍然需要继续发挥作用,但这样的突发流量并不常见; 如果对此特定时间为标准投入资源,无疑是巨大的浪费.<br />
使用消息队列能使关键组件顶住突发的压力,而不是因为突发的超负荷的请求完全崩溃</p>
<p>可恢复性</p>
<p>系统的一部分组件失效时,不会影响到整个系统. 消息队列降低了进程间的耦合度,<br />
即使一个处理消息的进程挂掉,加入队列中的消息仍然可以在恢复后被处理</p>
<p>顺序</p>
<p>在大多使用厂家下,数据处理的顺序都很重要. 大部分消息队列本来就是排序的,并且能保证数据按照特定的顺序来处理.<br />
kafka保证一个Partition内的消息有序性</p>
<p>缓冲</p>
<p>在任何重要的系统中,都会有需要不同的处理时间因素, 消息队列通过一个缓冲层来帮助业务最高效的执行-写入队列的处理尽可能的快速.<br />
缓冲有助于控制和优化数据流和系统的速度</p>
<p>异步通讯</p>
<p>很多时候并不需要立即处理消息,而消息队列提供了异步处理机制, 允许将消息放入到队列,但不立即处理它.<br />
只需要到一定的时间点处理即可</p>
<h2 id="referer"><a class="markdownIt-Anchor" href="#referer"></a> referer</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vaW50cm8vMTAwMDI5MjAx">Kafka 核心技术与实战<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC83NDA2MzI1MQ==">Kafka【入门】就这一篇！ - 知乎 (zhihu.com)<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>kafka</category>
        <category>MQ</category>
        <category>Apache kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Book List</title>
    <url>/19099.html</url>
    <content><![CDATA[<h2 id="图书清单"><a class="markdownIt-Anchor" href="#图书清单"></a> 图书清单</h2>
<h3 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h3>
<p>操作系统导论</p>
<p>现代操作系统</p>
<p>深入理解计算机操作系统</p>
<p>操作系统-精髓与设计原理</p>
<p>编译原理</p>
<p>系统之美</p>
<p>计算机程序设计艺术</p>
<p>计算机程序的构造和解释</p>
<p>计算机是怎么跑起来的</p>
<blockquote>
<p>较为适合入门,鸟瞰全茂</p>
</blockquote>
<h3 id="计算机网络"><a class="markdownIt-Anchor" href="#计算机网络"></a> 计算机网络</h3>
<p>计算机网络-谢希仁</p>
<blockquote>
<p>该书全面系统地介绍了计算机网络的发展和原理体系结构</p>
</blockquote>
<p>网络是怎样连接的</p>
<blockquote></blockquote>
<p>本书以探索之旅的形式，从在浏览器中输入网址开始，一路追踪了到显示出网页内容为止的整个过程，以图配文，讲解了网络的全貌，并重点介绍了实际的网络设备和软件是如何工作的。目的是帮助读者理解网络的本质意义，理解实际的设备和软件，进而熟练运用网络技术。</p>
<p>图解TCP/IP</p>
<p>图解http</p>
<blockquote>
<p>对互联网HTTP基盘-<br />
HTTP协议进行全面系统的介绍。该书由HTTP协议发展史娓娓道来。严谨细致的剖析HTTP结构，在讲解的同是还辅以大量的生动通讯图。最后延伸到Web安全、最新技术动向等方面。</p>
</blockquote>
<p>HTTP权威指南</p>
<blockquote>
<p>本书是HTTP及相关核心web技术的核心之作。主要介绍了web应用程序是怎么工作的，核心的英特网协议如何与架构交互的</p>
</blockquote>
<p>Wireshark网络分析就是这么简单</p>
<blockquote>
<p>采用风趣幽默的手法，由浅入深的使用Wireshark分析常见的网络协议</p>
</blockquote>
<p>Wireshark网络分析的艺术</p>
<blockquote>
<p>采用实际的场景通俗易懂的纵横Wireshark网络分析</p>
</blockquote>
<p>计算机网络-自顶向下方法</p>
<p>TCP/IP详解 卷1：协议</p>
<p>TCP/IP详解 卷2：实现</p>
<p>TCP/IP详解 卷3：TCP事务协议、HTTP、NNTP和UNIX域协议</p>
<h3 id="算法与数据结构"><a class="markdownIt-Anchor" href="#算法与数据结构"></a> 算法与数据结构</h3>
<p>算法导论</p>
<p>算法</p>
<p>剑指offer</p>
<p>算法图解</p>
<p>算法之美</p>
<p>程序员代码面试指南：</p>
<p>labuladong的算法小抄: 构造刷题框架</p>
<p>**相信以后的做为程序员的你一定会感谢曾经学过算法的自己，无论是在面试，coding、亦或者日常解决问题 都是如虎添翼<br />
**</p>
<h3 id="数学"><a class="markdownIt-Anchor" href="#数学"></a> 数学</h3>
<p>程序员的数学</p>
<p>程序员的数学1</p>
<p>程序员的数学2</p>
<p>数学之美</p>
<h3 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> Linux</h3>
<p>Linux命令行大全 Linux系统命令及Shell脚本</p>
<p>精通Linux Linux程序设计 Raspberry Pi入门指南</p>
<p>高性能Linux服务器运维实战</p>
<h3 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h3>
<h4 id="关系型数据库"><a class="markdownIt-Anchor" href="#关系型数据库"></a> 关系型数据库</h4>
<h5 id="my-sql"><a class="markdownIt-Anchor" href="#my-sql"></a> My SQL</h5>
<p>高性能的MySQL</p>
<blockquote>
<p>mysql 领域的经典之作，拥有广泛的影响力。第三版不但涵盖了最新mysql<br />
5.5版本的新特性，也讲述了关于固态盘、高可扩展性设计和云计算环境下的数据库相关的新内容，原有的基准测试和性能优化部分也做了大量的扩展和补充。全书共分为16<br />
章和6 个附录，内容涵盖mysql 架构和历史，基准测试和性能剖析，数据库软硬件性能优化，复制、备份和恢复，高可用与高可扩展性，以及云端的mysql<br />
和mysql相关工具等方面的内容。</p>
</blockquote>
<p>高可用MySQL</p>
<p>SQL必知必会</p>
<blockquote>
<p>与其他同类图书不同，它没有过多阐述数据库基础理论，而是专门针对一线软件开发人员，直接从SQL<br />
SELECT开始，讲述实际工作环境中最常用和最必需的SQL知识，实用性极强。通过本书，读者能够从没有多少SQL经验的新手，迅速编写出世界级的SQL！</p>
<p>本书是麻省理工学院、伊利诺伊大学等众多大学的参考教材。除了作为教程之外，独特的编排方式还使本书成为方便的快速查询手册。</p>
</blockquote>
<p>SQL入门经典</p>
<blockquote></blockquote>
<p>详细介绍了SQL语言的基本语法、基本概念，说明了各种SQL实现与ANSI标准之间的差别。书中包含了大量的范例，直观地说明了如何使用SQL对数据进行处理。每章后面还有针对性很强的测验与练习，能够帮助读者更好地理解和掌握学习的内容。在最后的附录里还有关于安装MySQL的详细介绍、书中用到的关键SQL语句、测验和练习的答案。</p>
<p>前金良方:MySQL性能优化金字塔法则</p>
<blockquote></blockquote>
<p>一共分为3篇：基础篇、案例篇和工具篇。“基础篇”从理论基础和基本原理层面介绍了MySQL的安装与配置、升级和体系结构，information_schema、sys_schema、performance_schema和mysql_schema，MySQL复制，MySQL事务，SQL语句优化及架构设计基础知识。“案例篇”从硬件和系统、MySQL架构等方面给出了性能优化的十几个案例，包括：性能测试的基本优化思路和需要关注的性能指标解释、对日常SQL语句执行慢的基本定位、避免x86可用性的一般性方法、节能模式会怎样影响性能、I/O存储作为数据库重要的依赖是如何影响数据库性能的、主备复制不一致可能有哪些原因、字符集不一致会造成哪些性能问题、在实际场景中锁的争用是怎样的。“工具篇”介绍了在MySQL性能优化过程中需要用到的各种工具，包括：dmidecode、top、dstat等硬件和系统排查工具；FIO、sysbench、HammerDB等压力测试工具；mysqldump、XtraBackup等备份工具；Percona、innotop、Prometheus等监控工具</p>
<p><strong>一本 《高性能的MySQL》足以争霸纵横</strong></p>
<h4 id="非关系性数据库"><a class="markdownIt-Anchor" href="#非关系性数据库"></a> 非关系性数据库</h4>
<h5 id="mongodb"><a class="markdownIt-Anchor" href="#mongodb"></a> MongoDB</h5>
<p>MongoDB权威指南</p>
<blockquote></blockquote>
<p>此书可作为数据库开发人员的工作指南，也可作为系统管理人员的进阶指导，还可供项目中其他成员了解MongoDB使用。书中介绍了面向文档的存储方式及利用MongoDB的无模式数据模型处理文档、集合和多个数据库，讲述了如何执行基本的写操作以及各种复杂的条件查询，还介绍了索引、聚合工具以及其他高级查询技术，另外对监控、安全性和身份验证、备份和修复、水平扩展MongoDB数据库等内容也有所涉及。</p>
<p>深入学习MongoDB</p>
<blockquote></blockquote>
<p>第一部分全面讲解了有关建立和使用集群的内容，不仅从应用开发人员的角度讲解了MongoDB的使用，而且从运维方面介绍了集群的管理。其中内容包括通过分片设置MongoDB集群，分片的工作原理，查询和更新数据，操作、监控和备份集群，错误处理。第二部分依次从应用设计、实现、优化、数据安全和管理方面介绍了使用MongoDB构建应用的技巧，内容包括范式化与反范式化的利弊权衡，复制组的故障恢复等。</p>
<p>大数据存储 MongoDB实战指南</p>
<blockquote>
<p>什么是MongoDB及其核心进程； MongoDB的查询语言系统； MongoDB的索引与查询优化； 增、删、改语句；<br />
Journaling日志功能； 聚集分析框架与MapReduce的编程模型； 复制集的功能与工作机制； 分片集群； 分布式文件系统；<br />
MongoDB的管理与监控； 权限控制； MongoDB的PHP驱动接口； 一个完整的电商平台实例。<br />
本书适合有海量数据存储需求的人员、数据库管理开发人员、数据挖掘与分析人员以及各类基于数据库的应用开发人员。读者将从书中获得诸多实用的知识和开发技巧</p>
</blockquote>
<h5 id="redis"><a class="markdownIt-Anchor" href="#redis"></a> Redis</h5>
<p>Redis开发与运维</p>
<blockquote>
<p>本书全面讲解Redis基本功能及其应用，并结合线上开发与运维监控中的实际使用案例，深入分析并总结了实际开发运维中遇到的“陷阱”，以及背后的原因，</p>
</blockquote>
<p>包含大规模集群开发与管理的场景、应用案例与开发技巧，为高效开发运维提供了大量实际经验和建议。本书不要求读者有任何Redis使用经验,对入门与进阶DevOps的开发者提供有价值的帮助。主要内容包括：Redis的安装配置、API、各种高效功能、客户端、持久化、复制、高可用、内存、哨兵、集群、缓存设计等，Redis高可用集群解决方案，Redis设计和使用中的问题，最后提供了一个开源工具：Redis监控运维云平台CacheCloud。</p>
<p>Redis设计与实现</p>
<blockquote></blockquote>
<p>本书全面而完整地讲解了Redis的内部机制与实现方式，对Redis的大多数单机功能以及所有多机功能的实现原理进行了介绍，展示了这些功能的核心数据结构以及关键的算法思想,图示丰富，描述清晰，并给出大量参考信息。通过阅读本书，读者可以快速、有效地了解Redis的内部构造以及运作机制，更好、更高效地使用Redis。</p>
<blockquote></blockquote>
<p>本书主要分为四大部分。第一部分“数据结构与对象”介绍了Redis中的各种对象及其数据结构，并说明这些数据结构如何影响对象的功能和性能。第二部分“单机数据库的实现”对Redis实现单机数据库的方法进行了介绍，包括数据库、RDB持久化、AOF持久化、事件等。第三部分“多机数据库的实现”对Redis的Sentinel、复制、集群三个多机功能进行了介绍。第四部分“独立功能的实现”对Redis中各个相对独立的功能模块进行了介绍，涉及发布与订阅、事务、Lua脚本、排序、二进制位数组、慢查询日志、监视器等。</p>
<p>Redis 深度历险核心原理与应用实践</p>
<blockquote>
<p>分为基础和应用篇、原理篇、集群篇、拓展篇、源码篇共 5</p>
</blockquote>
<p>大块内容。基础和应用篇讲解对读者来说最有价值的内容，可以直接应用到实际工作中；原理篇、集群篇让开发者透过简单的技术表面看到精致的底层世界；拓展篇帮助读者拓展技术视野和夯实基础，便于进阶学习；源码篇让高阶的读者能够读懂源码，掌握核心技术实力</p>
<h3 id="垃圾回收算法"><a class="markdownIt-Anchor" href="#垃圾回收算法"></a> 垃圾回收算法</h3>
<p>垃圾回收算法手册：自动内存管理的艺术</p>
<blockquote>
<p>本书汇集了自动内存管理研究者和开发者们在过去50年间的丰富经验，在本书中，作者在一个统一的易于接受的框架内比较了当下最重要的回收策略以及最先进的回收技术。</p>
</blockquote>
<p>本书从近年来硬件与软件的发展给垃圾回收所带来的新挑战出发，探讨了这些挑战给高性能垃圾回收器的设计者与实现者所带来的影响。在简单的传统回收算法之外，本书还涵盖了并行垃圾回收、增量式垃圾回收、并发垃圾回收以及实时垃圾回收。书中配备了丰富的伪代码与插图，以描述各种算法与概念。</p>
<p>垃圾回收的算法与实现</p>
<blockquote>
<p>本书前半介绍基本GC算法，包括标记-清除GC、引用计数、复制算法的GC、串行GC的算法、并发GC的算法等。后半介绍V8、Rubinius、Dalvik、CPython等几种具体GC的实现</p>
<p>深入浅出理解 垃圾回收 与实现</p>
</blockquote>
<p>深入分析gcc</p>
<blockquote></blockquote>
<p>结合GCC4.4.0源代码，围绕GCC编译过程，详细介绍了GCC的设计框架和实现过程，包括从源代码到AST、从AST到GIMPLE、从GIMPLE到RTL，以及从RTL到终的目标机器代码的详细过程，涉及各个阶段中间表示的详细分析、生成过程，使读者在了解编译原理的基础上进一步掌握其实现的总体流程和实现细节</p>
<h3 id="编码"><a class="markdownIt-Anchor" href="#编码"></a> 编码</h3>
<p>Head First设计模式</p>
<p>重构</p>
<blockquote>
<p>Refactoring: Improving the Design of Existing Code</p>
</blockquote>
<blockquote>
<p>重构，一言以蔽之，就是在不改变外部行为的前提下，有条不紊地改善代码。多年前，正是本书原版的出版，使重构终于从编程高手们的小圈子走出，成为众多普通程序员日常开发工作中不可或缺的一部分。</p>
</blockquote>
<p>本书凝聚了软件开发社区专家多年摸索而获得的宝贵经验，拥有不因时光流逝而磨灭的价值。今天，无论是重构本身，业界对重构的理解，还是开发工具对重构的支持力度，都与本书最初出版时不可同日而语，但书中所蕴涵的意味和精华，依然值得反复咀嚼，而且往往能够常读常新。</p>
<p>Effeactivate Debugging：软件和系统调试的66个有效方法</p>
<blockquote>
<p>本书所要讲解的调试知识，包括与调试有关的策略、工具及方法。当我们在开发并运作一款复杂的计算系统时，可能会遇到各种问题，而这些调试知识，则使大家能够应对这些问题。</p>
<p>过去我们所说的调试，主要是指检测并修复程序错误，而当前却很少有哪个程序会孤立地运作，即便是一个很小的程序，也会与外部的程序库相链接（通常是动态链接）。更为复杂的程序会运行在应用程序服务器中，会调用<br />
Web 服务，会使用关系型数据库及 NoSQL</p>
</blockquote>
<p>数据库，会从目录服务器上获取数据，会运行外部的程序，会利用其他的中间件，也会纳入很多第三方的软件包。于是，要想令整个系统及服务正常地运作，就必须确保其中的组件不会发生故障，这些组件可能是由公司内部人员所开发的，也可能是由第三方所提供的，它们所在的主机或许分布在全球各地。</p>
<h3 id="架构"><a class="markdownIt-Anchor" href="#架构"></a> 架构</h3>
<p>企业IT架构转型之道</p>
<p>微服务架构设计模式</p>
<p>架构简洁之道</p>
<p>大型网站技术架构</p>
<p>高可用架构</p>
<p>大型网站技术架构演进与性能优化</p>
<p>京东基础架构建设之路</p>
<h3 id="中间件"><a class="markdownIt-Anchor" href="#中间件"></a> 中间件</h3>
<h4 id="kafka"><a class="markdownIt-Anchor" href="#kafka"></a> Kafka</h4>
<p>Kafka:The Definitive Guide: Real-Time Data and Stream Processing at Scale</p>
<p>Kafka权威指南</p>
<blockquote></blockquote>
<p>本书由出身于LinkedIn的Kafka核心作者和一线技术人员共同执笔，详细介绍了如何部署Kafka集群、开发可靠的基于事件驱动的微服务，以及基于Kafka平台构建可伸缩的流式应用程序。通过详尽示例，你将会了解到Kafka的设计原则、可靠性保证、关键API，以及复制协议、控制器和存储层等架构细节</p>
<p>深入理解Kafka：核心设计与实践原理</p>
<blockquote>
<p>从Kafka的基础概念切入，循序渐进地转入对其内部原理的剖析。主要阐述了Kafka中生产者客户端、消费者客户端、主题与分区、日志存储、原理解析、监控管理、应用扩展及流式计算等内容。</p>
<p>虽然Kafka的内核使用Scala语言编写，但基本以Java语言作为主要的示例语言，方便大多数读者的理解。</p>
</blockquote>
<p>总体上可以划分为三个部分：基础篇、原理篇和扩展篇，前4章为基础篇，包括基础概念、生产者、消费者，以及主题与分区，学习完这4章的内容完全可以应对绝大多数的开发场景。第5章至第8章为原理篇，包括对日志存储、协议设计、控制器、组协调器、事务、一致性、可靠性等内容的探究，学习完这4章的内容可以让读者对Kafka有一个深刻的认知。最后4章从应用扩展层面来做讲解，可以归类为扩展篇，主要内容包括监控、应用工具、应用扩展（延时队列、重试队列、死信队列、消息轨迹等）、与Spark的集成等，让读者可以对Kafka的生态有一个更加全面的认知。</p>
<h4 id="elasticsearch"><a class="markdownIt-Anchor" href="#elasticsearch"></a> Elasticsearch</h4>
<p>Elasticsearch: The Definitive Guide A distributed real-time search and analytics engine</p>
<p>Elasticsearch in Action</p>
<p>本书主要展示如何使用Elasticsearch构建可扩展的搜索应用程序。书中覆盖了Elasticsearch的主要特性，从使用不同的分析器和查询类型进行相关性调优，到使用聚集功能进行实时性分析，还有地理空间搜索和文档过滤等更多吸引人的特性。</p>
<p>全书共分两个部分，第一部分解释了核心特性，内容主要涉及Elasticsearch的介绍，数据的索引、更新和删除，数据的搜索，数据的分析，使用相关性进行搜索，使用聚集来探索数据，文档间的关系等；第二部分介绍每个特性工作的更多细节及其对性能和可扩展性的影响，以便对核心功能进行产品化，内容主要涉及水平扩展和性能提升等。</p>
<h3 id="python"><a class="markdownIt-Anchor" href="#python"></a> Python</h3>
<p>Python编程：从入门到实战</p>
<p>Python学习手册</p>
<p>Think Python</p>
<blockquote>
<p>Think Python: How to Think Like a Computer Scientist</p>
</blockquote>
<p>本书从基本的编程概念开始讲起，包括语言的语法和语义，而且每个编程概念都有清晰的定义，引领读者循序渐进地学习变量、表达式、语句、函数和数据结构。书中还探讨了如何处理文件和数据库，如何理解对象、方法和面向对象编程，如何使用调试技巧来修正语法错误、运行时错误和语义错误。每一章都配有术语表和练习题，方便读者巩固所学的知识和技巧。此外，每一章都抽出一节来讲解如何调试程序。</p>
<p>Head First Python</p>
<p>Learn Python The Hard Way</p>
<p>Python Cookbook</p>
<blockquote>
<p>本书介绍了Python应用在各个领域中的一些使用技巧和方法，从最基本的字符、文件序列、字典和排序，到进阶的面向对象编程、数据库和数据持久化、<br />
XML处理和Web编程，再到比较高级和抽象的描述符、装饰器、元类、迭代器和生成器，均有涉及。书中还介绍了一些第三方包和库的使用，包括</p>
</blockquote>
<p>Twisted、GIL、PyWin32等。本书覆盖了Python应用中的很多常见问题，并提出了通用的解决方案。书中的代码和方法具有很强的实用性，可以方便地应用到实际的项目中，并产生立竿见影的效果。尤为难得的是，本书的各位作者都具有丰富的业界实践经验，因此，本书不仅给出了对各种问题的解决方案，同时还体现了很多专家的思维方式和良好的编程习惯，与具体的细节性知识相比，这部分内容无疑是本书的精华。</p>
<p>Python源码剖析</p>
<blockquote></blockquote>
<p>为了更好地利用Python语言，无论是使用Python语言本身，还是将Python与C/C++交互使用，深刻理解Python的运行原理都是非常重要的。本书以CPython为研究对象，在C代码一级，深入细致地剖析了Python的实现。书中不仅包括了对大量Python内置对象的剖析，更将大量的篇幅用于对Python虚拟机及Python高级特性的剖析。通过此书，读者能够透彻地理解Python中的一般表达式、控制结构、异常机制、类机制、多线程机制、模块的动态加载机制、内存管理机制等核心技术的运行原理，同时，本书所揭示的动态语言的核心技术对于理解其他动态语言，如<br />
Javascript、Ruby等也有较大的参考价值</p>
<p>流畅的Python</p>
<blockquote></blockquote>
<p>本书致力于帮助Python开发人员挖掘这门语言及相关程序库的优秀特性，避免重复劳动，同时写出简洁、流畅、易读、易维护，并且具有地道Python风格的代码。本书尤其深入探讨了Python语言的高级用法，涵盖数据结构、Python风格的对象、并行与并发，以及元编程等不同的方面。</p>
<p>Python高性能编程</p>
<blockquote></blockquote>
<p>围绕如何进行代码优化和加快实际应用的运行速度进行详细讲解。本书主要包含以下主题：计算机内部结构的背景知识、列表和元组、字典和集合、迭代器和生成器、矩阵和矢量计算、并发、集群和工作队列等。最后，通过一系列真实案例展现了在应用场景中需要注意的问题</p>
<p>编写高质量代码：改善Python程序的91个建议</p>
<blockquote>
<p>Effective Python: 90 Specific Ways to Write Better Python, Second Edition</p>
</blockquote>
<blockquote>
<p>本书可以帮你掌握真正的 Pythonic 编程方式，令你能够完全发挥出 Python 语言的强大功能，并写出健壮而高效的代码。汇聚了<br />
90 条实践原则、开发技巧和便捷方案，并以实用的代码范例来解释它们。</p>
</blockquote>
<h3 id="java"><a class="markdownIt-Anchor" href="#java"></a> Java</h3>
<p>Java核心技术</p>
<p>Effective Java</p>
<p>重学Java设计模式</p>
<p>Java编程思想</p>
<p>深入理解Java虚拟机</p>
<p>揭秘Java虚拟机</p>
<p>Java并发编程实战</p>
<p>Java性能权威指南</p>
<p>深入分析Java Web技术内幕</p>
<p>代码简洁之道(clean code)</p>
<blockquote>
<p>Clean Code: A Handbook of Agile Software Craftsmanship</p>
</blockquote>
<blockquote>
<p>软件质量，不但依赖于架构及项目管理，而且与代码质量紧密相关。这一点，无论是敏捷开发流派还是传统开发流派，都不得不承认。</p>
</blockquote>
<p>本书提出一种观念：代码质量与其整洁度成正比。干净的代码，既在质量上较为可靠，也为后期维护、升级奠定了良好基础。作为编程领域的佼佼者，本书作者给出了一系列行之有效的整洁代码操作实践。这些实践在本书中体现为一条条规则（或称“启示”），并辅以来自现实项目的正、反两面的范例。只要遵循这些规则，就能编写出干净的代码，从而有效提升代码质量。</p>
<blockquote>
<p>本书阅读对象为一切有志于改善代码质量的程序员及技术经理。书中介绍的规则均来自作者多年的实践经验，涵盖从命名到重构的多个编程方面，虽为一“家”之言，然诚有可资借鉴的价值。</p>
</blockquote>
<h3 id="android"><a class="markdownIt-Anchor" href="#android"></a> Android</h3>
<p>第一行代码:Android</p>
<p>打造高质量Android应用</p>
<p>Android进阶之光</p>
<p>Android 源码设计模式解析与实战</p>
<h3 id="golang"><a class="markdownIt-Anchor" href="#golang"></a> GoLang</h3>
<p>go语言程序设计</p>
<p>Go语言趣学指南</p>
<p>Go语言并发之道</p>
<p>Go语言编程之旅:一起用go做项目</p>
<p>Go语言学习笔记</p>
<p>Go Web 编程</p>
<p>Go专家编程</p>
<p>Go语言实战(Go in Action)</p>
<p>Go语言高级编程</p>
<p>GO语言高并发与微服务实战</p>
<h3 id="web"><a class="markdownIt-Anchor" href="#web"></a> Web</h3>
<p>Web性能实战</p>
<blockquote></blockquote>
<p>创建快速网站的指南，指导你如何以正确的方式创建高性能网站。书中介绍了如何加快向用户交付站点资源的速度、提高渲染速度、减少网站占用空间；探讨了HTTP/2等能够大幅提升网站速度的技术；阐述了如何构建一个自动化的工作流以完成常见的优化任务，同时提高开发效率。</p>
<p>Web性能权威指南</p>
<blockquote>
<p>涵盖Web 开发者技术体系中应该掌握的所有网络及性能优化知识。全书以性能优化为主线，从TCP、UDP 和TLS<br />
协议讲起，解释了如何针对这几种协议和基础设施来优化应用。然后深入探讨了无线和移动网络的工作机制。最后，揭示了HTTP<br />
协议的底层细节，同时详细介绍了HTTP 2.0、 XHR、SSE、WebSocket、WebRTC 和DataChannel 等现代浏览器新增的具有革命性的新能力。</p>
</blockquote>
<p>前端架构设计</p>
<p>同构 JavaScript 应用开发</p>
<h3 id="网络爬虫"><a class="markdownIt-Anchor" href="#网络爬虫"></a> 网络爬虫</h3>
<p><strong>Python 网络爬虫从入门到实践</strong></p>
<p><strong>Python3网络爬虫开发实战</strong></p>
<p><strong>Python3反爬虫原理与绕过实战</strong></p>
<p><strong>Android安全攻防权威指南</strong></p>
<p><strong>Android应用安全和逆向分析</strong></p>
<p><strong>IDA PRO 权威指南</strong></p>
<h3 id="数据分析"><a class="markdownIt-Anchor" href="#数据分析"></a> 数据分析</h3>
<h4 id="通识类"><a class="markdownIt-Anchor" href="#通识类"></a> 通识类</h4>
<blockquote>
<p>认识数据分析，构建数据分析思维，练就数据分析能力</p>
</blockquote>
<p><strong>深入浅出数据分析</strong></p>
<p><strong>精益数据分析</strong></p>
<p><strong>数学之美</strong></p>
<h4 id="统计学"><a class="markdownIt-Anchor" href="#统计学"></a> 统计学</h4>
<p><strong>统计学</strong></p>
<p><strong>深入浅出统计学</strong></p>
<p><strong>赤裸裸的统计学</strong></p>
<p><strong>统计学七支柱</strong></p>
<p>统计学习方法-李航</p>
<h4 id="实践类"><a class="markdownIt-Anchor" href="#实践类"></a> 实践类</h4>
<blockquote>
<p>what do? How do? Why do?</p>
</blockquote>
<h5 id="excel"><a class="markdownIt-Anchor" href="#excel"></a> Excel</h5>
<p><strong>谁说菜鸟不会数据分析</strong></p>
<p><strong>Excel数据分析思维、技术、与实践</strong></p>
<p><strong>对比Excel轻松学习数据分析</strong></p>
<h5 id="python-2"><a class="markdownIt-Anchor" href="#python-2"></a> Python</h5>
<p><strong>Python数据分析</strong></p>
<p><strong>利用Python进行数据分析</strong></p>
<p><strong>Python金融大数据分析</strong></p>
<p><strong>Python数据分析实战</strong></p>
<h5 id="可视化"><a class="markdownIt-Anchor" href="#可视化"></a> 可视化</h5>
<p><strong>用图表说话</strong></p>
<p><strong>Excel图表之道</strong></p>
<h4 id="数据分析技术的应用"><a class="markdownIt-Anchor" href="#数据分析技术的应用"></a> 数据分析技术的应用</h4>
<p>Python数据分析与数据化运营</p>
<p>数据挖掘与数据化运营实战</p>
<p>社交网站的数据挖掘与分析</p>
<h3 id="数据挖掘"><a class="markdownIt-Anchor" href="#数据挖掘"></a> 数据挖掘</h3>
<p>数据挖掘-概念与技术</p>
<p>数据挖掘导论</p>
<h3 id="深度学习"><a class="markdownIt-Anchor" href="#深度学习"></a> 深度学习</h3>
<p>深度学习的数学</p>
<p>深度学习入门</p>
<p>Python深度学习</p>
<p>深度学习</p>
<p>动手学习深度学习</p>
<p>深度学习进阶</p>
<h3 id="机器学习"><a class="markdownIt-Anchor" href="#机器学习"></a> 机器学习</h3>
<p>机器学习(西瓜书)-周志华</p>
<p>统计学习方法-李航</p>
<p>Patten Recongnition and Machine Learning</p>
<p>统计自然语言处理</p>
<h3 id="云原生"><a class="markdownIt-Anchor" href="#云原生"></a> 云原生</h3>
<h4 id="docker"><a class="markdownIt-Anchor" href="#docker"></a> Docker</h4>
<p><span class="exturl" data-url="aHR0cHM6Ly95ZWFzeS5naXRib29rLmlvL2RvY2tlcl9wcmFjdGljZS8=">Docker从入门到实践<i class="fa fa-external-link-alt"></i></span></p>
<p>深入浅出docker</p>
<blockquote>
<p>深入浅出的介绍了docker相关知识，清晰详细的操作步骤结合大量实际代码</p>
</blockquote>
<p>Docker容器与容器云</p>
<blockquote>
<p>从概念用法解析到核心原理分析，然后到高级实践，层层递进。全面介绍了docker以及围绕Docker构建的各类容器云平台，深入分析了Kubernetes背后的技术原理与设计思想</p>
</blockquote>
<p>第一本Docker书</p>
<blockquote></blockquote>
<p>本书专注于指导读者完成Docker的安装、部署、管理和扩展，带领读者经历从测试到生产的整个开发生命周期，让读者了解Docker适用于什么场景。书中先介绍Docker及其组件的基础知识，然后介绍用Docker构建容器和服务来完成各种任务：利用Docker为新项目建立测试环境，演示如何使用持续集成的工作流集成Docker，如何构建应用程序服务和平台，如何使用Docker的API，如何扩展Docker。</p>
<h4 id="kubernetes"><a class="markdownIt-Anchor" href="#kubernetes"></a> Kubernetes</h4>
<p>每天五分钟玩转Kubernetes</p>
<blockquote>
<p>内容简洁实用，核心观点点到即止。适合入门与碎片化学习</p>
</blockquote>
<p>再也不踩坑的Kubernetes</p>
<blockquote>
<p>各种环境搭建如Redis集群、RabbitMQ等。适合当工具书</p>
</blockquote>
<p>Kubernetes权威指南</p>
<blockquote></blockquote>
<p>从架构师、开发人员和运维人员的角度，阐述了Kubernetes的基本概念、实践指南、核心原理、开发指导、运维指南、新特性演进等内容，图文并茂、内容丰富、由浅入深、讲解全面；并围绕在生产环境中可能出现的问题，给出了大量的典型案例，比如安全配置方案、网络方案、共享存储方案、高可用方案及Trouble<br />
Shooting技巧等，有很强的实战指导意义。</p>
<p>Kubernetes进阶实战</p>
<p>Kubernetes网络权威指南</p>
<p>Kubernetes生产化与实践之路</p>
<p>深入剖析Kubernetes</p>
<p>Kubernetes源码剖析</p>
<p>Kubernetes in Action</p>
<p>云原生服务网格istio</p>
<p>性能之巅：洞悉系统、企业与云计算洞悉系统、企业与云计算</p>
<p>BPF之巅洞悉Linux系统和应用性能</p>
<h3 id="软技能"><a class="markdownIt-Anchor" href="#软技能"></a> 软技能</h3>
<p>程序员的三门课：技术精进，架构修炼、管理探秘</p>
<p>代码之外的功夫：程序员精进之道</p>
<p>程序员修炼之道:从小工到专家</p>
<p>高效程序员的45个习惯：敏捷开发修炼之道</p>
<p>Google方法法</p>
<p>Google 工作整理术</p>
<p>程序的自我修养</p>
<p>软件随想录</p>
<p>程序员的职业素养</p>
<p>人月神话</p>
<p>决断力</p>
<p>金字塔原理</p>
<p>逻辑表达：高效沟通的金字塔思维</p>
<p>麦肯锡教我的思维武器</p>
<p>持续更新…</p>
]]></content>
      <categories>
        <category>read</category>
        <category>book</category>
      </categories>
      <tags>
        <tag>read</tag>
      </tags>
  </entry>
  <entry>
    <title>cni already has an IP address different from ...</title>
    <url>/30373.html</url>
    <content><![CDATA[<h2 id="错误如下"><a class="markdownIt-Anchor" href="#错误如下"></a> 错误如下</h2>
<p>cni already has an IP address different from …</p>
<p>如图所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gtz8c50ce1j627w0mex5w02.jpg" alt="1421630332579_.pic_hd" /></p>
<h2 id="缘由"><a class="markdownIt-Anchor" href="#缘由"></a> 缘由</h2>
<p>node之前反复添加</p>
<h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找到对应的节点</span></span><br><span class="line">kubectl get pod --all-namespace -o wide</span><br></pre></td></tr></table></figure>
<p>在对应node上执行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重置Kubernetes集群</span></span><br><span class="line">kubeadm reset &amp;&amp; systemctl stop kubelet &amp;&amp; systemctl stop docker</span><br><span class="line"><span class="comment"># 删除残留</span></span><br><span class="line"><span class="built_in">rm</span> -rf /var/lib/cni/ &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/kubelet/* &amp;&amp; <span class="built_in">rm</span> -rf /etc/cni/</span><br><span class="line"><span class="comment"># 删除旧网络</span></span><br><span class="line">ifconfig cni0 down &amp;&amp; ifconfig flannel.1 down &amp;&amp; ifconfig docker0 down </span><br><span class="line">ip <span class="built_in">link</span> delete cni0 &amp;&amp; ip <span class="built_in">link</span> delete flannel.1</span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">systemctl restart docker &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure>
<p>在master上获取join token</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure>
<p>重新加入节点</p>
]]></content>
      <categories>
        <category>错误集合</category>
        <category>Kubernetes</category>
        <category>kubernetes</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>GC垃圾回收原理</title>
    <url>/30964.html</url>
    <content><![CDATA[<h2 id="如何判断对象是垃圾"><a class="markdownIt-Anchor" href="#如何判断对象是垃圾"></a> 如何判断对象是垃圾</h2>
<h3 id="经典判断方法-1引用计数法"><a class="markdownIt-Anchor" href="#经典判断方法-1引用计数法"></a> 经典判断方法 1：引用计数法</h3>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxyvrbqaj20ev07ymxp.jpg" alt="" /></p>
<p>思路很简单，但是如果出现循环引用，即 A 引用 B，B 又引用 A，这种情况下就不好办了。所以一般还使用了另一种称为“可达性分析”的判断方法。</p>
<h3 id="经典判断方法-2可达性分析"><a class="markdownIt-Anchor" href="#经典判断方法-2可达性分析"></a> 经典判断方法 2：可达性分析</h3>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxyyymz2j20hj084mxt.jpg" alt="" /></p>
<p>如果 A 引用 B，B 又引用 A（发生了循环引用问题），这 2 个对象是否能被 GC回收？</p>
<p>关键不是在于 A、B 之间是否有引用，而是 A、B 是否可以一直向上追溯到 GC Roots。如果与 GC Roots<br />
没有关联，则会被回收；否则，将继续存活。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxz0rom5j20g405sjrs.jpg" alt="" /></p>
<p>上图是一个用“可达性分析”标记垃圾对象的示例图，灰色的对象表示不可达对象，将等待回收</p>
<h2 id="哪些内存区域需要-gc"><a class="markdownIt-Anchor" href="#哪些内存区域需要-gc"></a> 哪些内存区域需要 GC</h2>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxz5gnwtj20m80ccab1.jpg" alt="" /></p>
<h2 id="常用的-4-种-gc-算法"><a class="markdownIt-Anchor" href="#常用的-4-种-gc-算法"></a> 常用的 4 种 GC 算法</h2>
<h3 id="mark-sweep-标记清除法"><a class="markdownIt-Anchor" href="#mark-sweep-标记清除法"></a> mark-sweep 标记清除法</h3>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxz88d9ej20iu0adjrm.jpg" alt="" /></p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry2t0q3mj20iu0adjrm.jpg" alt="" /></p>
<p>黑色区域表示待清理的垃圾对象，标记出来后直接清空。</p>
<p>优：简单快速；</p>
<p>缺：产生很多内存碎片。</p>
<h3 id="mark-copy-标记复制法"><a class="markdownIt-Anchor" href="#mark-copy-标记复制法"></a> mark-copy 标记复制法</h3>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxzb2sivj20j90aoq37.jpg" alt="" /></p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxzdg4ivj20j90aoq37.jpg" alt="" /></p>
<p>思路也很简单，将内存对半分，总是保留一块空着（上图中的右侧），将左侧存活的对象（浅灰色区域）复制到右侧，然后左侧全部清空。</p>
<p>优：避免了内存碎片问题；</p>
<p>缺：内存浪费很严重，相当于只能使用 50% 的内存。</p>
<h3 id="mark-compact-标记-整理也称标记-压缩法"><a class="markdownIt-Anchor" href="#mark-compact-标记-整理也称标记-压缩法"></a> mark-compact 标记-整理（也称标记-压缩）法</h3>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxzfpp7mj20j30akweq.jpg" alt="" /></p>
<p>将垃圾对象清理掉后，同时将剩下的存活对象进行整理挪动（类似于 windows 的磁盘碎片整理），保证它们占用的空间连续。</p>
<p>优：节约了内存，并避免了内存碎片问题。</p>
<p>缺：整理过程会降低 GC 的效率。</p>
<p>上述三种算法，每种都有各自的优缺点，都不完美；在现代 JVM 中，往往是综合使用的。经过大量实际分析，发现内存中的对象，大致可以分为两类：</p>
<p>有些生命周期很短，比如一些局部变量/临时对象；</p>
<p>而另一些则会存活很久，典型的比如 websocket 长连接中的 connection 对象。如下图，纵向 y 轴可以理解分配内存的字节数，横向<br />
x 轴理解为随着时间流逝（伴随着 GC）。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1rxzjx0woj20km0e9dge.jpg" alt="" /></p>
<p>可以发现大部分对象其实相当短命，很少有对象能在 GC 后活下来，因此诞生了分代的思想。</p>
<h3 id="generation-collect-分代收集算法"><a class="markdownIt-Anchor" href="#generation-collect-分代收集算法"></a> generation-collect 分代收集算法</h3>
<p>如下图所示，可以将内存分成了三大块：年青代（Young Genaration）、老年代（Old Generation）、永久代（Permanent<br />
Generation）。其中 Young Genaration 更是又细为分<br />
eden、S0、S1 三个区。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry01acb0j20ns0723z4.jpg" alt="" /></p>
<p>结合我们经常使用的一些 jvm 调优参数后，一些参数能影响的各区域内存大小值，示意图如下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry02qg80j20u00jnjsq.jpg" alt="" /></p>
<h2 id="gc-的主要过程"><a class="markdownIt-Anchor" href="#gc-的主要过程"></a> GC 的主要过程</h2>
<p>刚开始时，对象分配在 eden 区，s0（即：from）及 s1（即：to）区几乎是空着。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry0lve2fj20ky0cw74z.jpg" alt="" /></p>
<p>随着应用的运行，越来越多的对象被分配到 eden 区。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry3fxogzj20jm0cqgmc.jpg" alt="" /></p>
<p>当 eden 区放不下时，就会发生 minor GC（也被称为 young GC）。</p>
<p>首先当然是要先标识出不可达垃圾对象（即下图中的黄色块）；</p>
<p>然后将可达对象，移动到 s0 区（即：4个淡蓝色的方块挪到s0区）；</p>
<p>然后将黄色的垃圾块清理掉，这一轮后 eden 区就成空的了。</p>
<p>注：这里其实已经综合运用了“【标记-清理eden】+【标记-复制 eden-&gt;s0】”算法。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry0nc0w7j20m60bq3zi.jpg" alt="" /></p>
<p>随着时间推移，eden 如果又满了，再次触发 minor GC，同样还是先做标记，这时 eden 和 s0 区可能都有垃圾对象了（下图中的黄色块）。</p>
<p>这时 s1（即：to）区是空的，s0 区和 eden 区的存活对象，将直接搬到 s1 区。</p>
<p>然后将 eden 和 s0 区的垃圾清理掉，这一轮 minor GC 后，eden 和 s0 区就变成了空的了。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry0rz9rhj20ly0dcdgv.jpg" alt="" /></p>
<p>继续随着对象的不断分配，eden 空可能又满了，这时会重复刚才的 minor GC 过程。不过要注意的是：</p>
<p>这时候 s0 是空的，所以 s0 与 s1 的角色其实会互换。即存活的对象，会从 eden 和 s1 区，向 s0 区移动。</p>
<p>然后再把 eden 和 s1 区中的垃圾清除，这一轮完成后，eden 与 s1 区变成空的，如下图。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry0woahuj20li0dg3zk.jpg" alt="" /></p>
<h3 id="代龄与晋升"><a class="markdownIt-Anchor" href="#代龄与晋升"></a> 代龄与晋升</h3>
<p>对于那些比较“长寿”的对象一直在 s0 与 s1 中挪来挪去，一来很占地方，而且也会造成一定开销，降低 gc<br />
效率，于是有了“代龄(age)”及“晋升”。</p>
<p>对象在年青代的 3 个区（edge,s0,s1）之间，每次从一个区移到另一区，年龄 +1，在 young 区达到一定的年龄阈值后，将晋升到老年代。</p>
<p>下图中是 8，即挪动 8 次后，如果还活着，下次 minor GC 时，将移动到 Tenured 区。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry0xlvk2j20ke0eujsh.jpg" alt="" /></p>
<h3 id="晋升的主要过程"><a class="markdownIt-Anchor" href="#晋升的主要过程"></a> 晋升的主要过程</h3>
<p>下图是晋升的主要过程：对象先分配在年青代，经过多次 Young GC 后，如果对象还活着，晋升到老年代。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry0zgme5j20de0ew74o.jpg" alt="" /></p>
<p>如果老年代，最终也放满了，就会发生 major GC（即 Full<br />
GC）。由于老年代的的对象通常会比较多，标记-清理-整理（压缩）的耗时通常也会比较长，会让应用出现卡顿的现象。这也就是为什么很多应用要优化，尽量避免或减少<br />
Full GC<br />
的原因。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry11sat4j20jm0g8gmj.jpg" alt="" /></p>
<p>注：上面的过程主要来自 oracle 官网的资料，但是有一个细节官网没有提到：如果分配的新对象比较大，eden<br />
区放不下，但是 old 区可以放下时，会直接分配到 old 区。</p>
<p>即没有晋升这一过程，直接到老年代了。</p>
<h3 id="gc-流程图"><a class="markdownIt-Anchor" href="#gc-流程图"></a> GC 流程图</h3>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry13l204j20j90hg0ty.jpg" alt="" /></p>
<h2 id="8-种垃圾回收器"><a class="markdownIt-Anchor" href="#8-种垃圾回收器"></a> 8 种垃圾回收器</h2>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry16k2irj219a0mijt1.jpg" alt="" /></p>
<p>这些回收器都是基于分代的，把 G1 除外，按回收的分代划分如下。</p>
<p>横线以上的 3 种：Serial、ParNew、Parellel Scavenge 都是回收年青代的；</p>
<p>横线以下的 3 种：CMS、Serial Old、Parallel Old 都是回收老年代的。</p>
<p>接下来，我们将以上提到的 8 种垃圾回收器逐一讲解，其中 CMS、G1、ZGC 这三种收集器是面试考试重点，我也会着重讲解。</p>
<h3 id="serial-收集器"><a class="markdownIt-Anchor" href="#serial-收集器"></a> Serial 收集器</h3>
<p> 单线程用标记-复制算法，快刀斩乱麻，单线程的好处避免上下文切换，早期的机器，大多是单核，也比较实用。但执行期间会发生<br />
STW（Stop The World）。</p>
<h3 id="parnew-收集器"><a class="markdownIt-Anchor" href="#parnew-收集器"></a> ParNew 收集器</h3>
<p>Serial 的多线程版本，也同样会 STW，在多核机器上会更适用。</p>
<h3 id="parallel-scavenge-收集器"><a class="markdownIt-Anchor" href="#parallel-scavenge-收集器"></a> Parallel Scavenge 收集器</h3>
<p>ParNew 的升级版本，主要区别在于提供了两个参数：</p>
<p>-XX:MaxGCPauseMillis 最大垃圾回收停顿时间；</p>
<p>-XX:GCTimeRatio 垃圾回收时间与总时间占比。</p>
<p>通过这 2 个参数，可以适当控制回收的节奏，更关注于吞吐率，即总时间与垃圾回收时间的比例。</p>
<h3 id="serial-old-收集器"><a class="markdownIt-Anchor" href="#serial-old-收集器"></a> Serial Old 收集器</h3>
<p>因为老年代的对象通常比较多，占用的空间通常也会更大。如果采用复制算法，得留 50%<br />
的空间用于复制，相当不划算；而且因为对象多，从一个区，复制到另一个区，耗时也会比较长。</p>
<p>所以老年代的收集，通常会采用“标记-整理”法。从名字就可以看出来，这是单线程（串行）的， 依然会有 STW。</p>
<h3 id="parallel-old-收集器"><a class="markdownIt-Anchor" href="#parallel-old-收集器"></a> Parallel Old 收集器</h3>
<p>一句话：Serial Old 的多线程版本。</p>
<h3 id="cms-收集器"><a class="markdownIt-Anchor" href="#cms-收集器"></a> CMS 收集器</h3>
<p>Concurrent Mark Sweep，从名字上看，就能猜出它是并发多线程的。这是 JDK 7 中广泛使用的收集器，有必要多说一下。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1b60glj20u00jbjsz.jpg" alt="" /></p>
<h3 id="g1-收集器"><a class="markdownIt-Anchor" href="#g1-收集器"></a> G1 收集器</h3>
<p>鉴于 CMS 的一些不足之外，比如：老年代内存碎片化，STW 时间虽然已经改善了很多，但是仍然有提升空间。G1<br />
就横空出世了，它对于 heap 区的内存划思路很新颖，有点算法中分治法“分而治之”的味道。</p>
<blockquote>
<p>G1 的全称是 Garbage-First</p>
</blockquote>
<h4 id="g1-垃圾收集器的原理"><a class="markdownIt-Anchor" href="#g1-垃圾收集器的原理"></a> G1 垃圾收集器的原理</h4>
<p>如下图，G1 将 heap 内存区，划分为一个个大小相等（1-32M，2的 n 次方）、内存连续的 Region 区域，每个 region<br />
都对应 Eden、Survivor 、Old、Humongous 四种角色之一，但是 region<br />
与 region 之间不要求连续。</p>
<blockquote>
<p>注：Humongous，简称 H 区是专用于存放超大对象的区域，通常 &gt;= 1/2 Region Size，且只有 Full GC 阶段，才会回收<br />
H 区，避免了频繁扫描、复制/移动大对象。</p>
</blockquote>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1bnt2nj20u00afq3t.jpg" alt="" /></p>
<p>所有的垃圾回收，都是基于 1 个个 region 的。JVM 内部知道，哪些 region 的对象最少（即该区域最空），总是会优先收集这些<br />
region（因为对象少，内存相对较空，肯定快）。这就是 Garbage-First 得名的由来，G<br />
即是 Garbage 的缩写，1 即 First。</p>
<ol>
<li>G1 Young GC young GC 前：</li>
</ol>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry3j8ripj20k007oaan.jpg" alt="" /></p>
<p>young GC 后：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1efxdfj20k007eaak.jpg" alt="" /></p>
<p>理论上讲，只要有一个 Empty Region（空区域），就可以进行垃圾回收。</p>
<p>由于 region 与 region 之间并不要求连续，而使用 G1 的场景通常是大内存，比如 64G 甚至更大，为了提高扫描根对象和标记的效率，G1<br />
使用了二个新的辅助存储结构：</p>
<ul>
<li>
<p>Remembered Sets：简称 RSets，用于根据每个 region 里的对象，是从哪指向过来的（即谁引用了我），每个 Region<br />
都有独立的 RSets（Other Region -&gt; Self Region）。</p>
</li>
<li>
<p>Collection Sets ：简称 CSets，记录了等待回收的 Region 集合，GC 时这些 Region 中的对象会被回收（copied<br />
or moved）。</p>
</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1gs145j20gf0a1aae.jpg" alt="" /></p>
<p>RSets 的引入，在 YGC 时，将年青代 Region 的 RSets 做为根对象，可以避免扫描老年代的 region，能大大减轻 GC<br />
的负担。</p>
<blockquote>
<p>注：在老年代收集 Mixed GC 时，RSets 记录了 Old-&gt;Old 的引用，也可以避免扫描所有 Old 区。</p>
</blockquote>
<p>Old Generation Collection（也称为 Mixed GC）</p>
<p>按 oracle 官网文档描述，分为 5 个阶段：Initial Mark(STW) -&gt; Root Region Scan -&gt; Cocurrent Marking -&gt;<br />
Remark(STW) -&gt; Copying/Cleanup(<br />
STW &amp;&amp; Concurrent)</p>
<blockquote>
<p>注：也有很多文章会把 Root Region Scan 省略掉，合并到 Initial Mark 里，变成 4 个阶段。</p>
</blockquote>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1iktitj20dh09aaa9.jpg" alt="" /></p>
<p>阶段 1：存活对象的“初始标记”依赖于 Young GC，GC 日志中会记录成 young 字样。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1mixvuj20dm0983yt.jpg" alt="" /></p>
<p>阶段 2：并发标记过程中，如果发现某些 region 全是空的，会被直接清除。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1nh65sj20dc09574h.jpg" alt="" /></p>
<p>阶段 3：进入重新标记阶段。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1o63q3j20di097jrs.jpg" alt="" /></p>
<p>阶段 4：并发复制/清查阶段。这个阶段，Young 区和 Old 区的对象有可能会被同时清理。GC 日志中，会记录为 mixed<br />
字段，这也是 G1 的老年代收集，也称为 Mixed GC 的原因。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry3mdckmj20dc097aa8.jpg" alt="" /></p>
<p>上图是，老年代收集完后的示意图。</p>
<p>通过这几个阶段的分析，虽然看上去很多阶段仍然会发生 STW，但是 G1 提供了一个预测模型，通过统计方法，根据历史数据来预测本次收集，需要选择多少个<br />
Region 来回收，尽量满足用户的预期停顿值（-XX:MaxGCPauseMillis<br />
参数可指定预期停顿值）。</p>
<blockquote>
<p>注：如果 Mixed GC 仍然效果不理想，跟不上新对象分配内存的需求，会使用 Serial Old GC（Full GC）强制收集整个<br />
Heap。</p>
</blockquote>
<p>小结：与 CMS 相比，G1 有内存整理过程（标记-压缩），避免了内存碎片；STW 时间可控（能预测 GC 停顿时间）。</p>
<h3 id="zgc截止目前史上最好的-gc-收集器"><a class="markdownIt-Anchor" href="#zgc截止目前史上最好的-gc-收集器"></a> ZGC（截止目前史上最好的 GC 收集器）</h3>
<p>在 G1 的基础上，它做了如下 7 点改进</p>
<p><strong>动态调整大小的 Region</strong><br />
G1 中每个 Region 的大小是固定的，创建和销毁 Region，可以动态调整大小，内存使用更高效。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1poir8j208w07caa0.jpg" alt="" /></p>
<p><strong>不分代，干掉了 RSets</strong><br />
G1 中每个 Region 需要借助额外的 RSets 来记录“谁引用了我”，占用了额外的内存空间，每次对象移动时，RSets<br />
也需要更新，会产生开销。</p>
<p><strong>带颜色的指针 Colored Pointer</strong></p>
<p>这里的指针类似 Java 中的引用，意为对某块虚拟内存的引用。ZGC 采用了64位指针（注：目前只支持 linux 64<br />
位系统），将 42-45 这 4 个 bit 位置赋予了不同含义，即所谓的颜色标志位，也换为指针的 metadata。</p>
<ul>
<li>
<p>finalizable 位：仅 finalizer（类比 C++ 中的析构函数）可访问；</p>
</li>
<li>
<p>remap 位：指向对象当前（最新）的内存地址，参考下面提到的relocation；</p>
</li>
<li>
<p>marked0 &amp;&amp; marked1 位：用于标志可达对象。</p>
</li>
</ul>
<p>这 4 个标志位，同一时刻只会有 1 个位置是 1。每当指针对应的内存数据发生变化，比如内存被移动，颜色会发生变化。</p>
<p><strong>读屏障 Load Barrier</strong></p>
<p>传统 GC 做标记时，为了防止其他线程在标记期间修改对象，通常会简单的 STW。而 ZGC 有了 Colored Pointer<br />
后，引入了所谓的“读屏障”。</p>
<p>当指针引用的内存正被移动时，指针上的颜色就会变化，ZGC 会先把指针更新成最新状态，然后再返回（你可以回想下<br />
Java 中的 volatile 关键字，有异曲同工之妙）。这样仅读取该指针时，可能会略有开销，而不用将整个 heap STW。</p>
<p><strong>重定位 Relocation</strong></p>
<p>如下图，在标记过程中，先从 Roots 对象找到了直接关联的下级对象 1，2，4。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1rjw8kj20u0080gm0.jpg" alt="" /></p>
<p>然后继续向下层标记，找到了 5，8 对象， 此时已经可以判定 3，6，7 为垃圾对象。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry1y8q9zj20u0080aai.jpg" alt="" /></p>
<p>如果按常规思路，一般会将 8 从最右侧的 Region，移动或复制到中间的 Region，然后再将中间 Region 的 3<br />
干掉，最后再对中间 Region 做压缩 compact 整理。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry20tepej20u00aj74t.jpg" alt="" /></p>
<p>但 ZGC 做得更高明，它直接将 4，5 复制到了一个空的新 Region 就完事了，然后中间的 2 个 Region<br />
直接废弃，或理解为“释放”，作为下次回收的“新” Region。这样的好处是避免了中间 Region 的 compact<br />
整理过程。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry22szyaj20u00ajq3l.jpg" alt="" /></p>
<p>最后，指针重新调整为正确的指向（即：remap），而且上一阶段的 remap 与下一阶段的mark是混在一起处理的，相对更高效。</p>
<p><strong>多重映射 Multi-Mapping</strong></p>
<p>这个优化，说实话没完全看懂，只能谈下自己的理解（如果有误，欢迎指正)。虚拟内存与实际物理内存，OS<br />
会维护一个映射关系，才能正常使用，如下图：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry24pjryj20gp07ujrr.jpg" alt="" /></p>
<p>zgc 的 64 位颜色指针，在解除映射关系时，代价较高（需要屏蔽额外的 42-45 的颜色标志位）。考虑到这 4 个标志位，同<br />
1 时刻，只会有 1 位置成 1（如下图），另外 finalizable<br />
标志位，永远不希望被解除映射绑定（可不用考虑映射问题）。</p>
<p>所以剩下 3 种颜色的虚拟内存，可以都映射到同1段物理内存。即映射复用，或者更通俗点讲，本来 3 种不同颜色的指针，哪怕<br />
0-41 位完全相同，也需要映射到 3 段不同的物理内存，现在只需要映射到同 1 段物理内存即可。</p>
<p>支持 <span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9OVU1BLzY5MDYwMjU/ZnI9YWxhZGRpbg==">NUMA 架构<i class="fa fa-external-link-alt"></i></span></p>
<p>NUMA 是一种多核服务器的架构，简单来讲，一个多核服务器（比如 2core），每个 cpu<br />
都有属于自己的存储器，会比访问另一个核的存储器会慢很多（类似于就近访问更快）。</p>
<p>相对之前的 GC 算法，ZGC 首次支持了 NUMA 架构，申请堆内存时，判断当前线程属是哪个CPU在执行，然后就近申请该<br />
CPU 能使用的内存。</p>
<p>小结：革命性的 ZGC 经过上述一堆优化后，每次 GC 总体卡顿时间按官方说法&lt;10ms。</p>
<blockquote>
<p>注：启用 zgc，需要设置 -XX:+UnlockExperimentalVMOptions -XX:+UseZGC。</p>
</blockquote>
<h4 id="remap-的流程图"><a class="markdownIt-Anchor" href="#remap-的流程图"></a> Remap 的流程图</h4>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ry28bcsjj20ii0b5jry.jpg" alt="" /></p>
]]></content>
      <categories>
        <category>GC</category>
        <category>垃圾回收</category>
      </categories>
      <tags>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang-Array</title>
    <url>/62372.html</url>
    <content><![CDATA[<h2 id="array数组的介绍"><a class="markdownIt-Anchor" href="#array数组的介绍"></a> Array(数组)的介绍</h2>
<p>数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。<br />
基本语法：</p>
<blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组变量名 [数组数量]数组类型</span><br></pre></td></tr></table></figure>
<p>//数组的长度必须是常量，并且长度是数组类型的一部分。<br />
// 一旦定义，长度不能变。 [1]int和[2]int是不同的两种类型。<br />
数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> a [<span class="number">1</span>]<span class="type">int</span></span><br><span class="line"> <span class="keyword">var</span> b [<span class="number">2</span>]<span class="type">int</span></span><br><span class="line"> a = b </span><br><span class="line"><span class="comment">//  cannot use b (type [2]int) as type [1]int in assignment</span></span><br><span class="line"><span class="comment">//不可以这样做，因为此时a和b是不同的类型</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="array数组的定义"><a class="markdownIt-Anchor" href="#array数组的定义"></a> Array(数组)的定义</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> definitionPart1()</span><br><span class="line"> definitionPart2()</span><br><span class="line"> definitionPart3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化列表来设置数组元素的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">definitionPart1</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="type">int</span>                        <span class="comment">//数组会初始化为int类型的零值</span></span><br><span class="line"> <span class="keyword">var</span> numArray = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;              <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line"> <span class="keyword">var</span> cityArray = [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125; <span class="comment">//使用指定的初始值完成初始化</span></span><br><span class="line"> fmt.Println(testArray)                      <span class="comment">//[0 0 0]</span></span><br><span class="line"> fmt.Println(numArray)                       <span class="comment">//[1 2 0]</span></span><br><span class="line"> fmt.Println(cityArray)                      <span class="comment">//[北京 上海 深圳]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">definitionPart2</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> testArray [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line"> <span class="keyword">var</span> numArray = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"> <span class="keyword">var</span> cityArray = [...]<span class="type">string</span>&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;</span><br><span class="line"> fmt.Println(testArray)                          <span class="comment">//[0 0 0]</span></span><br><span class="line"> fmt.Println(numArray)                           <span class="comment">//[1 2]</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;type of numArray:%T\n&quot;</span>, numArray)   <span class="comment">//type of numArray:[2]int</span></span><br><span class="line"> fmt.Println(cityArray)                          <span class="comment">//[北京 上海 深圳]</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;type of cityArray:%T\n&quot;</span>, cityArray) <span class="comment">//type of cityArray:[3]string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指定索引值的方式来初始化数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">definitionPart3</span><span class="params">()</span></span> () &#123;</span><br><span class="line"> a := [...]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">5</span>&#125;</span><br><span class="line"> fmt.Println(a)                  <span class="comment">// [0 1 0 5]</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, a) <span class="comment">//type of a:[4]int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="array数组的定义遍历"><a class="markdownIt-Anchor" href="#array数组的定义遍历"></a> Array(数组)的定义遍历</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> a = [...]<span class="type">string</span>&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;</span><br><span class="line"> <span class="comment">// 方法1：for循环遍历</span></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">  fmt.Println(a[i])</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 方法2：for range遍历</span></span><br><span class="line"> <span class="keyword">for</span> index, value := <span class="keyword">range</span> a &#123;</span><br><span class="line">  fmt.Println(index, value)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多维数组嵌套数组"><a class="markdownIt-Anchor" href="#多维数组嵌套数组"></a> 多维数组(嵌套数组)</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> a := [<span class="number">4</span>][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;长沙&quot;</span>,</span><br><span class="line">  &#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Println(a) <span class="comment">//[[北京 上海] [广州 深圳] [成都 重庆]]</span></span><br><span class="line"> fmt.Println(a[<span class="number">2</span>][<span class="number">1</span>]) <span class="comment">//支持索引取值:重庆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组是值类型"><a class="markdownIt-Anchor" href="#数组是值类型"></a> 数组是值类型</h2>
<p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyArray</span><span class="params">(x [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> x[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyArray2</span><span class="params">(x [3][2]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> x[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"> modifyArray(a) <span class="comment">//在modify中修改的是a的副本x</span></span><br><span class="line"> fmt.Println(a) <span class="comment">//[10 20 30]</span></span><br><span class="line"> b := [<span class="number">3</span>][<span class="number">2</span>]<span class="type">int</span>&#123;</span><br><span class="line">  &#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"> modifyArray2(b) <span class="comment">//在modify中修改的是b的副本x</span></span><br><span class="line"> fmt.Println(b)  <span class="comment">//[[1 1] [1 1] [1 1]]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ol>
<li>数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。</li>
<li><code>[n]*T</code>表示指针数组，<code>*[n]T</code>表示数组指针</li>
</ol>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang-Defer详解</title>
    <url>/17571.html</url>
    <content><![CDATA[<h2 id="defer触发时机"><a class="markdownIt-Anchor" href="#defer触发时机"></a> defer触发时机</h2>
<blockquote>
<p>A “defer” statement invokes a function whose execution is deferred to the moment the surrounding<br />
function returns, either because the surrounding function executed a return statement, reached the<br />
end of its function body, or because the corresponding goroutine is panicking.</p>
</blockquote>
<p>Go官方文档中对defer的执行时机做了阐述，分别是。</p>
<ul>
<li>包裹defer的函数返回时</li>
<li>包裹defer的函数执行到末尾时</li>
<li>所在的goroutine发生panic时</li>
<li></li>
</ul>
<span id="more"></span>
<h2 id="defer执行顺序"><a class="markdownIt-Anchor" href="#defer执行顺序"></a> defer执行顺序</h2>
<p>当一个方法中有多个defer时， defer会将要延迟执行的方法“压栈”，当defer被触发时，将所有“压栈”的方法“出栈”并执行。所以defer的执行顺序是LIFO的。</p>
<p>执行顺序如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 常规执行</span></span><br><span class="line"></span><br><span class="line">语句1 -&gt; 语句2 -&gt; 语句3 -&gt; 语句4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在语句2，语句3中添加defer后执行顺序如下</span></span><br><span class="line"></span><br><span class="line">语句1 -&gt; 语句4 -&gt; 语句3(带defer) -&gt; 语句2(带defer) </span><br></pre></td></tr></table></figure>
<h2 id="defer示例"><a class="markdownIt-Anchor" href="#defer示例"></a> defer示例</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> d()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">d</span><span class="params">()</span></span> &#123;</span><br><span class="line"> fmt.Print(<span class="string">&quot;start&quot;</span> + <span class="string">&quot;  &quot;</span>)</span><br><span class="line"> fmt.Print(<span class="string">&quot;processing1&quot;</span> + <span class="string">&quot;  &quot;</span>)</span><br><span class="line"> fmt.Print(<span class="string">&quot;processing2&quot;</span> + <span class="string">&quot;  &quot;</span>)</span><br><span class="line"> fmt.Print(<span class="string">&quot;end&quot;</span> + <span class="string">&quot;  &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>没有defer：start -&gt; processing1 -&gt;  processing2 -&gt; end</li>
<li>processing1、processing2 加入defer：start -&gt; end -&gt; processing2 -&gt; processing1</li>
</ul>
<h2 id="defer使用规则"><a class="markdownIt-Anchor" href="#defer使用规则"></a> defer使用规则</h2>
<h3 id="defer会实时解析参数"><a class="markdownIt-Anchor" href="#defer会实时解析参数"></a> defer会实时解析参数</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> i := <span class="number">0</span></span><br><span class="line"> <span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line"> i ++</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是因为虽然我们在defer后面定义的是一个带变量的函数: fmt.Println(i). 但这个变量(i)<br />
在defer被声明的时候，就已经确定其确定的值了</p>
</blockquote>
<h3 id="defer的类栈执行"><a class="markdownIt-Anchor" href="#defer的类栈执行"></a> defer的类栈执行</h3>
<blockquote>
<p>栈：先入后出</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span>  &#123;</span><br><span class="line"> fmt.Println(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span></span>  &#123;</span><br><span class="line"> fmt.Println(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">defer</span> f1()</span><br><span class="line"> f2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2\1</span></span><br></pre></td></tr></table></figure>
<h3 id="defer可以读取有名返回值"><a class="markdownIt-Anchor" href="#defer可以读取有名返回值"></a> defer可以读取有名返回值</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c</span><span class="params">()</span></span> (i <span class="type">int</span>) &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; i++ &#125;()</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   fmt.Println(c())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在开头的时候，我们说过defer是在return调用之后才执行的。</p>
</blockquote>
<p>这里需要明确的是defer代码块的作用域仍然在函数之内，结合上面的函数也就是说，defer的作用域仍然在c函数之内。因此defer仍然可以读取c函数内的变量(</p>
<blockquote>
<p>如果无法读取函数内变量，那又如何进行变量清除呢…)。<br />
当执行return 1 之后，i的值就是1. 此时此刻，defer代码块开始执行，对i进行自增操作。 因此输出2.</p>
</blockquote>
]]></content>
      <categories>
        <category>go</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang-Map</title>
    <url>/3744.html</url>
    <content><![CDATA[<p>Go语言中提供的映射关系容器为<code>map</code>，其内部使用<code>散列表（hash）</code>实现map</p>
<p>map是一种无序的基于<code>key-value</code>的数据结构，Go语言中的map是<code>引用类型</code>，必须<code>初始化</code>才能使用。</p>
<span id="more"></span>
<h2 id="定义map"><a class="markdownIt-Anchor" href="#定义map"></a> 定义Map</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化定义</span></span><br><span class="line"><span class="keyword">map</span>[KeyType]ValueType</span><br><span class="line"></span><br><span class="line"><span class="comment">// KeyType:表示键的类型。map可以嵌套map，可以是key 也是是value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ValueType:表示键对应的值的类型。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">map</span>类型的变量默认初始值为<span class="literal">nil</span>，需要使用<span class="built_in">make</span>()函数来分配内存。语法为：</span><br><span class="line"></span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, [<span class="built_in">cap</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">map</span>[KeyType]ValueType&#123;</span><br><span class="line">  key1:value1</span><br><span class="line">  key2:value2</span><br><span class="line">  key4:value3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">a[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;Payne&quot;</span></span><br><span class="line">a[<span class="string">&quot;sex&quot;</span>] = <span class="string">&quot;male&quot;</span></span><br><span class="line">a[<span class="string">&quot;year&quot;</span>] = <span class="string">&quot;20&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;a:&quot;</span>, a)               <span class="comment">// a: map[name:Payne sex:male year:20]</span></span><br><span class="line">fmt.Println(<span class="string">&quot;a[&#x27;sex&#x27;]:&quot;</span>, a[<span class="string">&quot;sex&quot;</span>]) <span class="comment">// a[&#x27;sex&#x27;]: male</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Type of a:%T\n&quot;</span>, a)      <span class="comment">// Type of a:map[string]string</span></span><br><span class="line"></span><br><span class="line">b := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Tim&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Sex&quot;</span>:  <span class="string">&quot;male&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Year&quot;</span>: <span class="string">&quot;20&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;b:&quot;</span>, b)               <span class="comment">// b: map[Name:Tim Sex:male Year:20]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;b[&#x27;sex&#x27;]:&quot;</span>, b[<span class="string">&quot;Sex&quot;</span>]) <span class="comment">// b[&#x27;sex&#x27;]: male</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Type of b:%T&quot;</span>, b)   <span class="comment">// Type of b:map[string]string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="判断某个键是否存在"><a class="markdownIt-Anchor" href="#判断某个键是否存在"></a> 判断某个键是否存在</h2>
<p>Go语言中有个判断map中键是否存在的特殊写法，格式如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, ok := <span class="keyword">map</span>[key]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中 value可以为任意接受值。而 ok 必须写</span></span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;name1&quot;</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line"><span class="string">&quot;name2&quot;</span>: <span class="string">&quot;Tim&quot;</span>,</span><br><span class="line"><span class="string">&quot;name3&quot;</span>: <span class="string">&quot;Payne&quot;</span>,</span><br><span class="line"><span class="string">&quot;name4&quot;</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值</span></span><br><span class="line">value, ok := c[<span class="string">&quot;name1&quot;</span>]</span><br><span class="line">fmt.Println(value, ok)     <span class="comment">// Tom true</span></span><br><span class="line"></span><br><span class="line">value, ok := c[<span class="string">&quot;name5&quot;</span>]</span><br><span class="line">fmt.Println(value, ok)     <span class="comment">// false</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(value) <span class="comment">// Tom</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;nil&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="map遍历"><a class="markdownIt-Anchor" href="#map遍历"></a> map遍历</h2>
<p>Go语言中使用<code>for range</code>遍历map。</p>
<h3 id="示例-3"><a class="markdownIt-Anchor" href="#示例-3"></a> 示例</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">d := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;name1&quot;</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line"><span class="string">&quot;name2&quot;</span>: <span class="string">&quot;Tim&quot;</span>,</span><br><span class="line"><span class="string">&quot;name3&quot;</span>: <span class="string">&quot;Payne&quot;</span>,</span><br><span class="line"><span class="string">&quot;name4&quot;</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只遍历key</span></span><br><span class="line"><span class="keyword">for</span> d := <span class="keyword">range</span> d &#123;</span><br><span class="line">fmt.Print(d + <span class="string">&quot;,&quot;</span>)  <span class="comment">// name1,name2,name3,name4,</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="comment">// 只遍历value</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> d &#123;</span><br><span class="line">fmt.Print(v + <span class="string">&quot;,&quot;</span>)  <span class="comment">// Tom,Tim,Payne,John,</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="comment">// 遍历key value</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> d &#123;</span><br><span class="line">fmt.Print(k, <span class="string">&quot;:&quot;</span>, v, <span class="string">&quot; &quot;</span>)   <span class="comment">// name2:Tim name3:Payne name4:John name1:Tom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除key"><a class="markdownIt-Anchor" href="#删除key"></a> 删除key</h2>
<p>使用<code>delete()</code>内建函数从map中删除一组键值对，<code>delete()</code>函数的格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>, key)</span><br><span class="line"><span class="comment">// map:表示要删除键值对的map</span></span><br><span class="line"><span class="comment">// key:表示要删除的键值对</span></span><br></pre></td></tr></table></figure>
<h3 id="示例-4"><a class="markdownIt-Anchor" href="#示例-4"></a> 示例</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;name1&quot;</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line"><span class="string">&quot;name2&quot;</span>: <span class="string">&quot;Tim&quot;</span>,</span><br><span class="line"><span class="string">&quot;name3&quot;</span>: <span class="string">&quot;Payne&quot;</span>,</span><br><span class="line"><span class="string">&quot;name4&quot;</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">v1, ok := f[<span class="string">&quot;name1&quot;</span>]</span><br><span class="line">fmt.Println(v1, ok)  <span class="comment">// Tom true</span></span><br><span class="line"><span class="built_in">delete</span>(f, <span class="string">&quot;name1&quot;</span>)</span><br><span class="line">v2, ok := f[<span class="string">&quot;name1&quot;</span>]</span><br><span class="line">fmt.Println(v2, ok)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="元素为map类型的切片"><a class="markdownIt-Anchor" href="#元素为map类型的切片"></a> 元素为map类型的切片</h2>
<p>下面的代码演示了切片中的元素为map类型时的操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  mapSlice := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">for</span> index, value := <span class="keyword">range</span> mapSlice &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;index:%d value:%v\n&quot;</span>, index, value)</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Println(<span class="string">&quot;after init&quot;</span>)</span><br><span class="line"> <span class="comment">// 对切片中的map元素进行初始化</span></span><br><span class="line"> mapSlice[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line"> mapSlice[<span class="number">0</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;payne&quot;</span></span><br><span class="line"> mapSlice[<span class="number">0</span>][<span class="string">&quot;password&quot;</span>] = <span class="string">&quot;123456&quot;</span></span><br><span class="line"> mapSlice[<span class="number">0</span>][<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;cs&quot;</span></span><br><span class="line"> <span class="keyword">for</span> index, value := <span class="keyword">range</span> mapSlice &#123;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;index:%d value:%v\n&quot;</span>, index, value)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index:0 value:map[]</span></span><br><span class="line"><span class="comment">// index:1 value:map[]</span></span><br><span class="line"><span class="comment">// index:2 value:map[]</span></span><br><span class="line"><span class="comment">// after init</span></span><br><span class="line"><span class="comment">// index:0 value:map[address:cs name:payne password:123456]</span></span><br><span class="line"><span class="comment">// index:1 value:map[]</span></span><br><span class="line"><span class="comment">// index:2 value:map[]</span></span><br></pre></td></tr></table></figure>
<h2 id="值为切片类型的map"><a class="markdownIt-Anchor" href="#值为切片类型的map"></a> 值为切片类型的map</h2>
<p>下面的代码演示了map中值为切片类型的操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  sliceMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>, <span class="number">3</span>)</span><br><span class="line"> fmt.Println(sliceMap)</span><br><span class="line"> fmt.Println(<span class="string">&quot;after init&quot;</span>)</span><br><span class="line">key := <span class="string">&quot;中国&quot;</span></span><br><span class="line">value, ok := sliceMap[key]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">value = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> value = <span class="built_in">append</span>(value, <span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>)</span><br><span class="line"> sliceMap[key] = value</span><br><span class="line">fmt.Println(sliceMap)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// map[]</span></span><br><span class="line"><span class="comment">// after init</span></span><br><span class="line"><span class="comment">// map[中国:[北京 上海]]</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>可以map理解为key-value的容器，里面可包含基本数据类型\Map,不包含Array。包含sclice</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang-匿名函数与闭包</title>
    <url>/45903.html</url>
    <content><![CDATA[<h2 id="匿名函数"><a class="markdownIt-Anchor" href="#匿名函数"></a> 匿名函数</h2>
<h3 id="什么是匿名函数"><a class="markdownIt-Anchor" href="#什么是匿名函数"></a> 什么是匿名函数</h3>
<p>没有名字的函数，由于函数中不可定义<code>有名字</code>的函数，所有出现匿名函数，匿名函数常使用于函数中定义函数</p>
<span id="more"></span>
<h3 id="匿名函数的定义"><a class="markdownIt-Anchor" href="#匿名函数的定义"></a> 匿名函数的定义</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(参数)</span></span> (返回值)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中参数、返回值视情况酌情加入</p>
</blockquote>
<p>简单的示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> x * y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> fmt.Println(f1(<span class="number">2</span>, <span class="number">2</span>))   <span class="comment">// 4</span></span><br><span class="line"> fmt.Println(f2(<span class="number">2</span>, <span class="number">2</span>))   <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>f1:普通的函数有参数、返回值。直接使用<code>f1()</code>调用即可</p>
<p>f2:匿名函数，有参数，有返回值。变量f2,为函数类型，使用<code>f2()</code>可调用</p>
</blockquote>
<h2 id="闭包"><a class="markdownIt-Anchor" href="#闭包"></a> 闭包</h2>
<p>闭包指的是一个函数和与其相关的引用环境组合而成的实体。<code>闭包=函数+引用环境</code>。 示例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> fmt.Println(f1()(<span class="number">1</span>, <span class="number">2</span>)) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以简单理解为函数里面包含函数(多为匿名函数)</p>
</blockquote>
<h3 id="深入理解闭包"><a class="markdownIt-Anchor" href="#深入理解闭包"></a> 深入理解闭包</h3>
<p>闭包常常与作用域之间的关系慎密，首先让我们回顾一下作用域，作用域的范围由上到下分为这几种：</p>
<ul>
<li>全局：即全局均可调用，当在函数中调用修改后并不会直接影响</li>
<li>函数作用域：仅在此函数中进行有效</li>
<li>代码块作用域：仅在此代码块中有效，用完即释放。且外部访问不到此变量(常量)</li>
</ul>
<blockquote>
<p>除全局外，二者均是相对的概念，不必过于拘泥。</p>
</blockquote>
<h3 id="生命周期"><a class="markdownIt-Anchor" href="#生命周期"></a> 生命周期</h3>
<p>一旦进行嵌套的，很多朋友就会懵，那么我们进行几个case来尝试一下。如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"> <span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  x += y</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> f := f1()</span><br><span class="line"> fmt.Println(f(<span class="number">11</span>))</span><br><span class="line"> fmt.Println(f(<span class="number">22</span>))</span><br><span class="line"> fmt.Println(f(<span class="number">33</span>))</span><br><span class="line"> fmt.Println(f(<span class="number">44</span>))</span><br><span class="line"> fmt.Println(f(<span class="number">55</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 11,33,66,110,165</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>变量<code>f</code>是一个函数并且它引用了其外部作用域中的<code>x</code>变量，此时<code>f</code>就是一个闭包。 在<code>f</code><br />
的生命周期内，变量<code>x</code>也一直有效。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  x += y</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> f := f2(<span class="number">20</span>)</span><br><span class="line"> fmt.Println(f(<span class="number">21</span>))</span><br><span class="line"> fmt.Println(f(<span class="number">22</span>))</span><br><span class="line"> fmt.Println(f(<span class="number">23</span>))</span><br><span class="line"> fmt.Println(f(<span class="number">24</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>变量<code>f</code>是一个函数并且它引用了其外部作用域中的<code>x</code>变量，此时<code>f</code>就是一个闭包。 在<code>f</code><br />
的生命周期内，变量<code>x</code>也一直有效。</p>
</blockquote>
<h3 id="装饰器函数"><a class="markdownIt-Anchor" href="#装饰器函数"></a> 装饰器函数</h3>
<p>学其他语言的同学，一定听说过甚至使用过<code>装饰器</code>。那让我们使用golang来实现装饰器的这个功能，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decorator</span><span class="params">(f <span class="keyword">func</span>()</span></span>) &#123;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;The start Time: %s\n&quot;</span>, time.Now())</span><br><span class="line"> f()</span><br><span class="line"> fmt.Printf(<span class="string">&quot;The end Time: %s\n&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hw</span><span class="params">()</span></span> &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;HelloWorld&quot;</span>)</span><br><span class="line"> time.Sleep(<span class="number">20</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">//fmt.Println(f1()(1, 2))</span></span><br><span class="line"> Decorator(Hw)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>输入效果如下：</p>
<p>The start Time: 2020-11-17 19:24:23.969042 +0800 CST m=+0.000082415<br />
helloWorld<br />
The end Time: 2020-11-17 19:24:43.974545 +0800 CST m=+20.005388822</p>
</blockquote>
<p>闭包其实并不复杂，只要牢记<code>闭包=函数+引用环境(变量作用域)</code></p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang-接口(interface)</title>
    <url>/1962.html</url>
    <content><![CDATA[<p><strong>接口是一种类型</strong></p>
<p>最初的<code>int</code>、<code>string</code>、<code>bool</code>,再到稍微复杂的<code>Array</code>、<code>Map</code>、<code>Slice</code><br />
。他们都称之为基础数据类型，以及到多维度符合类型的<code>结构体</code>。以及今日咱们所需要学习的<code>接口</code>。</p>
<p>在Go语言编程中，Go(强类型语言)，也就是说必须是一种具体的类型，当我们需要只关注能调用它的什么方法，而不关注它是什么类型,该怎么办呢？</p>
<p>Go语言中为了解决类似上面的问题，就设计了接口这个概念。接口区别于我们之前所有的具体类型，接口是一种抽象的类型。<br />
当你看到一个接口类型的值时，你不知道它是什么，唯一知道的是通过它的方法能做什么。</p>
<p><strong>疑问：只关心调用的函数，而不关注其类型</strong></p>
<span id="more"></span>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span></span> speak() &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;shit~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span></span> speak() &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;汪汪汪~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// 接受一个参数，进来什么，什么就要speak</span></span><br><span class="line"> x.speak()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口的定义"><a class="markdownIt-Anchor" href="#接口的定义"></a> 接口的定义</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    方法名<span class="number">1</span>( 参数列表<span class="number">1</span>，参数列表<span class="number">2</span> ... ) (返回值列表<span class="number">1</span>,返回值列表<span class="number">2</span> ...)</span><br><span class="line">    方法名<span class="number">2</span>( 参数列表<span class="number">1</span>，参数列表<span class="number">2</span> ...) (返回值列表<span class="number">1</span>,返回值列表<span class="number">2</span> ...)</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>接口名：使用<code>type</code>将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加<code>er</code><br />
，如有写操作的接口叫<code>Writer</code>，有字符串功能的接口叫<code>Stringer</code>等。接口名最好要能突出该接口的类型含义。</li>
<li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li>
<li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</li>
</ul>
</blockquote>
<p>那么为了解决以上<a href="#jump_1">问题</a>，我们可以定义接口。实现如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">type</span> speak <span class="keyword">interface</span> &#123;</span><br><span class="line"> speak()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体person的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span></span> speak() &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;shit~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体dog 实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span></span> speak() &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;汪汪汪~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(s speak)</span></span> &#123;</span><br><span class="line"> <span class="comment">// 接受一个参数，进来什么，什么就调用它的speak</span></span><br><span class="line"> s.speak()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> p1 person</span><br><span class="line"> <span class="keyword">var</span> d1 dog</span><br><span class="line"></span><br><span class="line"> do(p1)</span><br><span class="line"> do(d1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// shit~</span></span><br><span class="line"><span class="comment">// 汪汪汪~</span></span><br></pre></td></tr></table></figure>
<h3 id="实现接口的条件"><a class="markdownIt-Anchor" href="#实现接口的条件"></a> 实现接口的条件</h3>
<p>一个变量如果实现了接口中全部的方法，那么此变量就实现了这个接口。</p>
<p>接口是一个<strong>需要实现的类型(方法列表)</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">type</span> speak <span class="keyword">interface</span> &#123;</span><br><span class="line"> speak()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体person的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span></span> speak() &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;shit~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体dog 实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span></span> speak() &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;汪汪汪~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(s speak)</span></span> &#123;</span><br><span class="line"> <span class="comment">// 接受一个参数，进来什么，什么就调用它的speak</span></span><br><span class="line"> s.speak()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> p1 person</span><br><span class="line"> <span class="keyword">var</span> d1 dog</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 定义一个接口类型：speak的变量speaks</span></span><br><span class="line"> <span class="keyword">var</span> speaks speak</span><br><span class="line"> speaks = d1</span><br><span class="line"> speaks = p1</span><br><span class="line"> fmt.Print(speaks)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="接口类型变量"><a class="markdownIt-Anchor" href="#接口类型变量"></a> 接口类型变量</h3>
<p>接口类型变量能够存储所有实现了该接口的实例。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> say <span class="keyword">interface</span> &#123;</span><br><span class="line"> say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cats <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> dogs <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cats)</span></span> say() &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;Fish~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dogs)</span></span> say() &#123;</span><br><span class="line"> fmt.Print(<span class="string">&quot;Shit~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayer</span><span class="params">(s say)</span></span> &#123;</span><br><span class="line"> <span class="comment">// 接受一个参数，进来什么，什么就调用它的speak</span></span><br><span class="line"> s.say()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> x say</span><br><span class="line"> a := cats&#123;&#125;</span><br><span class="line"> b := dogs&#123;&#125;</span><br><span class="line"> x = a</span><br><span class="line"> x.say()</span><br><span class="line"> x = b</span><br><span class="line"> x.say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="值的接受者与指针接收者实现接口"><a class="markdownIt-Anchor" href="#值的接受者与指针接收者实现接口"></a> 值的接受者与指针接收者实现接口</h3>
<h4 id="值的接受者实现接口"><a class="markdownIt-Anchor" href="#值的接受者实现接口"></a> 值的接受者实现接口</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> moving <span class="keyword">interface</span> &#123;</span><br><span class="line"> move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span></span> move() &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;丁丁～&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span></span> move() &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;喵呜～&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">move</span><span class="params">(m moving)</span></span> &#123;</span><br><span class="line"> <span class="comment">// 接受一个参数，进来什么，什么就调用它的speak</span></span><br><span class="line"> m.move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> x moving</span><br><span class="line"> a := dog&#123;&#125;</span><br><span class="line"> b := &amp;cat&#123;&#125;</span><br><span class="line"> x = a</span><br><span class="line"> x.move()</span><br><span class="line"> x = b</span><br><span class="line"> x.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中我们可以发现，使用值接收者实现接口之后，不管是dog结构体还是结构体指针*<br />
dog类型的变量都可以赋值给该接口变量。因为Go语言中有对指针类型变量求值的语法糖，cat指针<code>x</code><br />
内部会自动求值<code>(* ** x)</code></p>
<h4 id="指针接收者实现接口"><a class="markdownIt-Anchor" href="#指针接收者实现接口"></a> 指针接收者实现接口</h4>
<p>同样的代码我们再来测试一下使用指针接收者有什么区别：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> moving <span class="keyword">interface</span> &#123;</span><br><span class="line"> move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span></span> move() &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;丁丁～&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cat)</span></span> move() &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;喵呜～&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">move</span><span class="params">(m moving)</span></span> &#123;</span><br><span class="line"> <span class="comment">// 接受一个参数，进来什么，什么就调用它的speak</span></span><br><span class="line"> m.move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> x moving</span><br><span class="line"> a := dog&#123;&#125; <span class="comment">// a是dog类型</span></span><br><span class="line"> x = a      <span class="comment">// 可以接收dog类型</span></span><br><span class="line"> x.move()</span><br><span class="line"> b := cat&#123;&#125;</span><br><span class="line"> x = b <span class="comment">// 不可以接受指针类型</span></span><br><span class="line"> x.move()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// # command-line-arguments</span></span><br><span class="line"><span class="comment">// ./pointer.go:28:4: cannot use b (type cat) as type moving in assignment:</span></span><br><span class="line"><span class="comment">// cat does not implement moving (move method has pointer receiver)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang-结构体实现学生管理系统</title>
    <url>/1506.html</url>
    <content><![CDATA[<h2 id="基于结构体实现简易版学生管理系统"><a class="markdownIt-Anchor" href="#基于结构体实现简易版学生管理系统"></a> 基于“结构体”实现简易版学生管理系统</h2>
<p>首先咱们在做项目之前，需要对项目进行分析。切记不可贪功冒进，从而导致无用功</p>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<ol>
<li>学生类</li>
<li>管理者类</li>
<li>菜单栏</li>
<li>基于管理类实现功能
<ol>
<li>查看</li>
<li>添加</li>
<li>修改</li>
<li>删除</li>
<li>退出</li>
</ol>
</li>
</ol>
<span id="more"></span>
<p>结构图如下:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkzgz3v3vuj30gc0c4dhc.jpg" alt="" /></p>
<p>采用<code>自顶向下</code>的编程思维对以上分析进行复述，先整体、后细节(先全局、后详细)实现如上结构</p>
<h3 id="定义全局的学生类"><a class="markdownIt-Anchor" href="#定义全局的学生类"></a> 定义全局的学生类</h3>
<p>在定义学生类之前，我们需了解学生类包含的字段。这里我只定义了Id、姓名。其中id为唯一，姓名可重复。代码如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line"> id   <span class="type">int64</span></span><br><span class="line"> name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义全局的管理即操作类"><a class="markdownIt-Anchor" href="#定义全局的管理即操作类"></a> 定义全局的管理(即操作类)</h3>
<p>由于学号为唯一，且其对照关系，非常适合使用Map的<code>Key-value</code>格式。在这里仅做定义及声明并不做初始化，代码如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> studentMgr <span class="keyword">struct</span> &#123;</span><br><span class="line"> allStudent <span class="keyword">map</span>[<span class="type">int64</span>]student</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>借用好的数据结构，会让您的编程效率，编码思维，事半功倍</p>
</blockquote>
<h3 id="定义菜单栏"><a class="markdownIt-Anchor" href="#定义菜单栏"></a> 定义菜单栏</h3>
<p>定义菜单栏，以供使用者选择所对应的功能。根据其功能展示。并根据相对功能，定义应函数。如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showMenu</span><span class="params">()</span></span> &#123;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;Welcome student Manage System, TimeNow:%v&quot;</span>, time.Now())</span><br><span class="line"> fmt.Println(</span><br><span class="line">  <span class="string">` </span></span><br><span class="line"><span class="string">   1: 查看学生</span></span><br><span class="line"><span class="string">   2: 增加学生</span></span><br><span class="line"><span class="string">   3: 修改学生</span></span><br><span class="line"><span class="string">   4: 删除学生</span></span><br><span class="line"><span class="string">   5: 退出~</span></span><br><span class="line"><span class="string">    `</span>)</span><br><span class="line"> fmt.Print(<span class="string">&quot;What are you want do? Please input Serial number:&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由以上所知，我们许定义的函数有5个，他们分别是<code>查看学生</code>,<code>增加学生</code>,<code>修改学生</code>,<code>删除学生</code>,<code>退出</code>,如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> smr = studentMgr&#123;</span><br><span class="line">  allStudent: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]student),</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">  showMenu()</span><br><span class="line">  <span class="keyword">var</span> choice <span class="type">int64</span></span><br><span class="line">  fmt.Scan(&amp;choice)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;You select %d\n&quot;</span>, choice)</span><br><span class="line">  <span class="keyword">switch</span> choice &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">   smr.showStudent()</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">   smr.addStudent()</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">   smr.editStudent()</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">   smr.delStudent()</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">   os.Exit(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">   fmt.Println(<span class="string">&quot;Invalid input, please select again：&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里实例化了一个全局的管理类，所有的操作都经过它。</p>
<p>使用switch语句，进行多项的条件分支，更有利于我们编写更简洁的代码</p>
<h3 id="定义功能函数"><a class="markdownIt-Anchor" href="#定义功能函数"></a> 定义功能函数</h3>
<p><code>查看学生</code>,<code>增加学生</code>,<code>修改学生</code>,<code>删除学生</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看学生函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentMgr)</span></span> showStudent() &#123;&#125;</span><br><span class="line"><span class="comment">// 增加学生函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentMgr)</span></span> addStudent() &#123;&#125;</span><br><span class="line"><span class="comment">// 修改学生函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentMgr)</span></span> editStudent() &#123;&#125;</span><br><span class="line"><span class="comment">// 删除学生函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentMgr)</span></span> delStudent() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>基本的就已经做完了，基础结构就已经完成了，鼓掌～</p>
<p>那么接下来，我们只需要一个个实现相对应的函数。即可实现功能。</p>
<p>首先我们实现的是查看学生函数。</p>
<h3 id="实现查看学生功能"><a class="markdownIt-Anchor" href="#实现查看学生功能"></a> 实现查看学生功能</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentMgr)</span></span> showStudent() &#123;</span><br><span class="line"> <span class="keyword">for</span> _, stu := <span class="keyword">range</span> s.allStudent &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;ID:%d, Name:%s\n&quot;</span>, stu.id, stu.name)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们只需要遍历Map中所有的键与值，即可拿到所有的学生。这里没什么好说的</p>
</blockquote>
<p>实现增加学生功能</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentMgr)</span></span> addStudent() &#123;</span><br><span class="line"> <span class="keyword">var</span> (</span><br><span class="line">  stuId   <span class="type">int64</span></span><br><span class="line">  stuName <span class="type">string</span></span><br><span class="line"> )</span><br><span class="line"> <span class="comment">// 1. 根据输入内容创建学生</span></span><br><span class="line"> fmt.Print(<span class="string">&quot;Please input you need ID:&quot;</span>)</span><br><span class="line"> fmt.Scanln(&amp;stuId)</span><br><span class="line"> fmt.Print(<span class="string">&quot;Please input you need name:&quot;</span>)</span><br><span class="line"> fmt.Scanln(&amp;stuName)</span><br><span class="line"> newStu := student&#123;</span><br><span class="line">  id:   stuId,</span><br><span class="line">  name: stuName,</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 2. 将创建的学生加入stu中</span></span><br><span class="line"> s.allStudent[newStu.id] = newStu</span><br><span class="line"> fmt.Println(<span class="string">&quot;Added successfully&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们需要进行的有两步</p>
<ol>
<li>
<p>获取用户键盘输入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  stuId   <span class="type">int64</span></span><br><span class="line">  stuName <span class="type">string</span></span><br><span class="line"> )</span><br><span class="line"> <span class="comment">// 1. 根据输入内容创建学生</span></span><br><span class="line"> fmt.Print(<span class="string">&quot;Please input you need ID:&quot;</span>)</span><br><span class="line"> fmt.Scanln(&amp;stuId)</span><br><span class="line"> fmt.Print(<span class="string">&quot;Please input you need name:&quot;</span>)</span><br><span class="line"> fmt.Scanln(&amp;stuName)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将输入的学生信息加入到管理函数中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">newStu := student&#123;</span><br><span class="line">  id:   stuId,</span><br><span class="line">  name: stuName,</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 2. 将创建的学生加入stu中</span></span><br><span class="line"> s.allStudent[newStu.id] = newStu</span><br><span class="line"> fmt.Println(<span class="string">&quot;Added successfully&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>添加成功则提示成功</p>
</blockquote>
</li>
</ol>
<p>做到这里，咱们就可以进行一个小小的检测，有木有点小激动以及一点小方张。反正我有，示例如下</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkzi01hhipj30zm0u0jx0.jpg" alt="" /></p>
<p>**留下一个小Bug，等你去解决，提示，如果key已存在，那么该添加操作会进行？如果暂时没思路，可以继续往下看。虽然并没有直接这里告诉你，但却在下方进行的相对应的解决<br />
**</p>
<h3 id="实现修改学生功能"><a class="markdownIt-Anchor" href="#实现修改学生功能"></a> 实现修改学生功能</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentMgr)</span></span> editStudent() &#123;</span><br><span class="line"> <span class="comment">// 获取用户输入</span></span><br><span class="line"> <span class="keyword">var</span> StuId <span class="type">int64</span></span><br><span class="line"> fmt.Print(<span class="string">&quot;Please input want change student IdCode:&quot;</span>)</span><br><span class="line"> fmt.Scanln(&amp;StuId)</span><br><span class="line">  <span class="comment">// 检查该学号学生是否存在，没有则提示不存在</span></span><br><span class="line"> value, ok := s.allStudent[StuId]</span><br><span class="line"> <span class="keyword">if</span> !ok &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Not found&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;You want change student message:&quot;</span>+</span><br><span class="line">  <span class="string">&quot; Id: %d, Name:%s\n&quot;</span>, value.id, value.name)</span><br><span class="line"> <span class="comment">// 获取修改</span></span><br><span class="line"> <span class="keyword">var</span> newName <span class="type">string</span></span><br><span class="line"> fmt.Print(<span class="string">&quot;Please change to new message:&quot;</span>)</span><br><span class="line"> fmt.Scanln(&amp;newName)</span><br><span class="line"> value.name = newName</span><br><span class="line"> <span class="comment">// 更新学生的姓名</span></span><br><span class="line"> s.allStudent[StuId] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>首先我们获取用户输入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取用户输入</span></span><br><span class="line"> <span class="keyword">var</span> StuId <span class="type">int64</span></span><br><span class="line"> fmt.Print(<span class="string">&quot;Please input want change student IdCode:&quot;</span>)</span><br><span class="line"> fmt.Scanln(&amp;StuId)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>拿着用户输入的学生Id，去Map里面查找相对应的学生Id</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, ok := s.allStudent[StuId]</span><br><span class="line"> <span class="keyword">if</span> !ok &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Not found&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;You want change student message:&quot;</span>+</span><br><span class="line">  <span class="string">&quot; Id: %d, Name:%s\n&quot;</span>, value.id, value.name)</span><br></pre></td></tr></table></figure>
<p>若想实现修改，是需要存在的。如果不存在此学生，提示没有找到该学生，直接return掉。证明无法修改。如果存在那么它一定是唯一的一个Id，因为我们用的是Map格式的嘛，key唯一。</p>
</li>
<li>
<p>如果存在我们就需要获取到用户所修改的值，并且将原有的Name覆盖掉。即可实现修改</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newName <span class="type">string</span></span><br><span class="line"> fmt.Print(<span class="string">&quot;Please change to new message:&quot;</span>)</span><br><span class="line"> fmt.Scanln(&amp;newName)</span><br><span class="line"> value.name = newName</span><br><span class="line"> <span class="comment">// 更新学生的姓名</span></span><br><span class="line"> s.allStudent[StuId] = value</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>测试时间，示例如下：</p>
<p>首先我是添加了一个学生在里面，<code>Id:1,Name:Payne</code>.</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkziis5yxvj31020u044i.jpg" alt="" /></p>
<h3 id="实现删除学生功能"><a class="markdownIt-Anchor" href="#实现删除学生功能"></a> 实现删除学生功能</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentMgr)</span></span> delStudent() &#123;</span><br><span class="line"> <span class="keyword">var</span> studentID <span class="type">int64</span></span><br><span class="line"> <span class="comment">// 获取用户需删除的id</span></span><br><span class="line"> fmt.Print(<span class="string">&quot;Please input want delete studentId：&quot;</span>)</span><br><span class="line"> fmt.Scanln(&amp;studentID)</span><br><span class="line"> <span class="comment">// 去map里面查找，若有则删除。没有则退出重新选择</span></span><br><span class="line"> value, ok := s.allStudent[studentID]</span><br><span class="line"> <span class="keyword">if</span> !ok &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Not found&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;You want delete student message:&quot;</span>+</span><br><span class="line">  <span class="string">&quot; Id: %d, Name:%s\n&quot;</span>, value.id, value.name)</span><br><span class="line"> <span class="built_in">delete</span>(s.allStudent, studentID)</span><br><span class="line"> fmt.Print(<span class="string">&quot;Deleted Successfully\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>首先我们需要删除，那么它是一定存在我们才能去删除。这个没毛病吧？我觉很ok。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> studentID <span class="type">int64</span></span><br><span class="line"><span class="comment">// 获取用户需删除的id</span></span><br><span class="line">fmt.Print(<span class="string">&quot;Please input want delete studentId：&quot;</span>)</span><br><span class="line">fmt.Scanln(&amp;studentID)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不存在提示未找到</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, ok := s.allStudent[studentID]</span><br><span class="line"> <span class="keyword">if</span> !ok &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Not found&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;You want delete student message:&quot;</span>+</span><br><span class="line">  <span class="string">&quot; Id: %d, Name:%s\n&quot;</span>, value.id, value.name)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>存在进行修改</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;You want delete student message:&quot;</span>+</span><br><span class="line"> <span class="string">&quot; Id: %d, Name:%s\n&quot;</span>, value.id, value.name)</span><br><span class="line"><span class="built_in">delete</span>(s.allStudent, studentID)</span><br><span class="line">fmt.Print(<span class="string">&quot;Deleted Successfully\n&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang-自定义类型</title>
    <url>/41426.html</url>
    <content><![CDATA[<p>在Go语言中没有<code>类</code>，也没有相关于<code>类</code>的继承、多态的实现。却有一种&quot;新的概念&quot;–结构体</p>
<p>Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p>
<p>那么，接下来就让我们推开Go语言进阶部分内容的大门，Let’s Go</p>
<p>在学习<code>结构体</code>之前我们先预热一下，先了解Golang 的自定义类型</p>
<span id="more"></span>
<ul>
<li>自定义类型: 当现有类型不足以满足需求的时候, 自己创建的类型</li>
<li>类型别名: 仅存在于编写过程, 提高代码可读性 ( byte 是 uint8 的别名; rune 是 uint16 的别名 )</li>
</ul>
<h2 id="类型别名"><a class="markdownIt-Anchor" href="#类型别名"></a> 类型别名</h2>
<p><em><strong>类型别名</strong></em> 是 Go 1.9 版本添加的新功能。主要应用于代码升级、工程重构、迁移中类型的兼容性问题。C/C++<br />
语言中，代码的重构升级可以使用宏快速定义新的代码。Go<br />
语言中并未选择通过宏，而是选择通过类型别名解决重构中最复杂的类型名变更问题</p>
<h2 id="区分类型别名与类型定义"><a class="markdownIt-Anchor" href="#区分类型别名与类型定义"></a> 区分类型别名与类型定义</h2>
<p>类型别名规定：Type Alias只是Type 的别名，本质上Type Alias<br />
与Type是同一个类型，即基本数据类型是一致的。好比如我们小时家里人给我们起的小名，上学后英语老师给起的英文名字，但是这个名字都是指的我们自己。</p>
<p>表面上看类型别名与类型定义只有一个等号的差异（“=”）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个叫自定义类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个叫类型别名</span></span><br><span class="line"><span class="keyword">type</span> YourInt = <span class="type">int</span></span><br></pre></td></tr></table></figure>
<p>我们继续深入探究他们二者究竟有什么不同。如下代码所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">// type 后面的是类型</span><br><span class="line">type MyInt int     // 自定义类型</span><br><span class="line">type YourInt = int // 类型别名</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"> var m MyInt</span><br><span class="line"> var y YourInt</span><br><span class="line"> m = 10</span><br><span class="line"> y = 20</span><br><span class="line"> fmt.Printf(&quot;m 的类型是：%T, \n&quot;, m)</span><br><span class="line"> fmt.Printf(&quot;y 的类型是：%T, \n&quot;, y)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>m 的类型是：main.MyInt,<br />
y 的类型是：int,</p>
</blockquote>
<p>如上述代码，我们可以知道<code>自定义类型</code>是定义了一种新的类型，而类型别名是基于原始的类型的昵称而已。</p>
<p>相信你这时会想自定义类型有什么用？</p>
<p>既然可以自定义类型，那么我们是可以定制我们的类型的，例如，int是单纯的数字类型，如果我们可以自定义类型，我们是不是可以基于int把字符串里面的数字也包含进去呢？答案当然是可以的。如果有感兴趣的同学，可以自己去尝试一下。</p>
<p>预热完毕，那么让我们进入真正的操作环节，Go，Go，Go～</p>
<h2 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h2>
<p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称<code>struct</code><br />
。 也就是我们可以通过<code>struct</code>来定义自己的类型了。</p>
<p>Go语言中通过<code>struct</code>来实现<code>面向对象</code>的相关概念。</p>
<h3 id="结构体的定义"><a class="markdownIt-Anchor" href="#结构体的定义"></a> 结构体的定义</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用type和struct关键字来定义结构体</span></span><br><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体定义需注意</p>
<ul>
<li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li>
<li>字段名：表示结构体字段名。结构体中的字段名必须唯一。</li>
<li>字段类型：表示结构体字段的具体类型</li>
</ul>
<p>具体定义如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"> name <span class="type">string</span></span><br><span class="line"> age <span class="type">int</span></span><br><span class="line"> male <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当有相同类型的时候，我们还可以将相同类型的变量名使用“,”分割，写在一起。如下</span></span><br><span class="line"><span class="keyword">type</span> Person1 <span class="keyword">struct</span> &#123;</span><br><span class="line"> name,male <span class="type">string</span></span><br><span class="line"> age <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就拥有了一个的自定义类型<code>person</code>，它有<code>name</code>、<code>male</code>、<code>age</code><br />
三个字段，分别表示姓名、性别和年龄。这样我们使用这个<code>person</code>结构体就能够很方便的在程序中表示和存储人信息了。</p>
<p>语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和性别等，本质上是一种聚合型的数据类型</p>
<p>将前面的融汇贯通，整点复合型的东东，搞起</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString <span class="type">string</span></span><br><span class="line"><span class="keyword">type</span> MyInt=<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"> name MyString</span><br><span class="line"> age MyInt</span><br><span class="line"> male <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体定义了之后，咱们还需要进行初始化，才能使用。</p>
<h3 id="结构体初始化与基本使用"><a class="markdownIt-Anchor" href="#结构体初始化与基本使用"></a> 结构体初始化与基本使用</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyString <span class="type">string</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"> name MyString</span><br><span class="line"> age  MyInt</span><br><span class="line"> sex  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person1 <span class="keyword">struct</span> &#123;</span><br><span class="line"> name, sex <span class="type">string</span></span><br><span class="line"> age       <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> p Person</span><br><span class="line"> <span class="keyword">var</span> p1 Person1</span><br><span class="line"> p.name = <span class="string">&quot;Payne&quot;</span></span><br><span class="line"> p.sex = <span class="string">&quot;male&quot;</span></span><br><span class="line"> p.age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"> p1.name = <span class="string">&quot;Tim&quot;</span></span><br><span class="line"> p1.sex = <span class="string">&quot;female&quot;</span></span><br><span class="line"> p1.age = <span class="number">23</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;Type:%T,value:%v\n&quot;</span>, p, p)</span><br><span class="line"> fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p)</span><br><span class="line"> fmt.Printf(<span class="string">&quot;Type:%T,value:%v\n&quot;</span>, p1, p1)</span><br><span class="line"> fmt.Printf(<span class="string">&quot;%#v&quot;</span>, p1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Type:main.Person,value:{Payne 20 male}<br />
main.Person{name:“Payne”, age:20, sex:“male”}<br />
Type:main.Person1,value:{Tim female 23}<br />
main.Person1{name:“Tim”, sex:“female”, age:23}</p>
</blockquote>
<h3 id="匿名结构体"><a class="markdownIt-Anchor" href="#匿名结构体"></a> 匿名结构体</h3>
<p>在定义一些临时数据结构等场景下还可以使用匿名结构体。如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> person2 <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">  age  <span class="type">int</span></span><br><span class="line">  sex  <span class="type">string</span></span><br><span class="line"> &#125;</span><br><span class="line"> person2.name = <span class="string">&quot;Payne&quot;</span></span><br><span class="line"> person2.age = <span class="number">20</span></span><br><span class="line"> person2.sex = <span class="string">&quot;male&quot;</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;Type:%T,value:%v\n&quot;</span>, person2, person2)</span><br><span class="line"> fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, person2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type:struct &#123; name string; age int; sex string &#125;,value:&#123;Payne 20 male&#125;</span></span><br><span class="line"><span class="comment">// struct &#123; name string; age int; sex string &#125;&#123;name:&quot;Payne&quot;, age:20, sex:&quot;male&quot;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang介绍</title>
    <url>/10519.html</url>
    <content><![CDATA[<blockquote>
<ul>
<li>Golang官网地址:<span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcub3JnLw==">https://golang.org/<i class="fa fa-external-link-alt"></i></span></li>
<li>Golang官方文档:<span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcub3JnL2RvYy8=">https://golang.org/doc/<i class="fa fa-external-link-alt"></i></span></li>
<li>Golang Packages:<span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcub3JnL3BrZy8=">https://golang.org/pkg/<i class="fa fa-external-link-alt"></i></span></li>
<li>Golang中文网：<span class="exturl" data-url="aHR0cHM6Ly9zdHVkeWdvbGFuZy5jb20v">https://studygolang.com/<i class="fa fa-external-link-alt"></i></span></li>
<li>Golang中文文档：<span class="exturl" data-url="aHR0cDovL2RvY3Njbi5zdHVkeWdvbGFuZy5jb20v">http://docscn.studygolang.com/<i class="fa fa-external-link-alt"></i></span></li>
<li>Golang中文Packages：<span class="exturl" data-url="aHR0cHM6Ly9zdHVkeWdvbGFuZy5jb20vcGtnZG9j">https://studygolang.com/pkgdoc<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</blockquote>
<h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2>
<p>Golang(又称Go)<br />
是<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvR29vZ2xl">Google<i class="fa fa-external-link-alt"></i></span><br />
公司开发的一种<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlEJTk5JUU2JTgwJTgxJUU3JUIxJUJCJUU1JTlFJThC">静态<i class="fa fa-external-link-alt"></i></span><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUJDJUI3JUU5JUExJTlFJUU1JTlFJThC">强类型<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUI3JUE4JUU4JUFEJUFGJUU4JUFBJTlFJUU4JUE4JTgw">编译型<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUI4JUE2JUU4JUExJThDJUU4JUE4JTg4JUU3JUFFJTk3">并发型<i class="fa fa-external-link-alt"></i></span><br />
，并具有<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTlFJTgzJUU1JTlDJUJFJUU1JTlCJTlFJUU2JTk0JUI2XyglRTglQTglODglRTclQUUlOTclRTYlQTklOUYlRTclQTclOTElRTUlQUQlQjgp">垃圾回收功能<i class="fa fa-external-link-alt"></i></span><br />
的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUJDJTk2JUU3JUE4JThCJUU4JUFGJUFEJUU4JUE4JTgw">编程语言<i class="fa fa-external-link-alt"></i></span>。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3cvaW5kZXgucGhwP3RpdGxlPSVFNyVCRSU4NSVFNCVCQyVBRiVFNyU4OSVCOSVDMiVCNyVFNiVBMCVCQyVFNyU5MSU5RSVFNSU4RiVCMiVFOCU4RSVBQiZhbXA7YWN0aW9uPWVkaXQmYW1wO3JlZGxpbms9MQ==">罗伯特·格瑞史莫<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUJFJTg1JUU1JThCJTgzJUMyJUI3JUU2JUI0JUJFJUU1JTg1JThC">罗勃·派克<i class="fa fa-external-link-alt"></i></span><br />
（Rob<br />
Pike）及<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JTgyJUFGJUMyJUI3JUU2JUIxJUE0JUU2JTk5JUFFJUU5JTgwJThB">肯·汤普逊<i class="fa fa-external-link-alt"></i></span>于2007年9月开始设计GO，稍后Ian Lance<br />
Taylor、Russ<br />
Cox加入项目。Go是基于<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvSW5mZXJubw==">Inferno<i class="fa fa-external-link-alt"></i></span><br />
操作系统所开发的。Go于2009年11月正式宣布推出，成为<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTk2JThCJUU2JTk0JUJFJUU1JThFJTlGJUU1JUE3JThCJUU3JUEyJUJD">开放源代码<i class="fa fa-external-link-alt"></i></span><br />
项目，支持<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvTGludXg=">Linux<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvTWFjT1M=">macOS<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvV2luZG93cw==">Windows<i class="fa fa-external-link-alt"></i></span><br />
等操作系统。在2016年，Go被软件评价公司TIOBE<br />
选为“TIOBE 2016 年最佳语言”。</p>
<p>目前，Go每半年发布一个二级版本（即从a.x升级到a.y）。</p>
<span id="more"></span>
<h2 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h2>
<p>Go的语法接近<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvQyVFOCVBRiVBRCVFOCVBOCU4MA==">C语言<i class="fa fa-external-link-alt"></i></span><br />
，但对于<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3cvaW5kZXgucGhwP3RpdGxlPSVFNSU4RiU5OCVFOSU4NyU4RiVFNyU5QSU4NCVFNSVBMyVCMCVFNiU5OCU4RSZhbXA7YWN0aW9uPWVkaXQmYW1wO3JlZGxpbms9MQ==">变量的声明<i class="fa fa-external-link-alt"></i></span><br />
有所不同。Go支持<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTlFJTgzJUU1JTlDJUJFJUU1JTlCJTlFJUU2JTk0JUI2XyglRTglQTglODglRTclQUUlOTclRTYlQTklOUYlRTclQTclOTElRTUlQUQlQjgp">垃圾回收功能<i class="fa fa-external-link-alt"></i></span><br />
。Go的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUI5JUI2JUU4JUExJThDJUU4JUFFJUExJUU3JUFFJTk3">并行计算<i class="fa fa-external-link-alt"></i></span><br />
模型是以<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTlEJUIxJUU1JUIwJUJDJUMyJUI3JUU5JTlDJThEJUU3JTg4JUJF">东尼·霍尔<i class="fa fa-external-link-alt"></i></span><br />
的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJBJUE0JUU4JUFCJTg3JUU1JUJFJUFBJUU1JUJBJThGJUU3JUE4JThCJUU1JUJDJThG">通信顺序进程<i class="fa fa-external-link-alt"></i></span><br />
（CSP）为基础，采取类似模型的其他语言包括<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvT2NjYW0=">Occam<i class="fa fa-external-link-alt"></i></span><br />
和<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvTGltYm8=">Limbo<i class="fa fa-external-link-alt"></i></span>[<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvR28jY2l0ZV9ub3RlLWxhbmdmYXEtMw==">3]<i class="fa fa-external-link-alt"></i></span><br />
，Go也具有这个模型的特征，比如<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTgwJTlBJUU5JTgxJTkzXyglRTclQkMlOTYlRTclQTglOEIp">通道<i class="fa fa-external-link-alt"></i></span><br />
传输。通过goroutine和通道等并行构造可以建造<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUJBJUJGJUU3JUE4JThCJUU2JUIxJUEw">线程池<i class="fa fa-external-link-alt"></i></span><br />
和<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUFFJUExJUU5JTgxJTkzXyglRTglQkQlQUYlRTQlQkIlQjYp">管道<i class="fa fa-external-link-alt"></i></span><br />
等[<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvR28jY2l0ZV9ub3RlLTg=">8]<i class="fa fa-external-link-alt"></i></span>。在1.8版本中开放插件（Plugin）的支持，这意味着现在能从Go中动态加载部分函数。</p>
<p>与C++相比，Go并不包括如<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTlFJTlBJUU0JUI4JUJF">枚举<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUJDJTgyJUU1JUI4JUI4JUU1JUE0JTg0JUU3JTkwJTg2">异常处理<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUI5JUJDJUU2JTg5JUJGXyglRTglQTglODglRTclQUUlOTclRTYlQTklOUYlRTclQTclOTElRTUlQUQlQjgp">继承<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUIzJTlCJUU1JTlFJThC">泛型<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk2JUI3JUU4JUE4JTgwXyglRTclQTglOEIlRTUlQkMlOEYp">断言<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JTk5JTlBJUU1JTg3JUJEJUU2JTk1JUIw">虚函数<i class="fa fa-external-link-alt"></i></span><br />
等功能，但增加了<br />
切片(Slice)<br />
型、并发、管道、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTlFJTgzJUU1JTlDJUJFJUU1JTlCJTlFJUU2JTk0JUI2XyglRTglQTglODglRTclQUUlOTclRTYlQTklOUYlRTclQTclOTElRTUlQUQlQjgp">垃圾回收功能<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJCJThCJUU5JTlEJUEyXyglRTglQjMlODclRTglQTglOEElRTclQTclOTElRTYlOEElODAp">接口<i class="fa fa-external-link-alt"></i></span><br />
等特性的语言级支持。Go<br />
2.0版本将支持泛型[<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvR28jY2l0ZV9ub3RlLTk=">9]<i class="fa fa-external-link-alt"></i></span><br />
，对于<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk2JUI3JUU4JUE4JTgwXyglRTclQTglOEIlRTUlQkMlOEYp">断言<i class="fa fa-external-link-alt"></i></span><br />
的存在，则持负面态度，同时也为自己不提供类型<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUI5JUJDJUU2JTg5JUJGXyglRTglQTglODglRTclQUUlOTclRTYlQTklOUYlRTclQTclOTElRTUlQUQlQjgp">继承<i class="fa fa-external-link-alt"></i></span><br />
来辩护。</p>
<p>不同于<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvSmF2YQ==">Java<i class="fa fa-external-link-alt"></i></span><br />
，Go原生提供了<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg1JUIzJUU4JTgxJTk0JUU2JTk1JUIwJUU3JUJCJTg0">关联数组<i class="fa fa-external-link-alt"></i></span><br />
（也称为<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTkzJTg4JUU1JUI4JThDJUU4JUExJUE4">哈希表<i class="fa fa-external-link-alt"></i></span>（Hashes）或字典（Dictionaries）），就像字符串类型一样。</p>
<h2 id="历史"><a class="markdownIt-Anchor" href="#历史"></a> 历史</h2>
<p>2007年，<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvR29vZ2xl">Google<i class="fa fa-external-link-alt"></i></span><br />
设计Go，目的在于提高在<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUE0JTlBJUU2JUEwJUI4JUU1JUJGJTgzJUU4JTk5JTk1JUU3JTkwJTg2JUU1JTk5JUE4">多核<i class="fa fa-external-link-alt"></i></span>、网络机器（networked<br />
machines）、大型<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJCJUEzJUU3JUEwJTgxJUU1JUJBJTkz">代码库<i class="fa fa-external-link-alt"></i></span><br />
（codebases）的情况下的开发效率。当时在Google，设计师们想要解决其他语言使用中的缺点，但是仍保留他们的优点。</p>
<ul>
<li>静态类型和<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUJGJTkwJUU4JUExJThDJUU2JTk3JUI2">运行时<i class="fa fa-external-link-alt"></i></span><br />
效率。（如：<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvQyUyQiUyQg==">C++<i class="fa fa-external-link-alt"></i></span>）</li>
<li>可读性和易用性。（如：<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvUHl0aG9u">Python<i class="fa fa-external-link-alt"></i></span><br />
和 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvSmF2YVNjcmlwdA==">JavaScript<i class="fa fa-external-link-alt"></i></span>）[<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvR28jY2l0ZV9ub3RlLTEy">12]<i class="fa fa-external-link-alt"></i></span></li>
<li>高性能的网络和<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUE0JTlBJUU4JUJGJTlCJUU3JUE4JThC">多进程<i class="fa fa-external-link-alt"></i></span>。</li>
</ul>
<p>设计师们主要受他们之间流传的“不要像C++”启发。</p>
<p>Go于2009年11月正式宣布推出，[<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvR28jY2l0ZV9ub3RlLTE2">16]<i class="fa fa-external-link-alt"></i></span><br />
版本1.0在2012年3月发布。之后，Go广泛应用于Google的产品以及许多其他组织和开源项目。</p>
<p>在2016年11月，Go（一种<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk3JUEwJUU4JUExJUFDJUU3JUJBJUJGJUU0JUJEJTkz">无衬线体<i class="fa fa-external-link-alt"></i></span>）和Go Mono<br />
字体（一种<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUFEJTg5JUU1JUFFJUJEJUU1JUFEJTk3JUU0JUJEJTkz">等宽字体<i class="fa fa-external-link-alt"></i></span>）分别由设计师 Charles Bigelow 和 Kris<br />
Holmes 发布。<br />
两种字体均采用了 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3cvaW5kZXgucGhwP3RpdGxlPVdHTDQmYW1wO2FjdGlvbj1lZGl0JmFtcDtyZWRsaW5rPTE=">WGL4<i class="fa fa-external-link-alt"></i></span><br />
，并且依照着 DIN 1450 标准，可清晰地使用了 large<br />
x-height 和 letterforms 。</p>
<p>在2018年8月，本地的图标更换了 。待描述完整 然而，Gopher mascot 仍旧命相同的名字。</p>
<p>在2018年8月，Go的主要贡献者发布了两个关于语言新功能的“草稿设计——<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUIzJTlCJUU1JTlFJThC">泛型<i class="fa fa-external-link-alt"></i></span><br />
和 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUJDJTgyJUU1JUI4JUI4JUU1JUE0JTg0JUU3JTkwJTg2">异常处理<i class="fa fa-external-link-alt"></i></span>，同时寻求Go用户的反馈。Go<br />
由于在1.x时，缺少对 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JUIzJTlCJUU1JTlFJThC">泛型<i class="fa fa-external-link-alt"></i></span>编程<br />
的支持和冗长的 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUJDJTgyJUU1JUI4JUI4JUU1JUE0JTg0JUU3JTkwJTg2">异常处理<i class="fa fa-external-link-alt"></i></span> 而备受批评。</p>
<p><strong>以上来自<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvR28jJUU2JThGJThGJUU4JUJGJUIw">wiki<i class="fa fa-external-link-alt"></i></span>,更多详情可查看</strong></p>
<h2 id="为什么需要学习golang"><a class="markdownIt-Anchor" href="#为什么需要学习golang"></a> 为什么需要学习Golang？</h2>
<blockquote>
<p>“<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5pbS8/dGFyZ2V0PWh0dHBzJTNBJTJGJTJGdHdpdHRlci5jb20lMkZ0b2JpJTJGc3RhdHVzJTJGMzI2MDg2Mzc5MjA3NTM2NjQw">Go will be the server language of the future.<i class="fa fa-external-link-alt"></i></span>” —<br />
Tobias Lütke, Shopify</p>
</blockquote>
<h2 id="硬件的局限性"><a class="markdownIt-Anchor" href="#硬件的局限性"></a> 硬件的局限性</h2>
<ul>
<li></li>
</ul>
<p><em><span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5pbS8/dGFyZ2V0PWh0dHAlM0ElMkYlMkZ3d3cuaW52ZXN0b3BlZGlhLmNvbSUyRnRlcm1zJTJGbSUyRm1vb3Jlc2xhdy5hc3A=">摩尔定律<i class="fa fa-external-link-alt"></i></span><br />
正在失效。</em>*</p>
<p>英特尔公司在 <span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5pbS8/dGFyZ2V0PWh0dHAlM0ElMkYlMkZ3d3cuaW5mb3JtaXQuY29tJTJGYXJ0aWNsZXMlMkZhcnRpY2xlLmFzcHglM0ZwJTNEMzM5MDcz">2004 年推出<i class="fa fa-external-link-alt"></i></span><br />
了第一款具有<br />
3.0 GHz时钟速度的奔腾 4<br />
处理器。如今，我的 <span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5pbS8/dGFyZ2V0PWh0dHAlM0ElMkYlMkZ3d3cuYXBwbGUuY29tJTJGbWFjYm9vay1wcm8lMkZzcGVjcyUyRg==">2016款 MacBook Pro<i class="fa fa-external-link-alt"></i></span><br />
的时钟速度为<br />
2.9 GHz。因此，差不多十年，原始处理能力都没有太多的增加。你可以在下图中看到处理能力的增长与时间的关系。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkficnh9qrj30go0bkwkn.jpg" alt="" /></p>
<p>从上面的图表可以看出，单线程的性能和处理器的频率在近十年几乎保持稳定。如果你认为添加更多的晶体管是一种解决问题的方法，那你就错了。这是因为在微观尺度上，量子特性开始显现（例如：量子隧道穿越），放更多的晶体管代价也会越多(<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5pbS8/dGFyZ2V0PWh0dHBzJTNBJTJGJTJGd3d3LnF1b3JhLmNvbSUyRldoYXQtaXMtUXVhbnR1bS1UdW5uZWxpbmctTGltaXQtSG93LWRvZXMtaXQtbGltaXQtdGhlLXNpemUtb2YtYS10cmFuc2lzdG9y">为什么？<i class="fa fa-external-link-alt"></i></span>)<br />
，而且，每美元可以添加晶体管的数量也开始下降。</p>
<p>所以，针对上述问题的解决方案如下：</p>
<ul>
<li>厂商开始向处理器添加越来越多的内核。如今，我们已经有四核和八核的 CPU 可用。</li>
<li>我们还引入了超线程技术。</li>
<li>为处理器添加更多的缓存以提升性能。</li>
</ul>
<p>但是，以上方案也有它们自身的限制。我们无法向处理器添加更多的缓存以提升性能，因为缓存具有物理限制：缓存越大，速度越慢。添加更多的内核到处理器也有它的成本。而且，这也无法无限扩展。这些多核处理器能同时运行多个线程，同时也能带来并发能力。我们稍后会讨论它。</p>
<p>因此，如果我们不能依赖于硬件的改进，唯一的出路就是找到一个高效的软件来提升性能，但遗憾的是，现代编程语言都不是那么高效。</p>
<blockquote></blockquote>
<p>“现代处理器就像一辆有氮氧加速系统的直线竞速赛车，它们在直线竞速赛中表现优异。不幸的是，现代编程语言却像蒙特卡罗赛道，它们有大量的弯道。” - <span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5pbS8/dGFyZ2V0PWh0dHBzJTNBJTJGJTJGZW4ud2lraXBlZGlhLm9yZyUyRndpa2klMkZEYXZpZF9Vbmdhcg==">David Ungar<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="go-天生支持并发"><a class="markdownIt-Anchor" href="#go-天生支持并发"></a> Go 天生支持并发</h2>
<p>如上所述，硬件提供商正在向处理器添加更多的内核以提升性能。所有的数据中心都在这些处理器上运行，我们应该期待在未来几年内核数量的增长。更重要的是，如今的应用程序都是使用多个微服务来维持数据库的连接、消息队列和缓存的维护。因此，我们开发的软件和编程语言可以更容易的支持并发，并且它们应该随着内核数量的增长而可扩展。</p>
<p>但是大多数现代编程语言（如 Java、Python 等）都来自于 90<br />
年代的单线程环境。这些语言大多数都支持多线程。但真正的问题是并发执行，线程锁、竞争条件和死锁。这些问题都使得很难在这些语言上创建一个多线程的应用程序。</p>
<p>例如，在 Java 中创建新的线程会消耗大量内存。因为每一个线程都会消耗大约 1 MB<br />
大小的堆内存，如果你运行上千个线程，他们会对堆造成巨大的压力，最终会由于内存不足而宕机。此外，你想要在两个或者多个线程之间通信也是非常困难的。</p>
<p>另一方面，Go 于 2009 年发布，那时多核处理器已经上市了。这也是为什么 Go 是在考虑并发的基础上构建的。Go 用<br />
goroutine 来替代线程，它们从堆中消耗了大约 2 KB 的内存。因此你可以随时启动上百万个<br />
goroutine。</p>
<h2 id="go-直接在底层硬件上运行"><a class="markdownIt-Anchor" href="#go-直接在底层硬件上运行"></a> Go 直接在底层硬件上运行</h2>
<p>与其他现代高级语言（如 Java/Python）相比，使用 C、C++ 的最大好处就是它的性能，因为 C/C++ 是编译型语言而不是解释型语言。</p>
<p>处理器能理解二进制文件。通常来说，当你编译一个用 Java 或者其他基于 JVM<br />
的语言构建的应用程序，它将人类可读的代码编译为字节代码，这可以被 JVM<br />
或者在底层操作系统之上运行的其他虚拟机所理解。当执行的时候，虚拟机解释这些字节码并且将他们转化为处理器能理解的二进制文件。</p>
<h2 id="用-go-编写的代码易于维护"><a class="markdownIt-Anchor" href="#用-go-编写的代码易于维护"></a> 用 Go 编写的代码易于维护</h2>
<p>我告诉你一件事，Go 没有像其他语言一样疯狂于编程语法，它的语法非常整洁。</p>
<p>Go<br />
的的设计者在谷歌创建这门语言的时候就考虑到了这一点，由于谷歌拥有非常强大的代码库，成千上万的开发者都工作在相同的代码库上，代码应该易于其他开发者理解，一段代码应该对另一段代码有最小的影响。这些都会使得代码易于维护，易于修改。</p>
<p>Go 有意的忽视了许多现代面向对象语言的一些特性。</p>
<ul>
<li><strong>没有类。</strong> 所有代码都仅用 package 分开，Go 只有结构体而不是类。</li>
<li><strong>不支持继承。</strong> 这将使得代码易于修改。在其他语言中，如： Java/Python，如果类 ABC 继承类 XYZ 并且你在类<br />
XYZ 中做了一些改动，那么这可能会在继承类 XYZ 的其他类中产生一些副作用。通过移除继承，Go<br />
也使得理解代码变得很容易 <strong>（因为当你在看一段代码时不需要同时查看父类）</strong>。</li>
<li>没有构造方法。</li>
<li>没有注解。</li>
<li>没有泛型。</li>
<li>没有异常。</li>
</ul>
<p>以上这些改变使得 Go 与其他语言截然不同，这使得用 Go<br />
编程与其他语言很不一样。你可能不喜欢以上的一些观点。但是，并不是说没有上述这些特性，你就无法对你的应用程序编码。你要做的就是多写几行代码，但从积极的一面，它将使你的代码更加清晰，为代码添加更多的清晰度。</p>
<h2 id="go-来势汹汹"><a class="markdownIt-Anchor" href="#go-来势汹汹"></a> Go 来势汹汹</h2>
<ul>
<li>我知道这不是一个直接的技术优势，但 Go 是由谷歌设计并支持的，谷歌拥有世界上最大的云基础设施之一，并且规模庞大。谷歌设计<br />
Go 以解决可扩展性和有效性问题。这些是创建我们自己的服务器时都会遇到的问题。</li>
<li>Go 更多的也是被一些大公司所使用，如<br />
Adobe、BBC、IBM，因特尔甚至是 <span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5pbS8/dGFyZ2V0PWh0dHBzJTNBJTJGJTJGbWVkaXVtLmVuZ2luZWVyaW5nJTJGaG93LW1lZGl1bS1nb2VzLXNvY2lhbC1iN2RiZWZhNmQ0MTMlMjMucjhucWp4anBr">Medium<i class="fa fa-external-link-alt"></i></span>。</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang函数初探</title>
    <url>/15677.html</url>
    <content><![CDATA[<p>本节将探讨golang 的函数部分</p>
<ul>
<li>函数的结构分析函数的定义</li>
<li>函数的层次</li>
<li>函数的作用域</li>
<li>匿名函数</li>
<li>立即执行函数</li>
<li>闭包</li>
</ul>
<h2 id="函数存在的意义"><a class="markdownIt-Anchor" href="#函数存在的意义"></a> 函数存在的意义</h2>
<ul>
<li>函数是一段代码的封装</li>
<li>使用函数可以使结构更加清晰与简洁</li>
</ul>
<span id="more"></span>
<h3 id="代码重用"><a class="markdownIt-Anchor" href="#代码重用"></a> 代码重用</h3>
<p>函数存在的一个非常明显的作用和意义就是代码重用。没有代码重用，编程人员会被活活累死，费尽千辛万苦写出来的代码只能使用一次，有类似的功能需要完成时，不得不重头开始写起。</p>
<h3 id="有助于我们思考"><a class="markdownIt-Anchor" href="#有助于我们思考"></a> 有助于我们思考</h3>
<p>在函数设计上有一个原则，叫做单一职能原则，意思是说，一个函数只完成一个特定的功能。我以冒泡排序来向你解释什么叫做到单一职能原则，并向你展示函数是如何帮助我们思考问题的。</p>
<h2 id="初探golang函数"><a class="markdownIt-Anchor" href="#初探golang函数"></a> 初探Golang函数</h2>
<p>不知道你是否还记得我们写的第一个代码<code>HelloWorld</code>，来我们对他进行分析一下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;Hello，World&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它由以下几部分构成：</p>
<ul>
<li>
<p>任何一个函数的定义，都有一个 func 关键字，用于声明一个函数，就像使用 var 关键字声明一个变量一样。</p>
</li>
<li>
<p>紧跟的 main 是函数的名字，命名符合 Go 语言的规范即可，不能以数字开头。</p>
</li>
<li>
<p>main 函数名字后面的一对括号 () 是不能省略的，括号里可以定义函数使用的参数，这里的 main<br />
函数没有参数，所以是空括号 () 。</p>
</li>
<li>
<p>括号 () 后还可以有函数的返回值，因为 main 函数没有返回值，所以这里没有定义。</p>
</li>
<li>
<p>{} 函数体，你可以在函数体里书写代码，写该函数自己的业务逻辑。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main  <span class="comment">// 主函数入口，表面可执行文件。若不是main，则只能被调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  <span class="comment">// 导包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// func 关键字定义函数，与Python中的def效果一致</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   <span class="comment">// main函数名（主函数）入口，括号中为形参。没有可不写</span></span><br><span class="line"><span class="comment">// 业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>形参：即形式参数，只与内部调用有关。</p>
<p>当调用函数的时候，为位置为准，对应对应</p>
</blockquote>
<h2 id="初探函数"><a class="markdownIt-Anchor" href="#初探函数"></a> 初探函数</h2>
<h3 id="常见函数"><a class="markdownIt-Anchor" href="#常见函数"></a> 常见函数</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数、无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">t1</span><span class="params">()</span></span> &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;你好，我叫Payne&quot;</span>) <span class="comment">// 你好，我叫Payne</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数，有返回值（有返回值必须在后面写上返回值类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值，则需要多个类型参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">t2</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数，有返回值。同一类型可使用逗号隔开在最后写类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">t3</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数:最显著的特征是没有函数名，可以使用变量来接受它</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// # 在main 中使用a()即可调用此韩素</span></span><br><span class="line"><span class="keyword">var</span> a  = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"> &#125;()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> t1() <span class="comment">// 调用函数</span></span><br><span class="line"> <span class="comment">// 返回值需要我们打印，才能显示出来</span></span><br><span class="line"> fmt.Println(t2()) <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="函数结构分析"><a class="markdownIt-Anchor" href="#函数结构分析"></a> 函数结构分析</h3>
<p>由于main函数的定义并不利于理解golang的函数，那么我们自定义一个函数。如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// num(1,2) 调用函数</span></span><br><span class="line"> fmt.Println(num(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment">// 调用函数，并打印 2，1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">num</span><span class="params">(i, j <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line"> j, i = i, j</span><br><span class="line"> <span class="keyword">return</span> i, j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义多个参数与返回值的函数</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> fmt.Println(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(params ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"> sum := <span class="number">0</span></span><br><span class="line"> <span class="keyword">for</span> _, i := <span class="keyword">range</span> params &#123;</span><br><span class="line">  sum += i</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多个参数,多个参数的内部其实就是切片类型[...]int</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，如果定义的函数需要传递的参数既有普通参数，也有可变参数，那么可变参数一定要放在参数列表的最后一个，比如<br />
sum1(tip string,params …int) ，params 可变参数一定要放在最末尾。</p>
</blockquote>
<h3 id="函数进阶"><a class="markdownIt-Anchor" href="#函数进阶"></a> 函数进阶</h3>
<p>全局与局部：（变量与常量）</p>
<blockquote>
<p>全局：故名思义，全局均可访问的函数</p>
<p>局部：故名思义，仅有局部才可访问的变量</p>
<p>代码块作用域：仅在此代码块中</p>
<p>二则的区分：全局变量常常直接在代码的函数部分的上面定义，而局部变量仅在函数中定义。且不可被函数外部的访问</p>
</blockquote>
<p>golang的寻找变量的方式体现可简单理解为<code>就近原则</code>；示例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aA = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> &#123;</span><br><span class="line"> aA := <span class="number">2</span></span><br><span class="line"> fmt.Println(aA)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span></span> &#123;</span><br><span class="line"> fmt.Println(aA)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> f1()    <span class="comment">// 2</span></span><br><span class="line"> f2()    <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在函数f1中对变量<code>aA</code>，进行修改。而不影响全局的<code>aA</code>.且调用时先从函数内寻找，没有则往上。</p>
<p>不仅函数中有全局、局部的概念，例如循环中也有此概念</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func f1() &#123;</span><br><span class="line"> for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">  fmt.Print(i)</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func f2() &#123;</span><br><span class="line"> j := 0</span><br><span class="line"> for ; j &lt; 10; j++ &#123;</span><br><span class="line">  fmt.Print(j)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"> f1() </span><br><span class="line"> f2() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>二者的区别为，变量<code>i</code>使用完成后会立马销毁，释放内存。而变量<code>j</code>，则会一直存在</p>
</blockquote>
<h3 id="函数类型与变量"><a class="markdownIt-Anchor" href="#函数类型与变量"></a> 函数类型与变量</h3>
<h4 id="定义函数类型"><a class="markdownIt-Anchor" href="#定义函数类型"></a> 定义函数类型</h4>
<p>我们可以使用<code>type</code>关键字来定义一个函数类型，具体格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> calculation <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure>
<p>上面语句定义了一个<code>calculation</code>类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。</p>
<p>简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> x - y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>add和sub都能赋值给calculation类型的变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c calculation</span><br><span class="line">c = add</span><br></pre></td></tr></table></figure>
<h4 id="函数类型变量"><a class="markdownIt-Anchor" href="#函数类型变量"></a> 函数类型变量</h4>
<p>我们可以声明函数类型的变量并且为该变量赋值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> c calculation               <span class="comment">// 声明一个calculation类型的变量c</span></span><br><span class="line"> c = add                         <span class="comment">// 把add赋值给c</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;type of c:%T\n&quot;</span>, c) <span class="comment">// type of c:main.calculation</span></span><br><span class="line"> fmt.Println(c(<span class="number">1</span>, <span class="number">2</span>))            <span class="comment">// 像调用add一样调用c</span></span><br><span class="line"></span><br><span class="line"> f := add                        <span class="comment">// 将函数add赋值给变量f1</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;type of f:%T\n&quot;</span>, f) <span class="comment">// type of f:func(int, int) int</span></span><br><span class="line"> fmt.Println(f(<span class="number">10</span>, <span class="number">20</span>))          <span class="comment">// 像调用add一样调用f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang内置包之time</title>
    <url>/11529.html</url>
    <content><![CDATA[<h2 id="golang内置包之time"><a class="markdownIt-Anchor" href="#golang内置包之time"></a> GoLang内置包之time</h2>
<p>一寸光阴一寸金，寸金难买寸光阴</p>
<p>时间离我们仅在咫尺，无论是在编程中时间还是日常生活中对于时间的 记述都是离我们最近的，那么让我们一起来学习一下GoLang中内置包time。</p>
<span id="more"></span>
<p>Let’s Go</p>
<h3 id="time包源码怎么说"><a class="markdownIt-Anchor" href="#time包源码怎么说"></a> time包源码怎么说</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"> Nanosecond  Duration = <span class="number">1</span></span><br><span class="line"> Microsecond          = <span class="number">1000</span> * Nanosecond</span><br><span class="line"> Millisecond          = <span class="number">1000</span> * Microsecond</span><br><span class="line"> Second               = <span class="number">1000</span> * Millisecond</span><br><span class="line"> Minute               = <span class="number">60</span> * Second</span><br><span class="line"> Hour                 = <span class="number">60</span> * Minute</span><br><span class="line">)</span><br><span class="line">time.Duration是time包定义的一个类型，</span><br><span class="line">它代表两个时间点之间经过的时间，以纳秒为单位。time.Duration表示一段时间间隔，可表示的最长时间段大约<span class="number">290</span>年。</span><br><span class="line"></span><br><span class="line">例如：time.Duration表示<span class="number">1</span>纳秒，time.Second表示<span class="number">1</span>秒。</span><br></pre></td></tr></table></figure>
<h3 id="基本使用"><a class="markdownIt-Anchor" href="#基本使用"></a> 基本使用</h3>
<p>打印显示出现在的时间，基本示例如下。 其中now为<code>time.Time</code>类型,Month 为<code>time.Month</code>类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"> now := time.Now() <span class="comment">//获取当前时间</span></span><br><span class="line"> <span class="comment">// current time:2020-12-01 22:24:30.85736 +0800 CST m=+0.000096031</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;current time:%v\n&quot;</span>, now)</span><br><span class="line"></span><br><span class="line"> year := now.Year()     <span class="comment">//年</span></span><br><span class="line"> month := now.Month()   <span class="comment">//月</span></span><br><span class="line"> day := now.Day()       <span class="comment">//日</span></span><br><span class="line"> hour := now.Hour()     <span class="comment">//小时</span></span><br><span class="line"> minute := now.Minute() <span class="comment">//分钟</span></span><br><span class="line"> second := now.Second() <span class="comment">//秒</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d\n&quot;</span>, year, month, day, hour, minute, second)</span><br><span class="line"> fmt.Printf(<span class="string">&quot;%T,%T,%T,%T,%T,%T,%T\n&quot;</span>, now, year, month, day, hour, minute, second)</span><br><span class="line"> <span class="comment">// time.Time,int,time.Month,int,int,int,int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间戳"><a class="markdownIt-Anchor" href="#时间戳"></a> 时间戳</h3>
<p>在编程中对于时间戳的应用也尤为广泛,例如在Web开发中做cookies有效期，接口加密，<br />
Redis中的key有效期等等，大部分都是使用到了时间戳。</p>
<p>时间戳是自1970年1月1日（08:00:00GMT）至当前时间的总毫秒数。它也被称为Unix时间戳（UnixTimestamp）。<br />
在GoLang中,获取时间戳的操作如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeStamp</span><span class="params">()</span></span> &#123;</span><br><span class="line"> now := time.Now()</span><br><span class="line"> <span class="comment">// 当前时间戳 TimeStamp type:int64, TimeStamp:1606832965</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;TimeStamp type:%T, TimeStamp:%v&quot;</span>, now.Unix(), now.Unix())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外还有纳秒时间戳，我们可以使用<code>time.Now().UnixNano()</code>来获取它</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeStamp</span><span class="params">()</span></span> &#123;</span><br><span class="line"> now := time.Now()</span><br><span class="line"> <span class="comment">// 纳秒级时间戳TimeStamp type:int64, TimeStamp:1606833059999670000</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;TimeStamp type:%T, TimeStamp:%v\n&quot;</span>, now.UnixNano(), now.UnixNano())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么基本的时间戳的先暂且为止了，那该如何由时间戳转化为普通的时间格式呢？</p>
<p>当然也是有方法滴，莫急莫急，请听我一一道来，嘴比较笨就直接用代码吧，嘻嘻</p>
<p>在<code>go</code>语言中可以<code>time.Unix</code>来直接将时间戳转化为当前时间格式，实现瞬间替换。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeStampToTime</span><span class="params">()</span></span> &#123;</span><br><span class="line"> timestamp := time.Now().Unix()</span><br><span class="line"> timeObj := time.Unix(timestamp, <span class="number">0</span>) <span class="comment">//将时间戳转为时间格式</span></span><br><span class="line"> fmt.Println(timeObj)</span><br><span class="line"> year := timeObj.Year()     <span class="comment">//年</span></span><br><span class="line"> month := timeObj.Month()   <span class="comment">//月</span></span><br><span class="line"> day := timeObj.Day()       <span class="comment">//日</span></span><br><span class="line"> hour := timeObj.Hour()     <span class="comment">//小时</span></span><br><span class="line"> minute := timeObj.Minute() <span class="comment">//分钟</span></span><br><span class="line"> second := timeObj.Second() <span class="comment">//秒</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d\n&quot;</span>, year, month, day, hour, minute, second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以简单的将时间戳转化为时间格式，是不是很Nice</p>
<p>基本的定义查看就以及搞完了，那咱们整一下高级一点的东西，时间的操作</p>
<h3 id="操作时间"><a class="markdownIt-Anchor" href="#操作时间"></a> 操作时间</h3>
<h4 id="add"><a class="markdownIt-Anchor" href="#add"></a> ADD</h4>
<p>在原本的时间基础上在增加h时m分钟s秒，其增加的部分源码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// type Duration int64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Add(d Duration) Time &#123;</span><br><span class="line"> dsec := <span class="type">int64</span>(d / <span class="number">1e9</span>)</span><br><span class="line"> nsec := t.nsec() + <span class="type">int32</span>(d%<span class="number">1e9</span>)</span><br><span class="line"> <span class="keyword">if</span> nsec &gt;= <span class="number">1e9</span> &#123;</span><br><span class="line">  dsec++</span><br><span class="line">  nsec -= <span class="number">1e9</span></span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> nsec &lt; <span class="number">0</span> &#123;</span><br><span class="line">  dsec--</span><br><span class="line">  nsec += <span class="number">1e9</span></span><br><span class="line"> &#125;</span><br><span class="line"> t.wall = t.wall&amp;^nsecMask | <span class="type">uint64</span>(nsec) <span class="comment">// update nsec</span></span><br><span class="line"> t.addSec(dsec)</span><br><span class="line"> <span class="keyword">if</span> t.wall&amp;hasMonotonic != <span class="number">0</span> &#123;</span><br><span class="line">  te := t.ext + <span class="type">int64</span>(d)</span><br><span class="line">  <span class="keyword">if</span> d &lt; <span class="number">0</span> &amp;&amp; te &gt; t.ext || d &gt; <span class="number">0</span> &amp;&amp; te &lt; t.ext &#123;</span><br><span class="line">   <span class="comment">// Monotonic clock reading now out of range; degrade to wall-only.</span></span><br><span class="line">   t.stripMono()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   t.ext = te</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先如果要增加的话那么数据的类型必须是一致的，这个在强类型语言go中这个是一定的。</p>
<p>从上面的源码中函数定义的这个变量名<code>Add(d Duration)</code><br />
发现，其参数d为Duration类型，那么我们直接拿过来用即可，实现代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> &quot;fmt&quot;</span><br><span class="line"> &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func operating(h, m, s, mls, msc, ns time.Duration) &#123;</span><br><span class="line"> now := time.Now()</span><br><span class="line"> fmt.Println(now.Add(time.Hour*h + time.Minute*m + time.Second*s + time.Millisecond*mls + time.Microsecond*msc + time.Nanosecond*ns))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"> //timeDemo()</span><br><span class="line"> //timeStamp()</span><br><span class="line"> //timeStampToTime()</span><br><span class="line"> operating(3, 4, 5, 6, 7, 8)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意在这里并不能增加年\月\日，仅能增加时分秒,也就是以下的才被允许</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"> Nanosecond  Duration = <span class="number">1</span></span><br><span class="line"> Microsecond          = <span class="number">1000</span> * Nanosecond</span><br><span class="line"> Millisecond          = <span class="number">1000</span> * Microsecond</span><br><span class="line"> Second               = <span class="number">1000</span> * Millisecond</span><br><span class="line"> Minute               = <span class="number">60</span> * Second</span><br><span class="line"> Hour                 = <span class="number">60</span> * Minute</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="sub"><a class="markdownIt-Anchor" href="#sub"></a> Sub</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func operating() &#123;</span><br><span class="line"> now := time.Now()</span><br><span class="line"> targetTime := now.Add(time.Hour)</span><br><span class="line"> // 目标时间与此时相比相差1h0m0s</span><br><span class="line"> fmt.Println(targetTime.Sub(now))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>谁的sub谁为参照时间</p>
</blockquote>
<h4 id="equal"><a class="markdownIt-Anchor" href="#equal"></a> Equal</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Equal(u Time) <span class="type">bool</span></span><br></pre></td></tr></table></figure>
<p>判断两个时间是否相同，会考虑时区的影响，因此不同时区标准的时间也可以正确比较。本方法和用t==u不同，这种方法还会比较地点和时区信息。</p>
<h4 id="before"><a class="markdownIt-Anchor" href="#before"></a> Before</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Before(u Time) <span class="type">bool</span></span><br></pre></td></tr></table></figure>
<p>如果t代表的时间点在u之前，返回真；否则返回假。</p>
<h4 id="after"><a class="markdownIt-Anchor" href="#after"></a> After</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> After(u Time) <span class="type">bool</span></span><br></pre></td></tr></table></figure>
<p>如果t代表的时间点在u之后，返回真；否则返回假。</p>
<h4 id="定时器"><a class="markdownIt-Anchor" href="#定时器"></a> 定时器</h4>
<p>使用<code>time.Tick(时间间隔)</code>来设置定时器，定时器的本质上是一个通道（channel）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tickDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"> ticker := time.Tick(time.Second) <span class="comment">//定义一个1秒间隔的定时器</span></span><br><span class="line"> <span class="keyword">for</span> i := <span class="keyword">range</span> ticker &#123;</span><br><span class="line">  fmt.Println(i)<span class="comment">//每秒都会执行的任务</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间格式化"><a class="markdownIt-Anchor" href="#时间格式化"></a> 时间格式化</h3>
<p>时间类型有一个自带的方法<code>Format</code>进行格式化，需要注意的是Go语言中格式化时间模板不是常见的<code>Y-m-d H:M:S</code><br />
而是使用Go的诞生时间2006年1月2号15点04分（记忆口诀为2006 1 2 3 4）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"> now := time.Now()</span><br><span class="line"> <span class="comment">// 格式化的模板为Go的出生时间2006年1月2号15点04分 Mon Jan</span></span><br><span class="line"> <span class="comment">// 24小时制</span></span><br><span class="line"> fmt.Println(now.Format(<span class="string">&quot;2006-01-02 15:04:05.000 Mon Jan&quot;</span>))</span><br><span class="line"> <span class="comment">// 12小时制</span></span><br><span class="line"> fmt.Println(now.Format(<span class="string">&quot;2006-01-02 03:04:05.000 PM Mon Jan&quot;</span>))</span><br><span class="line"> fmt.Println(now.Format(<span class="string">&quot;2006/01/02 15:04&quot;</span>))</span><br><span class="line"> fmt.Println(now.Format(<span class="string">&quot;15:04 2006/01/02&quot;</span>))</span><br><span class="line"> fmt.Println(now.Format(<span class="string">&quot;2006/01/02&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充：如果想格式化为12小时方式，需指定<code>PM</code>。</p>
<h4 id="解析字符串格式的时间"><a class="markdownIt-Anchor" href="#解析字符串格式的时间"></a> 解析字符串格式的时间</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line"><span class="comment">// 加载时区</span></span><br><span class="line">loc, err := time.LoadLocation(<span class="string">&quot;Asia/Shanghai&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"> fmt.Println(err)</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照指定时区和指定格式解析字符串时间</span></span><br><span class="line">timeObj, err := time.ParseInLocation(<span class="string">&quot;2006/01/02 15:04:05&quot;</span>, <span class="string">&quot;2019/08/04 14:15:20&quot;</span>, loc)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"> fmt.Println(err)</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(timeObj)</span><br><span class="line">fmt.Println(timeObj.Sub(now))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang切片-slice</title>
    <url>/46493.html</url>
    <content><![CDATA[<p>在上篇数据类型-Array中写到<strong>因为数组的长度是固定的并且数组长度属于类型的一部分</strong>,所以数组有很多的局限性</p>
<span id="more"></span>
<blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arraySum</span><span class="params">(x [5]<span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line"> sum := <span class="number">0</span></span><br><span class="line"> <span class="keyword">for</span> _, v := <span class="keyword">range</span> x&#123;</span><br><span class="line">     sum = sum + v</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个求和函数只能接受<code>[5]int</code>类型，其他的都不支持。 再比如，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<p>数组a中已经有五个元素了，我们不能再继续往数组a中添加新元素了。</p>
</blockquote>
<h2 id="切片的本质"><a class="markdownIt-Anchor" href="#切片的本质"></a> 切片的本质</h2>
<p>切片的本质就是对底层数组的封装，它包含了三个信息：</p>
<ul>
<li>底层数组的指针</li>
<li>切片的长度（len）</li>
<li>切片的容量（cap)</li>
</ul>
<p>举个例子，现在有一个数组<code>a := [8]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</code>，切片<code>s1 := a[:5]</code>，相应示意图如下。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkl8xaagu0j318e0l2abf.jpg" alt="" /></p>
<p>切片<code>s2 := a[3:6]</code>，相应示意图如下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkl8xvn3bdj318e0l2q4b.jpg" alt="" /></p>
<h2 id="切片的定义"><a class="markdownIt-Anchor" href="#切片的定义"></a> 切片的定义</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化定义</span></span><br><span class="line"><span class="comment">// 基于var，var定义的时仅会声明，不会申请内存！！！</span></span><br><span class="line"><span class="keyword">var</span> 变量名 []类型</span><br><span class="line"><span class="comment">// make([]T, size, cap) make初始化分配内存</span></span><br><span class="line"><span class="built_in">make</span>([]类型, 切片中元素的数量, 切片的容量)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义</span></span><br><span class="line">变量名 := []类型&#123;值<span class="number">1</span>，值<span class="number">2</span>。。。&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// var</span></span><br><span class="line"> <span class="keyword">var</span> s1 []<span class="type">int</span>             <span class="comment">//var定义的时仅会声明，不会申请内存</span></span><br><span class="line"> fmt.Println(s1)          <span class="comment">// []</span></span><br><span class="line"> fmt.Println(s1 == <span class="literal">nil</span>)   <span class="comment">// true</span></span><br><span class="line"> s1 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"> fmt.Println(s1[<span class="number">0</span>:<span class="number">2</span>])     <span class="comment">// [1 2]</span></span><br><span class="line"> <span class="comment">// make</span></span><br><span class="line"> s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">4</span>, <span class="number">6</span>)   <span class="comment">// make初始化分配内存</span></span><br><span class="line"> fmt.Println(s2)           <span class="comment">// [0 0 0 0]</span></span><br><span class="line"> fmt.Println(s2 == <span class="literal">nil</span>)    <span class="comment">// false</span></span><br><span class="line"> s2 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"> fmt.Println(s2[<span class="number">0</span>:<span class="number">2</span>])       <span class="comment">// [1 2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="var-声明切片"><a class="markdownIt-Anchor" href="#var-声明切片"></a> var 声明切片</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// 声明切片类型</span></span><br><span class="line"> <span class="keyword">var</span> s1 []<span class="type">string</span>              <span class="comment">//声明一个字符串切片</span></span><br><span class="line">  <span class="keyword">var</span> s2 = []<span class="type">int</span>&#123;&#125;             <span class="comment">//声明一个整型切片并初始化(不规范写法，注意！！！)</span></span><br><span class="line"> <span class="keyword">var</span> s3 = []<span class="type">bool</span>&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="comment">//声明一个布尔切片并初始化</span></span><br><span class="line"> <span class="keyword">var</span> s4 = []<span class="type">bool</span>&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="comment">//声明一个布尔切片并初始化</span></span><br><span class="line"> fmt.Println(s1)              <span class="comment">//[]</span></span><br><span class="line"> fmt.Println(s2)              <span class="comment">//[]</span></span><br><span class="line"> fmt.Println(s3)              <span class="comment">//[false true]</span></span><br><span class="line"> fmt.Println(s4)              <span class="comment">//[false true]</span></span><br><span class="line"> fmt.Println(s1 == <span class="literal">nil</span>)       <span class="comment">//true</span></span><br><span class="line"> fmt.Println(s2 == <span class="literal">nil</span>)       <span class="comment">//false</span></span><br><span class="line"> fmt.Println(s3 == <span class="literal">nil</span>)       <span class="comment">//false</span></span><br><span class="line"> fmt.Println(s4 == <span class="literal">nil</span>)       <span class="comment">//false</span></span><br><span class="line"> <span class="comment">// fmt.Println(s3 == s4)       //切片是引用类型，不支持直接比较，只能和nil比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="make-初始化切片"><a class="markdownIt-Anchor" href="#make-初始化切片"></a> Make 初始化切片</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// make 初始化切片</span></span><br><span class="line"> s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">4</span>, <span class="number">6</span>)        </span><br><span class="line"> s2 := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">4</span>, <span class="number">6</span>)     </span><br><span class="line"> s3 := <span class="built_in">make</span>([]<span class="type">bool</span>,<span class="number">2</span>, <span class="number">4</span>)        </span><br><span class="line"> fmt.Println(s1)                <span class="comment">// [0 0 0 0]</span></span><br><span class="line"> fmt.Println(s2)                <span class="comment">// [       ]</span></span><br><span class="line"> fmt.Println(s3)                <span class="comment">// [false false]</span></span><br><span class="line"> fmt.Println(s1 == <span class="literal">nil</span>)         <span class="comment">// false</span></span><br><span class="line"> fmt.Println(s2 == <span class="literal">nil</span>)         <span class="comment">// false</span></span><br><span class="line"> fmt.Println(s3 == <span class="literal">nil</span>)         <span class="comment">// false</span></span><br><span class="line"> <span class="comment">//fmt.Println(s2 == s3)        // 切片是引用类型，不支持直接比较，只能和nil比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断切片是否为空"><a class="markdownIt-Anchor" href="#判断切片是否为空"></a> 判断切片是否为空</h2>
<p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</p>
<h3 id="切片不能直接比较"><a class="markdownIt-Anchor" href="#切片不能直接比较"></a> 切片不能直接比较</h3>
<p>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。<br />
切片唯一合法的比较操作是和<code>nil</code>比较。 一个<code>nil</code>值的切片并没有底层数组，一个<code>nil</code><br />
值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是<code>nil</code>，例如下面的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="type">int</span>         <span class="comment">//len(s1)=0;cap(s1)=0;s1==nil</span></span><br><span class="line">s2 := []<span class="type">int</span>&#123;&#125;        <span class="comment">//len(s2)=0;cap(s2)=0;s2!=nil</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>) <span class="comment">//len(s3)=0;cap(s3)=0;s3!=nil</span></span><br></pre></td></tr></table></figure>
<p>所以要判断一个切片是否是空的，要是用<code>len(s) == 0</code>来判断，不应该使用<code>s == nil</code>来判断。</p>
<h2 id="切片的赋值拷贝"><a class="markdownIt-Anchor" href="#切片的赋值拷贝"></a> 切片的赋值拷贝</h2>
<p>下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// 切片的赋值拷贝</span></span><br><span class="line"> s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"> s2 := s1</span><br><span class="line"> s1[<span class="number">0</span>] = <span class="number">80</span></span><br><span class="line"> s2[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line"> fmt.Println(s1)    <span class="comment">// [80 100]</span></span><br><span class="line"> fmt.Println(s2)    <span class="comment">// [80 100]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="切片遍历"><a class="markdownIt-Anchor" href="#切片遍历"></a> 切片遍历</h2>
<p>切片的遍历方式和数组(Array)是一致的，支持索引遍历和<code>for range</code>遍历。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">  fmt.Println(i, s[i])</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> index, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">  fmt.Println(index, value)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="切片添加元素"><a class="markdownIt-Anchor" href="#切片添加元素"></a> 切片添加元素</h2>
<p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目标变量 = append(需被加入切片的变量名， 需追加的常量或者切片的变量名)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">  <span class="comment">// 添加单个元素</span></span><br><span class="line"> s = <span class="built_in">append</span>(s, <span class="number">1</span>)        <span class="comment">// [1]</span></span><br><span class="line">  <span class="comment">// 添加多个元素</span></span><br><span class="line"> s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment">// [1 2 3 4]</span></span><br><span class="line"> s2 := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;  </span><br><span class="line">  <span class="comment">// 添加切片</span></span><br><span class="line"> s = <span class="built_in">append</span>(s, s2...)    <span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**注意：**通过var声明的零值切片，在<code>append()</code>函数中可直接使用，无需初始化。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以这样做，但没必要</span></span><br><span class="line"> s := []<span class="type">int</span>&#123;&#125; <span class="comment">// 没有必要初始化</span></span><br><span class="line"> s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"> fmt.Println(s)  <span class="comment">// 1,2,3,4,5,6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"> <span class="keyword">var</span> s = <span class="built_in">make</span>([]<span class="type">int</span>) </span><br><span class="line"> s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h2 id="切片底层内存原理探究"><a class="markdownIt-Anchor" href="#切片底层内存原理探究"></a> 切片底层内存原理探究</h2>
<h3 id="引入"><a class="markdownIt-Anchor" href="#引入"></a> 引入</h3>
<blockquote></blockquote>
<p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code><br />
函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p>
<blockquote>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gklp4pox1sj30t608875i.jpg" alt="" /></p>
<p>从上面的结果可以看出：</p>
<ol>
<li><code>append()</code>函数将元素追加到切片的最后并返回该切片。</li>
<li>切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。</li>
</ol>
</blockquote>
<h3 id="源码解读"><a class="markdownIt-Anchor" href="#源码解读"></a> 源码解读</h3>
<p><code>$GOROOT/src/runtime/slice.go</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright 2009 The Go Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style</span></span><br><span class="line"><span class="comment">// license that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> runtime</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;runtime/internal/math&quot;</span></span><br><span class="line"> <span class="string">&quot;runtime/internal/sys&quot;</span></span><br><span class="line"> <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 自定义类型定义了一个全新的类型。基于内置的基本类型定义，也可以通过struct定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// slice是一种新类型，同时也包含了struct所具有的特性</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123; <span class="comment">// 自定义类型名为slice，struct类型。</span></span><br><span class="line"> array unsafe.Pointer</span><br><span class="line"> <span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line"> <span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A notInHeapSlice is a slice backed by go:notinheap memory.</span></span><br><span class="line"><span class="comment">// notInHeapSlice是go：notinheap内存支持的切片</span></span><br><span class="line"><span class="keyword">type</span> notInHeapSlice <span class="keyword">struct</span> &#123;</span><br><span class="line"> array *notInHeap</span><br><span class="line"> <span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line"> <span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panicmakeslicelen</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="built_in">panic</span>(errorString(<span class="string">&quot;makeslice: len out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panicmakeslicecap</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="built_in">panic</span>(errorString(<span class="string">&quot;makeslice: cap out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// makeslicecopy allocates a slice of &quot;tolen&quot; elements of type &quot;et&quot;,</span></span><br><span class="line"><span class="comment">// then copies &quot;fromlen&quot; elements of type &quot;et&quot; into that new allocation from &quot;from&quot;.</span></span><br><span class="line"><span class="comment">// makeslicecopy会分配一片类型为“ et”的“ tolen”元素，然后将类型为“ et”的“ fromlen”元素复制到“ from”的新分配中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslicecopy</span><span class="params">(et *_type, tolen <span class="type">int</span>, fromlen <span class="type">int</span>, from unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line"> <span class="keyword">var</span> tomem, copymem <span class="type">uintptr</span></span><br><span class="line"> <span class="keyword">if</span> <span class="type">uintptr</span>(tolen) &gt; <span class="type">uintptr</span>(fromlen) &#123;</span><br><span class="line">  <span class="keyword">var</span> overflow <span class="type">bool</span></span><br><span class="line">  tomem, overflow = math.MulUintptr(et.size, <span class="type">uintptr</span>(tolen))</span><br><span class="line">  <span class="keyword">if</span> overflow || tomem &gt; maxAlloc || tolen &lt; <span class="number">0</span> &#123;</span><br><span class="line">   panicmakeslicelen()</span><br><span class="line">  &#125;</span><br><span class="line">  copymem = et.size * <span class="type">uintptr</span>(fromlen)</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// fromlen is a known good length providing and equal or greater than tolen,</span></span><br><span class="line">  <span class="comment">// thereby making tolen a good slice length too as from and to slices have the</span></span><br><span class="line">  <span class="comment">// same element width.</span></span><br><span class="line">    <span class="comment">// fromlen是已知的良好长度，提供并等于或大于tolen，因此也使tolen具有良好的切片长度，因为from和to切片具有//相同的元素宽度。</span></span><br><span class="line">  tomem = et.size * <span class="type">uintptr</span>(tolen)</span><br><span class="line">  copymem = tomem</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> to unsafe.Pointer</span><br><span class="line"> <span class="keyword">if</span> et.ptrdata == <span class="number">0</span> &#123;</span><br><span class="line">  to = mallocgc(tomem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">if</span> copymem &lt; tomem &#123;</span><br><span class="line">   memclrNoHeapPointers(add(to, copymem), tomem-copymem)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Note: can&#x27;t use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.</span></span><br><span class="line">    <span class="comment">// 注意：不能使用rawmem（这样可以避免内存清零），因为GC可以扫描未初始化的内存。</span></span><br><span class="line">  to = mallocgc(tomem, et, <span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">if</span> copymem &gt; <span class="number">0</span> &amp;&amp; writeBarrier.enabled &#123;</span><br><span class="line">   <span class="comment">// Only shade the pointers in old.array since we know the destination slice to</span></span><br><span class="line">   <span class="comment">// only contains nil pointers because it has been cleared during alloc.</span></span><br><span class="line">      <span class="comment">//因为我们知道到//的目标切片仅包含nil指针，所以仅在old.array中隐藏了指针，因为在分配过程中已将其清除。</span></span><br><span class="line">   bulkBarrierPreWriteSrcOnly(<span class="type">uintptr</span>(to), <span class="type">uintptr</span>(from), copymem)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">  callerpc := getcallerpc()</span><br><span class="line">  pc := funcPC(makeslicecopy)</span><br><span class="line">  racereadrangepc(from, copymem, callerpc, pc)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">  msanread(from, copymem)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> memmove(to, from, copymem)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> to</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line"> mem, overflow := math.MulUintptr(et.size, <span class="type">uintptr</span>(<span class="built_in">cap</span>))</span><br><span class="line"> <span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> || <span class="built_in">len</span> &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> Produce a &#x27;len out of range&#x27; error instead of a</span></span><br><span class="line">  <span class="comment">// &#x27;cap out of range&#x27; error when someone does make([]T, bignumber).</span></span><br><span class="line">  <span class="comment">// &#x27;cap out of range&#x27; is true too, but since the cap is only being</span></span><br><span class="line">  <span class="comment">// supplied implicitly, saying len is clearer.</span></span><br><span class="line">  <span class="comment">// See golang.org/issue/4085.</span></span><br><span class="line">    <span class="comment">////注意：当有人进行make（[] T，bignumber）时，产生一个&#x27;len out of range&#x27;错误，而不是一个&#x27;cap cap out range&#x27;错误。 “上限超出范围”也是正确的，但是由于上限是隐式提供的，因此说len更清楚。 参见golang.org/issue/4085。</span></span><br><span class="line">  mem, overflow := math.MulUintptr(et.size, <span class="type">uintptr</span>(<span class="built_in">len</span>))</span><br><span class="line">  <span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">   panicmakeslicelen()</span><br><span class="line">  &#125;</span><br><span class="line">  panicmakeslicecap()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> mallocgc(mem, et, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice64</span><span class="params">(et *_type, len64, cap64 <span class="type">int64</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line"> <span class="built_in">len</span> := <span class="type">int</span>(len64)</span><br><span class="line"> <span class="keyword">if</span> <span class="type">int64</span>(<span class="built_in">len</span>) != len64 &#123;</span><br><span class="line">  panicmakeslicelen()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">cap</span> := <span class="type">int</span>(cap64)</span><br><span class="line"> <span class="keyword">if</span> <span class="type">int64</span>(<span class="built_in">cap</span>) != cap64 &#123;</span><br><span class="line">  panicmakeslicecap()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> makeslice(et, <span class="built_in">len</span>, <span class="built_in">cap</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// growslice handles slice growth during append.</span></span><br><span class="line"><span class="comment">// It is passed the slice element type, the old slice, and the desired new minimum capacity,</span></span><br><span class="line"><span class="comment">// and it returns a new slice with at least that capacity, with the old data</span></span><br><span class="line"><span class="comment">// copied into it.</span></span><br><span class="line"><span class="comment">// The new slice&#x27;s length is set to the old slice&#x27;s length,</span></span><br><span class="line"><span class="comment">// NOT to the new requested capacity.</span></span><br><span class="line"><span class="comment">// This is for codegen convenience. The old slice&#x27;s length is used immediately</span></span><br><span class="line"><span class="comment">// to calculate where to write new values during an append.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> When the old backend is gone, reconsider this decision.</span></span><br><span class="line"><span class="comment">// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> slice &#123;</span><br><span class="line"> <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">  callerpc := getcallerpc()</span><br><span class="line">  racereadrangepc(old.array, <span class="type">uintptr</span>(old.<span class="built_in">len</span>*<span class="type">int</span>(et.size)), callerpc, funcPC(growslice))</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">  msanread(old.array, <span class="type">uintptr</span>(old.<span class="built_in">len</span>*<span class="type">int</span>(et.size)))</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">cap</span> &lt; old.<span class="built_in">cap</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: cap out of range&quot;</span>))</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> et.size == <span class="number">0</span> &#123;</span><br><span class="line">  <span class="comment">// append should not create a slice with nil pointer but non-zero len.</span></span><br><span class="line">  <span class="comment">// We assume that append doesn&#x27;t need to preserve old.array in this case.</span></span><br><span class="line">  <span class="keyword">return</span> slice&#123;unsafe.Pointer(&amp;zerobase), old.<span class="built_in">len</span>, <span class="built_in">cap</span>&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> newcap := old.<span class="built_in">cap</span></span><br><span class="line"> doublecap := newcap + newcap</span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">  newcap = <span class="built_in">cap</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">   newcap = doublecap</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line">   <span class="comment">// and prevent an infinite loop.</span></span><br><span class="line">   <span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">    newcap += newcap / <span class="number">4</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line">   <span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line">   <span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">    newcap = <span class="built_in">cap</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> overflow <span class="type">bool</span></span><br><span class="line"> <span class="keyword">var</span> lenmem, newlenmem, capmem <span class="type">uintptr</span></span><br><span class="line"> <span class="comment">// Specialize for common values of et.size.</span></span><br><span class="line"> <span class="comment">// For 1 we don&#x27;t need any division/multiplication.</span></span><br><span class="line"> <span class="comment">// For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant.</span></span><br><span class="line"> <span class="comment">// For powers of 2, use a variable shift.</span></span><br><span class="line"> <span class="keyword">switch</span> &#123;</span><br><span class="line"> <span class="keyword">case</span> et.size == <span class="number">1</span>:</span><br><span class="line">  lenmem = <span class="type">uintptr</span>(old.<span class="built_in">len</span>)</span><br><span class="line">  newlenmem = <span class="type">uintptr</span>(<span class="built_in">cap</span>)</span><br><span class="line">  capmem = roundupsize(<span class="type">uintptr</span>(newcap))</span><br><span class="line">  overflow = <span class="type">uintptr</span>(newcap) &gt; maxAlloc</span><br><span class="line">  newcap = <span class="type">int</span>(capmem)</span><br><span class="line"> <span class="keyword">case</span> et.size == sys.PtrSize:</span><br><span class="line">  lenmem = <span class="type">uintptr</span>(old.<span class="built_in">len</span>) * sys.PtrSize</span><br><span class="line">  newlenmem = <span class="type">uintptr</span>(<span class="built_in">cap</span>) * sys.PtrSize</span><br><span class="line">  capmem = roundupsize(<span class="type">uintptr</span>(newcap) * sys.PtrSize)</span><br><span class="line">  overflow = <span class="type">uintptr</span>(newcap) &gt; maxAlloc/sys.PtrSize</span><br><span class="line">  newcap = <span class="type">int</span>(capmem / sys.PtrSize)</span><br><span class="line"> <span class="keyword">case</span> isPowerOfTwo(et.size):</span><br><span class="line">  <span class="keyword">var</span> shift <span class="type">uintptr</span></span><br><span class="line">  <span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">   <span class="comment">// Mask shift for better code generation.</span></span><br><span class="line">   shift = <span class="type">uintptr</span>(sys.Ctz64(<span class="type">uint64</span>(et.size))) &amp; <span class="number">63</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   shift = <span class="type">uintptr</span>(sys.Ctz32(<span class="type">uint32</span>(et.size))) &amp; <span class="number">31</span></span><br><span class="line">  &#125;</span><br><span class="line">  lenmem = <span class="type">uintptr</span>(old.<span class="built_in">len</span>) &lt;&lt; shift</span><br><span class="line">  newlenmem = <span class="type">uintptr</span>(<span class="built_in">cap</span>) &lt;&lt; shift</span><br><span class="line">  capmem = roundupsize(<span class="type">uintptr</span>(newcap) &lt;&lt; shift)</span><br><span class="line">  overflow = <span class="type">uintptr</span>(newcap) &gt; (maxAlloc &gt;&gt; shift)</span><br><span class="line">  newcap = <span class="type">int</span>(capmem &gt;&gt; shift)</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line">  lenmem = <span class="type">uintptr</span>(old.<span class="built_in">len</span>) * et.size</span><br><span class="line">  newlenmem = <span class="type">uintptr</span>(<span class="built_in">cap</span>) * et.size</span><br><span class="line">  capmem, overflow = math.MulUintptr(et.size, <span class="type">uintptr</span>(newcap))</span><br><span class="line">  capmem = roundupsize(capmem)</span><br><span class="line">  newcap = <span class="type">int</span>(capmem / et.size)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// The check of overflow in addition to capmem &gt; maxAlloc is needed</span></span><br><span class="line"> <span class="comment">// to prevent an overflow which can be used to trigger a segfault</span></span><br><span class="line"> <span class="comment">// on 32bit architectures with this example program:</span></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> <span class="comment">// type T [1&lt;&lt;27 + 1]int64</span></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> <span class="comment">// var d T</span></span><br><span class="line"> <span class="comment">// var s []T</span></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> <span class="comment">// func main() &#123;</span></span><br><span class="line"> <span class="comment">//   s = append(s, d, d, d, d)</span></span><br><span class="line"> <span class="comment">//   print(len(s), &quot;\n&quot;)</span></span><br><span class="line"> <span class="comment">// &#125;</span></span><br><span class="line"> <span class="keyword">if</span> overflow || capmem &gt; maxAlloc &#123;</span><br><span class="line">  <span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: cap out of range&quot;</span>))</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line"> <span class="keyword">if</span> et.ptrdata == <span class="number">0</span> &#123;</span><br><span class="line">  p = mallocgc(capmem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">  <span class="comment">// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).</span></span><br><span class="line">  <span class="comment">// Only clear the part that will not be overwritten.</span></span><br><span class="line">  memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Note: can&#x27;t use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.</span></span><br><span class="line">  p = mallocgc(capmem, et, <span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">if</span> lenmem &gt; <span class="number">0</span> &amp;&amp; writeBarrier.enabled &#123;</span><br><span class="line">   <span class="comment">// Only shade the pointers in old.array since we know the destination slice p</span></span><br><span class="line">   <span class="comment">// only contains nil pointers because it has been cleared during alloc.</span></span><br><span class="line">   bulkBarrierPreWriteSrcOnly(<span class="type">uintptr</span>(p), <span class="type">uintptr</span>(old.array), lenmem-et.size+et.ptrdata)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> memmove(p, old.array, lenmem)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPowerOfTwo</span><span class="params">(x <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> x&amp;(x<span class="number">-1</span>) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicecopy</span><span class="params">(toPtr unsafe.Pointer, toLen <span class="type">int</span>, fmPtr unsafe.Pointer, fmLen <span class="type">int</span>, width <span class="type">uintptr</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> fmLen == <span class="number">0</span> || toLen == <span class="number">0</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> n := fmLen</span><br><span class="line"> <span class="keyword">if</span> toLen &lt; n &#123;</span><br><span class="line">  n = toLen</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> width == <span class="number">0</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> n</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">  callerpc := getcallerpc()</span><br><span class="line">  pc := funcPC(slicecopy)</span><br><span class="line">  racereadrangepc(fmPtr, <span class="type">uintptr</span>(n*<span class="type">int</span>(width)), callerpc, pc)</span><br><span class="line">  racewriterangepc(toPtr, <span class="type">uintptr</span>(n*<span class="type">int</span>(width)), callerpc, pc)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">  msanread(fmPtr, <span class="type">uintptr</span>(n*<span class="type">int</span>(width)))</span><br><span class="line">  msanwrite(toPtr, <span class="type">uintptr</span>(n*<span class="type">int</span>(width)))</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> size := <span class="type">uintptr</span>(n) * width</span><br><span class="line"> <span class="keyword">if</span> size == <span class="number">1</span> &#123; <span class="comment">// common case worth about 2x to do here</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> is this still worth it with new memmove impl?</span></span><br><span class="line">  *(*<span class="type">byte</span>)(toPtr) = *(*<span class="type">byte</span>)(fmPtr) <span class="comment">// known to be a byte pointer</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  memmove(toPtr, fmPtr, size)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicestringcopy</span><span class="params">(toPtr *<span class="type">byte</span>, toLen <span class="type">int</span>, fm <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">len</span>(fm) == <span class="number">0</span> || toLen == <span class="number">0</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> n := <span class="built_in">len</span>(fm)</span><br><span class="line"> <span class="keyword">if</span> toLen &lt; n &#123;</span><br><span class="line">  n = toLen</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">  callerpc := getcallerpc()</span><br><span class="line">  pc := funcPC(slicestringcopy)</span><br><span class="line">  racewriterangepc(unsafe.Pointer(toPtr), <span class="type">uintptr</span>(n), callerpc, pc)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">  msanwrite(unsafe.Pointer(toPtr), <span class="type">uintptr</span>(n))</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> memmove(unsafe.Pointer(toPtr), stringStructOf(&amp;fm).str, <span class="type">uintptr</span>(n))</span><br><span class="line"> <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>内存分配部分，重点部分</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">newcap := old.<span class="built_in">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line"> newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">  newcap = doublecap</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line">  <span class="comment">// and prevent an infinite loop.</span></span><br><span class="line">  <span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">   newcap += newcap / <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line">  <span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line">  <span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">   newcap = <span class="built_in">cap</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。</li>
<li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap），</li>
<li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for<br />
{newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li>
<li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</li>
</ul>
<p>需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如<code>int</code>和<code>string</code>类型的处理方式就不一样。</p>
</blockquote>
<h2 id="复制切片"><a class="markdownIt-Anchor" href="#复制切片"></a> 复制切片</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 疑问</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"> b := a</span><br><span class="line"> fmt.Println(a) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line"> fmt.Println(b) <span class="comment">//[1 2 3 4 5]</span></span><br><span class="line"> b[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line"> fmt.Println(a) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line"> fmt.Println(b) <span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缘由：由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。</span></span><br></pre></td></tr></table></figure>
<p>Go语言内建的<code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<code>copy()</code>函数的使用格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">copy</span>(destSlice, srcSlice []T)</span><br><span class="line"><span class="comment">// 其中：</span></span><br><span class="line">- srcSlice: 数据来源切片</span><br><span class="line">- destSlice: 目标切片</span><br></pre></td></tr></table></figure>
<p>示例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// copy()复制切片</span></span><br><span class="line"> s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"> s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"> <span class="built_in">copy</span>(s2, s1)     <span class="comment">//使用copy()函数将切片a中的元素复制到切片s2</span></span><br><span class="line"> fmt.Println(s1) <span class="comment">//[1 2 3]</span></span><br><span class="line"> fmt.Println(s2) <span class="comment">// [1 2 3 0 0]</span></span><br><span class="line"> s2[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line"> fmt.Println(s1) <span class="comment">//[1 2 3]</span></span><br><span class="line"> fmt.Println(s2) <span class="comment">//[10 2 3 0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除元素"><a class="markdownIt-Anchor" href="#删除元素"></a> 删除元素</h2>
<p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// 从切片中删除元素</span></span><br><span class="line"> a := []<span class="type">int</span>&#123;<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>&#125;</span><br><span class="line"> <span class="comment">// 要删除索引为2的元素</span></span><br><span class="line"> a = <span class="built_in">append</span>(a[:<span class="number">2</span>], a[<span class="number">3</span>:]...)</span><br><span class="line"> fmt.Println(a) <span class="comment">//[30 31 33 34 35 36 37]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p>
<h2 id="总结及注意点"><a class="markdownIt-Anchor" href="#总结及注意点"></a> 总结及注意点</h2>
<ul>
<li>底层数组的指针、切片的长度（len）、切片的容量（cap)</li>
<li><code>var</code>与<code>make</code>基于var，var定义的时仅会声明，不会申请内存。make初始化会分配内存。其内容为初始值。(string:<br />
空、int：0、bool：false、Array：var时为nil\make时为&quot;[]&quot;<br />
的内部有Len-1个0)</li>
<li>通过var声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</li>
<li>Append可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面需要加…）。</li>
<li>当内存小于1024时，每次扩宽两倍。当1024每次增加原本的1/4倍</li>
<li>要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang基础指令</title>
    <url>/18957.html</url>
    <content><![CDATA[<p>无论多么复杂的程序，多么复杂的逻辑。基本是由以下三种构成(当然除非其原本业务逻辑客观复杂)</p>
<p>大道至简、速归同途，找到这种感觉。come on～</p>
<h2 id="条件分支语句"><a class="markdownIt-Anchor" href="#条件分支语句"></a> 条件分支语句</h2>
<h3 id="if-条件分支语句"><a class="markdownIt-Anchor" href="#if-条件分支语句"></a> if 条件分支语句</h3>
<p>Golang条件语句是通过一条或多条语句的执行结果（True或者False）来决定是否执行的代码块。</p>
<p>Golang程序语言指定任何非0和非空（null）值为true，0 或者 null为false。</p>
<p>Golang 编程中 if 语句用于控制程序的执行，基本形式为：</p>
<span id="more"></span>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i:= <span class="number">3</span></span><br><span class="line">    <span class="keyword">if</span> i &gt;<span class="number">3</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;i&gt;3&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;i&lt;=3&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// i&lt;=3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> i := <span class="number">3</span></span><br><span class="line"> <span class="keyword">if</span> i &lt; <span class="number">3</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;i &lt; 3&quot;</span>)</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">3</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;i == 3&quot;</span>)</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;i &gt; 3&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i == 3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于 if 条件语句的使用规则：</p>
<ul>
<li>
<p>if 后面的条件表达式不需要使用 ()</p>
</li>
<li>
<p>每个条件分支（if 或者 else）中的大括号是必需的，哪怕大括号里只有一行代码（</p>
</li>
<li>
<p>if 紧跟的大括号 { 不能独占一行，else 前的大括号 } 也不能独占一行，否则会编译不通过。</p>
</li>
<li>
<p>在 if……else 条件语句中还可以增加多个 else if，增加更多的条件分支</p>
</li>
</ul>
</blockquote>
<h3 id="switch-选择语句"><a class="markdownIt-Anchor" href="#switch-选择语句"></a> switch 选择语句</h3>
<p>if 条件语句比较适合分支较少的情况，如果有很多分支的话，选择 switch 会更方便，比如以上示例，使用 switch<br />
改造后的代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">switch</span> i:=<span class="number">7</span>;&#123;</span><br><span class="line"> <span class="keyword">case</span> i&gt;<span class="number">10</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;i&gt;10&quot;</span>)</span><br><span class="line"> <span class="keyword">case</span> i&gt;<span class="number">5</span> &amp;&amp; i&lt;=<span class="number">10</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;5&lt;i&lt;=10&quot;</span>)</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;i&lt;=5&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5&lt;i&lt;=10</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>switch 语句同样也可以用一个简单的语句来做初始化，同样也是用分号 ; 分隔。每一个 case 就是一个分支，分支条件为<br />
true 该分支才会执行，而且 case 分支后的条件表达式也不用小括号 () 包裹。</p>
<p>在 Go 语言中，switch 的 case 从上到下逐一进行判断，一旦满足条件，立即执行对应的分支并返回，其余分支不再做判断。也就是说<br />
Go 语言的 switch 在默认情况下，case 最后自带 break。这和其他编程语言不一样，比如 C 语言在 case<br />
分支里必须要有明确的 break 才能退出一个 case。Go 语言的这种设计就是为了防止忘记写 break 时，下一个<br />
case 被执行。</p>
</blockquote>
<p>那么如果你真的有需要，的确需要执行下一个紧跟的 case 怎么办呢？Go 语言也考虑到了，提供了 fallthrough<br />
关键字。现在看个例子，如下面的代码所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">switch</span> j := <span class="number">1</span>; j &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">fallthrough</span>  <span class="comment">// 执行下一个case(即case2)</span></span><br><span class="line"> <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;没有匹配&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h2 id="for-循环语句"><a class="markdownIt-Anchor" href="#for-循环语句"></a> for 循环语句</h2>
<p>循环，顾名思义，就是遵循一定规则循环往复的执行，golang中语法循环如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始值；运行范围；表达式 &#123;</span><br><span class="line">  执行语句</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// for循环示例1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 2 3 4 5 6 7 8 9</span></span><br><span class="line"> <span class="comment">// for循环示例2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"> <span class="keyword">for</span> ;i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请思考两个示例有何不同？提示：作用域</span></span><br></pre></td></tr></table></figure>
<p>下面是一个经典的 for 循环示例，从这个示例中，我们可以分析出 for 循环由三部分组成，其中，需要使用两个 ;<br />
分隔，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> sum:=<span class="number">0</span></span><br><span class="line"> <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++ &#123;</span><br><span class="line">  sum+=i</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Println(<span class="string">&quot;The sum is&quot;</span>,sum)</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// The sum is 5050</span></span><br></pre></td></tr></table></figure>
<h3 id="高级for循环"><a class="markdownIt-Anchor" href="#高级for循环"></a> 高级for循环</h3>
<p>如果你以前学过其他编程语言，可能会见到 while 这样的循环语句，在 Go 语言中没有 while 循环，但是可以通过<br />
for 达到 while 的效果，如以下代码所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sum:=<span class="number">0</span></span><br><span class="line">i:=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i&lt;=<span class="number">100</span> &#123;</span><br><span class="line">    sum+=i</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;The sum is&quot;</span>,sum)</span><br><span class="line"><span class="comment">// The sum is 5050</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"> <span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"> <span class="keyword">for</span> ;i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在写循环时，一定需要先树立终止条件。避免写成死循环。他较于其他编程语言更能Kill掉你的电脑</p>
</blockquote>
<h2 id="continue-or-break"><a class="markdownIt-Anchor" href="#continue-or-break"></a> continue or break</h2>
<blockquote>
<p>break:用于终止</p>
<p>continue:跳过</p>
<p>二者仅且适用于if或者for</p>
<p>场景一：打印1-9，当值为6点时打印并退出(这个可能会有点牵强，主要用于理解break)</p>
<p>场景2: 打印1-9，其中不输出7</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 场景一：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line">      <span class="keyword">if</span> i == <span class="number">6</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 场景二：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line">  <span class="keyword">if</span> i == <span class="number">7</span> &#123;</span><br><span class="line">   <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="swith"><a class="markdownIt-Anchor" href="#swith"></a> swith</h2>
<p>if 条件语句比较适合分支较少的情况，如果有很多分支的话，选择 switch 会更方便，比如以上示例，使用 switch<br />
改造后的代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">switch</span> i := <span class="number">20</span>; &#123;</span><br><span class="line"> <span class="keyword">case</span> i &gt; <span class="number">10</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;i&gt;10&quot;</span>)</span><br><span class="line"> <span class="keyword">case</span> i &gt; <span class="number">5</span> &amp;&amp; i &lt;= <span class="number">10</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;5&lt;i&lt;=10&quot;</span>)</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;i&lt;=5&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// i&gt;10</span></span><br></pre></td></tr></table></figure>
<p>switch 语句同样也可以用一个简单的语句来做初始化，同样也用分号 ; 分隔。每一个 case 就是一个分支，分支条件为<br />
true 该分支才会执行，而且 case 分支后的条件表达式也不用小括号 () 包裹。</p>
<p>在 Go 语言中，switch 的 case 从上到下逐一进行判断，一旦满足条件，立即执行对应的分支并返回，其余分支不再做判断。也就是说<br />
Go 语言的 switch 在默认情况下，case 最后自带 break。这和其他编程语言不一样，比如<br />
C 语言在 case 分支里必须要有明确的 break 才能退出一个 case。Go 语言的这种设计就是为了防止忘记写 break<br />
时，下一个 case 被执行。那么如果你真的有需要，的确需要执行下一个紧跟的 case 怎么办呢？Go<br />
语言也考虑到了，提供了 fallthrough 关键字。如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">switch</span> i:=<span class="number">1</span>;i &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">fallthrough</span></span><br><span class="line"> <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;没有匹配&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上示例运行会输出 1，如果省略 case 1: 后面的 fallthrough，则不会有任何输出。</p>
<p>不知道你是否可以发现，和上一个例子对比，这个例子的 switch 后面是有表达式的，也就是输入了 ;j，而上一个例子的<br />
switch 后只有一个用于初始化的简单语句。</p>
<p>当 switch 之后有表达式时，case 后的值就要和这个表达式的结果类型相同，比如这里的 j 是 int 类型，那么<br />
case 后就只能使用 int 类型，如示例中的 case 1、case 2。如果是其他类型，比如使用 case &quot;<br />
a&quot; ，会提示类型不匹配，无法编译通过。</p>
<p>而对于 switch 后省略表达式的情况，整个 switch 结构就和 if……else 条件语句等同了。</p>
<p>switch 后的表达式也没有太多限制，是一个合法的表达式即可，也不用一定要求是常量或者整数。你甚至可以像如下代码一样，直接把比较表达式放在<br />
switch 之后：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">switch</span> <span class="number">2</span> &lt; <span class="number">1</span> &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;2&gt;1&quot;</span>)</span><br><span class="line"> <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;2&lt;=1&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2&lt;=1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang基础数据类型</title>
    <url>/11541.html</url>
    <content><![CDATA[<p>Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go<br />
语言的基本类型和其他语言大同小异。</p>
<h2 id="基本数据类型"><a class="markdownIt-Anchor" href="#基本数据类型"></a> 基本数据类型</h2>
<h3 id="整形"><a class="markdownIt-Anchor" href="#整形"></a> 整形</h3>
<p>整型分为以下两个大类：</p>
<blockquote>
<p>按长度分为：int8、int16、int32、int64<br />
无符号整型：uint8、uint16、uint32、uint64</p>
<ul>
<li><code>uint8</code>就是我们熟知的<code>byte</code>型</li>
<li><code>int16</code>对应C语言中的<code>short</code>型，</li>
<li><code>int64</code>对应C语言中的<code>long</code>型。</li>
</ul>
</blockquote>
<p>取值范围如下所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">取值范围为您操作系统的位数字，如果是64位操作系统。为int64</td>
</tr>
<tr>
<td style="text-align:center">int8</td>
<td style="text-align:center">有符号 8位整型 [ 2^8 + 1 到 2^8 -1](-255, 255)</td>
</tr>
<tr>
<td style="text-align:center">int16</td>
<td style="text-align:center">有符号 16位整型 [ 2^16 + 1 到 2^16 -1](-65535, 6535)</td>
</tr>
<tr>
<td style="text-align:center">int32</td>
<td style="text-align:center">有符号 16位整型 [ 2^32 + 1 到 2^32 -1](-4294967295, 4294967295)</td>
</tr>
<tr>
<td style="text-align:center">int64</td>
<td style="text-align:center">有符号 16位整型 [ 2^64 + 1 到 2^64 -1](-18446744073709551615, 18446744073709551615)</td>
</tr>
<tr>
<td style="text-align:center">uint</td>
<td style="text-align:center">取值范围为您操作系统的位数字，如果是64位操作系统。为int64</td>
</tr>
<tr>
<td style="text-align:center">uint8</td>
<td style="text-align:center">无符号 8位整型 (0 到 255)</td>
</tr>
<tr>
<td style="text-align:center">uint16</td>
<td style="text-align:center">无符号 16位整型 (0 到 65535)</td>
</tr>
<tr>
<td style="text-align:center">uint32</td>
<td style="text-align:center">无符号 32位整型 (0 到 4294967295)</td>
</tr>
<tr>
<td style="text-align:center">uint64</td>
<td style="text-align:center">无符号 64位整型 (0 到 18446744073709551615)</td>
</tr>
</tbody>
</table>
<p>特殊整形</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">uintptr <span class="comment"># 无符号整型，用于存放一个指针</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong> 在使用<code>int</code>和 <code>uint</code>类型时，不能假定它是32位或64位的整型，而是考虑<code>int</code>和<code>uint</code><br />
可能在不同平台上的差异。</p>
<p><strong>注意事项</strong> 获取对象的长度的内建<code>len()</code>函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或<br />
map 的元素数量等都可以用<code>int</code></p>
</blockquote>
<p>来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用<code>int</code></p>
<blockquote>
<p>和 <code>uint</code>。</p>
</blockquote>
<p>数字字面量语法（Number literals syntax</p>
<blockquote>
<p>Go1.13版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如：</p>
<ul>
<li>
<p><code>v := 0b00101101</code>， 代表二进制的 101101，相当于十进制的 45。</p>
</li>
<li>
<p><code>v := 0o377</code>，代表八进制的 377，相当于十进制的 255。</p>
</li>
<li>
<p><code>v := 0x1p-2</code>，代表十六进制的 1 除以 2²，也就是 0.25。</p>
</li>
</ul>
<p>我们可以用 <code>_</code> 来分隔数字，比如说： <code>v := 123_456</code> 表示 v 的值等于 123456。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">// 十进制</span></span><br><span class="line"> <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%d \n&quot;</span>, a)  <span class="comment">// 10</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%b \n&quot;</span>, a)  <span class="comment">// 1010  占位符%b表示二进制</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 八进制  以0开头</span></span><br><span class="line"> <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">077</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%o \n&quot;</span>, b)  <span class="comment">// 77</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 十六进制  以0x开头</span></span><br><span class="line"> <span class="keyword">var</span> c <span class="type">int</span> = <span class="number">0xff</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%x \n&quot;</span>, c)  <span class="comment">// ff</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%X \n&quot;</span>, c)  <span class="comment">// FF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="浮点型"><a class="markdownIt-Anchor" href="#浮点型"></a> 浮点型</h3>
<p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。</p>
<p>这两种浮点型数据格式遵循<code>IEEE 754</code>标准：</p>
<p><code>float32</code> 的浮点数的最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。</p>
<p><code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;%f\n&quot;</span>, math.Pi) <span class="comment">// 3.141593</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, math.Pi) <span class="comment">// 3.14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复数"><a class="markdownIt-Anchor" href="#复数"></a> 复数</h3>
<p>complex64和complex128</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"> <span class="keyword">var</span> c1 <span class="type">complex64</span></span><br><span class="line"> c1 = <span class="number">1</span> + <span class="number">2i</span></span><br><span class="line"> <span class="keyword">var</span> c2 <span class="type">complex128</span></span><br><span class="line"> c2 = <span class="number">2</span> + <span class="number">3i</span></span><br><span class="line"> fmt.Println(c1)</span><br><span class="line"> fmt.Println(c2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。</span></span><br></pre></td></tr></table></figure>
<h3 id="布尔值"><a class="markdownIt-Anchor" href="#布尔值"></a> 布尔值</h3>
<p>Go语言中以<code>bool</code>类型进行声明布尔型数据</p>
<p>布尔型数据只有<code>true（真）</code>和<code>false（假）</code>两个值。</p>
<p><strong>注意：</strong></p>
<ul>
<li>
<p>布尔类型变量的默认值为<code>false</code>。</p>
</li>
<li>
<p>Go 语言中不允许将整型强制转换为布尔型.</p>
</li>
<li>
<p>布尔型无法参与数值运算，也无法与其他类型进行转换。</p>
</li>
</ul>
<h3 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h3>
<blockquote>
<p>Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64<br />
等）一样。</p>
<p>Go 语言里的字符串的内部实现使用<code>UTF-8</code>编码。</p>
</blockquote>
<p>字符串的值为<code>双引号(&quot;&quot;)</code>中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span> = <span class="string">&quot;你好,nihao&quot;</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">string</span> = <span class="string">&quot;Hello，你好&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="byte和rune类型"><a class="markdownIt-Anchor" href="#byte和rune类型"></a> byte和rune类型</h3>
<p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’ '）包裹起来，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a := &#x27;一&#x27;</span><br><span class="line">var b := &#x27;x&#x27;</span><br></pre></td></tr></table></figure>
<p>Go 语言的字符有以下两种：</p>
<ol>
<li><code>uint8</code>类型，或者叫 byte 型，代表了<code>ASCII码</code>的一个字符。</li>
<li><code>rune</code>类型，代表一个 <code>UTF-8字符</code>。</li>
</ol>
<p>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。<code>rune</code>类型实际是一个<code>int32</code>。</p>
<p>Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte<br />
型进行默认字符串处理，性能和扩展性都有照顾。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> s := <span class="string">&quot;hello,世界&quot;</span></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123; <span class="comment">//byte</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;%v(%c) &quot;</span>, s[i], s[i])</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Println()</span><br><span class="line"> <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123; <span class="comment">//rune</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;%v(%c) &quot;</span>, r, r)</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//104(h) 101(e) 108(l) 108(l) 111(o) 44(,) 228(ä) 184(¸) 150() 231(ç) 149() 140() </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//104(h) 101(e) 108(l) 108(l) 111(o) 44(,) 19990(世) 30028(界) </span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。</p>
<p>字符串底层是一个byte数组，所以可以和<code>[]byte</code>类型相互转换。字符串是不能修改的<br />
字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。</p>
</blockquote>
<h3 id="修改字符串"><a class="markdownIt-Anchor" href="#修改字符串"></a> 修改字符串</h3>
<p>要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeString</span><span class="params">()</span></span> &#123;</span><br><span class="line"> s1 := <span class="string">&quot;big&quot;</span></span><br><span class="line"> <span class="comment">// 强制类型转换</span></span><br><span class="line"> byteS1 := []<span class="type">byte</span>(s1)</span><br><span class="line"> byteS1[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span></span><br><span class="line"> fmt.Println(<span class="type">string</span>(byteS1))</span><br><span class="line"></span><br><span class="line"> s2 := <span class="string">&quot;白萝卜&quot;</span></span><br><span class="line"> runeS2 := []<span class="type">rune</span>(s2)</span><br><span class="line"> runeS2[<span class="number">0</span>] = <span class="string">&#x27;红&#x27;</span></span><br><span class="line"> fmt.Println(<span class="type">string</span>(runeS2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型检查"><a class="markdownIt-Anchor" href="#类型检查"></a> 类型检查</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="comment">// &quot;math&quot;</span></span><br><span class="line"> <span class="string">&quot;reflect&quot;</span>  <span class="comment">// 内建包，提供类型检查函数</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> a <span class="type">int64</span> = <span class="number">1</span></span><br><span class="line"> fmt.Println(reflect.TypeOf(a)) <span class="comment">// int64</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%T&quot;</span>, a) <span class="comment">// int64</span></span><br><span class="line"> <span class="keyword">var</span> b = <span class="string">&quot;a&quot;</span></span><br><span class="line"> fmt.Println(reflect.TypeOf(b)) <span class="comment">// string</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%T&quot;</span>, b)            <span class="comment">// string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reflect.TypeOf() 源码示例</span></span><br><span class="line"><span class="comment">// TypeOf returns the reflection Type that represents the dynamic type of i.</span></span><br><span class="line"><span class="comment">// If i is a nil interface value, TypeOf returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type &#123;</span><br><span class="line"> eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line"> <span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型转换"><a class="markdownIt-Anchor" href="#类型转换"></a> 类型转换</h2>
<p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。</p>
<p>强制类型转换的基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Type(表达式)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Type表示目标转换类型。表达式包括变量、复杂算子和函数返回值等.</span></span><br></pre></td></tr></table></figure>
<p>比如计算直角三角形的斜边长时使用math包的Sqrt()<br />
函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrtDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"> <span class="keyword">var</span> c <span class="type">int</span></span><br><span class="line"> <span class="comment">// math.Sqrt()接收的参数是float64类型，需要强制转换</span></span><br><span class="line"> c = <span class="type">int</span>(math.Sqrt(<span class="type">float64</span>(a*a + b*b)))</span><br><span class="line"> fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于数字类型之间，可以通过强制转换的方式，如以下代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line"> i := 10</span><br><span class="line"> f64 := 10.102</span><br><span class="line"> i2f:=float64(i)</span><br><span class="line"> f2i:=int(f64)</span><br><span class="line"> f3 := float64(f2i)</span><br><span class="line"> fmt.Println(i2f,f2i, f3) // 10 10 10</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种使用方式比简单，采用“类型（要转换的变量）”格式即可。采用强制转换的方式转换数字类型，可能会丢失一些精度，比如浮点型转为整型时，小数点部分会全部丢失.</p>
<p>把变量转换为相应的类型后，就可以对相同类型的变量进行各种表达式运算和赋值了。</p>
<h4 id="字符串和数字互转"><a class="markdownIt-Anchor" href="#字符串和数字互转"></a> 字符串和数字互转</h4>
<p>Go 语言是强类型的语言，也就是说不同类型的变量是无法相互使用和计算的，这也是为了保证Go<br />
程序的健壮性，所以不同类型的变量在进行赋值或者计算前，需要先进行类型转换。涉及类型转换的知识点非常多，这里我先介绍这些基础类型之间的转换</p>
<p>以字符串和数字互转这种最常见的情况为例，如下面的代码所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line"> Age       <span class="type">int</span></span><br><span class="line"> Name, sex <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> i := <span class="number">10</span></span><br><span class="line"> <span class="comment">// 通过包 strconv 的 Itoa 函数可以把一个 int 类型转为 string，Atoi 函数则用来把 string 转为 int。</span></span><br><span class="line"> i2s:=strconv.Itoa(i)</span><br><span class="line"></span><br><span class="line"> s2i,err:=strconv.Atoi(i2s)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//fmt.Println(i2s,s2i,err)</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;i2s: type:%T, value:%v\n&quot;</span>, i2s, i2s)  <span class="comment">// i2s: type:string, value:10</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;s2i: type:%T, value:%v, err:%v&quot;</span>, s2i, s2i, err)  <span class="comment">// s2i: type:int, value:10, &lt;nil&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> 补充</h2>
<h3 id="占位的相关用法"><a class="markdownIt-Anchor" href="#占位的相关用法"></a> 占位的相关用法</h3>
<p>golang 的fmt 包实现了格式化I/O函数，类似于C的 printf 和 scanf。Python中的print等</p>
<h4 id="普通占位符"><a class="markdownIt-Anchor" href="#普通占位符"></a> 普通占位符</h4>
<table>
<thead>
<tr>
<th style="text-align:left">占位符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%v</td>
<td style="text-align:center">相应值的默认格式。</td>
</tr>
<tr>
<td style="text-align:left">%+v</td>
<td style="text-align:center">打印结构体时，会添加字段名</td>
</tr>
<tr>
<td style="text-align:left">%#v</td>
<td style="text-align:center">相应值的Go语法表示</td>
</tr>
<tr>
<td style="text-align:left">%T</td>
<td style="text-align:center">相应值的类型的Go语法表示</td>
</tr>
<tr>
<td style="text-align:left">%%</td>
<td style="text-align:center">字面上的百分号，并非值的占位符</td>
</tr>
<tr>
<td style="text-align:left">布尔占位符 (%t)</td>
<td style="text-align:center">true 或 false</td>
</tr>
</tbody>
</table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line"> Age       <span class="type">int</span></span><br><span class="line"> Name, sex <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> people := Human&#123;Name: <span class="string">&quot;Payne&quot;</span>, Age: <span class="number">20</span>, sex: <span class="string">&quot;male&quot;</span>&#125;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;%v&quot;</span>, people)  <span class="comment">// &#123;20 Payne male&#125;</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%+v&quot;</span>, people) <span class="comment">// &#123;20 Payne male&#125;&#123;Age:20 Name:Payne sex:male&#125;</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%#v&quot;</span>, people) <span class="comment">// &#123;20 Payne male&#125;&#123;Age:20 Name:Payne sex:male&#125;main.Human&#123;Age:20, Name:&quot;Payne&quot;, sex:&quot;male&quot;&#125;</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%T&quot;</span>, people)  <span class="comment">// main.Human</span></span><br><span class="line"> <span class="comment">//fmt.Printf(&quot;%%&quot;)  // main.Humanß</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="整数占位符"><a class="markdownIt-Anchor" href="#整数占位符"></a> 整数占位符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">占位符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%b</td>
<td style="text-align:center">二进制表示</td>
</tr>
<tr>
<td style="text-align:center">%o</td>
<td style="text-align:center">八进制表示</td>
</tr>
<tr>
<td style="text-align:center">%d</td>
<td style="text-align:center">十进制表示</td>
</tr>
<tr>
<td style="text-align:center">%x</td>
<td style="text-align:center">十六进制表示(小写)</td>
</tr>
<tr>
<td style="text-align:center">%X</td>
<td style="text-align:center">十六进制表示(大写)</td>
</tr>
<tr>
<td style="text-align:center">%f</td>
<td style="text-align:center">有小数点而无指数，例如 123.456浮点数</td>
</tr>
<tr>
<td style="text-align:center">%c</td>
<td style="text-align:center">相应Unicode码点所表示的字符</td>
</tr>
<tr>
<td style="text-align:center">%q</td>
<td style="text-align:center">单引号围绕的字符字面值，由Go语法安全地转义</td>
</tr>
<tr>
<td style="text-align:center">%U</td>
<td style="text-align:center">Unicode格式：U+1234，等同于 “U+%04X”</td>
</tr>
</tbody>
</table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// 定义十进制变量a</span></span><br><span class="line"> <span class="comment">//a := 542</span></span><br><span class="line"> <span class="comment">// 数字</span></span><br><span class="line"> <span class="comment">//fmt.Printf(&quot; Binary: %d,\n Octal: %o,\n Decimal:%d,\n Hex: %x,\n Uppercase_hexadecimal:%X&quot;, a, a, a, a, a)</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Binary: 542,</span></span><br><span class="line"><span class="comment">  Octal: 1036,</span></span><br><span class="line"><span class="comment">  Decimal:542,</span></span><br><span class="line"><span class="comment">  Hex: 21e,</span></span><br><span class="line"><span class="comment">  Uppercase_hexadecimal:21E</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%c&quot;</span>, <span class="number">0x3E2E</span>) <span class="comment">// 㸮</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%q&quot;</span>, <span class="number">0x3E2E</span>) <span class="comment">// &#x27;㸮&#x27;</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;%f\n&quot;</span>, <span class="number">100.1000201</span>)     <span class="comment">// 100.100020</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%.1f\n&quot;</span>, <span class="number">100.1000201</span>)   <span class="comment">// 100.1</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, <span class="number">100.1000201</span>)   <span class="comment">// 100.10</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%.3f\n&quot;</span>, <span class="number">100.1000201</span>)   <span class="comment">// 100.100</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%.4f\n&quot;</span>, <span class="number">100.1000201</span>)   <span class="comment">// 100.1000</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="浮点数和复数的组成部分实部和虚部"><a class="markdownIt-Anchor" href="#浮点数和复数的组成部分实部和虚部"></a> 浮点数和复数的组成部分（实部和虚部）</h4>
<table>
<thead>
<tr>
<th style="text-align:center">占位符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%e</td>
<td style="text-align:center">科学计数法，例如 -1234.456e+78</td>
</tr>
<tr>
<td style="text-align:center">%E</td>
<td style="text-align:center">科学计数法，例如 -1234.456E+78</td>
</tr>
<tr>
<td style="text-align:center">%g</td>
<td style="text-align:center">根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出</td>
</tr>
<tr>
<td style="text-align:center">%G</td>
<td style="text-align:center">根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出</td>
</tr>
</tbody>
</table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> a := math.Pow(<span class="number">20</span>, <span class="number">3</span>) <span class="comment">// 8000</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%e\n&quot;</span>, a) <span class="comment">// 8.000000e+03</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%E\n&quot;</span>, a) <span class="comment">// 8.000000E+03</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%g\n&quot;</span>, <span class="number">10.20</span>)    <span class="comment">// 10.2</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%G\n&quot;</span>, <span class="number">10.20</span>+<span class="number">2i</span>) <span class="comment">// (10.2+2i)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="字符串与字节切片"><a class="markdownIt-Anchor" href="#字符串与字节切片"></a> 字符串与字节切片</h4>
<table>
<thead>
<tr>
<th style="text-align:left">占位符</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">举例</th>
<th style="text-align:center">输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%s</td>
<td style="text-align:center">输出字符串表示（string类型或[]byte)</td>
<td style="text-align:center">Printf(“%s”, []byte(“Go语言”))</td>
<td style="text-align:center">Go语言</td>
</tr>
<tr>
<td style="text-align:left">%q</td>
<td style="text-align:center">双引号围绕的字符串，由Go语法安全地转义</td>
<td style="text-align:center">Printf(“%q”, “Go语言”)</td>
<td style="text-align:center">“Go语言”</td>
</tr>
<tr>
<td style="text-align:left">%x</td>
<td style="text-align:center">十六进制，小写字母，每字节两个字符</td>
<td style="text-align:center">Printf(“%x”, “golang”)</td>
<td style="text-align:center">676f6c616e67</td>
</tr>
<tr>
<td style="text-align:left">%X</td>
<td style="text-align:center">十六进制，大写字母，每字节两个字符</td>
<td style="text-align:center">Printf(“%X”, “golang”)</td>
<td style="text-align:center">676F6C616E67</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"> //a := &quot;golang编程语言&quot;</span><br><span class="line"> fmt.Printf(&quot;%s\n&quot;, []byte(a))     // golang编程语言</span><br><span class="line"> fmt.Printf(&quot;%q\n&quot;, []byte(a))     // golang编程语言</span><br><span class="line"> fmt.Printf(&quot;%x\n&quot;, []byte(a))     // 676f6c616e67e7bc96e7a88be8afade8a880</span><br><span class="line"> fmt.Printf(&quot;%X\n&quot;, []byte(a))     // 676F6C616E67E7BC96E7A88BE8AFADE8A880</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="6指针"><a class="markdownIt-Anchor" href="#6指针"></a> 6)指针</h4>
<table>
<thead>
<tr>
<th style="text-align:left">占位符</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">举例</th>
<th style="text-align:center">输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%p</td>
<td style="text-align:center">十六进制表示，前缀 0x</td>
<td style="text-align:center">Printf(“%p”, &amp;people)</td>
<td style="text-align:center">0x4f57f0</td>
</tr>
</tbody>
</table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// 地址值</span></span><br><span class="line"> a := <span class="number">10</span></span><br><span class="line"> <span class="keyword">var</span> b []<span class="type">int</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;a)    <span class="comment">// 0xc000014080</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;b)    <span class="comment">// 0xc0000a6020</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="strings"><a class="markdownIt-Anchor" href="#strings"></a> Strings</h3>
<p>Strings 包 讲到基础类型，尤其是字符串，不得不提 Go SDK 为我们提供的一个标准包<br />
strings。它是用于处理字符串的工具包，里面有很多常用的函数，帮助我们对字符串进行操作，比如查找字符串、去除字符串的空格、拆分字符串、判断字符串是否有某个前缀或者后缀等。掌握好它，有利于我们的高效编程。</p>
<p>以下代码是我写的关于 strings<br />
包的一些例子，你自己可以根据<span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcuZ29vZ2xlLmNuL3BrZy9zdHJpbmdzLw==">strings 文档<i class="fa fa-external-link-alt"></i></span><br />
或者$GOPATH/src/stringls.go.以及自己写一些示例，多练习熟悉它们。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> s1 := <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"> <span class="comment">//判断s1的前缀是否是H</span></span><br><span class="line"> fmt.Println(strings.HasPrefix(s1,<span class="string">&quot;H&quot;</span>)) <span class="comment">// true</span></span><br><span class="line"> <span class="comment">//在s1中查找字符串o</span></span><br><span class="line"> fmt.Println(strings.Index(s1,<span class="string">&quot;o&quot;</span>))     <span class="comment">// 4</span></span><br><span class="line"> <span class="comment">//把s1全部转为大写</span></span><br><span class="line"> fmt.Println(strings.ToUpper(s1))              <span class="comment">// HELLO WORLD</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// s1 中是否包含某一个或一段字符串</span></span><br><span class="line"> fmt.Println(strings.Contains(s1, <span class="string">&quot;ee &quot;</span>)) <span class="comment">// false</span></span><br><span class="line"> fmt.Println(strings.Contins(s1, <span class="string">&quot;e&quot;</span>))   <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="referer"><a class="markdownIt-Anchor" href="#referer"></a> referer</h2>
<p><a href="https://golang.google.cn/src/fmt/doc.go"><code>fmt</code></a></p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang常量-变量-匿名变量</title>
    <url>/29980.html</url>
    <content><![CDATA[<blockquote>
<p>常量：一旦声明即不可被改变</p>
<p>变量：声明后可以发生改变。若初始化后未赋值则为初始值</p>
<p>例如：</p>
<p>int -&gt; 0</p>
<p>Bool -&gt; false</p>
<p>String -&gt; 空</p>
</blockquote>
<h2 id="关键字与保留字"><a class="markdownIt-Anchor" href="#关键字与保留字"></a> 关键字与保留字</h2>
<p>关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。</p>
<span id="more"></span>
<p>关键字</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span>        <span class="keyword">default</span>      <span class="function"><span class="keyword">func</span>         <span class="title">interface</span>    <span class="title">select</span></span></span><br><span class="line">   <span class="keyword">case</span>         <span class="keyword">defer</span>        <span class="keyword">go</span>           <span class="keyword">map</span>          <span class="keyword">struct</span></span><br><span class="line">   <span class="keyword">chan</span>         <span class="keyword">else</span>         <span class="keyword">goto</span>         <span class="keyword">package</span>      <span class="keyword">switch</span></span><br><span class="line">   <span class="keyword">const</span>        <span class="keyword">fallthrough</span>  <span class="keyword">if</span>           <span class="keyword">range</span>        <span class="keyword">type</span></span><br><span class="line">   <span class="keyword">continue</span>     <span class="keyword">for</span>          <span class="keyword">import</span>       <span class="keyword">return</span>       <span class="keyword">var</span></span><br></pre></td></tr></table></figure>
<p>保留字</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Constants:    <span class="literal">true</span>  <span class="literal">false</span>  <span class="literal">iota</span>  <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    Types:    <span class="type">int</span>  <span class="type">int8</span>  <span class="type">int16</span>  <span class="type">int32</span>  <span class="type">int64</span>  </span><br><span class="line">              <span class="type">uint</span>  <span class="type">uint8</span>  <span class="type">uint16</span>  <span class="type">uint32</span>  <span class="type">uint64</span>  <span class="type">uintptr</span></span><br><span class="line">              <span class="type">float32</span>  <span class="type">float64</span>  <span class="type">complex128</span>  <span class="type">complex64</span></span><br><span class="line">              <span class="type">bool</span>  <span class="type">byte</span>  <span class="type">rune</span>  <span class="type">string</span>  <span class="type">error</span></span><br><span class="line"></span><br><span class="line">Functions:   <span class="built_in">make</span>  <span class="built_in">len</span>  <span class="built_in">cap</span>  <span class="built_in">new</span>  <span class="built_in">append</span>  <span class="built_in">copy</span>  <span class="built_in">close</span>  <span class="built_in">delete</span></span><br><span class="line">             <span class="built_in">complex</span>  <span class="built_in">real</span>  <span class="built_in">imag</span></span><br><span class="line">             <span class="built_in">panic</span>  <span class="built_in">recover</span></span><br></pre></td></tr></table></figure>
<h2 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h2>
<h3 id="变量的来历"><a class="markdownIt-Anchor" href="#变量的来历"></a> 变量的来历</h3>
<p>程序运行过程中的数据都是保存在内存中，我们想要在代码中操作某个数据时就需要去内存上找到这个变量，但是如果我们直接在代码中通过内存地址去操作变量的话，代码的可读性会非常差而且还容易出错，所以我们就利用变量将这个数据的内存地址保存起来，以后直接通过这个变量就能找到内存上对应的数据了。</p>
<blockquote>
<p>相当于开辟相对应的内存，并对此内存取了个别名。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">string</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment">// 申请一块内存，把字符串hello放进去</span></span><br><span class="line">并它的地址为指向变量名 a</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="变量类型"><a class="markdownIt-Anchor" href="#变量类型"></a> 变量类型</h3>
<p>变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有：整型、浮点型、布尔型等。</p>
<p>Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。</p>
<h3 id="变量声明"><a class="markdownIt-Anchor" href="#变量声明"></a> 变量声明</h3>
<p>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。 并且Go语言的变量声明后必须使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标准声明</span></span><br><span class="line"><span class="keyword">var</span> 变量名 类型</span><br><span class="line"><span class="comment">// 类型推到声明，必须有初始值， 否则声明失败</span></span><br><span class="line"><span class="keyword">var</span> 变量名 = 值</span><br><span class="line"><span class="comment">// 简短声明（必须在函数中）</span></span><br><span class="line">变量名 := 值</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量声明(多用于全局变量声明)，类型为必须</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  变量名 类型</span><br><span class="line">   变量名 类型</span><br><span class="line">   变量名 类型</span><br><span class="line">  。。。</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 同类型批量声明</span></span><br><span class="line"><span class="keyword">var</span> 变量名<span class="number">1</span>，变量名<span class="number">2</span>，变量名<span class="number">3</span> 类型</span><br><span class="line">或</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"> 变量名<span class="number">1</span>,</span><br><span class="line"> 变量名<span class="number">2</span>, </span><br><span class="line"> 变量名<span class="number">3</span> <span class="type">string</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简短批量声明 注意必须在函数中</span></span><br><span class="line">变量名<span class="number">1</span>,变量名<span class="number">2</span>, 变量名<span class="number">3</span> := 值<span class="number">1</span>，值<span class="number">2</span>， 值<span class="number">3</span> </span><br></pre></td></tr></table></figure>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准声明</span></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;Payne&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型推到声明</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//批量声明</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"> x <span class="type">string</span></span><br><span class="line"> y <span class="type">string</span></span><br><span class="line"> j <span class="type">bool</span></span><br><span class="line"> k <span class="type">byte</span></span><br><span class="line"> z <span class="type">int</span></span><br><span class="line"> </span><br><span class="line">)</span><br><span class="line"><span class="comment">// 同类型批量声明</span></span><br><span class="line"><span class="keyword">var</span> a, b, c, d <span class="type">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// 简短声明</span></span><br><span class="line"> hobby := <span class="string">&quot;programming&quot;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//测试输入</span></span><br><span class="line"> fmt.Println(<span class="string">&quot;Name is :&quot;</span>, name) <span class="comment">// Name is : Payne</span></span><br><span class="line"> fmt.Println(<span class="string">&quot;Age is :&quot;</span>, age) <span class="comment">// Age is : 20</span></span><br><span class="line"> fmt.Println(<span class="string">&quot;hobby &quot;</span>, hobby) <span class="comment">// hobby  programming</span></span><br><span class="line"> fmt.Print(a) <span class="comment">// 0 声明未赋值采用初始值。int 类型初始值为0</span></span><br><span class="line"> <span class="comment">// 批量简短声明</span></span><br><span class="line"> a, b := <span class="number">1</span>, <span class="string">&quot;string&quot;</span></span><br><span class="line"> fmt.Print(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匿名变量"><a class="markdownIt-Anchor" href="#匿名变量"></a> 匿名变量</h3>
<blockquote>
<p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 (在<code>Lua</code><br />
等编程语言里，匿名变量也被叫做哑元变量。)</p>
</blockquote>
<p>在使用多重赋值时，如果想要忽略某个值，可以使用<code>匿名变量（anonymous variable）</code>。 匿名变量用一个下划线<code>_</code><br />
表示，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里可能会有点绕，仅仅是为了使用“_”，而使用_</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> (<span class="type">string</span>, <span class="type">int</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span>  <span class="string">&quot;payne&quot;</span>, <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> name, _ := foo()</span><br><span class="line"> _, age := foo()</span><br><span class="line"> fmt.Println(<span class="string">&quot;name=&quot;</span>, name) <span class="comment">//name= payne</span></span><br><span class="line"> fmt.Println(<span class="string">&quot;age=&quot;</span>, age) <span class="comment">//age= 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意事项：</p>
<ol>
<li>函数外的每个语句都必须以关键字开始（var、const、func等）</li>
<li><code>_</code>多用于占位，表示忽略值。</li>
</ol>
</blockquote>
<h2 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h2>
<p>常量与变量的声明基本一致，类型一致。若有声明变化的话那就是将关键字<code>var</code>， 替换成了<code>const</code>.增加了<code>iota</code><br />
，减少了简短声明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常量声明声明时必须给值，否则则定义失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准声明</span></span><br><span class="line"><span class="keyword">const</span> 变量名 类型 = 值</span><br><span class="line"><span class="comment">// 类型推导</span></span><br><span class="line"><span class="keyword">const</span> 变量名  = 值</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="string">&quot;2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> fmt.Println(a) <span class="comment">// 1</span></span><br><span class="line"> fmt.Println(b) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="iota"><a class="markdownIt-Anchor" href="#iota"></a> Iota</h3>
<p><code>iota</code>是go语言的常量计数器，只能在常量的表达式中使用。</p>
<p><code>iota</code>在const关键字出现时将被重置为0。const中每新增一行常量声明将使<code>iota</code>计数一次(<br />
iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `iota`在const关键字出现时将被重置为0,请牢记！！</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">  n2        <span class="comment">//1</span></span><br><span class="line">  n3        <span class="comment">//2</span></span><br><span class="line">  n4        <span class="comment">//3</span></span><br><span class="line"> )</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 使用_跳过某些值</span></span><br><span class="line"> <span class="keyword">const</span> (</span><br><span class="line">  n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">  n2        <span class="comment">//1</span></span><br><span class="line">  _</span><br><span class="line">  n4        <span class="comment">//3</span></span><br><span class="line"> )</span><br><span class="line"><span class="comment">// iota声明中间插队</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">  n2 = <span class="number">100</span>  <span class="comment">//100</span></span><br><span class="line">  n3 = <span class="literal">iota</span> <span class="comment">//2</span></span><br><span class="line">  n4        <span class="comment">//3</span></span><br><span class="line"> )</span><br><span class="line"> <span class="keyword">const</span> n5 = <span class="literal">iota</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h2 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> 补充</h2>
<h3 id="常量与变量的对比示例"><a class="markdownIt-Anchor" href="#常量与变量的对比示例"></a> 常量与变量的对比示例</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主要体现为 变量可以被修改</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"> fmt.Println(a) <span class="comment">// 1</span></span><br><span class="line"> a = <span class="number">2</span></span><br><span class="line"> fmt.Println(a) <span class="comment">// 2</span></span><br><span class="line"> <span class="keyword">const</span> b = <span class="number">3</span></span><br><span class="line"> fmt.Println(b) <span class="comment">// 3</span></span><br><span class="line"> b = <span class="number">4</span></span><br><span class="line"> fmt.Print(b) <span class="comment">// Error: cannot assign to b</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数的初探"><a class="markdownIt-Anchor" href="#函数的初探"></a> 函数的初探</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(形参)</span></span> (返回值类型) &#123;</span><br><span class="line"> 表达式</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">函数名(实参)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种方式（匿名函数）</span></span><br><span class="line"><span class="keyword">var</span> 函数名 = <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line"> 表达式</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">函数名(实参)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名立即执行函数</span></span><br><span class="line"><span class="keyword">var</span> 函数名 = <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line"> 表达式</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 此时的函数为结果的值</span></span><br></pre></td></tr></table></figure>
<h3 id="函数的调用的顺序"><a class="markdownIt-Anchor" href="#函数的调用的顺序"></a> 函数的调用的顺序</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> a = <span class="number">2</span></span><br><span class="line"> fmt.Print(a) <span class="comment">//  2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思考：</p>
<p>为什么打印的是2？</p>
<p>原因为<code>函数</code>参数的调用采用<code>就近的原则</code></p>
</blockquote>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang并发深入了解</title>
    <url>/34063.html</url>
    <content><![CDATA[<h2 id="协程控制需要"><a class="markdownIt-Anchor" href="#协程控制需要"></a> 协程控制需要</h2>
<p>重学编程之Golang的plan中的上一篇文章我向大家介绍了，<code>并发编程基础</code>，<code>goroutine的创建</code>，<code>channel</code><br />
，正由于go语言的简洁性,我们可以简易快速的创建任意个协程。同时也留下了许多隐患，如果没有更加深入的学习，其实很难直接将其运用到实际项目中，实际生活中。为什么呢？并发的场景许许多多，但一味的只知道其创建，是很难有效的解决问题。例如以下场景-资源竞争</p>
<span id="more"></span>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 公共资源</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> sum += i</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">//开启1000个协程让sum+1</span></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> add(<span class="number">1</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//防止提前退出</span></span><br><span class="line"> time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line"> fmt.Println(<span class="string">&quot;和为:&quot;</span>, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也许你的期望值是1000,可惜结果总会差强人意，造成其终究原因是资源竞争，也就是当<code>goroutine1</code><br />
与<code>goroutineN</code>多次执行了同一步骤</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gldr8ifn5pj31aa0ti7al.jpg" style="zoom:25%;" /><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gldr9uujd0j31dn0u0n4z.jpg" style="zoom:25%;" /></p>
<h2 id="协程控制原理与实现"><a class="markdownIt-Anchor" href="#协程控制原理与实现"></a> 协程控制原理与实现</h2>
<p>协程的控制原理基本是就是加各种锁，防止<code>意外</code><br />
发送，牺牲无序的高速，带来相对有序正确执行。例如<code>互斥锁、读写锁、等等</code></p>
<h3 id="同任务唯一执行-互斥锁"><a class="markdownIt-Anchor" href="#同任务唯一执行-互斥锁"></a> 同任务唯一执行-互斥锁</h3>
<p><strong>互斥锁</strong>（英语：Mutual exclusion，缩写<br />
Mutex）是一种用于<span class="exturl" data-url="aHR0cHM6Ly9iay50dy5sdmZ1a2VqaS5jb20vYmFpa2UtJUU1JUE0JTlBJUU3JUJBJUJGJUU3JUE4JThC">多线程<i class="fa fa-external-link-alt"></i></span><span class="exturl" data-url="aHR0cHM6Ly9iay50dy5sdmZ1a2VqaS5jb20vYmFpa2UtJUU3JUJDJTk2JUU3JUE4JThC">编程<i class="fa fa-external-link-alt"></i></span><br />
中，防止两条<span class="exturl" data-url="aHR0cHM6Ly9iay50dy5sdmZ1a2VqaS5jb20vYmFpa2UtJUU3JUJBJUJGJUU3JUE4JThC">线程<i class="fa fa-external-link-alt"></i></span><br />
同时对同一公共资源（比如<span class="exturl" data-url="aHR0cHM6Ly9iay50dy5sdmZ1a2VqaS5jb20vYmFpa2UtJUU1JTg1JUE4JUU1JTlGJTlGJUU4JUFFJThBJUU2JTk1JUI4">全局变量<i class="fa fa-external-link-alt"></i></span><br />
）进行读写的机制。该目的通过将代码切片成一个一个的<span class="exturl" data-url="aHR0cHM6Ly9iay50dy5sdmZ1a2VqaS5jb20vYmFpa2UtJUU0JUI4JUI0JUU3JTk1JThDJUU1JThDJUJBJUU1JTlGJTlG">临界区域<i class="fa fa-external-link-alt"></i></span><br />
（critical<br />
section）达成。临界区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。一个程序、进程、线程可以拥有多个临界区域，但是并不一定会应用互斥锁。</p>
<p>例如：一段代码（甲）正在分步修改一块数据。这时，另一条线程（乙）由于一些原因被唤醒。如果乙此时去读取甲正在修改的数据，而甲碰巧还没有完成整个修改过程，这个时候这块数据的状态就处在极大的不确定状态中，读取到的数据当然也是有问题的。更严重的情况是乙也往这块地方写数据，这样的一来，后果将变得不可收拾。因此，多个线程间共享的数据必须被保护。达到这个目的的方法，就是确保同一时间只有一个临界区域处于运行状态，而其他的临界区域，无论是读是写，都必须被挂起并且不能获得运行机会。</p>
<p>在golang里面实现互斥锁也非常的粗暴，简单可分为三步，声明互斥锁，加锁、执行业务代码、释放锁、下一次执行步骤。更深入理解可参考<span class="exturl" data-url="aHR0cHM6Ly9iay50dy5sdmZ1a2VqaS5jb20vd2lraS8lRTQlQkElOTIlRTYlOTYlQTUlRTklOTQlODE=">wiki互斥锁<i class="fa fa-external-link-alt"></i></span><br />
，示例如下</p>
<p>示例一：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;sync&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"> sum <span class="type">int</span>  <span class="comment">// 全局资源sum</span></span><br><span class="line"> mutex sync.Mutex  <span class="comment">// 互斥锁</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> mutex.Lock()  <span class="comment">// 加锁</span></span><br><span class="line"> sum += i    <span class="comment">// 执行业务代码</span></span><br><span class="line"> mutex.Unlock() <span class="comment">// 释放锁，进行下一步骤</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">//开启1000个协程让sum+1</span></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> add(<span class="number">1</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//防止提前退出</span></span><br><span class="line"> time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line"> fmt.Println(<span class="string">&quot;和为:&quot;</span>, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例二：当我们的业务代码不再是如此简单，可能会忘记释放互斥锁，而造成BUG，我们可以借助<code>defer</code>关键字，以免忘记</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;sync&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"> sum <span class="type">int</span>  <span class="comment">// 全局资源sum</span></span><br><span class="line"> mutex sync.Mutex  <span class="comment">// 互斥锁</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> mutex.Lock()</span><br><span class="line"> <span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line"> sum += i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">//开启1000个协程让sum+1</span></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> add(<span class="number">1</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//防止提前退出</span></span><br><span class="line"> time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line"> fmt.Println(<span class="string">&quot;和为:&quot;</span>, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用互斥锁能够保证同一时间有且只有一个<code>goroutine</code>进入临界区，其他的<code>goroutine</code><br />
则在等待锁；当互斥锁释放后，等待的<code>goroutine</code>才可以获取锁进入临界区，多个<code>goroutine</code>同时等待一个锁时，**<br />
唤醒的策略是随机的**。</p>
<h3 id="读多写少-读少写多-读写锁"><a class="markdownIt-Anchor" href="#读多写少-读少写多-读写锁"></a> 读多写少、读少写多-读写锁</h3>
<p>现在我们解决了多个 goroutine 同时读写的资源竞争问题，但是又遇到另外一个问题——性能。因为每次读写共享资源都要加锁，所以性能低下。</p>
<p>这个特殊场景的出现，有以下几种情况：</p>
<ol>
<li>写的时候不能同时读，因为这个时候读取的话可能读到脏数据（不正确的数据）；</li>
<li>读的时候不能同时写，因为也可能产生不可预料的结果；</li>
<li>读的时候可以同时读，因为数据不会改变，所以不管多少个 goroutine 读都是并发安全的。</li>
</ol>
<p>所以就可以通过读写锁 sync.RWMutex 来优化这段代码，提升性能。现在我将以上示例改为读写锁，来实现我们想要的结果，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;sync&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"> sum <span class="type">int</span> <span class="comment">// 全局资源sum</span></span><br><span class="line"> mutex sync.Mutex  <span class="comment">// 互斥锁</span></span><br><span class="line"> mutexRW sync.RWMutex <span class="comment">// 读写锁</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处为写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> <span class="comment">// 互斥锁</span></span><br><span class="line"> mutex.Lock()</span><br><span class="line"> <span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line"> sum += i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加了一个读取的函数，便于演示并发读业务场景</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readSum</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line"> <span class="comment">//只获取读锁</span></span><br><span class="line"> mutexRW.RLock()</span><br><span class="line"> <span class="keyword">defer</span> mutexRW.RUnlock()</span><br><span class="line"> b := sum</span><br><span class="line"> <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// 开启 1000个</span></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> add(<span class="number">1</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> fmt.Println(<span class="string">&quot;和为:&quot;</span>, readSum())</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 防止提前退出</span></span><br><span class="line"> time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高效率决策完成时间-waitgroup"><a class="markdownIt-Anchor" href="#高效率决策完成时间-waitgroup"></a> 高效率决策完成时间-WaitGroup</h3>
<p>相信你注意到了这段 time.Sleep(2 * time.Second) 代码，这是为了防止主函数 main 返回使用，一旦 main<br />
函数返回了，程序也就退出了。因为我们不知道 10000 个执行 add 的协程和 10 个执行<br />
readSum 的协程什么时候完全执行完毕，所以设置了一个比较长的等待时间。</p>
<p>但在实际的项目，如果运行一个较大的业务，需要运行的时间，我们无法预估，且并不合理。那我们该如何解决它？其实我们可以使用<code>WaitGroup</code><br />
来进行阻塞主程序，防止退出。在这里相当实现了一个<code>生产者</code>与<code>消费者</code>模型</p>
<p>示例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;math&quot;</span></span><br><span class="line"> <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"> sum     <span class="type">int</span>          <span class="comment">// 全局资源sum</span></span><br><span class="line"> mutex   sync.Mutex   <span class="comment">// 互斥锁</span></span><br><span class="line"> mutexRW sync.RWMutex <span class="comment">// 读写锁</span></span><br><span class="line"> round =  <span class="type">int</span>(math.Pow(<span class="number">100</span>, <span class="number">2</span>)) + <span class="number">100</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> <span class="comment">// 互斥锁</span></span><br><span class="line"> mutex.Lock()</span><br><span class="line"> <span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line"> sum += i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readSum</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line"> <span class="comment">//只获取读锁</span></span><br><span class="line"> mutexRW.RLock()</span><br><span class="line"> <span class="keyword">defer</span> mutexRW.RUnlock()</span><br><span class="line"> b := sum</span><br><span class="line"> <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"> <span class="comment">//因为要监控110个协程，所以设置计数器为110</span></span><br><span class="line"> <span class="comment">//round =  int(math.Pow(100, 2)) + 100</span></span><br><span class="line"> wg.Add(round)</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//计数器值减1</span></span><br><span class="line">   <span class="keyword">defer</span> wg.Done()</span><br><span class="line">   add(<span class="number">10</span>)</span><br><span class="line">  &#125;()</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(math.Pow(<span class="number">100</span>, <span class="number">2</span>)); i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//计数器值减1</span></span><br><span class="line">   <span class="keyword">defer</span> wg.Done()</span><br><span class="line">   fmt.Println(<span class="string">&quot;和为:&quot;</span>, readSum())</span><br><span class="line">  &#125;()</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//一直等待，直到计数器值为0</span></span><br><span class="line"> wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<ul>
<li>
<p>在这里的生产者<code>round</code>与总消费者的和必须相等。</p>
</li>
<li>
<p><code>sync.WaitGroup</code>是一个结构体，传递的时候要传递指针。</p>
</li>
</ul>
</blockquote>
<h3 id="执行且只执行一次协程单例-synconce"><a class="markdownIt-Anchor" href="#执行且只执行一次协程单例-synconce"></a> 执行且只执行一次协程单例-sync.Once</h3>
<p>在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。</p>
<p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案–<code>sync.Once</code>。</p>
<p><code>sync.Once</code>只有一个<code>Do</code>方法，其签名如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;&#125;</span><br><span class="line"><span class="comment">// *备注：如果要执行的函数`f`需要传递参数就需要搭配闭包来使用。*</span></span><br></pre></td></tr></table></figure>
<h4 id="加载配置文件示例"><a class="markdownIt-Anchor" href="#加载配置文件示例"></a> 加载配置文件示例</h4>
<p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="type">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line"> icons = <span class="keyword">map</span>[<span class="type">string</span>]image.Image&#123;</span><br><span class="line">  <span class="string">&quot;left&quot;</span>:  loadIcon(<span class="string">&quot;left.png&quot;</span>),</span><br><span class="line">  <span class="string">&quot;up&quot;</span>:    loadIcon(<span class="string">&quot;up.png&quot;</span>),</span><br><span class="line">  <span class="string">&quot;right&quot;</span>: loadIcon(<span class="string">&quot;right.png&quot;</span>),</span><br><span class="line">  <span class="string">&quot;down&quot;</span>:  loadIcon(<span class="string">&quot;down.png&quot;</span>),</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 被多个goroutine调用时不是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123;</span><br><span class="line"> <span class="keyword">if</span> icons == <span class="literal">nil</span> &#123;</span><br><span class="line">  loadIcons()</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多个<code>goroutine</code>并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个<code>goroutine</code><br />
都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line"> icons = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]image.Image)</span><br><span class="line"> icons[<span class="string">&quot;left&quot;</span>] = loadIcon(<span class="string">&quot;left.png&quot;</span>)</span><br><span class="line"> icons[<span class="string">&quot;up&quot;</span>] = loadIcon(<span class="string">&quot;up.png&quot;</span>)</span><br><span class="line"> icons[<span class="string">&quot;right&quot;</span>] = loadIcon(<span class="string">&quot;right.png&quot;</span>)</span><br><span class="line"> icons[<span class="string">&quot;down&quot;</span>] = loadIcon(<span class="string">&quot;down.png&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下就会出现即使判断了<code>icons</code><br />
不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化<code>icons</code><br />
的时候不会被其他的<code>goroutine</code>操作，但是这样做又会引发性能问题。</p>
<p>使用<code>sync.Once</code>改造的示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> （</span><br><span class="line"> icons <span class="keyword">map</span>[<span class="type">string</span>]image.Image </span><br><span class="line"> loadIconsOnce sync.Once</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line"> icons = <span class="keyword">map</span>[<span class="type">string</span>]image.Image&#123;</span><br><span class="line">  <span class="string">&quot;left&quot;</span>:  loadIcon(<span class="string">&quot;left.png&quot;</span>),</span><br><span class="line">  <span class="string">&quot;up&quot;</span>:    loadIcon(<span class="string">&quot;up.png&quot;</span>),</span><br><span class="line">  <span class="string">&quot;right&quot;</span>: loadIcon(<span class="string">&quot;right.png&quot;</span>),</span><br><span class="line">  <span class="string">&quot;down&quot;</span>:  loadIcon(<span class="string">&quot;down.png&quot;</span>),</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image &#123;</span><br><span class="line"> loadIconsOnce.Do(loadIcons)</span><br><span class="line"> <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="并发安全的单例"><a class="markdownIt-Anchor" href="#并发安全的单例"></a> 并发安全的单例</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doOnce</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// 声明协程单例</span></span><br><span class="line"> <span class="keyword">var</span> once sync.Once</span><br><span class="line"> onceBody := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Only Once Do&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 建立搞并发场景</span></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 实现仅实现一次</span></span><br><span class="line">   once.Do(onceBody)</span><br><span class="line">  &#125;()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> doOnce()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="协控制随心所欲-synccond"><a class="markdownIt-Anchor" href="#协控制随心所欲-synccond"></a> 协控制随心所欲-sync.Cond</h3>
<p>在 Go 语言中，sync.WaitGroup 用于最终完成的场景，关键点在于一定要等待所有协程都执行完毕。</p>
<p>而 sync.Cond 可以用于发号施令，一声令下所有协程都可以开始执行，关键点在于协程开始的时候是等待的，要等待<br />
sync.Cond 唤醒才能执行。</p>
<p>sync.Cond 从字面意思看是条件变量，它具有阻塞协程和唤醒协程的功能，所以可以在满足一定条件的情况下唤醒协程，但条件变量只是它的一种使用场景。</p>
<p>sync.Cond 有三个方法，它们分别是：</p>
<ol>
<li><strong>Wait</strong>，阻塞当前协程，直到被其他协程调用 Broadcast 或者 Signal 方法唤醒，使用的时候需要加锁，使用<br />
sync.Cond 中的锁即可，也就是 L 字段。</li>
<li><strong>Signal</strong>，唤醒一个等待时间最长的协程。</li>
<li><strong>Broadcast</strong>，唤醒所有等待的协程。</li>
</ol>
<blockquote>
<p>在调用 Signal 或者 Broadcast 之前，要确保目标协程处于 Wait 阻塞状态，不然会出现死锁问题。</p>
</blockquote>
<p>下面我们以 10 个人赛跑为例来演示 sync.Cond 的用法。在这个示例中有一个裁判，裁判要先等这 10<br />
个人准备就绪，然后一声发令枪响，这 10 个人就可以开始跑了，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;sync&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//10个人赛跑，1个裁判发号施令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">race</span><span class="params">()</span></span>&#123;</span><br><span class="line"> cond :=sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line"> <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"> wg.Add(<span class="number">11</span>)</span><br><span class="line"> <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(num <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span>  wg.Done()</span><br><span class="line">   fmt.Println(num,<span class="string">&quot;号已经就位&quot;</span>)</span><br><span class="line">   cond.L.Lock()</span><br><span class="line">   cond.Wait()<span class="comment">//等待发令枪响</span></span><br><span class="line">   fmt.Println(num,<span class="string">&quot;号开始跑……&quot;</span>)</span><br><span class="line">   cond.L.Unlock()</span><br><span class="line">  &#125;(i)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//等待所有goroutine都进入wait状态</span></span><br><span class="line"> time.Sleep(<span class="number">2</span>*time.Second)</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span>  wg.Done()</span><br><span class="line">  fmt.Println(<span class="string">&quot;裁判已经就位，准备发令枪&quot;</span>)</span><br><span class="line">  fmt.Println(<span class="string">&quot;比赛开始～&quot;</span>)</span><br><span class="line">  cond.Broadcast()<span class="comment">//发令枪响</span></span><br><span class="line"> &#125;()</span><br><span class="line"> <span class="comment">//防止函数提前返回退出</span></span><br><span class="line"> wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> race()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="syncmap"><a class="markdownIt-Anchor" href="#syncmap"></a> sync.Map</h3>
<p>Go语言中内置的map不是并发安全的。请看下面的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> m[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(key <span class="type">string</span>, value <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> m[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">  wg.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   key := strconv.Itoa(n)</span><br><span class="line">   set(key, n)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;k=:%v,v:=%v\n&quot;</span>, key, get(key))</span><br><span class="line">   wg.Done()</span><br><span class="line">  &#125;(i)</span><br><span class="line"> &#125;</span><br><span class="line"> wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码开启少量几个<code>goroutine</code><br />
的时候可能没什么问题，当并发多了之后执行上面的代码就会报<code>fatal error: concurrent map writes</code>错误。</p>
<p>像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的<code>sync</code><br />
包中提供了一个开箱即用的并发安全版map–<code>sync.Map</code><br />
。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时<code>sync.Map</code><br />
内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">  wg.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   key := strconv.Itoa(n)</span><br><span class="line">   m.Store(key, n)</span><br><span class="line">   value, _ := m.Load(key)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;k=:%v,v:=%v\n&quot;</span>, key, value)</span><br><span class="line">   wg.Done()</span><br><span class="line">  &#125;(i)</span><br><span class="line"> &#125;</span><br><span class="line"> wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang并发编程</title>
    <url>/52507.html</url>
    <content><![CDATA[<h2 id="单个goroutine"><a class="markdownIt-Anchor" href="#单个goroutine"></a> 单个goroutine</h2>
<p>Go语言中使用<code>goroutine</code>非常简单，只需要在调用函数的时候在前面加上<code>go</code><br />
关键字，就可以为一个函数创建一个<code>goroutine</code>。</p>
<span id="more"></span>
<p>一个<code>goroutine</code>必定对应一个函数，可以创建多个<code>goroutine</code>去执行相同的函数。开启一个goroutine，示例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> funciton()</span><br></pre></td></tr></table></figure>
<p>是不是很简单呢？那我们在实际中使用一下，示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo1</span><span class="params">()</span></span>  &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;我是 demo goroutine&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">go</span> demo1()</span><br><span class="line"> fmt.Println(<span class="string">&quot;我是 main goroutine&quot;</span>)</span><br><span class="line"> time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我是 demo goroutine</span></span><br><span class="line"><span class="comment">// 我是 main goroutine</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>细心的伙伴肯定发现了<code>time.Sleep(time.Second)</code>，在这里并不仅仅是为睡一秒，还有进类似于等待执行的作用。如果没有<br />
time.Sleep(time.Second)，你会发现 <strong>我是 demo goroutine</strong>，将不会被打印。</p>
<p>首先为什么会先打印<code>我是 main goroutine</code><br />
，这是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的<code>goroutine</code>是继续执行的。</p>
</blockquote>
<h3 id="channel"><a class="markdownIt-Anchor" href="#channel"></a> Channel</h3>
<p>多个goroutine的时候该怎么办呢？难道是这样？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo1</span><span class="params">()</span></span>  &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;我是 demo goroutine&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> demo1()</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Println(<span class="string">&quot;我是 main goroutine&quot;</span>)</span><br><span class="line"> time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没错，这样确实可行的，但之间的相互通信，以及 time.Sleep(time.Second)<br />
该怎么去掉，不可能为了这个所为的并发而强制去睡一秒吧，这也并不现实。其实我们可以使用channel（通道）来解决这个问题</p>
<h3 id="channel的定义"><a class="markdownIt-Anchor" href="#channel的定义"></a> channel的定义</h3>
<p>在 Go 语言中，声明一个 channel 非常简单，使用内置的 make 函数即可，如下所示：</p>
<blockquote>
<p>无缓冲 channel,使用 make 创建的 chan 就是一个无缓冲 channel，它的容量是 0，不能存储任何数据。所以无缓冲<br />
channel 只起到传输数据的作用，数据并不会在 channel 中做任何停留。这也意味着，无缓冲 channel<br />
的发送和接收操作是同时进行的，它也可以称为同步 channel。</p>
</blockquote>
<p>其中 chan 是一个关键字，表示是 channel 类型。后面的 string 表示 channel 里的数据是 string 类型。通过<br />
channel 的声明也可以看到，chan 是一个集合类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ch:=make(chan type)</span><br><span class="line">// type 为传递的类型，由传递值的类型决定</span><br></pre></td></tr></table></figure>
<p>定义好 chan 后就可以使用了，一个 chan 的操作只有两种：发送和接收。</p>
<p>接收：获取 chan 中的值，操作符为 &lt;- chan。</p>
<p>发送：向 chan 发送值，把值放在 chan 中，操作符为 chan &lt;-。</p>
<h4 id="channel-2"><a class="markdownIt-Anchor" href="#channel-2"></a> channel</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ch &lt;- <span class="string">&quot;goroutine 执行完成&quot;</span></span><br><span class="line"> &#125;()</span><br><span class="line"> v := &lt;-ch</span><br><span class="line"> fmt.Printf(<span class="string">&quot;管道ch接受到的值为%v, 类型为%T&quot;</span>, v, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管道ch接受到的值为goroutine 执行完成, 类型为string</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里注意发送和接收的操作符，都是 &lt;- ，只不过位置不同。接收的 &lt;- 操作符在 chan 的左侧，发送的 &lt;- 操作符在<br />
chan 的右侧。</p>
</blockquote>
<p>这样我就实现了最基本的协程</p>
<h4 id="有缓冲-channel"><a class="markdownIt-Anchor" href="#有缓冲-channel"></a> 有缓冲 channel</h4>
<p>有缓冲 channel 类似一个可阻塞的队列，内部的元素先进先出。通过 make 函数的第二个参数可以指定 channel<br />
容量的大小，进而创建一个有缓冲 channel，如下面的代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ChCache:=make(chan int,10)</span><br></pre></td></tr></table></figure>
<p>在这里我们创建了一个容量为 10 的 channel，内部的元素类型是 int，也就是说这个 channel 内部最多可以存放<br />
10个类型为 int 的元素</p>
<p>有缓冲 channel 具备以下特点：</p>
<ul>
<li>
<p>有缓冲 channel 的内部有一个缓冲队列；</p>
</li>
<li>
<p>发送操作是向队列的尾部插入元素，如果队列已满，则阻塞等待，直到另一个 goroutine 执行，接收操作释放队列的空间；</p>
</li>
<li>
<p>接收操作是从队列的头部获取元素并把它从队列中删除，如果队列为空，则阻塞等待，直到另一个 goroutine<br />
执行，发送操作插入新的元素。</p>
</li>
</ul>
<p>我创建了一个容量为 5 的 channel，内部的元素类型是 int，也就是说这个 channel 内部最多可以存放 5 个类型为<br />
int 的元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">   ch &lt;- i</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  value := &lt;-ch</span><br><span class="line">  fmt.Printf(<span class="string">&quot;这次接受ch的值为:%v, 第%d接收\n&quot;</span>, value, i+<span class="number">1</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这次接受ch的值为:0, 第1接收</span></span><br><span class="line"><span class="comment">// 这次接受ch的值为:1, 第2接收</span></span><br><span class="line"><span class="comment">// 这次接受ch的值为:2, 第3接收</span></span><br><span class="line"><span class="comment">// 这次接受ch的值为:3, 第4接收</span></span><br><span class="line"><span class="comment">// 这次接受ch的值为:4, 第5接收</span></span><br><span class="line"><span class="comment">// 这次接受ch的值为:5, 第6接收</span></span><br><span class="line"><span class="comment">// 这次接受ch的值为:6, 第7接收</span></span><br><span class="line"><span class="comment">// 这次接受ch的值为:7, 第8接收</span></span><br><span class="line"><span class="comment">// 这次接受ch的值为:8, 第9接收</span></span><br><span class="line"><span class="comment">// 这次接受ch的值为:9, 第10接收</span></span><br></pre></td></tr></table></figure>
<p>通过内置函数 cap 可以获取 channel 的容量，也就是最大能存放多少个元素，通过内置函数 len 可以获取<br />
channel 中元素的个数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;ch的容量:&quot;</span>, <span class="built_in">cap</span>(ch), <span class="string">&quot;ch长度为:&quot;</span>, <span class="built_in">len</span>(ch))</span><br></pre></td></tr></table></figure>
<p>以上我们都是定义的双向chan，可以取也可以存。那让我们继续深入学习</p>
<h4 id="单向channel"><a class="markdownIt-Anchor" href="#单向channel"></a> 单向channel</h4>
<p>单向 channel 的声明也很简单，只需要在声明的时候带上 &lt;- 操作符即可，如下面的代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 单向channel(只存)</span><br><span class="line">onlySendChan := make(chan&lt;- int)</span><br><span class="line">// 单向channel(只取)</span><br><span class="line">onlyReceiveChan:=make(&lt;-chan int)</span><br></pre></td></tr></table></figure>
<h4 id="关闭channel"><a class="markdownIt-Anchor" href="#关闭channel"></a> 关闭channel</h4>
<p>当我们需要关闭channel的时候，我们可以使用内置的Close函数即可关闭</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Close(channel)</span><br></pre></td></tr></table></figure>
<p>如果一个 channel 被关闭了，就不能向里面发送数据了，如果发送的话，会引起 painc 异常。但是还可以接收<br />
channel 里的数据，如果 channel 里没有数据的话，接收的数据是元素类型的零值。</p>
<p>不难看出channel的坑比较多，一不小心就会写出一个bug。常见情况总结如下</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1glaz73x65uj31bs0iiqfn.jpg" alt="" /></p>
<h3 id="多协程-worker-poolgoroutine池"><a class="markdownIt-Anchor" href="#多协程-worker-poolgoroutine池"></a> 多协程-worker pool（goroutine池）</h3>
<p>在工作中我们通常会使用可以指定启动的goroutine数量–worker pool模式，控制goroutine的数量，防止goroutine泄漏和暴涨。</p>
<p>一个简易的work pool示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, jobs &lt;-<span class="keyword">chan</span> <span class="type">int</span>, results <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> j := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;worker:%d start job:%d\n&quot;</span>, id, j)</span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;worker:%d end job:%d\n&quot;</span>, id, j)</span><br><span class="line">  results &lt;- j * <span class="number">2</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line"> results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line"> <span class="comment">// 开启3个goroutine</span></span><br><span class="line"> <span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= <span class="number">3</span>; w++ &#123;</span><br><span class="line">  <span class="keyword">go</span> worker(w, jobs, results)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 5个任务</span></span><br><span class="line"> <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++ &#123;</span><br><span class="line">  jobs &lt;- j</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">close</span>(jobs)</span><br><span class="line"> <span class="comment">// 输出结果</span></span><br><span class="line"> <span class="keyword">for</span> a := <span class="number">1</span>; a &lt;= <span class="number">5</span>; a++ &#123;</span><br><span class="line">  &lt;-results</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多路复用"><a class="markdownIt-Anchor" href="#多路复用"></a> 多路复用</h3>
<p>假设要从网上下载一个文件，启动 3 个 goroutine 进行下载，并把结果发送到 3 个 channel 中。哪个先下载好，就会使用哪个<br />
channel 的结果。</p>
<p>在这种情况下，如果我们尝试获取第一个 channel 的结果，程序就会被阻塞，无法获取剩下两个 channel<br />
的结果，也无法判断哪个先下载好。这个时候就需要用到多路复用操作了，在 Go 语言中，通过 select<br />
语句可以实现多路复用，其语句格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">    <span class="comment">//todo  1</span></span><br><span class="line"><span class="keyword">case</span> i2 &lt;- c2:</span><br><span class="line">    <span class="comment">//todo 2</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// default todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体结构和 switch 非常像，都有 case 和 default，只不过 select 的 case 是一个个可以操作的 channel。</p>
<blockquote>
<p>多路复用可以简单地理解为，N 个 channel 中，任意一个 channel 有数据产生，select<br />
都可以监听到，然后执行相应的分支，接收数据并处理。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadFile</span><span class="params">(chanName <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"> <span class="comment">//随机time.Sleep,模拟下载文件</span></span><br><span class="line"> time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line"> <span class="keyword">return</span> chanName + <span class="string">&quot;:filePath&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">//声明三个存放结果的channel</span></span><br><span class="line"> <span class="comment">//firstCh := make(chan string)</span></span><br><span class="line"> <span class="comment">//secondCh := make(chan string)</span></span><br><span class="line"> <span class="comment">//threeCh := make(chan string)</span></span><br><span class="line"> firstCh, secondCh, threeCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"> <span class="comment">//同时开启3个goroutine下载</span></span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  firstCh &lt;- downloadFile(<span class="string">&quot;firstCh&quot;</span>)</span><br><span class="line"> &#125;()</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  secondCh &lt;- downloadFile(<span class="string">&quot;secondCh&quot;</span>)</span><br><span class="line"> &#125;()</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  threeCh &lt;- downloadFile(<span class="string">&quot;threeCh&quot;</span>)</span><br><span class="line"> &#125;()</span><br><span class="line"> <span class="comment">//开始select多路复用，哪个channel能获取到值，</span></span><br><span class="line"> <span class="comment">//就说明哪个最先下载好，就用哪个。</span></span><br><span class="line"> <span class="keyword">select</span> &#123;</span><br><span class="line"> <span class="keyword">case</span> filePath := &lt;-firstCh:</span><br><span class="line">  fmt.Println(filePath)</span><br><span class="line"> <span class="keyword">case</span> filePath := &lt;-secondCh:</span><br><span class="line">  fmt.Println(filePath)</span><br><span class="line"> <span class="keyword">case</span> filePath := &lt;-threeCh:</span><br><span class="line">  fmt.Println(filePath)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang介绍</title>
    <url>/10520.html</url>
    <content><![CDATA[<blockquote>
<p>Go 语言开发包</p>
<p>国外：<span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcub3JnL2RsLw==">https://golang.org/dl/<i class="fa fa-external-link-alt"></i></span></p>
<p>国内(推荐)： <span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcuZ29vZ2xlLmNuL2RsLw==">https://golang.google.cn/dl/<i class="fa fa-external-link-alt"></i></span></p>
<p>编辑器</p>
<ul>
<li>Golang:<span class="exturl" data-url="aHR0cHM6Ly93d3cuamV0YnJhaW5zLmNvbS9nby8=">https://www.jetbrains.com/go/<i class="fa fa-external-link-alt"></i></span></li>
<li>Visual Studio Code: <span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20v">https://code.visualstudio.com/<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</blockquote>
<p>搭建 Go 语言开发环境，需要先下载 Go 语言开发包。</p>
<h3 id="查看操作系统及版本"><a class="markdownIt-Anchor" href="#查看操作系统及版本"></a> 查看操作系统及版本</h3>
<p>Windows：<img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfvrumlwpj31fk0m70x2.jpg" alt="" /></p>
<p>Mac:</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfvxbp6hmj317i0d21b8.jpg" alt="" /></p>
<p>Linux:</p>
<p>终端输入<code>uname -a</code>,示例如下</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfw129kelj31qe03c0uw.jpg" alt="" /></p>
<span id="more"></span>
<h3 id="golang语言开发包"><a class="markdownIt-Anchor" href="#golang语言开发包"></a> Golang语言开发包</h3>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfvdmu9zsj31au0u0ap5.jpg" alt="Golang开发包" /></p>
<p>MSI 安装的方式比较简单推荐使用</p>
<p>Windows 系统上推荐使用这种方式。现在的操作系统基本上都是 64 位的，所以选择 64 位的<br />
go1.15.windows-amd64.msi 下载即可，如果操作系统是 32 位的，选择 go1.15.windows-386.msi<br />
进行下载。</p>
<p>下载后双击该 MSI 安装文件，按照提示一步步地安装即可。在默认情况下，Go 语言开发工具包会被安装到 c:\Go<br />
目录，你也可以在安装过程中选择自己想要安装的目录。</p>
<p>假设安装到 c:\Go 目录，安装程序会自动把 c:\Go\bin 添加到你的 PATH<br />
环境变量中，如果没有的话，你可以通过系统 -&gt; 控制面板 -&gt; 高级 -&gt; 环境变量选项来手动添加。示例如下</p>
<ul>
<li>进入</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfwha3s32j31fk0kw77n.jpg" alt="" /></p>
<ul>
<li>配置</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfwhx99dij30uu0huwfx.jpg" alt="" /></p>
<h3 id="macos-下安装"><a class="markdownIt-Anchor" href="#macos-下安装"></a> macOS 下安装</h3>
<p>如果你的操作系统是 macOS，可以采用 PKG 安装包。下载 <code>go1.15.darwin-amd64.pkg</code><br />
后，双击按照提示安装即可。安装成功后，路径<code>/usr/local/go/bin</code> 应该已经被添加到了 PATH<br />
环境变量中。</p>
<p>如果没有的话，你可以手动添加，把如下内容添加到 /etc/profile 或者 $HOME/.profile 文件保存即可。命令如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/go/bin</span><br></pre></td></tr></table></figure>
<p>BrewHome安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># brewHome安装</span></span><br><span class="line">brew install golang</span><br></pre></td></tr></table></figure>
<h3 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> Linux</h3>
<ul>
<li>保护管理工具安装</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum(Centos)</span></span><br><span class="line"><span class="built_in">sudo</span> yum -y update <span class="comment"># 更新yum</span></span><br><span class="line"><span class="built_in">sudo</span> yum install -y golang</span><br><span class="line"><span class="comment"># apt(ubantu)</span></span><br><span class="line"><span class="built_in">sudo</span> apt -y update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y golang</span><br></pre></td></tr></table></figure>
<ul>
<li>压缩包安装(安装前请查看操作系统版本)</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># amd 版本</span></span><br><span class="line">wget https://golang.google.cn/dl/go1.15.4.linux-amd64.tar.gz</span><br><span class="line"><span class="comment"># arm版本</span></span><br><span class="line">https://golang.google.cn/dl/go1.15.4.linux-arm64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压(amd)</span></span><br><span class="line"><span class="built_in">sudo</span> tar -C /usr/local/ -xzvf go1.15.4.linux-amd64.tar.gz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line"><span class="built_in">sudo</span> tar -C /usr/local/ -xzvf go1.15.4.linux-arm64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境变量配置</span></span><br><span class="line"><span class="comment"># sudo vim /etc/profile</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cat</span> &gt;&gt; /etc/profile &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">export GOROOT=/usr/local/go</span></span><br><span class="line"><span class="string">export GOPATH=/home/bruce/go</span></span><br><span class="line"><span class="string">export GOBIN=\$GOPATH/bin</span></span><br><span class="line"><span class="string">export PATH=\$PATH:$GOROOT/bin</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="comment"># 环境变量生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>GOROOT</code>设置golang开发包的安装位置，我们解压到了<code>/usr/local/</code>目录，该目录下的<code>go/</code><br />
文件夹一定是go的环境的根目录，就是打开<code>go</code>目录后别再有一个<code>go/</code>目录。</p>
<p><code>GOBIN</code>目录是执行 <code>go install</code> 后生成可执行文件的目录</p>
<p><code>GOPATH</code>是我们的工作目录，一般我们设置到用户目录下，这个要根据你电脑的实际情况去配置。在介绍一下go的工作目录结构。在我们设置的工作目录下有3个子目录</p>
</blockquote>
<h2 id="测试安装"><a class="markdownIt-Anchor" href="#测试安装"></a> 测试安装</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 任意目录下输入go version</span></span><br><span class="line">go version go1.15.2 darwin/amd64</span><br><span class="line"><span class="comment"># 查看环境配置</span></span><br><span class="line">go <span class="built_in">env</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># go env</span></span><br><span class="line">GO111MODULE=<span class="string">&quot;on&quot;</span></span><br><span class="line">GOARCH=<span class="string">&quot;amd64&quot;</span></span><br><span class="line">GOBIN=<span class="string">&quot;&quot;</span></span><br><span class="line">GOCACHE=<span class="string">&quot;/Users/stringle-004/Library/Caches/go-build&quot;</span></span><br><span class="line">GOENV=<span class="string">&quot;/Users/stringle-004/Library/Application Support/go/env&quot;</span></span><br><span class="line">GOEXE=<span class="string">&quot;&quot;</span></span><br><span class="line">GOFLAGS=<span class="string">&quot;&quot;</span></span><br><span class="line">GOHOSTARCH=<span class="string">&quot;amd64&quot;</span></span><br><span class="line">GOHOSTOS=<span class="string">&quot;darwin&quot;</span></span><br><span class="line">GOINSECURE=<span class="string">&quot;&quot;</span></span><br><span class="line">GOMODCACHE=<span class="string">&quot;/Users/stringle-004/go/pkg/mod&quot;</span></span><br><span class="line">GONOPROXY=<span class="string">&quot;&quot;</span></span><br><span class="line">GONOSUMDB=<span class="string">&quot;&quot;</span></span><br><span class="line">GOOS=<span class="string">&quot;darwin&quot;</span></span><br><span class="line">GOPATH=<span class="string">&quot;/Users/stringle-004/go&quot;</span></span><br><span class="line">GOPRIVATE=<span class="string">&quot;&quot;</span></span><br><span class="line">GOPROXY=<span class="string">&quot;https://goproxy.cn,direct&quot;</span></span><br><span class="line">GOROOT=<span class="string">&quot;/usr/local/go&quot;</span>  <span class="comment"># golang开发包的安装位置</span></span><br><span class="line">GOSUMDB=<span class="string">&quot;sum.golang.org&quot;</span></span><br><span class="line">GOTMPDIR=<span class="string">&quot;&quot;</span></span><br><span class="line">GOTOOLDIR=<span class="string">&quot;/usr/local/go/pkg/tool/darwin_amd64&quot;</span></span><br><span class="line">GCCGO=<span class="string">&quot;gccgo&quot;</span></span><br><span class="line">AR=<span class="string">&quot;ar&quot;</span></span><br><span class="line">CC=<span class="string">&quot;clang&quot;</span></span><br><span class="line">CXX=<span class="string">&quot;clang++&quot;</span></span><br><span class="line">CGO_ENABLED=<span class="string">&quot;1&quot;</span></span><br><span class="line">GOMOD=<span class="string">&quot;/Users/stringle-004/go/src/github.com/payne/awesomeProject/go.mod&quot;</span></span><br><span class="line">CGO_CFLAGS=<span class="string">&quot;-g -O2&quot;</span></span><br><span class="line">CGO_CPPFLAGS=<span class="string">&quot;&quot;</span></span><br><span class="line">CGO_CXXFLAGS=<span class="string">&quot;-g -O2&quot;</span></span><br><span class="line">CGO_FFLAGS=<span class="string">&quot;-g -O2&quot;</span></span><br><span class="line">CGO_LDFLAGS=<span class="string">&quot;-g -O2&quot;</span></span><br><span class="line">PKG_CONFIG=<span class="string">&quot;pkg-config&quot;</span></span><br><span class="line">GOGCCFLAGS=<span class="string">&quot;-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/sb/__n99hm13ms08lkk2lv5pxj40000gn/T/go-build659271527=/tmp/go-build -gno-record-gcc-switches -fno-common&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="goproxy"><a class="markdownIt-Anchor" href="#goproxy"></a> GOPROXY</h3>
<p>Go1.14版本之后，都推荐使用<code>go mod</code>模式来管理依赖环境了，也不再强制我们把代码必须写在<code>GOPATH</code><br />
下面的src目录了，你可以在你电脑的任意位置编写go代码。（网上有些教程适用于1.11版本之前。）</p>
<p>默认GoPROXY配置是：<code>GOPROXY=https://proxy.golang.org,direct</code><br />
，由于国内访问不到<code>https://proxy.golang.org</code><br />
，所以我们需要换一个PROXY，这里推荐使用<code>https://goproxy.io</code>或<code>https://goproxy.cn</code>。</p>
<p>可以执行下面的命令修改GOPROXY：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>
<h2 id="跨平台编译"><a class="markdownIt-Anchor" href="#跨平台编译"></a> 跨平台编译</h2>
<p>Go 语言开发工具包的另一强大功能就是可以跨平台编译。什么是跨平台编译呢？</p>
<p>就是在 macOS 开发，可以编译 Linux、Window<br />
等平台上的可执行程序，这样你开发的程序，就可以在这些平台上运行。也就是说，你可以选择喜欢的操作系统做开发，并跨平台编译成需要发布平台的可执行程序即可。</p>
<p>Go 语言通过两个环境变量来控制跨平台编译，它们分别是 <code>GOOS</code> 和 <code>GOARCH</code> 。</p>
<ul>
<li>
<p>GOOS：代表要编译的目标操作系统，常见的有 Linux、Windows、Darwin 等。</p>
</li>
<li>
<p>GOARCH：代表要编译的目标处理器架构，常见的有 386、AMD64、ARM64 等。</p>
</li>
</ul>
<p>这样通过组合不同的 GOOS 和 GOARCH，就可以编译出不同的可执行程序。比如我现在的操作系统是 macOS AMD64<br />
的，我想编译出 Linux AMD64 的可执行程序，只需要执行 go build 命令即可，如以下代码所示：</p>
<p>关于 GOOS 和 GOARCH 更多的组合，参考官方文档的 $GOOS and $GOARCH 这一节即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GOOS=linux GOARCH=amd64 go build /Users/stringle-004/go/main.go</span><br></pre></td></tr></table></figure>
<p>关于 GOOS 和 GOARCH 更多的组合，参考<span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcub3JnL2RvYy9pbnN0YWxsL3NvdXJjZSNlbnZpcm9ubWVudA==">官方文档<i class="fa fa-external-link-alt"></i></span>的<br />
$GOOS and $GOARCH 这一节即可</p>
<h3 id="相关工具链安装"><a class="markdownIt-Anchor" href="#相关工具链安装"></a> 相关工具链安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go install golang.org/x/lint/golint@latest</span><br><span class="line">go install golang.org/x/tools/cmd/godoc@latest</span><br></pre></td></tr></table></figure>
<h2 id="go-编辑器"><a class="markdownIt-Anchor" href="#go-编辑器"></a> Go 编辑器</h2>
<p>第一款是 Visual Studio Code + Go<br />
扩展插件，可以让你非常高效地开发，通过<span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20v">官方网站<i class="fa fa-external-link-alt"></i></span>下载所对应操作系统版本的Visual<br />
Studio Code。</p>
<ul>
<li>安装：略（进入官网，下载安装即可）</li>
<li>Visual Studio Code + Go设置</li>
</ul>
<h4 id="安装中文简体插件"><a class="markdownIt-Anchor" href="#安装中文简体插件"></a> 安装中文简体插件</h4>
<p>点击左侧菜单栏最后一项<code>管理扩展</code>，在<code>搜索框</code>中输入<code>chinese</code> ，选中结果列表第一项，点击<code>install</code>安装。</p>
<p>安装完毕后右下角会提示<code>重启VS Code</code>，重启之后你的VS Code就显示中文啦！</p>
<p><code>VSCode</code>主界面介绍：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfxc8ujjej30y80lcgok.jpg" alt="" /></p>
<h4 id="安装go扩展"><a class="markdownIt-Anchor" href="#安装go扩展"></a> 安装go扩展</h4>
<p>现在我们要为我们的VS Code编辑器安装<code>Go</code>扩展插件，让它支持Go语言开发。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfxc5nin1j30y80pw0xy.jpg" alt="" /></p>
<h4 id="安装中文简体插件-2"><a class="markdownIt-Anchor" href="#安装中文简体插件-2"></a> 安装中文简体插件</h4>
<p>点击左侧菜单栏最后一项<code>管理扩展</code>，在<code>搜索框</code>中输入<code>chinese</code> ，选中结果列表第一项，点击<code>install</code>安装。</p>
<p>安装完毕后右下角会提示<code>重启VS Code</code>，重启之后你的VS Code就显示中文啦！</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkfxc0dxgxg30xq0ppngg.gif" alt="" /></p>
<p>第二款是老牌 IDE 公司 JetBrains 推出的<br />
Goland，所有插件已经全部集成，更容易上手，并且功能强大，新手老手都适合，你可以通过官方网站 <span class="exturl" data-url="aHR0cHM6Ly93d3cuamV0YnJhaW5zLmNvbS9nby8=">https://www.jetbrains.com/go/<i class="fa fa-external-link-alt"></i></span><br />
下载使用。</p>
<h2 id="第一个golang程序"><a class="markdownIt-Anchor" href="#第一个golang程序"></a> 第一个Golang程序</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main   <span class="comment">//  可执行文件必须为package main开头</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>   <span class="comment">// 导入“fmt”包，用于打印（fmt.Print（打印）、fmt.Println（换行打印）、fmt.Printf(格式化打印)等）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   <span class="comment">// 主函数main</span></span><br><span class="line"> fmt.Print(<span class="string">&quot;你好，我叫payne&quot;</span>)  <span class="comment">// 输入</span></span><br><span class="line">&#125;</span><br><span class="line"># 你好，我叫payne</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang并发编程初探</title>
    <url>/21490.html</url>
    <content><![CDATA[<h2 id="基本概念了解"><a class="markdownIt-Anchor" href="#基本概念了解"></a> 基本概念了解</h2>
<h3 id="并发与并行略偏向于多线-进程方面"><a class="markdownIt-Anchor" href="#并发与并行略偏向于多线-进程方面"></a> 并发与并行：(略偏向于多线 / 进程方面)</h3>
<ul>
<li>并发： 指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行</li>
<li>并行： 指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的</li>
</ul>
<span id="more"></span>
<h3 id="阻塞与非阻塞略偏向于协程-异步方向"><a class="markdownIt-Anchor" href="#阻塞与非阻塞略偏向于协程-异步方向"></a> 阻塞与非阻塞：（略偏向于协程 / 异步方向）</h3>
<ul>
<li>
<p>阻塞：阻塞状态指程序未得到所需计算资源时被挂起的状态。程序在等待某个操作完成期间，自身无法继续处理其他的事情，则称该程序在该操作上是阻塞的。</p>
</li>
<li>
<p>非阻塞：程序在等待某操作过程中，自身不被阻塞，可以继续处理其他的事情，则称该程序在该操作上是非阻塞的</p>
</li>
</ul>
<h3 id="同步与异步"><a class="markdownIt-Anchor" href="#同步与异步"></a> 同步与异步</h3>
<ul>
<li>
<p>同步：不同程序单元为了完成某个任务，在执行过程中需靠某种通信方式以协调一致，我们称这些程序单元是同步执行的。</p>
</li>
<li>
<p>异步：为完成某个任务，不同程序单元之间过程中无需通信协调，也能完成任务的方式，不相关的程序单元之间可以是异步的。</p>
</li>
<li>
<p><strong>多线程（英语：multithreading）</strong><br />
：指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理（Chip-level<br />
multithreading）或同时多线程（Simultaneous multithreading）处理器。在一个程序中，这些独立运行的程序片段叫作<br />
“线程”（Thread），利用它编程的概念就叫作<br />
“多线程处理（Multithreading）”</p>
</li>
<li>
<p><strong>多进程 (Multiprocessing):</strong><br />
每个正在系统上运行的程序都是一个进程。每个进程包含一到多个线程。进程也可能是整个程序或者是部分程序的动态执行。线程是一组指令的集合，或者是程序的特殊段，它可以在程序里独立执行。也可以把它理解为代码运行的上下文。所以线程基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。线程是程序中一个单一的顺序控制流程。在单个程序中同时运行多个线程完成不同的工作，称为多线程.</p>
</li>
<li>
<p>**二者的区别：**线程和进程的区别在于，子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其执行上下文。多线程主要是为了节约<br />
CPU<br />
时间，发挥利用，根据具体<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlODMlODUlRTUlODYlQjU=">情况<i class="fa fa-external-link-alt"></i></span><br />
而定。线程的运行中需要使用计算机的<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlODYlODUlRTUlQUQlOTg=">内存<i class="fa fa-external-link-alt"></i></span>资源和 CPU。</p>
</li>
<li>
<p><strong>协程 (Coroutine):</strong> 又称微线程、纤程，协程是一种用户态的轻量级线程。<br />
协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
</li>
</ul>
<h2 id="go并发编程"><a class="markdownIt-Anchor" href="#go并发编程"></a> Go并发编程</h2>
<p>Go 语言中没有线程的概念，只有协程，也称为 goroutine。相比线程来说，协程更加轻量，一个程序可以随意启动成千上万个<br />
goroutine。</p>
<p>Go语言中的<code>goroutine</code>就是这样一种机制，<code>goroutine</code>的概念类似于线程，但 <code>goroutine</code><br />
是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine<br />
中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p>
<p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–<code>goroutine</code><br />
，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个<code>goroutine</code><br />
去执行这个函数就可以了，就是这么简单粗暴。</p>
<h3 id="goroutine与线程"><a class="markdownIt-Anchor" href="#goroutine与线程"></a> goroutine与线程</h3>
<h4 id="可增长的栈"><a class="markdownIt-Anchor" href="#可增长的栈"></a> 可增长的栈</h4>
<p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个<code>goroutine</code><br />
的栈在其生命周期开始时只有很小的栈（典型情况下2KB），<code>goroutine</code><br />
的栈不是固定的，他可以按需增大和缩小，<code>goroutine</code><br />
的栈大小限制可以达到1GB，虽然极少会用到这么大。所以在Go语言中一次创建十万左右的<code>goroutine</code>也是可以的。</p>
<h4 id="goroutine调度"><a class="markdownIt-Anchor" href="#goroutine调度"></a> goroutine调度</h4>
<p><code>GPM</code>是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p>
<ul>
<li><code>G</code>很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</li>
<li><code>P</code><br />
管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</li>
<li><code>M（machine）</code>是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系，<br />
一个groutine最终是要放到M上执行的；</li>
</ul>
<p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G<br />
挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p>
<p>P的个数是通过<code>runtime.GOMAXPROCS</code>设定（最大256），Go1.5版本之后默认为物理线程数。<br />
在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p>
<p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，<code>goroutine</code><br />
则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:<br />
n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的，<br />
不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池，<br />
不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。<br />
另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上，<br />
再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang指针-pointer</title>
    <url>/10091.html</url>
    <content><![CDATA[<p>区别于C/C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。</p>
<p>要搞明白Go语言中的指针需要先知道3个概念：指针地址、指针类型和指针取值。</p>
<span id="more"></span>
<h2 id="go语言中的指针"><a class="markdownIt-Anchor" href="#go语言中的指针"></a> Go语言中的指针</h2>
<blockquote>
<p>任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。</p>
</blockquote>
<p>比如，“永远不要高估自己”这句话，我想把它写入程序中，程序一启动这句话是要加载到内存（假设内存地址0x123456），我在程序中把这段话赋值给变量<code>A</code><br />
，把内存地址赋值给变量<code>B</code>。这时候变量<code>B</code>就是一个指针变量。通过变量<code>A</code>和变量<code>B</code>都能找到我的座右铭。</p>
<blockquote>
<p>Go语言中的指针不能进行偏移和运算，因此Go语言中的指针操作非常简单，我们只需要记住两个符号：<code>&amp;</code><br />
（取地址）和<code>*</code>（根据地址取值）。</p>
<p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用<code>&amp;</code>字符放在变量前面对变量进行“取地址”操作。</p>
</blockquote>
<p>Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：<code>*int</code>、<code>*int64</code>、<code>*string</code></p>
<blockquote>
<p>等。</p>
</blockquote>
<p>取变量指针的语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ptr := &amp;v    <span class="comment">// v的类型为T</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>v:代表被取地址的变量，类型为<code>T</code></li>
<li>ptr:用于接收地址的变量，ptr的类型就为<code>*T</code>，称做T的指针类型。*代表指针。</li>
</ul>
</blockquote>
<p>注意：<code>&amp;</code>仅对基本类型适用基本类型(包含int\bool\string，不包含数组、切片等),<code>fmt.printf(%p)</code>使用于所有类型。</p>
<p>示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> a := <span class="number">10</span></span><br><span class="line"> b := &amp;a     <span class="comment">// &amp; 取地址值操作</span></span><br><span class="line"> c := *b     <span class="comment">// * 根据地址值取值操作</span></span><br><span class="line"> fmt.Println(a, reflect.TypeOf(a))  <span class="comment">// 10 int</span></span><br><span class="line"> <span class="comment">// 每次的地址值不一定，若打印出0x开头的即成功获取到该变量地址值</span></span><br><span class="line"> fmt.Println(b, reflect.TypeOf(b))  <span class="comment">// 0xc000014080 *int</span></span><br><span class="line"> fmt.Println(c, reflect.TypeOf(c))  <span class="comment">// 10 int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结：</strong> 取地址操作符<code>&amp;</code>和取值操作符<code>*</code>是一对互补操作符，<code>&amp;</code>取出地址，<code>*</code>根据地址取出地址指向的值。</p>
<p>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</p>
<ul>
<li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</li>
<li>指针变量的值是指针地址。</li>
<li>对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。</li>
</ul>
</blockquote>
<h2 id="make-or-new"><a class="markdownIt-Anchor" href="#make-or-new"></a> Make or New</h2>
<p>导入</p>
<blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a *<span class="type">int</span></span><br><span class="line">*a = <span class="number">10</span></span><br><span class="line">fmt.Println(*a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">b[<span class="string">&quot;Payne&quot;</span>] = <span class="number">10</span></span><br><span class="line">fmt.Println(b)</span><br><span class="line"><span class="comment">// runtime error: invalid memory address or nil pointer dereference</span></span><br></pre></td></tr></table></figure>
<p>执行上面的代码会引发panic，为什么呢？</p>
<p>在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。</p>
<p>而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。<br />
Go语言中new和make是内建的两个函数，主要用来分配内存。</p>
</blockquote>
<h3 id="new"><a class="markdownIt-Anchor" href="#new"></a> new</h3>
<p>new是一个内置的函数，它的函数签名如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span></span> *Type</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type表示类型，new函数只接受一个参数，这个参数是一个类型</span></span><br><span class="line"><span class="comment">// *Type表示类型指针，new函数返回一个指向该类型内存地址的指针。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> a := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line"> b := <span class="built_in">new</span>(<span class="type">bool</span>)</span><br><span class="line"> fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, a) <span class="comment">// *int</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, b) <span class="comment">// *bool</span></span><br><span class="line"> fmt.Println(*a)       <span class="comment">// 0</span></span><br><span class="line"> fmt.Println(*b)       <span class="comment">// false</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>示例代码中<code>var a *int</code><br />
只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a *<span class="type">int</span></span><br><span class="line">  a = <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">  *a = <span class="number">10</span></span><br><span class="line">  fmt.Println(*a)  <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="make"><a class="markdownIt-Anchor" href="#make"></a> make</h3>
<p>make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span></span> Type</span><br></pre></td></tr></table></figure>
<blockquote>
<p>make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。</p>
</blockquote>
<h3 id="new与make的同与异"><a class="markdownIt-Anchor" href="#new与make的同与异"></a> new与make的同与异</h3>
<ol>
<li>二者都是用来做内存分配的。</li>
<li>make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；</li>
<li>而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</li>
</ol>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang运算符</title>
    <url>/61463.html</url>
    <content><![CDATA[<blockquote>
<p>本章目标：</p>
<ul>
<li>了解运算符、运算符的种类、各运算符的特征</li>
<li>进制</li>
<li>位运算符及位运算</li>
<li>运算符优先级</li>
</ul>
</blockquote>
<h2 id="什么是运算符"><a class="markdownIt-Anchor" href="#什么是运算符"></a> 什么是运算符</h2>
<p>运算符用于执行程序代码运算，会针对一个以上操作数项目来进行<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglQkYlOTAlRTclQUUlOTcvNTg2Njg1Ng==">运算<i class="fa fa-external-link-alt"></i></span><br />
。例如：2+3，其<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTMlOEQlRTQlQkQlOUMlRTYlOTUlQjAvNzY1ODI3MA==">操作数<i class="fa fa-external-link-alt"></i></span>是2和3，而运算符则是“+”。</p>
<p>在vb2005中运算符大致可以分为5种类型：<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclQUUlOTclRTYlOUMlQUYlRTglQkYlOTAlRTclQUUlOTclRTclQUMlQTYvOTMyNDk0Nw==">算术运算符<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQkQlOEQlRTglQkYlOTAlRTclQUUlOTclRTclQUMlQTYvMjc4NjE2Mz9mcj1hbGFkZGlu">位运算符<i class="fa fa-external-link-alt"></i></span>、 <span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlODUlQjMlRTclQjMlQkIlRTglQkYlOTAlRTclQUUlOTclRTclQUMlQTYvMzUyNzc0">关系运算符<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglQjUlOEIlRTUlODAlQkMlRTglQkYlOTAlRTclQUUlOTclRTclQUMlQTYvMjQ4MjcyMQ==">赋值运算符<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklODAlQkIlRTglQkUlOTElRTglQkYlOTAlRTclQUUlOTclRTclQUMlQTYvNDEyMzUwNQ==">逻辑运算符<i class="fa fa-external-link-alt"></i></span>。</p>
<span id="more"></span>
<h2 id="算数运算符"><a class="markdownIt-Anchor" href="#算数运算符"></a> 算数运算符</h2>
<p>| 运算符 | 描述 | | :----: | :–: | | + | 相加 | | - | 相减 | | * | 相乘 | | / | 相除 | | % | 求余 |</p>
<blockquote>
<p><strong>注意：</strong> <code>++</code>（自增）和<code>--</code>（自减）在Go语言中是单独的语句，并不是运算符。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> a, b := <span class="number">3</span>,<span class="number">4</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;a 加 b = %d\n&quot;</span>, a + b)</span><br><span class="line"> fmt.Printf(<span class="string">&quot;a 减 b = %d\n&quot;</span>, a - b)</span><br><span class="line"> fmt.Printf(<span class="string">&quot;a 乘 b = %d\n&quot;</span>, a * b)</span><br><span class="line"> fmt.Printf(<span class="string">&quot;a 除 b = %d\n&quot;</span>, a / b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关系运算符"><a class="markdownIt-Anchor" href="#关系运算符"></a> 关系运算符</h2>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">==</td>
<td style="text-align:center">检查两个值是否相等，如果相等返回 True 否则返回 False。</td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td style="text-align:center">&gt; =</td>
<td style="text-align:center">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
</tbody>
</table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> a, b := <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"> <span class="comment">//fmt.Println(&quot;a == b?&quot;,  a == b)         // a == b? false</span></span><br><span class="line"> <span class="comment">//fmt.Println(&quot;a != b?&quot;,  a != b)         // a != b? true</span></span><br><span class="line"> <span class="comment">//fmt.Println(&quot;a &gt;  b?&quot;,  a &gt; b )         // a &gt;  b? true</span></span><br><span class="line"> <span class="comment">//fmt.Println(&quot;a &gt;= b?&quot;,  a &gt;= b)         // a &gt;= b? false</span></span><br><span class="line"> <span class="comment">//fmt.Println(&quot;a &lt;  b?&quot;,  a &lt; b )         // a &gt;= b? true</span></span><br><span class="line"> <span class="comment">//fmt.Println(&quot;a &lt;= b?&quot;,  a &lt;= b )        // a &lt;= b? true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符"></a> 逻辑运算符</h2>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center">\</td>
</tr>
<tr>
<td style="text-align:center">!</td>
<td style="text-align:center">逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td>
</tr>
</tbody>
</table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> a, b := <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line"> fmt.Println(<span class="string">&quot;a &amp;&amp; b ?&quot;</span>, a &amp;&amp; b)      <span class="comment">// a &amp;&amp; b ? false</span></span><br><span class="line"> fmt.Println(<span class="string">&quot;a || b ?&quot;</span>, a || b)      <span class="comment">// a || b ? true</span></span><br><span class="line"> fmt.Println(<span class="string">&quot;  !a ?&quot;</span>, !a)            <span class="comment">//  !a ? false</span></span><br><span class="line"> fmt.Println(<span class="string">&quot;  !b ?&quot;</span>, !b)            <span class="comment">//  !b ? true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="位运算符"><a class="markdownIt-Anchor" href="#位运算符"></a> 位运算符</h2>
<h3 id="常见进制"><a class="markdownIt-Anchor" href="#常见进制"></a> 常见进制</h3>
<ul>
<li>
<p>二进制：只有 0 和 1，Go语言中不能直接使用二进制表示整数；</p>
</li>
<li>
<p>八进制：0-7，以数字 0 开头；</p>
</li>
<li>
<p>十进制：0-9；</p>
</li>
<li>
<p>十六进制：0-9 以及 A-F，以 0X 开头，A-F 以及 X 不区分大小写。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> a := <span class="number">10</span></span><br><span class="line"> <span class="comment">// 二进制</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%b\n&quot;</span>,a)    <span class="comment">// 1010</span></span><br><span class="line"> <span class="comment">// 八进制</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%o\n&quot;</span>,a)    <span class="comment">// 12</span></span><br><span class="line"> <span class="comment">// 十进制</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%d\n&quot;</span>,a)    <span class="comment">// 10</span></span><br><span class="line"> <span class="comment">// 十六进制</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%x\n&quot;</span>,a)    <span class="comment">// a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>任意进制转换为十进制</p>
<p>二进制转十进制：从最低位开始，每个位上数乘以 2 的位数减 1 次方然后求和。</p>
<p>1011 = 1<em>20 + 1</em>21 + 0<em>22 + 1</em>23 = 11</p>
<p>八进制转十进制：从最低位开始，每个位上数乘以 8 的位数减 1 次方然后求和。</p>
<p>0123 = 3<em>80 + 2</em>81 + 1<em>82 + 0</em>83 = 83</p>
<h3 id="其他进制互转"><a class="markdownIt-Anchor" href="#其他进制互转"></a> 其他进制互转</h3>
<ul>
<li>二进制转换八进制：将二进制数从低位开始，每三位一组，转换成八进制数即可；</li>
<li>二进制转十六进制：将二进制数从低位开始，每四位一组，转换成十六进制数即可；</li>
<li>八进制转换二进制：将八进制数每 1 位转换成一个 3 位的二进制数（首位 0 除外）；</li>
<li>十六进制转二进制：将十六进制每 1 位转换成对应的一个 4 位的二进制数即可。</li>
</ul>
<h3 id="反码补码"><a class="markdownIt-Anchor" href="#反码补码"></a> 反码补码</h3>
<p>对于有符号数而言，二进制的最高为是符号位：0 表示正数，1 表示负数。</p>
<p>短除法进行进制转变</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkj31dvdq2j30no0f6wks.jpg" alt="" /></p>
<p><code>十进制</code>的10-&gt; 二进制：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkj392vw2zj30o00fi441.jpg" alt="" /></p>
<p><code>二进制</code>的1011 -&gt; 十进制</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkj3cnxtifj30o00ba786.jpg" alt="" /></p>
<p>想要详细了解其原理的可以参考<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclOUYlQUQlRTklOTklQTQlRTYlQjMlOTUvMzY0MDk1OD9mcj1hbGFkZGlu">短除法<i class="fa fa-external-link-alt"></i></span><br />
相关说明</p>
<p>位运算符对整数在内存中的二进制位进行操作。</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">参与运算的两数各对应的二进位相与。 （两位均为1才为1）</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1）</td>
</tr>
<tr>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:center">左移n位就是乘以2的n次方。 “a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td>
</tr>
<tr>
<td style="text-align:center">&gt; &gt;</td>
<td style="text-align:center">右移n位就是除以2的n次方。 “a&gt;&gt;b”是把a的各二进位全部右移b位。</td>
</tr>
</tbody>
</table>
<p>XOR - 异或：相同为0，不同为1.也可用“进位加法”来理解</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x ^ <span class="number">0</span> = X</span><br><span class="line">x ^ <span class="number">1</span>s = ~x  # <span class="number">1</span>s = ~ <span class="number">0</span></span><br><span class="line">x ^ (~x) = <span class="number">1</span>s </span><br><span class="line">x ^ x = <span class="number">0</span></span><br><span class="line">c = a ^ b  =&gt; a ^ c = b, b ^c = a # 交换两数</span><br><span class="line">a ^ b ^ c = a ^(b ^ c) = (a ^ b) ^c # associative</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定未知的位运算</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 将x最右边的n位请零： x &amp; (~<span class="number">0</span> &lt;&lt; n )</span><br><span class="line"><span class="number">2.</span> 获取x的第n位值（<span class="number">0</span> 或 <span class="number">1</span>）： （x &gt;&gt; n）&amp; <span class="number">1</span></span><br><span class="line"><span class="number">3.</span> 获取x的第n位的幂值：x &amp; （<span class="number">1</span> &lt;&lt; n）</span><br><span class="line"><span class="number">4.</span> 仅将第n位置为 <span class="number">1</span>： x | (<span class="number">1</span> &lt;&lt; n)</span><br><span class="line"><span class="number">5.</span> 仅将第n位置为<span class="number">0</span>：x &amp; （~<span class="number">1</span>（<span class="number">1</span> &lt;&lt; n））</span><br><span class="line"><span class="number">6.</span> 将x最高位至第n位(含)清零：x &amp; ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实战位运算要点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断奇偶性</span></span><br><span class="line">x % <span class="number">2</span> == <span class="number">1</span> - &gt; (x &amp; <span class="number">1</span>) == <span class="number">1</span> </span><br><span class="line">x &amp; <span class="number">2</span> == <span class="number">0</span> -&gt; (x&amp;<span class="number">1</span>) == <span class="number">0</span></span><br><span class="line"> <span class="comment">// 清零最低位的1</span></span><br><span class="line">x = x &amp; (x - <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 得到最低位的1</span></span><br><span class="line">x &amp; ~x </span><br><span class="line">x &amp; ~ x = &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>为了更清晰的观察其变化，我们使用二进制来进行演示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> a, b := <span class="number">13</span>, <span class="number">21</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;a:%b &amp; %b = %b\n&quot;</span>, a, b, a &amp; b)</span><br><span class="line"> fmt.Printf(<span class="string">&quot;a:%b | %b = %b\n&quot;</span>, a, b, a | b)</span><br><span class="line"> fmt.Printf(<span class="string">&quot;a:%b ^ %b = %b\n&quot;</span>, a, b, a ^ b)</span><br><span class="line"> fmt.Printf(<span class="string">&quot;a:%b ^ %b = %b\n&quot;</span>, a, b, a ^ b)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 左移</span></span><br><span class="line">  <span class="comment">// 二进制表示</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%b &lt;&lt; %b = %b\n&quot;</span>,<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&lt;&lt;<span class="number">2</span>) <span class="comment">// 10 &lt;&lt; 10 = 1000</span></span><br><span class="line">  <span class="comment">// 十进制</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%d &lt;&lt; %d = %d\n&quot;</span>,<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&lt;&lt;<span class="number">2</span>) <span class="comment">// 2 &lt;&lt; 2 = 8</span></span><br><span class="line"> <span class="comment">// 右移</span></span><br><span class="line">  <span class="comment">// 二进制</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%b &gt;&gt; %b = %b\n&quot;</span>,<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&gt;&gt;<span class="number">2</span>) <span class="comment">// 10 &gt;&gt; 10 = 0</span></span><br><span class="line">  <span class="comment">// 十进制</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%d &gt;&gt; %d = %d\n&quot;</span>,<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&gt;&gt;<span class="number">2</span>) <span class="comment">// 2 &gt;&gt; 2 = 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="赋值运算符"><a class="markdownIt-Anchor" href="#赋值运算符"></a> 赋值运算符</h2>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">简单的赋值运算符，将一个表达式的值赋给一个左值</td>
</tr>
<tr>
<td style="text-align:center">+=</td>
<td style="text-align:center">相加后再赋值</td>
</tr>
<tr>
<td style="text-align:center">-=</td>
<td style="text-align:center">相减后再赋值</td>
</tr>
<tr>
<td style="text-align:center">*=</td>
<td style="text-align:center">相乘后再赋值</td>
</tr>
<tr>
<td style="text-align:center">/=</td>
<td style="text-align:center">相除后再赋值</td>
</tr>
<tr>
<td style="text-align:center">%=</td>
<td style="text-align:center">求余后再赋值</td>
</tr>
<tr>
<td style="text-align:center">&lt;&lt;=</td>
<td style="text-align:center">左移后赋值</td>
</tr>
<tr>
<td style="text-align:center">&gt; &gt; =</td>
<td style="text-align:center">右移后赋值</td>
</tr>
<tr>
<td style="text-align:center">&amp;=</td>
<td style="text-align:center">按位与后赋值</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center">=</td>
</tr>
<tr>
<td style="text-align:center">^=</td>
<td style="text-align:center">按位异或后赋值</td>
</tr>
</tbody>
</table>
<h2 id="运算符优先级"><a class="markdownIt-Anchor" href="#运算符优先级"></a> 运算符优先级</h2>
<p>运算符优先级确定表达式中的分组。这会影响表达式的计算方式。某些运算符比其他运算符具有更高的优先级;<br />
例如，乘法运算符比加法运算符有更高的优先级。</p>
<p>当同级别的运算符出现在同一个表达式中，从左到右的顺序计算，比如乘除一起，不管是乘在前面还是除在前面都是从左到右计算乘、除运算符。加减亦是如此。</p>
<p>例如：<code>x = 7 + 3 * 2</code>; 这里，计算结果<code>x</code>被分配<code>13</code>，而不是<code>20</code>，因为运算符 <code>*</code>具有比<code>+</code><br />
有更的优先级，所以它首先乘以<code>3 * 2</code>，然后加上<code>7</code>。</p>
<p>这里，具有最高优先级的运算符放在表的顶部，具有最低优先级的运算符出现在底部。 在表达式中，将首先计算较高优先级运算符。</p>
<table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">关联性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">后缀</td>
<td style="text-align:center">()[]-&gt;.++ –</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">一元</td>
<td style="text-align:center">+ -!~++ --(type)*&amp;sizeof</td>
<td style="text-align:center">右到左</td>
</tr>
<tr>
<td style="text-align:center">乘法</td>
<td style="text-align:center">*/ %</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">加法</td>
<td style="text-align:center">+ -</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">移位</td>
<td style="text-align:center">&lt;&lt;&gt;&gt;</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">关系</td>
<td style="text-align:center">&lt;&lt;=&gt;&gt;=</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">相等</td>
<td style="text-align:center">==!=</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">按位AND</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">按位XOR</td>
<td style="text-align:center">^</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">按位OR</td>
<td style="text-align:center">\</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">逻辑AND</td>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">左到右</td>
</tr>
<tr>
<td style="text-align:center">逻辑OR</td>
<td style="text-align:center">\</td>
<td style="text-align:center">\</td>
</tr>
<tr>
<td style="text-align:center">条件</td>
<td style="text-align:center">?:</td>
<td style="text-align:center">右到左</td>
</tr>
<tr>
<td style="text-align:center">分配</td>
<td style="text-align:center">=+=-=*=/= %=&gt;&gt;= &lt;&lt;= &amp;= ^= \</td>
<td style="text-align:center">=</td>
</tr>
<tr>
<td style="text-align:center">逗号</td>
<td style="text-align:center">,</td>
<td style="text-align:center">左到右</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang初识结构体</title>
    <url>/64552.html</url>
    <content><![CDATA[<h2 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h2>
<p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称<code>struct</code><br />
。 也就是我们可以通过<code>struct</code>来定义自己的类型了。</p>
<p>Go语言中通过<code>struct</code>来实现<code>面向对象</code>的相关概念。</p>
<span id="more"></span>
<h3 id="结构体的定义"><a class="markdownIt-Anchor" href="#结构体的定义"></a> 结构体的定义</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用type和struct关键字来定义结构体</span></span><br><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体定义需注意</p>
<ul>
<li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li>
<li>字段名：表示结构体字段名。结构体中的字段名必须唯一。</li>
<li>字段类型：表示结构体字段的具体类型</li>
</ul>
<p>具体定义如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"> name <span class="type">string</span></span><br><span class="line"> age <span class="type">int</span></span><br><span class="line"> male <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当有相同类型的时候，我们还可以将相同类型的变量名使用“,”分割，写在一起。如下</span></span><br><span class="line"><span class="keyword">type</span> Person1 <span class="keyword">struct</span> &#123;</span><br><span class="line"> name,male <span class="type">string</span></span><br><span class="line"> age <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就拥有了一个的自定义类型<code>person</code>，它有<code>name</code>、<code>male</code>、<code>age</code><br />
三个字段，分别表示姓名、性别和年龄。这样我们使用这个<code>person</code>结构体就能够很方便的在程序中表示和存储人信息了。</p>
<p>语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和性别等，本质上是一种聚合型的数据类型</p>
<p>将前面的融汇贯通，整点复合型的东东，搞起</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyString <span class="type">string</span></span><br><span class="line"><span class="keyword">type</span> MyInt=<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"> name MyString</span><br><span class="line"> age MyInt</span><br><span class="line"> male <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体定义了之后，咱们还需要进行初始化，才能使用。</p>
<h3 id="结构体初始化与基本使用"><a class="markdownIt-Anchor" href="#结构体初始化与基本使用"></a> 结构体初始化与基本使用</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyString <span class="type">string</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"> name MyString</span><br><span class="line"> age  MyInt</span><br><span class="line"> sex  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person1 <span class="keyword">struct</span> &#123;</span><br><span class="line"> name, sex <span class="type">string</span></span><br><span class="line"> age       <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> p Person</span><br><span class="line"> <span class="keyword">var</span> p1 Person1</span><br><span class="line"> p.name = <span class="string">&quot;Payne&quot;</span></span><br><span class="line"> p.sex = <span class="string">&quot;male&quot;</span></span><br><span class="line"> p.age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"> p1.name = <span class="string">&quot;Tim&quot;</span></span><br><span class="line"> p1.sex = <span class="string">&quot;female&quot;</span></span><br><span class="line"> p1.age = <span class="number">23</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;Type:%T,value:%v\n&quot;</span>, p, p)</span><br><span class="line"> fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p)</span><br><span class="line"> fmt.Printf(<span class="string">&quot;Type:%T,value:%v\n&quot;</span>, p1, p1)</span><br><span class="line"> fmt.Printf(<span class="string">&quot;%#v&quot;</span>, p1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Type:main.Person,value:{Payne 20 male}<br />
main.Person{name:“Payne”, age:20, sex:“male”}<br />
Type:main.Person1,value:{Tim female 23}<br />
main.Person1{name:“Tim”, sex:“female”, age:23}</p>
</blockquote>
<p>通过以上示例我们知道，它是通过<code>.</code>，来一个一个的进行赋值</p>
<p>当然我们也是可以通过键值对对形式，从而进行批量赋值的，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p1 := Person1&#123;</span><br><span class="line"> name: <span class="string">&quot;a&quot;</span>,</span><br><span class="line"> age:  <span class="number">20</span>,</span><br><span class="line"> sex:  <span class="string">&quot;male&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;type: %T, value:%#v&quot;</span>, p1, p1)</span><br></pre></td></tr></table></figure>
<h4 id="匿名结构体"><a class="markdownIt-Anchor" href="#匿名结构体"></a> 匿名结构体</h4>
<p>在定义一些临时数据结构等场景下还可以使用匿名结构体。如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> person2 <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">  age  <span class="type">int</span></span><br><span class="line">  sex  <span class="type">string</span></span><br><span class="line"> &#125;</span><br><span class="line"> person2.name = <span class="string">&quot;Payne&quot;</span></span><br><span class="line"> person2.age = <span class="number">20</span></span><br><span class="line"> person2.sex = <span class="string">&quot;male&quot;</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;Type:%T,value:%v\n&quot;</span>, person2, person2)</span><br><span class="line"> fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, person2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type:struct &#123; name string; age int; sex string &#125;,value:&#123;Payne 20 male&#125;</span></span><br><span class="line"><span class="comment">// struct &#123; name string; age int; sex string &#125;&#123;name:&quot;Payne&quot;, age:20, sex:&quot;male&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="指针类型结构体"><a class="markdownIt-Anchor" href="#指针类型结构体"></a> 指针类型结构体</h3>
<p>通过使用<code>new</code>关键字堆结构体初始化，得到的是结构体的地址值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person3 <span class="keyword">struct</span> &#123;</span><br><span class="line"> name   <span class="type">string</span></span><br><span class="line"> gender <span class="type">string</span></span><br><span class="line"> hobby  <span class="type">string</span></span><br><span class="line"> age    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> p3 = <span class="built_in">new</span>(person3)</span><br><span class="line"> fmt.Printf(<span class="string">&quot;Type:%T, Vlue:%v&quot;</span>, p3, p3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然是地址值，那么我们也是可以使用<code>&amp;</code>对他进行运算等操作的，相当于new</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person3 <span class="keyword">struct</span> &#123;</span><br><span class="line"> name   <span class="type">string</span></span><br><span class="line"> gender <span class="type">string</span></span><br><span class="line"> hobby  []<span class="type">string</span></span><br><span class="line"> age    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> p3 := &amp;person3&#123;&#125;</span><br><span class="line"> p3.name = <span class="string">&quot;payne&quot;</span></span><br><span class="line"> p3.gender = <span class="string">&quot;sex&quot;</span></span><br><span class="line"> p3.hobby = []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line"> p3.age = <span class="number">20</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>p3.name = &quot;payne&quot;</code>其实在底层是<code>(*p3).name = &quot;payne&quot;</code>，这是Go语言帮我们实现的语法糖。</p>
</blockquote>
<h3 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h3>
<p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个<code>person</code>的构造函数。<br />
因为<code>struct</code>是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型</p>
<p>借用结构体构造函数，实现<code>类</code>的概念，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person5 <span class="keyword">struct</span> &#123;</span><br><span class="line"> name <span class="type">string</span></span><br><span class="line"> age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newClass</span><span class="params">(name <span class="type">string</span>, age <span class="type">int</span>)</span></span> *person5 &#123;</span><br><span class="line"> <span class="keyword">return</span> &amp;person5&#123;</span><br><span class="line">  name: name,</span><br><span class="line">  age:  age,</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> p5 := newClass(<span class="string">&quot;payne&quot;</span>, <span class="number">10</span>)</span><br><span class="line"> fmt.Printf(<span class="string">&quot;value:%#v&quot;</span>, p5)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go语言中的<code>方法（Method）</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者（Receiver）</code><br />
。接收者的概念就类似于其他语言中的<code>this</code>或者 <code>self</code>。</p>
<p>方法的定义格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span></span> 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(谁能调用我？-接收者)</span></span> 方法名(参数列表) (返回类型) &#123;</span><br><span class="line">  函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是<code>self</code>、<code>this</code><br />
之类的命名。例如，<code>Person</code>类型的接收者变量应该命名为 <code>p</code>，<code>Connector</code><br />
类型的接收者变量应该命名为<code>c</code>等。</li>
<li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li>
<li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person 结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"> name <span class="type">string</span></span><br><span class="line"> age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewPerson 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="type">string</span>, age <span class="type">int8</span>)</span></span> *Person &#123;</span><br><span class="line"> <span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">  name: name,</span><br><span class="line">  age:  age,</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dream Person做梦的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Dream() &#123;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;%s的梦想是学好Go语言！\n&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> p1 := NewPerson(<span class="string">&quot;Payne&quot;</span>, <span class="number">25</span>)</span><br><span class="line"> p1.Dream()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p>
<h3 id="值类型的接收者"><a class="markdownIt-Anchor" href="#值类型的接收者"></a> 值类型的接收者</h3>
<p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SetAge2 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用值接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> SetAge2(newAge <span class="type">int8</span>) &#123;</span><br><span class="line"> p.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> p1 := NewPerson(<span class="string">&quot;Payne&quot;</span>, <span class="number">25</span>)</span><br><span class="line"> p1.Dream()</span><br><span class="line"> fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line"> p1.SetAge2(<span class="number">30</span>) <span class="comment">// (*p1).SetAge2(30)</span></span><br><span class="line"> fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指针类型的接收者"><a class="markdownIt-Anchor" href="#指针类型的接收者"></a> 指针类型的接收者</h3>
<p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的<code>this</code><br />
或者<code>self</code>。 例如我们为<code>Person</code><br />
添加一个<code>SetAge</code>方法，来修改实例变量的年龄。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SetAge 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用指针接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> SetAge(newAge <span class="type">int8</span>) &#123;</span><br><span class="line"> p.age = newAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用该方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> p1 := NewPerson(<span class="string">&quot;Payne&quot;</span>, <span class="number">25</span>)</span><br><span class="line"> fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line"> p1.SetAge(<span class="number">30</span>)</span><br><span class="line"> fmt.Println(p1.age) <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="什么时候应该使用指针类型接收者"><a class="markdownIt-Anchor" href="#什么时候应该使用指针类型接收者"></a> 什么时候应该使用指针类型接收者</h3>
<ol>
<li>需要修改接收者中的值</li>
<li>接收者是拷贝代价比较大的大对象</li>
<li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li>
</ol>
<h2 id="结构体的继承"><a class="markdownIt-Anchor" href="#结构体的继承"></a> 结构体的“继承”</h2>
<p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line"> name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span></span> move() &#123;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;%s会动！\n&quot;</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line"> Feet    <span class="type">int8</span></span><br><span class="line"> *Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> wang() &#123;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> d1 := &amp;Dog&#123;</span><br><span class="line">  Feet: <span class="number">4</span>,</span><br><span class="line">  Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">   name: <span class="string">&quot;aw&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"> &#125;</span><br><span class="line"> d1.wang() <span class="comment">//aw会汪汪汪~</span></span><br><span class="line"> d1.move() <span class="comment">//aw会动！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意点"><a class="markdownIt-Anchor" href="#注意点"></a> 注意点</h2>
<ol>
<li>Golang传递参数，永远是拷贝。也就是说，在函数内部改变其值，仅仅在内部生效。若想在某一函数中改变其全局的值。需要使用指针</li>
</ol>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>HomeBrew使用技巧</title>
    <url>/48740.html</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0hvbWVicmV3L2JyZXc=">GitHub<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9icmV3LnNoLw==">HomeBrew官方地址<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmJyZXcuc2gv">docs<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmJyZXcuc2gvRm9ybXVsYS1Db29rYm9vayNob21lYnJldy10ZXJtaW5vbG9neQ==">docs-Formula-Cookbook<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9icmV3LmlkYXllci5jb20v">brew.idayer<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="homebrew是什么"><a class="markdownIt-Anchor" href="#homebrew是什么"></a> Homebrew是什么</h2>
<p>Homebrew简单来说他是类似于<code>yum、apt</code>,mac的包管理工具，使用它我们可以非常简单、丝滑的下载大部分的包、或者软件</p>
<h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 官方</span></span><br><span class="line">/bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span></span><br><span class="line"><span class="comment"># cdn</span></span><br><span class="line">/bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>完成安装后使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew update &amp;&amp; brew upgrade &amp;&amp; brew doctor &amp;&amp; brew -v</span><br></pre></td></tr></table></figure>
<h2 id="使用技巧"><a class="markdownIt-Anchor" href="#使用技巧"></a> 使用技巧</h2>
<h3 id="配置阿里云镜像"><a class="markdownIt-Anchor" href="#配置阿里云镜像"></a> 配置阿里云镜像</h3>
<p>配置阿里云mirror：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9taXJyb3IvaG9tZWJyZXc=">https://developer.aliyun.com/mirror/homebrew<i class="fa fa-external-link-alt"></i></span></p>
<p>完成后记得使用如下命令进行更新</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew update; brew upgrade; brew cleanup; brew doctor</span><br></pre></td></tr></table></figure>
<h3 id="防止更新特定的自制配方"><a class="markdownIt-Anchor" href="#防止更新特定的自制配方"></a> 防止更新特定的自制配方</h3>
<p>如果要避免更新某些公式，可以使用以下brew命令将当前版本保持不变：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew pin [name]</span><br></pre></td></tr></table></figure>
<p>当然，您可以取消固定公式以再次对其进行更新：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew unpin [formula]</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看使用brew安装的服务列表</span></span><br><span class="line">brew services list</span><br><span class="line"> <span class="comment"># 启动服务（仅启动不注册）</span></span><br><span class="line">brew services run formula|--all</span><br><span class="line"><span class="comment"># 启动服务，并注册</span></span><br><span class="line">brew services start formula|--all</span><br><span class="line"><span class="comment"># 停止服务，并取消注册</span></span><br><span class="line">brew services stop formula|--all</span><br><span class="line"><span class="comment"># 重启服务，并注册</span></span><br><span class="line">brew services restart formula|--all</span><br><span class="line"><span class="comment"># 清除已卸载应用的无用的配置</span></span><br><span class="line">brew services cleanup  </span><br></pre></td></tr></table></figure>
<h3 id="基于软连接实现多版本控制"><a class="markdownIt-Anchor" href="#基于软连接实现多版本控制"></a> 基于软连接实现多版本控制</h3>
<p>当hombrew中有多个版本时，可以基于<code>link</code> or <code>unlink</code> 实现包版本的控制</p>
<blockquote>
<ul>
<li>当并不需要配置环境变量时</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew <span class="built_in">link</span> [name]</span><br></pre></td></tr></table></figure>
<h2 id="linux-下homebrew安装"><a class="markdownIt-Anchor" href="#linux-下homebrew安装"></a> Linux 下Homebrew安装</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Debian or Ubuntu</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y build-essential procps curl file git</span><br><span class="line"><span class="comment"># Fedora, CentOS, or Red Hat</span></span><br><span class="line"><span class="built_in">sudo</span> yum groupinstall -y <span class="string">&#x27;Development Tools&#x27;</span></span><br><span class="line"><span class="built_in">sudo</span> yum install -y procps-ng curl file git libxcrypt-compat</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmJyZXcuc2gvSG9tZWJyZXctb24tTGludXgjcmVxdWlyZW1lbnRz">https://docs.brew.sh/Homebrew-on-Linux#requirements<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="tap"><a class="markdownIt-Anchor" href="#tap"></a> TAP</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">homebrew/cask</span><br><span class="line">homebrew/core</span><br><span class="line">homebrew/services</span><br><span class="line">isacikgoz/taps</span><br><span class="line">mongodb/brew</span><br><span class="line">petere/postgresql</span><br><span class="line">shivammathur/php</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>HomeBrew</category>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>HomeBrew</tag>
      </tags>
  </entry>
  <entry>
    <title>JS逆向算法还原常用技巧</title>
    <url>/34708.html</url>
    <content><![CDATA[<p>Hi，许久不见，我是Payne啊。</p>
<p>ok，那么我们先说说核心本质吧，其核心本质个人认为依旧是伪装。就像爬虫为对面对反爬虫反制，从而添加特征，不断的逼近<br />
<strong>像</strong>真人。</p>
<p>自然在参数、环境还原这里也是。</p>
<p>无论是一下的<strong>补环境</strong>、<strong>扣代码</strong>、<strong>手动还原</strong>，也都是在模拟生成加密逻辑。</p>
<h2 id="补环境"><a class="markdownIt-Anchor" href="#补环境"></a> 补环境</h2>
<h3 id="补环境的定义"><a class="markdownIt-Anchor" href="#补环境的定义"></a> 补环境的定义</h3>
<p>补环境顾名思义就是，将获取到的关键JS在通过<strong>修补环境</strong>的方法在本地或服务器上能够正常运行获取到正确的返回值，从而完成参数的加密模拟。</p>
<p>当然大部分情况下补环境与抠代码密不可分（一般是扣代码，然后在补环境），扣代码移步第二部分</p>
<h3 id="核心本质"><a class="markdownIt-Anchor" href="#核心本质"></a> 核心本质</h3>
<p>无论是缺啥补啥的前的构建错误，还是使用代理监控运行。都是在做链路追踪。在补环境这里是秉承着遇河搭桥，缺啥补啥思路。</p>
<p>常用的方法一般有两个：</p>
<blockquote>
<p>假设获取到了核心的JS代码后</p>
</blockquote>
<p>一种是使用运行，从而构建错误实现报错，然后通过补方法、对象来fix。从而完成补环境，（当然这是必须的）。</p>
<p>当完成以上的操作后，遇见风控、遇见伏点。可以正常通过运行，但无法获取到正确的参数。此时使用<code>Proxy</code><br />
来监听实现监测，协助调试。</p>
<h3 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h3>
<p>是方法写空方法<code>arguments</code>看传参，对象写空对象<code>Proxy</code>来相助，进行链路追踪，完成模拟</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span> = <span class="variable language_">global</span>;</span><br><span class="line"><span class="variable language_">document</span> = &#123;</span><br><span class="line">  <span class="attr">location</span>: &#123;<span class="string">&#x27;protocol&#x27;</span>: <span class="string">&#x27;https:&#x27;</span>&#125;,</span><br><span class="line">  <span class="attr">referrer</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">getElementById</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;getElementById:&quot;</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getElementsByClassName</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;getElementsByClassName:&quot;</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getElementsByName</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;getElementsByName:&quot;</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getElementsByTagName</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;getElementsByTagName:&quot;</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getElementsByTagNameNS</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;getElementsByTagNameNS:&quot;</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">createElement</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;createElement:&quot;</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">navigator = &#123;</span><br><span class="line">  <span class="attr">appCodeName</span>: <span class="string">&quot;Mozilla&quot;</span>,</span><br><span class="line">  <span class="attr">appName</span>: <span class="string">&quot;Netscape&quot;</span>,</span><br><span class="line">  <span class="attr">appVersion</span>: <span class="string">&quot;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36&quot;</span>,</span><br><span class="line">  <span class="attr">language</span>: <span class="string">&quot;zh-CN&quot;</span>,</span><br><span class="line">  <span class="attr">languages</span>: (<span class="number">2</span>)[<span class="string">&#x27;zh-CN&#x27;</span>, <span class="string">&#x27;zh&#x27;</span>],</span><br><span class="line">  <span class="attr">platform</span>: <span class="string">&quot;MacIntel&quot;</span>,</span><br><span class="line">  <span class="attr">product</span>: <span class="string">&quot;Gecko&quot;</span>,</span><br><span class="line">  <span class="attr">productSub</span>: <span class="string">&quot;20030107&quot;</span>,</span><br><span class="line">  <span class="attr">userAgent</span>: <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36&quot;</span>,</span><br><span class="line">  <span class="attr">vendor</span>: <span class="string">&quot;Google Inc.&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">screen = &#123;</span><br><span class="line">  <span class="attr">availHeight</span>: <span class="number">1055</span>,</span><br><span class="line">  <span class="attr">availLeft</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">availTop</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">availWidth</span>: <span class="number">1920</span>,</span><br><span class="line">  <span class="attr">colorDepth</span>: <span class="number">24</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">1080</span>,</span><br><span class="line">  <span class="attr">pixelDepth</span>: <span class="number">24</span>,</span><br><span class="line">  <span class="attr">width</span>: <span class="number">1920</span>,</span><br><span class="line">&#125;;</span><br><span class="line">location = &#123;</span><br><span class="line">  <span class="attr">href</span>: <span class="string">&#x27;https://www.xxx.com/website-login/captcha?redirectPath=https%3A%2F%2Fwww.xxx.com%2Fdiscovery%2Fitem%2F618bf8f60000000001027ccd&#x27;</span>,</span><br><span class="line">  <span class="attr">hostname</span>: <span class="string">&#x27;www.xxx.com&#x27;</span>,</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&#x27;www.xxx.com&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3>
<ol>
<li>缺啥补啥：通过本地运行实现错误</li>
</ol>
<p>Proxy</p>
<p>空对象：使用proxy代理，空方法：使用其中的<code>arguments</code>，获取传入参数</p>
<p>获取DOM节点：当做<code>[ ]</code>处理</p>
<p>创建DOM节点：当作<code>&#123; &#125;</code>处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">null_function = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">proxy</span> = (<span class="params">obj, obj_name</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function">(<span class="params">target, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(obj_name, <span class="string">&quot;Getting&quot;</span>, key)</span><br><span class="line">      <span class="keyword">return</span> target[key];</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//吐环境</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">proxy</span>(<span class="params">proxy_array</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; proxy_array; i++) &#123;</span><br><span class="line">    <span class="built_in">eval</span>(proxy_array[i] + <span class="string">&#x27; = new Proxy(&#x27;</span> + proxy_array[i] + <span class="string">&#x27;,&#123; &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;get(target,key)&#123; &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;debugger;&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;console.log(&quot;====================&quot;)&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;console.log(&quot;获取了&quot;,&#x27;</span> + proxy_array[i] + <span class="string">&#x27; 的key属性&quot;); &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;console.log(&quot;====================&quot;)&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;return target[key]; &#125;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常用的proxy_array</span></span><br><span class="line"><span class="keyword">var</span> proxy_array = [<span class="string">&quot;window&quot;</span>, <span class="string">&quot;document&quot;</span>, <span class="string">&quot;location&quot;</span>, <span class="string">&quot;navigator&quot;</span>]</span><br><span class="line"><span class="title function_">proxy</span>(proxy_array)</span><br></pre></td></tr></table></figure>
<h2 id="抠代码"><a class="markdownIt-Anchor" href="#抠代码"></a> 抠代码</h2>
<p>找到关键入口，抠下来🐶～。</p>
<p>重在调试，不再抠（抠就是复制粘贴）</p>
<p>小技巧：</p>
<p>打开浏览器的设置，找到如下所示的<code>code filding</code> 勾选打开。JS代码收缩复制一气呵成，妙啊～</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gxnrxih3bqj308v07mweo.jpg" alt="image-20211223145757359" /></p>
<h2 id="手动还原"><a class="markdownIt-Anchor" href="#手动还原"></a> 手动还原</h2>
<p>通过调试查看算法实现过程，结合加密库复现。</p>
<blockquote>
<p>Tip: 可以但没必要，手撕随爽，但可不要贪杯哦</p>
</blockquote>
]]></content>
      <categories>
        <category>JS</category>
        <category>逆向</category>
        <category>sec</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JetBrains编辑器清理(mac)</title>
    <url>/33092.html</url>
    <content><![CDATA[<h2 id="缘由"><a class="markdownIt-Anchor" href="#缘由"></a> 缘由</h2>
<p>由于不可描述的原因，我需要将<code>JetBrains</code>的所有已安装的编辑器进行清理。但我们知道MAC上单纯将应用软件中的软件拖入废纸篓是无法进行彻底删除的。</p>
<blockquote>
<p>Tip: 有<code>Cleaner One Pro</code>或者<code>clean my mac</code> 专业版的（也就是付费版）的朋友可以直接在该软件中进行软件的卸载与清理，具体操作便不再此过多赘述</p>
</blockquote>
<h2 id="关键目录"><a class="markdownIt-Anchor" href="#关键目录"></a> 关键目录</h2>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">~/Library/Application\ Support/JetBrains</span><br><span class="line">~/Library/Logs/JetBrains</span><br><span class="line">~/Library/Preferences/JetBrains.*</span><br><span class="line">~/Library/Caches/JetBrains</span><br><span class="line">/Applications</span><br></pre></td></tr></table></figure>
<h3 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h3>
<blockquote>
<p>Tip：建议先将<code>/Applications</code> 中的内容先进行删除</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -rf ~/Library/Application\ Support/JetBrains/*</span><br><span class="line">rm -rf ~/Library/Logs/JetBrains/*</span><br><span class="line">rm -rf ~/Library/Preferences/JetBrains.*</span><br><span class="line">rm -rf ~/Library/Caches/JetBrains/*</span><br></pre></td></tr></table></figure>
<h2 id="evalreset-cleanr-script"><a class="markdownIt-Anchor" href="#evalreset-cleanr-script"></a> Evalreset Cleanr Script</h2>
<h3 id="maclinux"><a class="markdownIt-Anchor" href="#maclinux"></a> Mac/Linux</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env sh</span></span><br><span class="line"><span class="comment"># reset jetbrains ide evals</span></span><br><span class="line"></span><br><span class="line">OS_NAME=$(<span class="built_in">uname</span> -s)</span><br><span class="line">JB_PRODUCTS=<span class="string">&quot;IntelliJIdea CLion PhpStorm GoLand PyCharm WebStorm Rider DataGrip RubyMine AppCode&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$OS_NAME</span> == <span class="string">&quot;Darwin&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&#x27;macOS:&#x27;</span></span><br><span class="line"> </span><br><span class="line"> <span class="built_in">rm</span> -rf ~/Library/Logs/JetBrains/*</span><br><span class="line"> <span class="built_in">rm</span> -rf ~/Library/Caches/JetBrains/*</span><br><span class="line"> <span class="built_in">rm</span> -rf ~/Library/Preferences/JetBrains.*</span><br><span class="line"> <span class="keyword">for</span> PRD <span class="keyword">in</span> <span class="variable">$JB_PRODUCTS</span>; <span class="keyword">do</span></span><br><span class="line">     <span class="built_in">rm</span> -rf ~/Library/Preferences/<span class="variable">$&#123;PRD&#125;</span>*/*</span><br><span class="line">     <span class="built_in">rm</span> -rf ~/Library/Application\ Support/JetBrains/<span class="variable">$&#123;PRD&#125;</span>*/eval</span><br><span class="line"> <span class="keyword">done</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$OS_NAME</span> == <span class="string">&quot;Linux&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&#x27;Linux:&#x27;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> PRD <span class="keyword">in</span> <span class="variable">$JB_PRODUCTS</span>; <span class="keyword">do</span></span><br><span class="line">     <span class="built_in">rm</span> -rf ~/.<span class="variable">$&#123;PRD&#125;</span>*/config/eval</span><br><span class="line">     <span class="built_in">rm</span> -rf ~/.config/<span class="variable">$&#123;PRD&#125;</span>*/eval</span><br><span class="line"> <span class="keyword">done</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&#x27;unsupport&#x27;</span></span><br><span class="line"> <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;done.&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows</h3>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Set</span> oShell = <span class="built_in">CreateObject</span>(<span class="string">&quot;WScript.Shell&quot;</span>)</span><br><span class="line"><span class="keyword">Set</span> oFS = <span class="built_in">CreateObject</span>(<span class="string">&quot;Scripting.FileSystemObject&quot;</span>)</span><br><span class="line">sHomeFolder = oShell.ExpandEnvironmentStrings(<span class="string">&quot;%USERPROFILE%&quot;</span>)</span><br><span class="line">sJBDataFolder = oShell.ExpandEnvironmentStrings(<span class="string">&quot;%APPDATA%&quot;</span>) + <span class="string">&quot;\JetBrains&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Set</span> re = <span class="keyword">New</span> RegExp</span><br><span class="line">re.Global     = <span class="literal">True</span></span><br><span class="line">re.IgnoreCase = <span class="literal">True</span></span><br><span class="line">re.Pattern    = <span class="string">&quot;\.?(IntelliJIdea|GoLand|CLion|PyCharm|DataGrip|RubyMine|AppCode|PhpStorm|WebStorm|Rider).*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> remove<span class="built_in">Eval</span>(<span class="keyword">ByVal</span> file, <span class="keyword">ByVal</span> sEvalPath)</span><br><span class="line"> bMatch = re.Test(file.Name)</span><br><span class="line">    <span class="keyword">If</span> <span class="keyword">Not</span> bMatch <span class="keyword">Then</span></span><br><span class="line">  <span class="keyword">Exit</span> <span class="keyword">Sub</span></span><br><span class="line"> <span class="keyword">End</span> <span class="keyword">If</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">If</span> oFS.FolderExists(sEvalPath) <span class="keyword">Then</span></span><br><span class="line">  oFS.DeleteFolder sEvalPath, <span class="literal">True</span> </span><br><span class="line"> <span class="keyword">End</span> <span class="keyword">If</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> oFS.FolderExists(sHomeFolder) <span class="keyword">Then</span></span><br><span class="line"> <span class="keyword">For</span> <span class="keyword">Each</span> oFile <span class="keyword">In</span> oFS.GetFolder(sHomeFolder).SubFolders</span><br><span class="line">     removeEval oFile, sHomeFolder + <span class="string">&quot;\&quot;</span> + oFile.Name + <span class="string">&quot;\config\eval&quot;</span></span><br><span class="line"> <span class="keyword">Next</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> oFS.FolderExists(sJBDataFolder) <span class="keyword">Then</span></span><br><span class="line"> <span class="keyword">For</span> <span class="keyword">Each</span> oFile <span class="keyword">In</span> oFS.GetFolder(sJBDataFolder).SubFolders</span><br><span class="line">     removeEval oFile, sJBDataFolder + <span class="string">&quot;\&quot;</span> + oFile.Name + <span class="string">&quot;\eval&quot;</span></span><br><span class="line"> <span class="keyword">Next</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br><span class="line"></span><br><span class="line">MsgBox <span class="string">&quot;done&quot;</span></span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9zaGltby5pbS9kb2NzL3FYSHJLcWRydGpKWDZ4dFgvcmVhZA==">qXHrKqdrtjJX6xtX<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3ZyZzEyMy5jb20v">vrg123<i class="fa fa-external-link-alt"></i></span> :  4565</p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aGlsZS5pby8yMDIwLzExLzE4L2pldGJyYWlucy1ldmFsLXJlc2V0LWRhMzNhOTNkLmh0bWw=">zhile<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLnpoaWxlLmlv">Zhile-plug<i class="fa fa-external-link-alt"></i></span>:    <span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLnpoaWxlLmlv">https://plugins.zhile.io<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Jetbrains</category>
      </categories>
      <tags>
        <tag>Jetbrains</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetbrains plugins</title>
    <url>/51384.html</url>
    <content><![CDATA[<h2 id="jetbrains-plugins"><a class="markdownIt-Anchor" href="#jetbrains-plugins"></a> Jetbrains plugins</h2>
<h3 id="通用"><a class="markdownIt-Anchor" href="#通用"></a> 通用</h3>
<p>ignore：生成git、dodkcer配置文件</p>
<p>Node.js：提供nodejs 支持</p>
<p>CSV: 用于编辑 CSV/TSV/PSV 文件的轻量级插件，具有灵活的表格编辑器、语法验证、结构突出显示、可自定义的颜色、新意图和有用的检查。</p>
<p>Rainbow CSV：用于以不同颜色突出显示 CSV 文件的插件。</p>
<p>Rainbow：基于 IntelliJ IDEA 的 IDE 的彩虹高亮标识符和分隔符</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudGFibmluZS5jb20vaW5zdGFsbA==">Tabnine<i class="fa fa-external-link-alt"></i></span>： 代码智能提示</p>
<p>Ideolog： “.log”文件的交互式查看器。</p>
<p>CodeGlance Pro：提供代码缩略图</p>
<p>env files support：基于 .env、Dockerfile 和 docker-compose.yml 文件的环境变量补全。</p>
<p>BashSupport Pro：是用于高级Bash和shell脚本开发的插件—调试器、测试运行程序、代码完成、查找用法、重命名、ShellCheck、shfmt等。</p>
<p>Key Promoter X：提供快捷键提示</p>
<p>Nyan Progress Bar：彩虹进度条</p>
<p>translation： 翻译插件</p>
<p>Markdown：提供markdown 格式支持</p>
<p>Monokai Pro：主题</p>
<p>Material Theme UI Plugin： 提供主题</p>
<p>Material Design Dark-Theme: 黑暗主题</p>
<p>warmneon: 个人最爱的主题配色</p>
<p>AEM IDE： 保护您避免引入讨厌的错误，在编写代码时给您反馈</p>
<p>Save Actions：格式化代码插件</p>
<p>Grep console: 自定义控制台输出</p>
<p>statistic：代码统计插件</p>
<p>GitToolBox： git增强</p>
<p>Selenium UI Testing: 为 UI 自动化提供高级支持</p>
<p>Test Data: 生成测试数据</p>
<p>test-management: 与TMS 集成,提供了许多智能功能</p>
<h3 id="pycharm"><a class="markdownIt-Anchor" href="#pycharm"></a> Pycharm</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9pbnRlbGxpai1hZW0uZ2l0bGFiLmlvLw==">AEM<i class="fa fa-external-link-alt"></i></span> PRO: 本部分提供有关开始使用 IntelliJ AEM<br />
所需步骤的信息，包括插件安装和初始项目设置。</p>
<p>Sourcery 是一个人工智能驱动的编码助手，它可以帮助你更快地编写更好的 Python<br />
代码。它通过动态提供重构建议来工作，您可以立即将这些建议集成到您的代码中。</p>
<h3 id="idea"><a class="markdownIt-Anchor" href="#idea"></a> IDEA</h3>
<p>Codota: 代码智能提示</p>
<p>Lombok：简化臃肿代码插件</p>
<p>Alibaba Java Coding Guidelines：阿里巴巴代码规范检查插件</p>
<p>CamelCase： 驼峰命名和下划线命名转换</p>
<p>MybatisX：高效操作 MybatisX 插件</p>
<p>SonarLint：代码质量检查插件</p>
<p>checkstyle：代码风格检查插件</p>
<p>MetricsReloaded 代码复杂度检查插件</p>
<p>Jump To Line: 转到任意行并设置执行点而无需执行前面的代码。</p>
<p>Maven helper: 查看、分析和排除相互冲突的依赖项</p>
<p>Squaretest: 自动生成单元测试</p>
<p>Jrebel：热部署插件</p>
<p>EasyCode： 数据库表自动的生成实体类</p>
<p>Arthas Idea： Java 在线诊断工具</p>
<p>Graph Buddy: 旨在加快您阅读和学习源代码的过程。Graph Buddy<br />
插件提供了一组有用的功能和技术，可帮助您轻松浏览扭曲的代码依赖项。同时，它可以让您更好地了解代码库中的代码结构。</p>
<p>源码插件技巧：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDEyMTY4MTUwNDkzOTU0MDc5">https://juejin.cn/post/7012168150493954079<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Jetbrains</category>
        <category>plugins</category>
      </categories>
      <tags>
        <tag>Jetbrains</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka发行版本与版本号</title>
    <url>/57663.html</url>
    <content><![CDATA[<h2 id="kafka-发行版本"><a class="markdownIt-Anchor" href="#kafka-发行版本"></a> Kafka 发行版本</h2>
<h3 id="apache-kafka"><a class="markdownIt-Anchor" href="#apache-kafka"></a> Apache Kafka</h3>
<p>Apache Kafka 是最“正宗”的 Kafka，也应该最熟悉的发行版。</p>
<p>自 Kafka 开源伊始，它便在 Apache 基金会孵化并最终毕业成为顶级项目，它也被称为社区版 Kafka。咱们专栏就是以这个版本的<br />
Kafka<br />
作为模板来学习的。更重要的是，它是后面其他所有发行版的基础。也就是说，后面提到的发行版要么是原封不动地继承了<br />
Apache Kafka，要么是在此之上扩展了新功能，总之 Apache Kafka 是我们学习和使用 Kafka 的基础</p>
<h4 id="优"><a class="markdownIt-Anchor" href="#优"></a> 优</h4>
<p>对 Apache Kafka 而言，它现在依然是开发人数最多、版本迭代速度最快的 Kafka。在 2018 年度 Apache<br />
基金会邮件列表开发者数量最多的 Top 5 排行榜中，Kafka 社区邮件组排名第二位。如果你使用 Apache<br />
Kafka 碰到任何问题并提交问题到社区，社区都会比较及时地响应你。这对于我们 Kafka 普通使用者来说无疑是非常友好的。</p>
<h4 id="劣"><a class="markdownIt-Anchor" href="#劣"></a> <strong>劣</strong></h4>
<p><em>Apache Kafka</em> 的劣势在于它仅仅提供最最基础的组件，特别是对于前面提到的 <em>Kafka Connect</em> 而言，社区版<br />
<em>Kafka</em><br />
只提供一种连接器，即读写磁盘文件的连接器，而没有与其他外部系统交互的连接器，在实际使用过程中需要自行编写代码实现，这是它的一个劣势。</p>
<p>另外 <em>Apache Kafka</em> 没有提供任何监控框架或工具。显然在线上环境不加监控肯定是不可行的，你必然需要借助第三方的监控框架实现对<br />
<em>Kafka</em> 的监控。好消息是目前有一些开源的监控框架可以帮助用于监控 <em>Kafka</em>（比如 *<br />
Kafka manager*）。</p>
<blockquote>
<p>总而言之，如果仅仅需要一个消息引擎系统亦或是简单的流处理应用场景，同时需要对系统有较大把控度，那么推荐你使用<br />
Apache Kafka。</p>
</blockquote>
<h3 id="confluent-kafka"><a class="markdownIt-Anchor" href="#confluent-kafka"></a> Confluent Kafka</h3>
<p>它主要从事商业化 Kafka 工具开发，并在此基础上发布了 Confluent Kafka。Confluent Kafka 提供了一些 Apache<br />
Kafka 没有的高级特性，</p>
<p>比如跨数据中心备份、Schema 注册中心以及集群监控工具等。</p>
<h4 id="优-2"><a class="markdownIt-Anchor" href="#优-2"></a> 优</h4>
<p>Confluent Kafka 目前分为免费版和企业版两种。</p>
<p>前者和 Apache Kafka 非常相像，除了常规的组件之外，免费版还包含 Schema 注册中心和 REST proxy 两大功能。</p>
<p>前者是帮助你集中管理 Kafka 消息格式以实现数据前向 / 后向兼容；</p>
<p>后者用开放 HTTP 接口的方式允许你通过网络访问 Kafka 的各种功能，这两个都是 Apache Kafka 所没有的。</p>
<p>除此之外，免费版包含了更多的连接器，它们都是 Confluent 公司开发并认证过的，可以免费使用它们。</p>
<p>至于企业版，它提供的功能就更多了。最有用的当属跨数据中心备份和集群监控两大功能了。</p>
<p>多个数据中心之间数据的同步以及对集群的监控历来是 Kafka 的痛点，Confluent Kafka 企业版提供了强大的解决方案帮助你“干掉”它们</p>
<h4 id="劣-2"><a class="markdownIt-Anchor" href="#劣-2"></a> 劣</h4>
<p>Confluent 公司暂时没有发展国内业务的计划，相关的资料以及技术支持都很欠缺，很多国内 Confluent Kafka<br />
使用者甚至无法找到对应的中文文档，因此目前 Confluent Kafka 在国内的普及率是比较低的。</p>
<blockquote>
<p>如果需要用到 Kafka 的一些高级特性，那么推荐使用 Confluent Kafka。</p>
</blockquote>
<h3 id="clouderahortonworks-kafka"><a class="markdownIt-Anchor" href="#clouderahortonworks-kafka"></a> Cloudera/Hortonworks Kafka</h3>
<p>Cloudera 提供的 CDH 和 Hortonworks 提供的 HDP<br />
是非常著名的大数据平台，里面集成了目前主流的大数据框架，能够帮助用户实现从分布式存储、集群调度、流处理到机器学习、实时数据库等全方位的数据处理。</p>
<p>很多创业公司在搭建数据平台时首选就是这两个产品。不管是 CDH 还是 HDP 里面都集成了 Apache<br />
Kafka，因此把这两款产品中的 Kafka 称为 CDH Kafka 和 HDP Kafka。</p>
<h4 id="优-3"><a class="markdownIt-Anchor" href="#优-3"></a> 优</h4>
<p>大数据平台天然集成了 Apache Kafka，通过便捷化的界面操作将 Kafka 的安装、运维、管理、监控全部统一在控制台中。所有的操作都可以在前端<br />
UI 界面上完成，而不必去执行复杂的 Kafka 命令。</p>
<h4 id="劣-3"><a class="markdownIt-Anchor" href="#劣-3"></a> 劣</h4>
<p>这样做的结果是直接降低了你对 Kafka 集群的掌控程度。</p>
<p>另一个弊端在于它的滞后性。</p>
<p>由于它有自己的发布周期，因此是否能及时地包含最新版本的 Kafka 就成为了一个问题。比如 CDH 6.1.0 版本发布时<br />
Apache Kafka 已经演进到了 2.1.0 版本，但 CDH 中的 Kafka 依然是 2.0.0<br />
版本，显然那些在 Kafka 2.1.0 中修复的 Bug 只能等到 CDH 下次版本更新时才有可能被真正修复。</p>
<h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3>
<ul>
<li>
<p>Apache Kafka，也称社区版 Kafka。</p>
<ul>
<li>优势在于迭代速度快，社区响应度高，使用它可以让你有更高的把控度</li>
<li>缺陷在于仅提供基础核心组件，缺失一些高级的特性。</li>
</ul>
</li>
<li>
<p>Confluent Kafka，Confluent 公司提供的 Kafka。</p>
<ul>
<li>优势在于集成了很多高级特性且由 Kafka 原班人马打造，质量上有保证</li>
<li>缺陷在于相关文档资料不全，普及率较低，没有太多可供参考的范例。</li>
</ul>
</li>
<li>
<p>CDH/HDP Kafka，大数据云公司提供的 Kafka，内嵌 Apache Kafka。</p>
<ul>
<li>优势在于操作简单，节省运维成本</li>
<li>缺陷在于把控度低，演进速度较慢。</li>
</ul>
</li>
</ul>
<h2 id="kafka-版本号"><a class="markdownIt-Anchor" href="#kafka-版本号"></a> kafka 版本号</h2>
<h3 id="kafka-版本命名"><a class="markdownIt-Anchor" href="#kafka-版本命名"></a> Kafka 版本命名</h3>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0qywsepyjj21660eignb.jpg" alt="image-20220329191711226" /></p>
<p>其中前半部分为 Scala语言版本，后才为kafka版本，如上图所示</p>
<blockquote>
<p>他们均符合x.y.z 命名规范</p>
</blockquote>
<h3 id="kafka-版本演进"><a class="markdownIt-Anchor" href="#kafka-版本演进"></a> Kafka 版本演进</h3>
<p>Kafka 目前总共演进了 7 个大版本，分别是 0.7.x、0.8.x、0.9.x、0.10.x、0.11.x、1.x 、 2.x，3.x 其中的小版本和<br />
Patch 版本很</p>
<p>多。</p>
<blockquote>
<p>本文书写 时最新版本为 3.10（2022-03-29）</p>
</blockquote>
<h4 id="07x版本"><a class="markdownIt-Anchor" href="#07x版本"></a> 0.7.x版本</h4>
<p>很老的Kafka版本，它只有基本的<strong>消息队列</strong>功能，连消息副本机制都没有，不建议使用。</p>
<h4 id="08x版本"><a class="markdownIt-Anchor" href="#08x版本"></a> 0.8.x版本</h4>
<p>两个重要特性，</p>
<p>一个是Kafka 0.8.0增加了副本机制，</p>
<p>另一个是Kafka 0.8.2.0引入了新版本Producer API。</p>
<p>新旧版本Producer API如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//旧版本Producer</span></span><br><span class="line">kafka.javaapi.producer.Producer&lt;K,V&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment">//新版本Producer</span></span><br><span class="line">org.apache.kafka.clients.producer.KafkaProducer&lt;K,V&gt;</span><br></pre></td></tr></table></figure>
<p>与旧版本相比，新版本Producer<br />
API有点不同，一是连接Kafka方式上，旧版本的生产者及消费者API连接的是Zookeeper，而新版本则连接的是Broker；二是新版Producer采用异步方式发送消息，比之前同步发送消息的性能有所提升。但此时的新版Producer<br />
API尚不稳定，不建议生产使用。</p>
<h4 id="09x版本"><a class="markdownIt-Anchor" href="#09x版本"></a> 0.9.x版本</h4>
<p>Kafka 0.9 是一个重大的版本迭代，增加了非常多的新特性，主要体现在三个方面：</p>
<ul>
<li><strong>安全方面</strong>：在0.9.0之前，Kafka安全方面的考虑几乎为0。Kafka 0.9.0<br />
在安全认证、授权管理、数据加密等方面都得到了支持，包括支持Kerberos等。</li>
<li><strong>新版本Consumer API</strong>：Kafka 0.9.0 重写并提供了新版消费端API，使用方式也是从连接Zookeeper切到了连接Broker，但是此时新版Consumer<br />
API也不太稳定、存在不少Bug，生产使用可能会比较痛苦；而0.9.0版本的Producer API已经比较稳定了，生产使用问题不大。</li>
<li><strong>Kafka Connect</strong>：Kafka 0.9.0 引入了新的组件 Kafka Connect ，用于实现Kafka与其他外部系统之间的数据抽取。</li>
</ul>
<h4 id="010x版本"><a class="markdownIt-Anchor" href="#010x版本"></a> 0.10.x版本</h4>
<p>Kafka 0.10 是一个重要的大版本，因为Kafka 0.10.0.0 引入了 Kafka<br />
Streams，使得Kafka不再仅是一个消息引擎，而是往一个分布式流处理平台方向发展。0.10 大版本包含两个小版本：0.10.1<br />
和<br />
0.10.2，它们的主要功能变更都是在 Kafka Streams 组件上。</p>
<p>值得一提的是，自 0.10.2.2 版本起，新版本 Consumer API 已经比较稳定了，而且 Producer API<br />
的性能也得到了提升，因此对于使用 0.10.x 大版本的用户，建议使用或升级到 Kafka 0.10.2.2<br />
版本。</p>
<h4 id="011x版本"><a class="markdownIt-Anchor" href="#011x版本"></a> 0.11.x版本</h4>
<p>Kafka 0.11 是一个里程碑式的大版本，主要有两个大的变更，一是Kafka从这个版本开始支持 **Exactly-Once 语义<br />
**<br />
即精准一次语义，主要是实现了Producer端的消息幂等性，以及事务特性，这对于Kafka流式处理具有非常大的意义。</p>
<p>另一个重大变更是<strong>Kafka消息格式的重构</strong>，Kafka<br />
0.11主要为了实现Producer幂等性与事务特性，重构了投递消息的数据结构。这一点非常值得关注，因为Kafka<br />
0.11之后的消息格式发生了变化，所以我们要特别注意Kafka不同版本间消息格式不兼容的问题。</p>
<h4 id="1x版本"><a class="markdownIt-Anchor" href="#1x版本"></a> 1.x版本</h4>
<p>Kafka 1.x 更多的是Kafka Streams方面的改进，以及Kafka Connect的改进与功能完善等。但仍有两个重要特性，一是Kafka<br />
1.0.0实现了<strong>磁盘的故障转移</strong><br />
，当Broker的某一块磁盘损坏时数据会自动转移到其他正常的磁盘上，Broker还会正常工作，这在之前版本中则会直接导致Broker宕机，因此Kafka的可用性与可靠性得到了提升；</p>
<p>二是Kafka 1.1.0开始支持<strong>副本跨路径迁移</strong><br />
，分区副本可以在同一Broker不同磁盘目录间进行移动，这对于磁盘的<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9wcm9kdWN0L2NsYj9mcm9tPTEwNjgw">负载均衡<i class="fa fa-external-link-alt"></i></span><br />
非常有意义。</p>
<h4 id="2x版本"><a class="markdownIt-Anchor" href="#2x版本"></a> 2.x版本</h4>
<p>Kafka 2.x 更多的也是Kafka Streams、Connect方面的性能提升与功能完善，以及安全方面的增强等。一个使用特性，Kafka<br />
2.1.0开始支持ZStandard的压缩方式，提升了消息的压缩比，显著减少了磁盘空间与网络io消耗。</p>
<h4 id="3x版本"><a class="markdownIt-Anchor" href="#3x版本"></a> 3.x版本</h4>
<ul>
<li>不再支持 Java 8 和 Scala 2.12</li>
<li>Kafka Raft 支持元数据主题的快照以及自我管理的仲裁中的其他改进</li>
<li>为默认启用的 Kafka 生产者提供更强的交付保证</li>
<li>弃用消息格式 v0 和 v1</li>
<li>OffsetFetch 和 FindCoordinator 请求的优化</li>
<li>更灵活的 Mirror Maker 2 配置和 Mirror Maker 1 的弃用</li>
<li>能够在 Kafka Connect 中的一次调用中重新启动连接器的任务</li>
<li>现在默认启用连接器日志上下文和连接器客户端覆盖</li>
<li>Kafka Streams 中时间戳同步的增强语义</li>
<li>改进了 Stream 的 TaskId 的公共 API</li>
<li>Kafka 中的默认 serde 变为 null</li>
</ul>
<h3 id="kafka版本建议"><a class="markdownIt-Anchor" href="#kafka版本建议"></a> Kafka版本建议</h3>
<ol>
<li>遵循一个基本原则，Kafka客户端版本和服务端版本应该保持一致，否则可能会遇到一些问题。</li>
<li>根据是否用到了Kafka的一些新特性来选择，假如要用到Kafka生产端的消息幂等性，那么建议选择Kafka 0.11<br />
或之后的版本。</li>
<li>选择一个自己熟悉且稳定的版本，如果说没有比较熟悉的版本，建议选择一个较新且稳定、使用比较广泛的版本。</li>
</ol>
<h2 id="referer"><a class="markdownIt-Anchor" href="#referer"></a> referer</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNTk2NzQ3">Apache Kafka 版本演进及特性介绍<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9hcmNoaXZlLmFwYWNoZS5vcmcvZGlzdC9rYWZrYS8zLjAuMC9SRUxFQVNFX05PVEVTLmh0bWw=">RELEASE_NOTES<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>kafka</category>
        <category>MQ</category>
        <category>Apache kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka线上部署</title>
    <url>/48511.html</url>
    <content><![CDATA[<p>工欲善其事，必先利其器。先把Kafka跑起来！为了资源更有效的利用，需要考虑磁盘、网络带宽</p>
<h2 id="资源规划"><a class="markdownIt-Anchor" href="#资源规划"></a> 资源规划</h2>
<h3 id="磁盘容量"><a class="markdownIt-Anchor" href="#磁盘容量"></a> 磁盘容量</h3>
<p>需要考虑几个因素：</p>
<ul>
<li>新增消息数</li>
<li>消息留存时间</li>
<li>平均消息大小</li>
<li>备份数</li>
<li>是否启用压缩</li>
</ul>
<p>计算公式为：新增消息数 <em>消息留存时间</em> 平均消息大小 <em>备份数</em> 压缩率 * （1 + 10 %）(索引以及其他数据)</p>
<p>假设有个业务每天需要向 Kafka 集群发送 1 亿条消息，每条消息保存两份以防止数据丢失，另外消息默认保存两周时间。现在假设消息的平均大小是<br />
1KB，那么你能说出你的 Kafka 集群需要为这个业务预留多少磁盘空间吗？</p>
<p>每天 1 亿条 1KB 大小的消息，保存两份且留存两周的时间，那么总的空间大小就等于</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup><mo>∗</mo><mn>1</mn><mo>∗</mo><mn>2</mn><mo>=</mo><mn>2</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup><mi>K</mi><mi>B</mi><mo>=</mo><mn>0.2</mn><mi>T</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">10 ^ 8 *1* 2 = 2 * 10^8 KB = 0.2 TB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></p>
<p>加上索引以及其他类型数据 在原有基础上增加 <em>10%</em>,那就是0.22TB</p>
<p>保留两周：0.22TB * 14 = 3.08 TB</p>
<p>压缩率为80%： 3.08 * 0.8 = 2.464 TB ≈ 2.5 TB</p>
<p>保险起见建议预留3 TB的存储空间</p>
<h3 id="网络带宽"><a class="markdownIt-Anchor" href="#网络带宽"></a> 网络带宽</h3>
<p>对于 Kafka 这种通过网络大量进行数据传输的框架而言，带宽特别容易成为瓶颈。事实上，在接触的真实案例当中，带宽资源不足导致<br />
Kafka 出现性能问题的比例<strong>至少占 60% 以上</strong>。</p>
<p>当规划带宽时到不如说是部署kafka<strong>服务器数量</strong></p>
<p>通常情况下只能假设 Kafka 会用到 70% 的带宽资源，因为总要为其他应用或进程留一些资源。根据实际使用经验，超过<br />
70% 的阈值就有网络丢包的可能性了，故 70% 的设定是一个比较合理的值，也就是说单台 Kafka<br />
服务器最多也就能使用大约 700Mb 的带宽资源。</p>
<p>稍等，这只是它能使用的最大带宽资源，你不能让 Kafka 服务器常规性使用这么多资源，故通常要再额外预留出 2/3<br />
的资源，即单台服务器使用带宽 700Mb / 3 ≈ 240Mbps。需要提示的是，这里的 2/3<br />
其实是相当保守的，你可以结合你自己机器的使用情况酌情减少此值。</p>
<p>好了，有了 240Mbps，我们就可以计算 1 小时内处理 1TB 数据所需的服务器数量了。根据这个目标，我们每秒需要处理<br />
2336Mb 的数据，除以 240，约等于 10 台服务器。如果消息还需要额外复制两份，那么总的服务器台数还要乘以<br />
3，即 30 台。</p>
<h2 id="参数配置"><a class="markdownIt-Anchor" href="#参数配置"></a> 参数配置</h2>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">config</span><br><span class="line">├── connect-console-sink.properties </span><br><span class="line">├── connect-console-source.properties</span><br><span class="line">├── connect-distributed.properties</span><br><span class="line">├── connect-file-sink.properties</span><br><span class="line">├── connect-file-source.properties</span><br><span class="line">├── connect-log4j.properties</span><br><span class="line">├── connect-mirror-maker.properties</span><br><span class="line">├── connect-standalone.properties</span><br><span class="line">├── consumer.properties</span><br><span class="line">├── kraft</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── broker.properties</span><br><span class="line">│   ├── controller.properties</span><br><span class="line">│   └── server.properties</span><br><span class="line">├── log4j.properties </span><br><span class="line">├── producer.properties</span><br><span class="line">├── server.properties </span><br><span class="line">├── tools-log4j.properties</span><br><span class="line">├── trogdor.conf</span><br><span class="line">└── zookeeper.properties</span><br></pre></td></tr></table></figure>
<h3 id="jvm-参数与垃圾回收算法"><a class="markdownIt-Anchor" href="#jvm-参数与垃圾回收算法"></a> JVM 参数与垃圾回收算法</h3>
<p>Kafka 服务器端代码是用 Scala 语言编写的，但终归还是会编译成 <code>.Class</code>  文件在 JVM 上运行，因此 JVM<br />
参数设置对于 Kafka 集群的重要性不言而喻。</p>
<p>JVM 端设置，堆大小这个参数至关重要，无脑通用的建议：将 JVM 堆大小设置成 6GB</p>
<p>垃圾回收器的设置，也就是平时常说的 GC 设置。</p>
<p>手动设置使用 G1 收集器。在没有任何调优的情况下，G1 表现得要比 CMS 出色，主要体现在更少的 Full<br />
GC，需要调整的参数更少等，所以使用 G1 就好了。</p>
<p>KAFKA_HEAP_OPTS：指定堆大小。</p>
<p>KAFKA_JVM_PERFORMANCE_OPTS：指定 GC 参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> KAFKA_HEAP_OPTS=--Xms6g  --Xmx6g</span><br><span class="line"><span class="built_in">export</span> KAFKA_JVM_PERFORMANCE_OPTS= -server -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:+ExplicitGCInvokesConcurrent -Djava.awt.headless=<span class="literal">true</span></span><br><span class="line">kafka-server-start.sh <span class="variable">$&#123;KAFKA_HOME&#125;</span>/config/server.properties</span><br></pre></td></tr></table></figure>
<h3 id="操作系统参数"><a class="markdownIt-Anchor" href="#操作系统参数"></a> 操作系统参数</h3>
<p>通常情况下，Kafka 并不需要设置太多的 系统参数</p>
<p>下面这几个在此较为重要：</p>
<ul>
<li>文件描述符限制：比如ulimit -n 1000000</li>
<li>文件系统类型： 根据官网的测试报告，XFS 的性能要强于 ext4，所以生产环境最好还是使用 XFS甚至是ZFS。</li>
<li>swap：建议将 swappniess 配置成一个接近 0 但不为 0 的值，比如 1。</li>
<li>提交时间：适当的增加提交间隔来降低物理磁盘的写操作</li>
</ul>
<h2 id="部署"><a class="markdownIt-Anchor" href="#部署"></a> 部署</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装jdk</span></span><br><span class="line"><span class="built_in">sudo</span> yum group install -y <span class="string">&quot;development tools&quot;</span></span><br><span class="line"><span class="built_in">sudo</span> yum install -y java-1.8.0-openjdk.x86_64</span><br><span class="line"><span class="comment"># 下载kafka</span></span><br><span class="line">wget -c https://mirrors.tuna.tsinghua.edu.cn/apache/kafka/3.1.0/kafka_2.13-3.1.0.tgz</span><br><span class="line"><span class="comment"># 解压缩</span></span><br><span class="line">tar -zxf kafka_2.13-3.1.0.tgz -C /usr/local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="comment"># kafka env config </span></span><br><span class="line"><span class="built_in">export</span> KAFKA_HOME=/usr/local/kafka_2.13-3.1.0</span><br><span class="line"><span class="built_in">export</span> KAFKA_BIN=<span class="variable">$&#123;KAFKA_HOME&#125;</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;KAFKA_BIN&#125;</span>:PATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">kafka-storage.sh format -c <span class="variable">$&#123;KAFKA_HOME&#125;</span>/config/kraft/server.properties -t `kafka-storage.sh random-uuid`</span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">kafka-server-start.sh <span class="variable">$&#123;KAFKA_HOME&#125;</span>/config/kraft/server.properties</span><br></pre></td></tr></table></figure>
<h3 id="验证"><a class="markdownIt-Anchor" href="#验证"></a> 验证</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建quickstart-events主题</span></span><br><span class="line">kafka-topics.sh --create --topic quickstart-events --bootstrap-server localhost:9092</span><br><span class="line"></span><br><span class="line">kafka-console-producer.sh --topic quickstart-events --bootstrap-server localhost:9092</span><br><span class="line"></span><br><span class="line">kafka-console-consumer.sh --topic quickstart-events --from-beginning --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>
<h2 id="kafka监控工具"><a class="markdownIt-Anchor" href="#kafka监控工具"></a> Kafka监控工具</h2>
<ul>
<li>JMXTool: 可以实时查看kafka JMX 指标，但仅限于简单的监控场景</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RpZGkvTG9naUtN">Logi-KM<i class="fa fa-external-link-alt"></i></span>: didi开源的**一站式<code>Apache Kafka</code>集群指标监控与运维管控平台<br />
**</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pteHRyYW5zL2pteHRyYW5z">JMXTrans<i class="fa fa-external-link-alt"></i></span> + InfluxDB + Grafana</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NtYXJ0bG9saS9FRkFL">EFAK<i class="fa fa-external-link-alt"></i></span>：</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2Fma2F0b29sLmNvbS8=">Kafka tool<i class="fa fa-external-link-alt"></i></span>：</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lhaG9vL0NNQUs=">CMAK<i class="fa fa-external-link-alt"></i></span>：雅虎源的kafka监控器，阿里在用</li>
</ul>
]]></content>
      <categories>
        <category>kafka</category>
        <category>MQ</category>
        <category>Apache kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes集群搭建</title>
    <url>/18864.html</url>
    <content><![CDATA[<p>其实本节的文章我在很久之前就已经发过了一次，但不够详细，层次不轻。我今天部署的时候看的够呛(<br />
虽然也是部署成功了)<br />
，也算是对以前的坑，做个忏悔吧。本文可能会比较boring，但请相信这并不是我的本意。这一定是最精简的笔记之一，相信我这绝对不是混水。</p>
<p>本文主要分三大部分，他们分别是系统初始化、安装docker、安装Kubernetes，测试验证与删库跑路</p>
<span id="more"></span>
<h3 id="系统初始化"><a class="markdownIt-Anchor" href="#系统初始化"></a> 系统初始化</h3>
<blockquote>
<p>请注意后面的单词all，代表所有(master、node)</p>
<p>Master：仅在master上</p>
<p>node: 仅在node上</p>
</blockquote>
<h4 id="关闭防火墙all"><a class="markdownIt-Anchor" href="#关闭防火墙all"></a> 关闭防火墙(<code>all</code>)</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 临时关闭</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment">## 永久关闭</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"><span class="comment">## 验证防火墙是否关闭</span></span><br><span class="line">systemctl status firewalld </span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gne8fmrrrpj31cw0h6dl3.jpg" alt="" /></p>
<h4 id="关闭selinuxall"><a class="markdownIt-Anchor" href="#关闭selinuxall"></a> 关闭selinux(<code>all</code>)</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 临时关闭</span></span><br><span class="line">setenforce 0</span><br><span class="line"><span class="comment"># 永久</span></span><br><span class="line">sed -i <span class="string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="关闭swapall"><a class="markdownIt-Anchor" href="#关闭swapall"></a> 关闭swap(<code>all</code>)</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 临时</span></span><br><span class="line">swapoff -a </span><br><span class="line"><span class="comment"># 永久</span></span><br><span class="line">sed  -ri <span class="string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一条命令完成所有</span></span><br><span class="line">systemctl stop firewalld &amp;&amp; setenforce 0 &amp;&amp; swapoff -a &amp;&amp; systemctl status firewalld </span><br></pre></td></tr></table></figure>
<h4 id="设置主机名称all"><a class="markdownIt-Anchor" href="#设置主机名称all"></a> 设置主机名称(<code>all</code>)</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置名称(k8s-m-1)忽略大写字母</span><br><span class="line">hostnamectl set-hostname master</span><br><span class="line"># 验证</span><br><span class="line">hostname</span><br></pre></td></tr></table></figure>
<h4 id="时间同步all"><a class="markdownIt-Anchor" href="#时间同步all"></a> 时间同步(<code>All</code>)</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y ntpdate  &amp;&amp; ntpdate time.windows.com</span><br></pre></td></tr></table></figure>
<h4 id="在master添加hostnamemaster"><a class="markdownIt-Anchor" href="#在master添加hostnamemaster"></a> 在<code>Master</code>添加Hostname(<code>master</code>)</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置</span></span><br><span class="line"><span class="built_in">cat</span> &gt;&gt; /etc/hosts &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">masterIp master</span></span><br><span class="line"><span class="string">node1Ip node1</span></span><br><span class="line"><span class="string">node2Ip node2</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># example</span></span><br><span class="line"><span class="built_in">cat</span> &gt;&gt; /etc/hosts &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">192.168.50.182  master</span></span><br><span class="line"><span class="string">192.168.50.252   node</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>验证，此时<code>ping node</code>， 看是否能ping通</p>
</blockquote>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gne92s7tj7j31800ge41c.jpg" alt="" /></p>
<h4 id="将桥接的ipv4-流量传递到iptables的链all"><a class="markdownIt-Anchor" href="#将桥接的ipv4-流量传递到iptables的链all"></a> 将桥接的IPV4 流量传递到iptables的链(<code>all</code>)</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /etc/sysctl.d/k8s.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生效</span></span><br><span class="line">sysctl --system</span><br></pre></td></tr></table></figure>
<h3 id="安装docker"><a class="markdownIt-Anchor" href="#安装docker"></a> 安装Docker</h3>
<h4 id="删除docker可选"><a class="markdownIt-Anchor" href="#删除docker可选"></a> 删除docker(可选)</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># You can use scripts for one click installation，You may need to type enter at the end</span></span><br><span class="line"><span class="comment"># remove docker </span></span><br><span class="line"><span class="built_in">sudo</span> yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"><span class="comment"># Set up repository</span></span><br><span class="line"><span class="built_in">sudo</span> yum install -y yum-utils</span><br><span class="line">wget https:/mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span><br><span class="line">yum -y install docker-18.06.1.ce-3.e17</span><br></pre></td></tr></table></figure>
<h4 id="安装docker-2"><a class="markdownIt-Anchor" href="#安装docker-2"></a> 安装docker</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Use Aliyun Docker</span></span><br><span class="line"><span class="built_in">sudo</span> yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="comment"># install docker from yum</span></span><br><span class="line">yum install  -y docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="comment"># cat version </span></span><br><span class="line">docker --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置镜像加速</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://etdea28s.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># reload</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="comment"># 配置开启自启</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> docker</span><br><span class="line"><span class="comment"># start docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<p><strong>验证docker镜像加速</strong></p>
<p>在终端上输入<code>docker info</code>,效果图如下</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gne9v1z6acj30ks03q3yn.jpg" alt="" /></p>
<p>完成～</p>
<h3 id="安装kubernetes"><a class="markdownIt-Anchor" href="#安装kubernetes"></a> 安装Kubernetes</h3>
<h4 id="配置阿里镜像源all"><a class="markdownIt-Anchor" href="#配置阿里镜像源all"></a> 配置阿里镜像源(all)</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">repo_gpgcheck=1</span></span><br><span class="line"><span class="string">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<h4 id="安装-kubectl-kubelet-kubeadmall"><a class="markdownIt-Anchor" href="#安装-kubectl-kubelet-kubeadmall"></a> 安装 kubectl kubelet kubeadm(<code>all</code>)</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ignore automatic updates</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;exclude=kube*&quot;</span> &gt;&gt; /etc/yum.conf</span><br><span class="line"><span class="comment"># install kubectl kubelet kubeadm</span></span><br><span class="line">yum install -y kubectl kubelet kubeadm --disableexcludes=kubernetes</span><br><span class="line"><span class="comment">#--disableexcludes=kubernetes  禁掉除了这个之外的别的仓库</span></span><br><span class="line"><span class="comment"># set boot on opening computer</span></span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet</span><br></pre></td></tr></table></figure>
<h4 id="kubeadm初始化master"><a class="markdownIt-Anchor" href="#kubeadm初始化master"></a> kubeadm初始化(<code>Master</code>)</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=masterIp   \</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers  \</span><br><span class="line">--service-cidr=10.10.0.0/16 \</span><br><span class="line">--pod-network-cidr=10.122.0.0/16</span><br><span class="line"></span><br><span class="line"><span class="comment"># eg  </span></span><br><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=192.168.50.182   \</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers  \</span><br><span class="line">--service-cidr=10.96.0.0/12 \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure>
<p>如果没有Error，即kubeadm开始初始化成功</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnea5d1zctj31ek0b240h.jpg" alt="" /></p>
<p>等上几分钟，初始化成功，如下图</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gneaijhntij31mw0l6jup.jpg" alt="" /></p>
<p><strong>开启集群(master)</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">kubectl get node</span><br><span class="line"><span class="comment"># 正常打印出信息即，成功</span></span><br></pre></td></tr></table></figure>
<p><strong>节点加入集群(node)</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例如</span></span><br><span class="line">kubeadm <span class="built_in">join</span> 192.168.50.182:6443 --token 7t70cl.hr22v89g7wkqojdf \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:d0541c10506744981838a7d4ce504eb69d28fdcfc8e1261373505c42047be33f</span><br></pre></td></tr></table></figure>
<p>这个是初始化完成后，系统给的。请以自己输出为准</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 默认token24hour后过期，获取新token命令如下：</span><br><span class="line">kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure>
<p><strong>部署CNI网络组件</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由于是国外的源，国内无法访问。我们需要添加镜像，若存在，则忽略</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;199.232.28.133 raw.githubusercontent.com&quot;</span> &gt;&gt; /etc/hosts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署CNI网络组件</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开启IPVS，修改ConfigMap的kube-system/kube-proxy中的模式为ipvs</span><br><span class="line">kubectl edit cm kube-proxy -n kube-system </span><br><span class="line"># 将空的data -&gt; ipvs -&gt; mode中替换如下</span><br><span class="line">mode: &quot;ipvs&quot;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk82xypglpj30rg0eo431.jpg" alt="" /></p>
<p>此时已经全部就绪了，如下</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnebsqe1pwj310g03sq3g.jpg" alt="" /></p>
<h3 id="验证测试"><a class="markdownIt-Anchor" href="#验证测试"></a> 验证测试</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl create deployment NAME --image=image -- [COMMAND] [args...] [options]</span></span><br><span class="line"><span class="comment"># 简单部署nginx</span></span><br><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line"><span class="comment"># 对外暴露端口</span></span><br><span class="line">kubectl expose deployment nginx --port=80 --<span class="built_in">type</span>=NodePort</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">kubectl get pod,svc</span><br><span class="line"><span class="comment"># 查看命名空间</span></span><br><span class="line">kubectl get all -n kube-system</span><br></pre></td></tr></table></figure>
<p>部署成功示意图</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnebxc1qlfj3114032weu.jpg" alt="" /></p>
<p>向外暴露随机端口</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnebyb224zj315q03i0t8.jpg" alt="" /></p>
<p>访问集群中任意一个ip</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnec5gpwbij30ni0gogn2.jpg" alt="" /></p>
<p>完成～</p>
<p>补充，删除部署的服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get deployment </span><br><span class="line"># 我们只需要删除对应的deploy 即可</span><br><span class="line">kubectl delete deployment nginx</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnec92m03hj30wm03q0sv.jpg" alt="" /></p>
<p>删除成功后，已经找不到nginx的影子，完成</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnece8de4uj31w40bkgr2.jpg" alt="" /></p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>本节我们对使用<code>kubeadm</code>工具快速搭建搭建了Kubernetes的集群，系统初始化，记得关闭防火墙、分区等哦。</p>
<p>如果对你有帮助，感觉不错。可以推荐给朋友哦，让他拿着笔记部署，怎一个香字了得，加油，冲冲冲～</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux command多版本设置</title>
    <url>/43326.html</url>
    <content><![CDATA[<p>在Linux上有这样一个需求，需要将Python的默认版本设置为<code>python3.8</code><br />
但由于Linux系统自带的是3.6.那么实现他只需要完成python3.8的安装，以及python命令的指向问题。</p>
<p>python3.8 的安装在此便不再过多赘述，如下命令都可任选其一即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y python38 python38-pip</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> dnf install -y python38 python38-pip</span><br></pre></td></tr></table></figure>
<h2 id="修改指向"><a class="markdownIt-Anchor" href="#修改指向"></a> 修改指向</h2>
<h3 id="alternatives-修改"><a class="markdownIt-Anchor" href="#alternatives-修改"></a> alternatives 修改</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alternatives --config python3</span><br></pre></td></tr></table></figure>
<p>此时直接输入1，修改即可。如下图所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h19tu6qge1j218w0ggtak.jpg" alt="image-20220415024725606" /></p>
<h3 id="alternatives-install"><a class="markdownIt-Anchor" href="#alternatives-install"></a> alternatives --install</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alternatives --install &lt;链接&gt; &lt;名称&gt; &lt;路径&gt; &lt;优先度&gt;</span><br><span class="line">update-alternatives --install /usr/bin/python python /usr/bin/python2.7 2</span><br></pre></td></tr></table></figure>
<h3 id="软链接"><a class="markdownIt-Anchor" href="#软链接"></a> 软链接</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -fs /usr/bin/python3.8 /usr/bin/python3</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL优化</title>
    <url>/43137.html</url>
    <content><![CDATA[<p>mysql优化老生常谈了，但却也离不开业务。脱离业务来讲mysql可以从两个方面进行优化</p>
<ul>
<li>
<p>安全优化（业务持续性）</p>
</li>
<li>
<p>性能优化（业务高效性）</p>
</li>
</ul>
<p>所谓优化，个人认为有两大需要提前知道的<strong>稳定性和业务可持续性通常比性能更重要</strong>，**优化是由业务需要驱使的<br />
**</p>
<p>通常优化也与操作系统、运行环境等息息相关，结合业务适合自己才是最好的。</p>
<h2 id="安全优化"><a class="markdownIt-Anchor" href="#安全优化"></a> 安全优化</h2>
<p>足够强度的安全是保证业务正常运行的基石，安全优化通常可以以系统安全，应用程序安全，与sql安全。</p>
<h3 id="系统安全"><a class="markdownIt-Anchor" href="#系统安全"></a> 系统安全</h3>
<blockquote>
<p>具体详情请参考Linux系统安全</p>
</blockquote>
<p><strong>物理安全</strong></p>
<p>物理环境安全，小微企业一般使用云服务器，大型企业一般有多个机房，实现异地多活</p>
<p><strong>防火墙策略、关闭或切换不必要的端口</strong></p>
<blockquote>
<ol>
<li>修改常见应用默认端口，22、3306、27017、6379等</li>
</ol>
</blockquote>
<p><strong>账户安全</strong></p>
<p>用户连接权限、用户权限</p>
<blockquote>
<ol>
<li>禁止root远程</li>
<li>账号管理（密码强度、用户权限）</li>
</ol>
</blockquote>
<p><strong>源代码文件目录权限管理</strong></p>
<p><strong>备份</strong>等</p>
<h3 id="mysql安全"><a class="markdownIt-Anchor" href="#mysql安全"></a> MySQL安全</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZG91YmxleGkvcC85NzMyMjc0Lmh0bWw=">https://www.cnblogs.com/doublexi/p/9732274.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>MySQL版本的选择</p>
<p>MySQL的命名机制使用由3个数字和一个后缀组成的版本号。例如，像mysql-5.0.9-beta的版本号这样解释：</p>
<p>数字(5)是主版本号，描述了文件格式。所有版本5的发行都有相同的文件格式。</p>
<p>数字(0)是发行级别。主版本号和发行级别组合到一起便构成了发行序列号。</p>
<p>数字(9)是在此发行系列的版本号，随每个新分发版递增。通常你需要已经选择的发行(release)的最新版本(版本)。</p>
<p>每次更新后，版本字符串的最后一个数字递增。如果相对于前一个版本增加了新功能或有微小的不兼容性，字符串的第二个数字递增。如果文件格式改变，第一个数字递增。</p>
<p>后缀显示发行的稳定性级别。通过一系列后缀显示如何改进稳定性。可能的后缀有：</p>
<p><strong>·alpha表明发行包含大量未被彻底测试的新代码</strong><br />
。已知的缺陷应该在新闻小节被记录。请参见附录D：MySQL变更史。在大多数alpha版本中也有新的命令和扩展。alpha版本也可能有主要代码更改等开发。但我们在发布前一定对其进行测试。</p>
<p><strong>·beta意味着该版本功能是完整的</strong><br />
，并且所有的新代码被测试了，没有增加重要的新特征，应该没有已知的缺陷。当alpha版本至少一个月没有出现报导的致命漏洞，并且没有计划增加导致已经实施的功能不稳定的新功能时，版本则从alpha版变为beta版。</p>
<p>在以后的beta版、发布版或产品发布中，所有API、外部可视结构和SQL命令列均不再更改。</p>
<p><strong>·rc是发布代表</strong>；是一个发行了一段时间的beta版本，看起来应该运行正常。只增加了很小的修复。(<br />
发布代表即以前所称的gamma版)</p>
<p>·如果没有后缀，这意味着该版本已经在很多地方运行一段时间了，而且没有非平台特定的缺陷报告。只增加了关键漏洞修复修复。这就是我们称为一个产品(<br />
稳定)或“通用”版本的东西。</p>
<p>MySQL的命名机制于其它产品稍有不同。一般情况，我们可以很放心地使用已经投放市场两周而没有被相同发布系列的新版本所代替的版本。</p>
<ul>
<li>稳定不要最新：最新GA版超过10个月或比最新GA版晚3、4个版本的GA版。</li>
<li>前后无大BUG：要选择前后几个月没有<strong>大的BUG修复的版本</strong>，而不是大量<strong>修复BUG的集中版本</strong>。</li>
<li>向后少更新：最好向后较长时间没有更新发布的版本，<strong>若目标版本修复的BUG巨多，向前推进一个版本号。</strong></li>
<li>兼容开发：验证功能瓶颈、性能瓶颈，要考虑开发人员开发程序使用的版本是否兼容你选的版本</li>
<li>测试先行：作为内部开发测试数据库环境，跑大概3-6个月的时间。</li>
<li>非核心先行：优先企业非核心业务采用新版本的数据库GA版本软件。</li>
</ul>
<h4 id="用户安全"><a class="markdownIt-Anchor" href="#用户安全"></a> 用户安全</h4>
<p><strong>禁止root账户远程访问</strong></p>
<p>root权限太高，拥有安全隐患，root只允许本地登陆</p>
<p><strong>mysql用户登录shell为nologin</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod -s /sbin/nologin mysql</span><br></pre></td></tr></table></figure>
<p><strong>对MySQL运行用户降权，以普通用户身份运行MySQL</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /etc/my.cnf</span></span><br><span class="line">[mysqld]</span><br><span class="line">user=mysql</span><br></pre></td></tr></table></figure>
<p><strong>删除匿名账号和空口令账号</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除空密码用户</span></span><br><span class="line">delete from mysql.user <span class="built_in">where</span> user is NULL or Password IS NULL;</span><br></pre></td></tr></table></figure>
<p><strong>用户与权限管理</strong></p>
<p>遵循权限最小化原则。</p>
<h4 id="连接安全"><a class="markdownIt-Anchor" href="#连接安全"></a> 连接安全</h4>
<p>修改默认端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /etc/my.cnf</span></span><br><span class="line">[mysqld]</span><br><span class="line">port=8912</span><br></pre></td></tr></table></figure>
<h4 id="容灾"><a class="markdownIt-Anchor" href="#容灾"></a> 容灾</h4>
<p>在误删除数据的情况下，可以通过二进制日志恢复到某个时间点</p>
<h4 id="二进制日志"><a class="markdownIt-Anchor" href="#二进制日志"></a> 二进制日志</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看bin log（sql）</span><br><span class="line">show variables like &#x27;%log_bin%&#x27;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gu5zib6numj60p40ag75902.jpg" alt="image-20210905193857001" /></p>
<p>修改MySQL配置文件my.cnf，加入如下两行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server-id = 1</span><br><span class="line">log_bin = /data/mysql/mysql-bin</span><br></pre></td></tr></table></figure>
<p>重启服务</p>
<h2 id="性能优化"><a class="markdownIt-Anchor" href="#性能优化"></a> 性能优化</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">效果 sql与索引优化&gt;Schema设计&gt;数据库实例优化&gt;文件系统&gt;操作系统&gt;硬件优化</span><br><span class="line">成本 硬件优化&gt;操作系统&gt;文件系统&gt;数据库实例优化&gt;Schema设计&gt;sql与索引优化</span><br></pre></td></tr></table></figure>
<h3 id="硬件优化"><a class="markdownIt-Anchor" href="#硬件优化"></a> 硬件优化</h3>
<h4 id="主机"><a class="markdownIt-Anchor" href="#主机"></a> 主机</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">真实的硬件（PC Server）: DELL  R系列 ，华为，浪潮，HP，联想</span><br><span class="line">云产品：ECS、数据库RDS、DRDS</span><br><span class="line">IBM 小型机 P6  570  595   P7 720  750 780     P8 </span><br></pre></td></tr></table></figure>
<h4 id="cpu"><a class="markdownIt-Anchor" href="#cpu"></a> CPU</h4>
<blockquote>
<p>根据业务场景选择</p>
</blockquote>
<p>OLTP \ OLAP IO密集型：线上系统，OLTP主要是IO密集型的业务，高并发<br />
CPU密集型：数据分析数据处理，OLAP，cpu密集型的，需要CPU高计算能力（i系列，IBM power系列） CPU密集型： I<br />
系列的，主频很高，核心少 IO密集型： E系列（至强），主频相对低，核心数量多</p>
<h4 id="内存"><a class="markdownIt-Anchor" href="#内存"></a> 内存</h4>
<p>建议2-3倍cpu核心数量 （ECC）</p>
<h4 id="磁盘选择"><a class="markdownIt-Anchor" href="#磁盘选择"></a> 磁盘选择</h4>
<p>SATA-III SAS Fc SSD（sata） pci-e ssd Flash 主机 RAID卡的BBU(Battery Backup Unit)关闭</p>
<h4 id="存储"><a class="markdownIt-Anchor" href="#存储"></a> 存储</h4>
<p>根据存储数据种类的不同，选择不同的存储设备 配置合理的RAID级别(raid5、raid10、热备盘)<br />
r0 :条带化 ,性能高 r1 :镜像，安全 r5 :校验+条带化，安全较高+性能较高（读），写性能较低 （适合于读多写少）<br />
r10：安全+性能都很高，最少四块盘，浪费一半的空间（高IO要求）</p>
<h4 id="网络"><a class="markdownIt-Anchor" href="#网络"></a> 网络</h4>
<p>1、硬件买好的（单卡单口）</p>
<p>2、网卡绑定(bonding)，交换机堆叠 以上问题，提前规避掉。</p>
<h3 id="操作系统优化"><a class="markdownIt-Anchor" href="#操作系统优化"></a> 操作系统优化</h3>
<h4 id="swap调整"><a class="markdownIt-Anchor" href="#swap调整"></a> Swap调整</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 0 &gt;/proc/sys/vm/swappiness的内容改成0（临时），</span><br><span class="line">/etc/sysctl.conf</span><br><span class="line">上添加vm.swappiness=0（永久）</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
<p>此参数决定了Linux是倾向于使用swap，还是倾向于释放文件系统cache。在内存紧张的情况下，数值越低越倾向于释放文件系统cache。<br />
当然，这个参数只能减少使用swap的概率，并不能避免Linux使用swap。</p>
<p>修改MySQL的配置参数innodb_flush_method，开启O_DIRECT模式 这种情况下，InnoDB的buffer<br />
pool会直接绕过文件系统cache来访问磁盘，但是redo<br />
log依旧会使用文件系统cache。值得注意的是，Redo log是覆写模式的，即使使用了文件系统的cache，也不会占用太多</p>
<h4 id="io调度策略"><a class="markdownIt-Anchor" href="#io调度策略"></a> IO调度策略</h4>
<p>raid、no lvm、ext4或xfs、ssd、IO调度策略</p>
<h3 id="数据库实例优化"><a class="markdownIt-Anchor" href="#数据库实例优化"></a> 数据库实例优化</h3>
<p>查看系统配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like “xxx”</span><br></pre></td></tr></table></figure>
<p>查看状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show status like</span><br></pre></td></tr></table></figure>
<h4 id="连接"><a class="markdownIt-Anchor" href="#连接"></a> 连接</h4>
<h5 id="max_connect_errors"><a class="markdownIt-Anchor" href="#max_connect_errors"></a> max_connect_errors</h5>
<p>max_connect_errors是一个mysql中与安全有关的计数器值，它负责阻止过多尝试失败的客户端以防止暴力破解密码等情况，当超过指定次数，mysql服务器将禁连接请求，</p>
<p>直到mysql服务器重启或通过flush hosts命令清空此host的相关信息 max_connect_errors的值与性能并无太大关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改/etc/my.cnf文件，在[mysqld]下面添加如下内容</span><br><span class="line">max_connect_errors=1000</span><br></pre></td></tr></table></figure>
<h5 id="max_connections"><a class="markdownIt-Anchor" href="#max_connections"></a> Max_connections</h5>
<blockquote></blockquote>
<p>Mysql的最大连接数，如果服务器的并发请求量比较大，可以调高这个值，当然这是要建立在机器能够支撑的情况下，因为如果连接数越来越多，mysql会为每个连接提供缓冲区，就会开销的越多的内存，所以需要适当的调整该值，不能随便去提高设值</p>
<p>开启数据库时,临时设置一个比较大的测试值, 观察show status like ‘Max_used_connections’;变化<br />
如果max_used_connections跟max_connections相同,那么就是max_connections设置过低或者超过服务器的负载上限了，低于10%则设置过大.</p>
<h5 id="back_log"><a class="markdownIt-Anchor" href="#back_log"></a> back_log</h5>
<blockquote></blockquote>
<p>mysql能暂存的连接数量，当主要mysql线程在一个很短时间内得到非常多的连接请求时候它就会起作用，如果mysql的连接数据达到max_connections时候，新来的请求将会被存在堆栈中，等待某一连接释放资源，该推栈的数量及back_log,如果等待连接的数量超过back_log，将不被授予连接资源。</p>
<blockquote>
<p>back_log值指出在mysql暂时停止回答新请求之前的短时间内有多少个请求可以被存在推栈中，只有如果期望在一个短时间内有很多连接的时候需要增加它</p>
</blockquote>
<p><strong>判断依据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show full processlist</span><br></pre></td></tr></table></figure>
<p>发现大量的待连接进程时，就需要加大back_log或者加大max_connections的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim /etc/my.cnf </span></span><br><span class="line">back_log=xxx</span><br></pre></td></tr></table></figure>
<h5 id="wait_timeout"><a class="markdownIt-Anchor" href="#wait_timeout"></a> wait_timeout</h5>
<blockquote></blockquote>
<p>wait_timeout：指的是mysql在关闭一个非交互的连接之前所要等待的秒数，如果设置太小，那么连接关闭的就很快，从而使一些持久的连接不起作用。长连接的应用，为了不去反复的回收和分配资源，降低额外的开销。</p>
<p>如果设置太大，容易造成连接打开时间过长，在show processlist时候，能看到很多的连接 ，一般希望wait_timeout尽可能低</p>
<h5 id="interactive_timeout"><a class="markdownIt-Anchor" href="#interactive_timeout"></a> interactive_timeout</h5>
<blockquote>
<p>如果设置太大，容易造成连接打开时间过长造成资源损耗，在show processlist时候，能看到很多的连接<br />
，一般希望wait_timeout尽可能低</p>
</blockquote>
<p>关闭一个交互的连接之前所需要等待的秒数，比如我们在终端上进行mysql管理，使用的即使交互的连接，这时候，如果没有操作的时间超过了interactive_time设置的时间就会自动的断开，默认的是28800，可调优为7200</p>
<h5 id="key_buffer_size"><a class="markdownIt-Anchor" href="#key_buffer_size"></a> key_buffer_size</h5>
<p>key_buffer_size指定索引缓冲区的大小，它决定索引处理的速度，尤其是索引读的速度</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">临时表的创建有关（多表链接、子查询中、union）</span><br><span class="line">     在有以上查询语句出现的时候，需要创建临时表，用完之后会被丢弃</span><br><span class="line">     临时表有两种创建方式：</span><br><span class="line">                        内存中-------&gt;key_buffer_size</span><br><span class="line">                        磁盘上-------&gt;ibdata1(<span class="number">5.6</span>)</span><br><span class="line">                                      ibtmp1 (<span class="number">5.7</span>）</span><br></pre></td></tr></table></figure>
<h4 id="处理"><a class="markdownIt-Anchor" href="#处理"></a> 处理</h4>
<h5 id="sort_buffer_size"><a class="markdownIt-Anchor" href="#sort_buffer_size"></a> sort_buffer_size</h5>
<blockquote>
<p>每个需要进行排序的线程分配该大小的一个缓冲区。增加这值加速</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ORDER BY </span><br><span class="line">GROUP BY</span><br><span class="line">distinct</span><br><span class="line">union </span><br></pre></td></tr></table></figure>
<p>Sort_Buffer_Size并不是越大越好，由于是connection级的参数，过大的设置+高并发可能会耗尽系统内存资源。<br />
列如：500个连接将会消耗500*sort_buffer_size（2M）=1G内存</p>
<p><strong>配置方法</strong><br />
修改/etc/my.cnf文件，在[mysqld]下面添加如下： sort_buffer_size=1M</p>
<h5 id="max_allowed_packet"><a class="markdownIt-Anchor" href="#max_allowed_packet"></a> max_allowed_packet</h5>
<blockquote>
<p>mysql根据配置文件会限制，server接受的数据包大小</p>
</blockquote>
<p>有时候大的插入和更新会受max_allowed_packet参数限制，导致写入或者更新失败，更大值是1GB，必须设置1024的倍数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">max_allowed_packet=32M</span><br></pre></td></tr></table></figure>
<h5 id="join_buffer_size"><a class="markdownIt-Anchor" href="#join_buffer_size"></a> join_buffer_size</h5>
<p>用于表间关联缓存的大小，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。<br />
尽量在SQL与方面进行优化，效果较为明显。 优化的方法：在on条件列加索引，至少应当是有MUL索引</p>
<h5 id="thread_cache_size"><a class="markdownIt-Anchor" href="#thread_cache_size"></a> thread_cache_size</h5>
<blockquote></blockquote>
<p>服务器线程缓存，这个值表示可以重新利用保存在缓存中线程的数量,当断开连接时,那么客户端的线程将被放到缓存中以响应下一个客户而不是销毁(<br />
前提是缓存数未达上限),如果线程重新被请求，那么请求将从缓存中读取,如果缓存中是空的或者是新的请求，那么这个线程将被重新创建,如果有很多新的线程，增加这个值可以改善系统性能</p>
<p>通过比较 Connections 和 Threads_created 状态的变量，可以看到这个变量的作用。 设置规则如下：1GB<br />
内存配置为8，2GB配置为16，3GB配置为32，4GB或更高内存，可配置更大。<br />
服务器处理此客户的线程将会缓存起来以响应下一个客户而不是销毁(前提是缓存数未达上限)</p>
<table>
<thead>
<tr>
<th style="text-align:left">Variable_name</th>
<th style="text-align:left">Value</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Threads_cached</td>
<td style="text-align:left">178</td>
<td>当前此时此刻线程缓存中有多少空闲线程</td>
</tr>
<tr>
<td style="text-align:left">Threads_connected</td>
<td style="text-align:left">78</td>
<td>当前已建立连接的数量，因为一个连接就需要一个线程，所以也可以看成当前被使用的线程数</td>
</tr>
<tr>
<td style="text-align:left">Threads_created</td>
<td style="text-align:left">479</td>
<td>从最近一次服务启动，已创建线程的数量，如果发现Threads_created值过大的话，表明MySQL服务器一直在创建线程，这也是比较耗cpu SYS资源，可以适当增加配置文件中thread_cache_size值</td>
</tr>
<tr>
<td style="text-align:left">Threads_running</td>
<td style="text-align:left">2</td>
<td>当前激活的（非睡眠状态）线程数。并不是代表正在使用的线程数，有时候连接已建立，但是连接处于sleep状态</td>
</tr>
</tbody>
</table>
<p>Threads_created ：一般在架构设计阶段，会设置一个测试值，做压力测试。 结合zabbix监控，看一段时间内此状态的变化。<br />
如果在一段时间内，Threads_created趋于平稳，说明对应参数设定是OK。<br />
如果一直陡峭的增长，或者出现大量峰值，那么继续增加此值的大小，在系统资源够用的情况下（内存）</p>
<h5 id="innodb_buffer_pool_size"><a class="markdownIt-Anchor" href="#innodb_buffer_pool_size"></a> innodb_buffer_pool_size</h5>
<blockquote>
<p>对于InnoDB表来说，innodb_buffer_pool_size的作用就相当于key_buffer_size对于MyISAM表的作用一样。</p>
</blockquote>
<p><em><u>配置依据</u></em></p>
<p>InnoDB使用该参数指定大小的内存来缓冲数据和索引。</p>
<p>对于单独的MySQL数据库服务器，最大可以把该值设置成物理内存的80%,一般我们建议不要超过物理内存的70%。</p>
<p><u><em>配置方法</em></u></p>
<p>innodb_buffer_pool_size=2048M</p>
<h5 id="innodb_flush_log_at_trx_commit"><a class="markdownIt-Anchor" href="#innodb_flush_log_at_trx_commit"></a> innodb_flush_log_at_trx_commit</h5>
<p>主要控制了innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，取值分别为0、1、2三个。<br />
0，表示当事务提交时，不做日志写入操作，而是每秒钟将log buffer中的数据写入日志文件并flush磁盘一次；<br />
1，每次事务的提交都会引起redo日志文件写入、flush磁盘的操作，确保了事务的ACID；<br />
2，每次事务提交引起写入日志文件的动作,但每秒钟完成一次flush磁盘操作。</p>
<p><em>配置依据</em><br />
实际测试发现，该值对插入数据的速度影响非常大，设置为2时插入10000条记录只需要2秒，设置为0时只需要1秒，而设置为1时则需要229秒。因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅提高速度。<br />
根据MySQL官方文档，在允许丢失最近部分事务的危险的前提下，可以把该值设为0或2。</p>
<p><u><em>配置方法</em></u></p>
<p>innodb_flush_log_at_trx_commit=1 双1标准中的一个1</p>
<h5 id="innodb_thread_concurrency"><a class="markdownIt-Anchor" href="#innodb_thread_concurrency"></a> innodb_thread_concurrency</h5>
<blockquote>
<p>此参数用来设置innodb线程的并发数量，默认值为0表示不限制。</p>
</blockquote>
<p>在官方文档上，对于innodb_thread_concurrency的使用，也给出了一些建议，如下：</p>
<ul>
<li>如果一个工作负载中，并发用户线程的数量小于64，建议设置innodb_thread_concurrency=0；</li>
<li>如果工作负载一直较为严重甚至偶尔达到顶峰，建议先设置innodb_thread_concurrency=128， 并通过不断的降低这个参数，96,<br />
80, 64等等，直到发现能够提供最佳性能的线程数，</li>
</ul>
<p>假设系统通常有40到50个用户，但定期的数量增加至60，70，甚至200。你会发现，<br />
性能在80个并发用户设置时表现稳定，如果高于这个数，性能反而下降。在这种情况下，<br />
建议设置innodb_thread_concurrency参数为80，以避免影响性能。</p>
<p>如果你不希望InnoDB使用的虚拟CPU数量比用户线程使用的虚拟CPU更多（比如20个虚拟CPU），<br />
建议通过设置innodb_thread_concurrency 参数为这个值（也可能更低，这取决于性能体现），</p>
<p>如果你的目标是将MySQL与其他应用隔离，你可以l考虑绑定mysqld进程到专有的虚拟CPU。 但是需<br />
要注意的是，这种绑定，在myslqd进程一直不是很忙的情况下，可能会导致非最优的硬件使用率。在这种情况下，<br />
你可能会设置mysqld进程绑定的虚拟 CPU，允许其他应用程序使用虚拟CPU的一部分或全部。<br />
在某些情况下，最佳的innodb_thread_concurrency参数设置可以比虚拟CPU的数量小。<br />
定期检测和分析系统，负载量、用户数或者工作环境的改变可能都需要对innodb_thread_concurrency参数的设置进行调整</p>
<p>128 -----&gt; top cpu<br />
<u><em>设置标准</em></u><br />
1、当前系统cpu使用情况，均不均匀 top</p>
<p>2、当前的连接数，有没有达到顶峰 show status like ‘threads_%’; show processlist; （3）配置方法：<br />
innodb_thread_concurrency=8 方法:</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">看top ,观察每个cpu的各自的负载情况</span><br><span class="line">发现不平均,先设置参数为cpu个数,然后不断增加(一倍)这个数值</span><br><span class="line">一直观察top状态,直到达到比较均匀时,说明已经到位了.</span><br></pre></td></tr></table></figure>
<h5 id="innodb_log_buffer_size"><a class="markdownIt-Anchor" href="#innodb_log_buffer_size"></a> <strong>innodb_log_buffer_size</strong></h5>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">此参数确定些日志文件所用的内存大小，以M为单位。缓冲区更大能提高性能，对于较大的事务，可以增大缓存大小。</span><br><span class="line">innodb<span class="built_in">_</span>log<span class="built_in">_</span>buffer<span class="built_in">_</span>size=128M</span><br><span class="line">设定依据：</span><br><span class="line">1、大事务： 存储过程调用 CALL</span><br><span class="line">2、多事务</span><br></pre></td></tr></table></figure>
<h5 id="innodb_log_file_size-100m"><a class="markdownIt-Anchor" href="#innodb_log_file_size-100m"></a> innodb_log_file_size = 100M</h5>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">设置 ib<span class="built_in">_</span>logfile0  ib<span class="built_in">_</span>logfile1 </span><br><span class="line">此参数确定数据日志文件的大小，以M为单位，更大的设置可以提高性能.</span><br><span class="line">innodb<span class="built_in">_</span>log<span class="built_in">_</span>file<span class="built_in">_</span>size = 100M</span><br></pre></td></tr></table></figure>
<h5 id="innodb_log_files_in_group-3"><a class="markdownIt-Anchor" href="#innodb_log_files_in_group-3"></a> innodb_log_files_in_group = 3</h5>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3</span><br></pre></td></tr></table></figure>
<h5 id="read_buffer_size-1m"><a class="markdownIt-Anchor" href="#read_buffer_size-1m"></a> read_buffer_size = 1M</h5>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">MySql读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySql会为它分配一段内存缓冲区。如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能。和 sort<span class="built_in">_</span>buffer<span class="built_in">_</span>size一样，该参数对应的分配内存也是每个连接独享</span><br></pre></td></tr></table></figure>
<h5 id="read_rnd_buffer_size-1m"><a class="markdownIt-Anchor" href="#read_rnd_buffer_size-1m"></a> read_rnd_buffer_size = 1M</h5>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">MySql的随机读（查询操作）缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySql会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySql会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。</span><br><span class="line">注：顺序读是指根据索引的叶节点数据就能顺序地读取所需要的行数据。随机读是指一般需要根据辅助索引叶节点中的主键寻找实际行数据，而辅助索引和主键所在的数据段不同，因此访问方式是随机的。</span><br></pre></td></tr></table></figure>
<h5 id="bulk_insert_buffer_size-8m"><a class="markdownIt-Anchor" href="#bulk_insert_buffer_size-8m"></a> bulk_insert_buffer_size = 8M</h5>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">批量插入数据缓存大小，可以有效提高插入效率，默认为8M</span><br><span class="line">tokuDB    percona</span><br><span class="line">myrocks   </span><br><span class="line">RocksDB</span><br><span class="line">TiDB</span><br><span class="line">MongoDB</span><br></pre></td></tr></table></figure>
<h5 id="binary-log"><a class="markdownIt-Anchor" href="#binary-log"></a> binary log</h5>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">log-bin</span> = /data/mysql-bin</span><br><span class="line"><span class="attr">binlog_cache_size</span> = <span class="number">2</span>M //为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存, 提高记录bin-log的效率。没有什么大事务，dml也不是很频繁的情况下可以设置小一点，如果事务大而且多，dml操作也频繁，则可以适当的调大一点。前者建议是--<span class="number">1</span>M，后者建议是：即 <span class="number">2</span>--<span class="number">4</span>M</span><br><span class="line"><span class="attr">max_binlog_cache_size</span> = <span class="number">8</span>M //表示的是binlog 能够使用的最大cache 内存大小</span><br><span class="line"><span class="attr">max_binlog_size</span> = <span class="number">512</span>M //指定binlog日志文件的大小，如果当前的日志大小达到max_binlog_size，还会自动创建新的二进制日志。你不能将该变量设置为大于<span class="number">1</span>GB或小于<span class="number">4096</span>字节。默认值是<span class="number">1</span>GB。在导入大容量的sql文件时，建议关闭sql_log_bin，否则硬盘扛不住，而且建议定期做删除。</span><br><span class="line"><span class="attr">expire_logs_days</span> = <span class="number">7</span> //定义了mysql清除过期日志的时间。</span><br><span class="line">二进制日志自动删除的天数。默认值为0,表示“没有自动删除”。</span><br><span class="line"><span class="attr">log-bin</span> = /mysql-bin</span><br><span class="line"><span class="attr">binlog_format</span> = row</span><br><span class="line"><span class="attr">sync_binlog</span> = <span class="number">1</span></span><br><span class="line">双1标准(基于安全的控制)：</span><br><span class="line"><span class="attr">sync_binlog</span> = <span class="number">1</span>   // 什么时候刷新binlog到磁盘，每次事务commit</span><br><span class="line"><span class="attr">innodb_flush_log_at_trx_commit</span> = <span class="number">1</span></span><br><span class="line">set <span class="attr">sql_log_bin</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">show status like &#x27;com_%&#x27;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">basedir</span> = /data/mysql</span><br><span class="line"><span class="attr">datadir</span> = /data/mysql/data</span><br><span class="line"><span class="attr">socket</span> = /tmp/mysql.sock</span><br><span class="line"><span class="attr">log-error</span> = /var/log/mysql.log</span><br><span class="line"><span class="attr">log_bin</span> = /data/binlog/mysql-bin</span><br><span class="line"><span class="attr">binlog_format</span> = row</span><br><span class="line">skip-name-resolve</span><br><span class="line"><span class="attr">server-id</span> = <span class="number">52</span></span><br><span class="line"><span class="attr">gtid-mode</span> = <span class="literal">on</span></span><br><span class="line"><span class="attr">enforce-gtid-consistency</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">log-slave-updates</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">relay_log_purge</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">max_connections</span> = <span class="number">1024</span></span><br><span class="line"><span class="attr">back_log</span> = <span class="number">128</span></span><br><span class="line"><span class="attr">wait_timeout</span> = <span class="number">60</span></span><br><span class="line"><span class="attr">interactive_timeout</span> = <span class="number">7200</span></span><br><span class="line"><span class="attr">key_buffer_size</span> = <span class="number">16</span>M</span><br><span class="line"><span class="attr">query_cache_size</span> = <span class="number">64</span>M</span><br><span class="line"><span class="attr">query_cache_type</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">query_cache_limit</span> = <span class="number">50</span>M</span><br><span class="line"><span class="attr">max_connect_errors</span> = <span class="number">20</span></span><br><span class="line"><span class="attr">sort_buffer_size</span> = <span class="number">2</span>M</span><br><span class="line"><span class="attr">max_allowed_packet</span> = <span class="number">32</span>M</span><br><span class="line"><span class="attr">join_buffer_size</span> = <span class="number">2</span>M</span><br><span class="line"><span class="attr">thread_cache_size</span> = <span class="number">200</span></span><br><span class="line"><span class="attr">innodb_buffer_pool_size</span> = <span class="number">1024</span>M</span><br><span class="line"><span class="attr">innodb_flush_log_at_trx_commit</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">innodb_log_buffer_size</span> = <span class="number">32</span>M</span><br><span class="line"><span class="attr">innodb_log_file_size</span> = <span class="number">128</span>M</span><br><span class="line"><span class="attr">innodb_log_files_in_group</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">binlog_cache_size</span> = <span class="number">2</span>M</span><br><span class="line"><span class="attr">max_binlog_cache_size</span> = <span class="number">8</span>M</span><br><span class="line"><span class="attr">max_binlog_size</span> = <span class="number">512</span>M</span><br><span class="line"><span class="attr">expire_logs_days</span> = <span class="number">7</span></span><br><span class="line"><span class="attr">read_buffer_size</span> = <span class="number">2</span>M</span><br><span class="line"><span class="attr">read_rnd_buffer_size</span> = <span class="number">2</span>M</span><br><span class="line"><span class="attr">bulk_insert_buffer_size</span> = <span class="number">8</span>M</span><br><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="attr">socket</span> = /tmp/mysql.sock  </span><br></pre></td></tr></table></figure>
<h2 id="sql与索引优化"><a class="markdownIt-Anchor" href="#sql与索引优化"></a> sql与索引优化</h2>
<h3 id="sql使用建议"><a class="markdownIt-Anchor" href="#sql使用建议"></a> sql使用建议</h3>
<ol>
<li>
<p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
</li>
<li>
<p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id</span><br><span class="line"><span class="keyword">from</span> t</span><br><span class="line"><span class="keyword">where</span> num <span class="keyword">is</span> <span class="keyword">null</span> # 可以在num上设置默认值<span class="number">0</span>，确保表中num列没有<span class="keyword">null</span>值，然后这样查询：</span><br><span class="line"><span class="keyword">select</span> id</span><br><span class="line"><span class="keyword">from</span> t</span><br><span class="line"><span class="keyword">where</span> num <span class="operator">=</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p>
</li>
<li>
<p>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id</span><br><span class="line"><span class="keyword">from</span> t</span><br><span class="line"><span class="keyword">where</span> num <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">   <span class="keyword">or</span> num <span class="operator">=</span> <span class="number">20</span> # 可以这样查询：</span><br><span class="line"><span class="keyword">select</span> id</span><br><span class="line"><span class="keyword">from</span> t</span><br><span class="line"><span class="keyword">where</span> num <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> id</span><br><span class="line"><span class="keyword">from</span> t</span><br><span class="line"><span class="keyword">where</span> num <span class="operator">=</span> <span class="number">20</span>   </span><br></pre></td></tr></table></figure>
<ol start="5">
<li>in 和 not in 也要慎用，否则会导致全表扫描，如：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id</span><br><span class="line"><span class="keyword">from</span> t</span><br><span class="line"><span class="keyword">where</span> num <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) # 对于连续的数值，能用 <span class="keyword">between</span> 就不要用 <span class="keyword">in</span> 了：</span><br><span class="line"><span class="keyword">select</span> id</span><br><span class="line"><span class="keyword">from</span> t</span><br><span class="line"><span class="keyword">where</span> num <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span>  </span><br></pre></td></tr></table></figure>
<ol start="6">
<li>下面的查询也将导致全表扫描：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id</span><br><span class="line"><span class="keyword">from</span> t</span><br><span class="line"><span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%abc%&#x27;</span>   </span><br></pre></td></tr></table></figure>
<ol start="7">
<li>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id</span><br><span class="line"><span class="keyword">from</span> t</span><br><span class="line"><span class="keyword">where</span> num <span class="operator">/</span> <span class="number">2</span> <span class="operator">=</span> <span class="number">100</span> # 应改为:</span><br><span class="line"><span class="keyword">select</span> id</span><br><span class="line"><span class="keyword">from</span> t</span><br><span class="line"><span class="keyword">where</span> num <span class="operator">=</span> <span class="number">100</span> <span class="operator">*</span> <span class="number">2</span>   </span><br></pre></td></tr></table></figure>
<ol start="8">
<li>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id</span><br><span class="line"><span class="keyword">from</span> t</span><br><span class="line"><span class="keyword">where</span> <span class="built_in">substring</span>(name, <span class="number">1</span>, <span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span><span class="comment">--name以abc开头的id   </span></span><br><span class="line">    # 应改为:</span><br><span class="line"><span class="keyword">select</span> id</span><br><span class="line"><span class="keyword">from</span> t</span><br><span class="line"><span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;abc%&#x27;</span>   </span><br></pre></td></tr></table></figure>
<ol start="9">
<li>
<p>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
</li>
<li>
<p>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p>
</li>
<li>
<p>不要写一些没有意义的查询，如需要生成一个空表结构</p>
</li>
<li>
<p>很多时候用 exists 代替 in 是一个好的选择：</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> num</span><br><span class="line"><span class="keyword">from</span> a</span><br><span class="line"><span class="keyword">where</span> num <span class="keyword">in</span> (<span class="keyword">select</span> num <span class="keyword">from</span> b) # 用下面的语句替换：</span><br><span class="line"><span class="keyword">select</span> num</span><br><span class="line"><span class="keyword">from</span> a</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> b <span class="keyword">where</span> num <span class="operator">=</span> a.num)   </span><br></pre></td></tr></table></figure>
<ol start="13">
<li></li>
</ol>
<p>并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p>
<ol start="14">
<li>
<p>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，<br />
因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。<br />
一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p>
</li>
<li>
<p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。<br />
这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>
</li>
<li>
<p>尽可能的使用 varchar 代替 char ，因为首先变长字段存储空间小，可以节省存储空间，<br />
其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
</li>
<li>
<p>任何地方都不要使用 select <em>from t ，用具体的字段列表代替“</em>”，不要返回用不到的任何字段。</p>
</li>
<li>
<p>避免频繁创建和删除临时表，以减少系统表资源的消耗。</p>
</li>
<li>
<p>临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</p>
</li>
<li>
<p>在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量<br />
log ，<br />
以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p>
</li>
<li>
<p>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table<br />
，这样可以避免系统表的较长时间锁定。</p>
</li>
<li>
<p>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p>
</li>
<li>
<p>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p>
</li>
<li>
<p>与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD<br />
游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。</p>
</li>
</ol>
<p>在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p>
<ol start="25">
<li>
<p>尽量避免大事务操作，提高系统并发能力。</p>
</li>
<li>
<p>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p>
</li>
</ol>
<h3 id="sql调优思路"><a class="markdownIt-Anchor" href="#sql调优思路"></a> sql调优思路</h3>
<ol>
<li>slow_query_log 收集慢日志 结合explain分析索引命中与进行索引优化</li>
<li>减少索引扫描行数，对于慢sql进行优化</li>
<li>建立联合索引，由于联合索引的每个叶子节点都包含检索字段信息，按最左原则匹配，按照其他条件过滤，减少回表的数据量</li>
<li>使用虚拟列和联合索引来提升复杂查询执行效率</li>
</ol>
<h3 id="索引失效"><a class="markdownIt-Anchor" href="#索引失效"></a> 索引失效</h3>
<ol>
<li>联合索引不遵循最左匹配原则</li>
<li><code>SELECT *</code>使用不当</li>
<li>索引列参与计算—查询条件使用函数在索引列上，或者对索引列进行运算，运算包括(+，-，*，/，! 等)</li>
<li>错误的使用<code>lIKE</code>, 进行模糊查询</li>
<li>查询条件与索引列类型不一致，造成类型转换</li>
<li>WHERE 子查询中<code>OR</code> 使用不当</li>
<li><code>&lt; &gt;</code>、<code>IS NOT NULL</code> 、<code>NOT IN</code>、<code>NOT EXISTS</code></li>
<li><code>ORDER BY</code> 多个字段时不走索引</li>
<li>优化器判断失误不走索引</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>DBMS</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL存储引擎</title>
    <url>/14571.html</url>
    <content><![CDATA[<blockquote>
<p>Server version:  8.0.20 Source distribution</p>
</blockquote>
<p><code>SHOW ENGINES</code></p>
<table>
<thead>
<tr>
<th style="text-align:left">Engine</th>
<th style="text-align:left">Support</th>
<th style="text-align:left">Comment</th>
<th style="text-align:left">Transactions</th>
<th style="text-align:left">XA</th>
<th style="text-align:left">Savepoints</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">FEDERATED</td>
<td style="text-align:left">NO</td>
<td style="text-align:left">Federated MySQL storage engine</td>
<td style="text-align:left"><em>NULL</em></td>
<td style="text-align:left"><em>NULL</em></td>
<td style="text-align:left">*</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">NULL*</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">MEMORY</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">Hash based, stored in memory, useful for temporary…</td>
<td style="text-align:left">NO</td>
<td style="text-align:left">NO</td>
<td style="text-align:left">NO</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">InnoDB</td>
<td style="text-align:left">DEFAULT</td>
<td style="text-align:left">Supports transactions, row-level locking, and fore…</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">YES</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">PERFORMANCE_SCHEMA</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">Performance Schema</td>
<td style="text-align:left">NO</td>
<td style="text-align:left">NO</td>
<td style="text-align:left">NO</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">MyISAM</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">MyISAM storage engine</td>
<td style="text-align:left">NO</td>
<td style="text-align:left">NO</td>
<td style="text-align:left">NO</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">MRG_MYISAM</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">Collection of identical MyISAM tables</td>
<td style="text-align:left">NO</td>
<td style="text-align:left">NO</td>
<td style="text-align:left">NO</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">BLACKHOLE</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">/dev/null storage engine (anything you write to it…</td>
<td style="text-align:left">NO</td>
<td style="text-align:left">NO</td>
<td style="text-align:left">NO</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">CSV</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">CSV storage engine</td>
<td style="text-align:left">NO</td>
<td style="text-align:left">NO</td>
<td style="text-align:left">NO</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">ARCHIVE</td>
<td style="text-align:left">YES</td>
<td style="text-align:left">Archive storage engine</td>
<td style="text-align:left">NO</td>
<td style="text-align:left">NO</td>
<td style="text-align:left">NO</td>
<td></td>
</tr>
</tbody>
</table>
<p>MySQL中常用的存储引擎有InnoDB、MyISAM、MEMORY、ARCHIVE和CSV</p>
<h2 id="存储引擎"><a class="markdownIt-Anchor" href="#存储引擎"></a> 存储引擎</h2>
<h3 id="innodb存储引擎"><a class="markdownIt-Anchor" href="#innodb存储引擎"></a> InnoDB存储引擎</h3>
<p>支持事务 锁级别为行锁，比MyISAM存储引擎支持更高的并发 能够通过二进制日志恢复数据 支持外键操作<br />
在索引存储上，索引和数据存储在同一个文件中，默认按照B+Tree组织索引的结构。同时，主键索引的叶子节点存储完整的数据记录，非主键索引的叶子节点存储主键的值。</p>
<p><strong>在MySQL 5.6版本之后，默认使用InnoDB存储引擎。</strong></p>
<p><strong>在MySQL 5.6版本之后，InnoDB存储引擎支持全文索引。</strong></p>
<h3 id="myisam存储引擎"><a class="markdownIt-Anchor" href="#myisam存储引擎"></a> MyISAM存储引擎</h3>
<p>不支持事务。</p>
<p>锁级别为表锁，在要求高并发的场景下不太适用。</p>
<p>如果数据文件损坏，难以恢复数据。</p>
<p>不支持外键。</p>
<p>在索引存储上，索引文件与数据文件分离。</p>
<p>支持全文索引。</p>
<h3 id="memory存储引擎"><a class="markdownIt-Anchor" href="#memory存储引擎"></a> MEMORY存储引擎</h3>
<p>不支持TEXT和BLOB数据类型，只支持固定长度的字符串类型。例如，在MEMORY存储引擎中，会将VARCHAR类型自动转化成CHAR类型。</p>
<p>锁级别为表锁，在高并发场景下会成为瓶颈。</p>
<p>通常会被作为临时表使用，存储查询数据时产生中间结果。</p>
<p>数据存储在内存中，重启服务器后数据会丢失。如果是需要持久化的数据，不适合存储在MEMORY存储引擎的数据表中。</p>
<h3 id="archive存储引擎"><a class="markdownIt-Anchor" href="#archive存储引擎"></a> ARCHIVE存储引擎</h3>
<p>支持数据压缩，在存储数据前会对数据进行压缩处理，适合存储归档的数据。</p>
<p>只支持数据的插入和查询，插入数据后，不能对数据进行更改和删除，而只能查询。</p>
<p>只支持在整数自增类型的字段上添加索引。</p>
<h3 id="csv存储引擎"><a class="markdownIt-Anchor" href="#csv存储引擎"></a> CSV存储引擎</h3>
<p>主要存储的是csv格式的文本数据，可以直接打开存储的文件进行编辑。</p>
<p>可以将MySQL中某个数据表中的数据直接导出为csv文件，也可以将.csv文件导入数据表中。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL3N0b3JhZ2UtZW5naW5lcy5odG1s">https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL2lubm9kYi1zdG9yYWdlLWVuZ2luZS5odG1s">https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>DBMS</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库一些概念</title>
    <url>/48341.html</url>
    <content><![CDATA[<h1 id="mysql数据库一些概念"><a class="markdownIt-Anchor" href="#mysql数据库一些概念"></a> MySQL数据库一些概念</h1>
<h2 id="数据库的定义"><a class="markdownIt-Anchor" href="#数据库的定义"></a> 数据库的定义</h2>
<p>​<br />
数据库的定义在某种程度上，数据库代表着一种存储技术，并不局限于某种存储形式。一个简单的数据库可以将数据只存储在某台特定的计算机上，供某个特定的用户使用，而一个复杂的数据库可以将数据分散存储到多台计算机上，能够供成千上万的用户同时使用。从存储容量上来说，一个数据库的存储容量可以小到只能够存储几KB的数据，也可以大到存储TB甚至是PB级别的数据。</p>
<h3 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h3>
<p>​<br />
数据库（DataBase，DB）从本质上讲就是一个文件系统，它能够将数据有组织地集合在一起，按照一定的规则长期存储到计算机的磁盘中，并且能够供多个用户共享和使用，同时，用户能够对数据库中的数据进行插入、删除、修改和查询操作。数据库将数据进行集中存储和管理，有效地分离了应用程序和业务数据，降低了应用程序和业务数据之间的耦合性，大大简化了数据的存储和管理工作。同时，数据库提供了对存储数据的统一控制功能。数据除了能够被存储在计算机的磁盘中，还能够被存储在计算机的内存中，所以在某种程度上，可以将数据库分为永久型数据库和内存型数据库。</p>
<h3 id="数据表"><a class="markdownIt-Anchor" href="#数据表"></a> 数据表</h3>
<p>​<br />
对于关系型数据库来说，数据表是以一个二维数组的形式来存储和管理数据的，它能够存储和管理数据并操作数据的逻辑结构。通常，一个数据表由行和列组成，一行数据能够表示一条完整的基础信息，所以行在关系型数据库中是组织数据的基本单位；列也被称为字段，它能够表示行的一个属性，同时，每一列都有相应的数据类型和数据长度的定义。</p>
<h3 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h3>
<p>​<br />
关系型数据库中的数据类型表示数据在数据库中的存储格式，其反映了数据在计算机中的存储格式。计算机根据不同的数据类型来组织和存储数据，并为不同数据类型的数据分配不同的存储空间。数据类型在大的分类上可以分为数值类型、日期和时间类型、字符串类型。在关系型数据库中，表中的每个字段都会被指定一种数据类型。例如，表1-1中，将商品编号、商品名称和商品类型定义为字符串类型，将商品价格定义为数值类型（定点数类型），将上架时间定义为日期和时间类型。</p>
<span id="more"></span>
<h3 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h3>
<p>​<br />
数据库中内置了一些函数，能够很方便地对数据进行数学计算、字符串处理、加密/解密及聚合处理等。相应地，函数可以分为数学函数、字符串函数、日期和时间函数、流程处理函数、加密与解密函数、数据聚合函数、获取数据库信息函数以及数据库中的其他函数等</p>
<h3 id="主键"><a class="markdownIt-Anchor" href="#主键"></a> 主键</h3>
<p>​ 在关系型数据库中，主键（Primary<br />
Key）又称为主码，能够唯一标识数据表中的一行记录。主键可以包含数据表中的一列或者多列，主键不能为空。同时，在同一个数据表中，主键列上不能有两行甚至多行相同的值，也就是说，在同一个数据表中，每行数据对应的主键列的值必须唯一。</p>
<h3 id="外键"><a class="markdownIt-Anchor" href="#外键"></a> 外键</h3>
<p>​<br />
外键从本质上讲就是一个引用，它引用的是另外一张表中的一列或者多列数据，被引用的表中的列需要具备主键约束或者唯一性约束。也就是说，被引用的列在其对应的数据表中能够唯一标识一行数据。外键反映的是两个表之间的连接关系。</p>
<h3 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h3>
<p>​<br />
索引从本质上来讲是一种单独的数据库结构，它能够单独地存储在计算机的磁盘上，包含着对相关数据表中所有数据的引用指针。通过索引能够快速定位并查询出数据表中的一行或者多行数据，而不必进行全表扫描。在某种程度上，数据库的索引和书籍的目录有些类似。当查找书籍中的内容时，往往不会直接翻阅书籍的内容，这样查找起来相当烦琐；如果先根据书籍的目录定位到要查找的内容在书籍中的大概章节，然后再到相关的章节中去查找内容就比较简单了。索引使查询能够快速到达计算机中的某个位置去搜寻数据文件，而不必对所有的数据进行扫描。索引的建立，可以大大提高数据查询的效率</p>
<h3 id="视图"><a class="markdownIt-Anchor" href="#视图"></a> 视图</h3>
<p>​<br />
视图从本质上来讲是数据库的一种虚表，它是由SELECT查询语句从一张表或者多张表中导出的一种虚表。不能向视图中插入、更新和删除数据，即视图不负责数据的实际存储。当通过视图修改数据时，实际上修改的是构成视图的基本表中的数据，当修改了构成视图的基本表中的数据时，视图中的数据也会随之改变。使用视图能够大大简化数据库中表与表之间复杂的关联查询。</p>
<h3 id="存储过程"><a class="markdownIt-Anchor" href="#存储过程"></a> 存储过程</h3>
<p>​<br />
存储过程是一种SQL语句集，经过编译后存储在数据库中，通过指定存储过程的名称和参数信息来调用存储过程，使其完成特定的功能。在创建存储过程的时候，可以自定义变量来存储一些中间结果的数据，也可以在存储过程中定义一些执行逻辑和执行流程。存储过程经过一次编译后可以永久使用（只要不删除存储过程）。将一些复杂的查询逻辑封装在存储过程中重复使用，应用程序只需要调用存储过程的名称并传入相应的参数即可，大大简化了开发和数据查询的复杂度。另外，使用存储过程也可以防止用户直接访问数据表，只需要赋予用户对存储过程的访问权限即可。</p>
<h3 id="触发器"><a class="markdownIt-Anchor" href="#触发器"></a> 触发器</h3>
<p>​<br />
触发器从本质上来讲是一种特殊的存储过程。触发器的执行不是由应用程序调用，也不是由手动执行的，而是由数据库中的事件执行的。当对某个表中的数据进行插入、更新和删除操作时，系统会自动执行相应的触发器。在某种程度上，触发器和钩子函数有些类似。应用程序在执行某项操作时，会自动调用相应的钩子函数，执行钩子函数的逻辑。而触发器是对数据表进行操作时自动执行的。当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。</p>
<h3 id="存储引擎"><a class="markdownIt-Anchor" href="#存储引擎"></a> 存储引擎</h3>
<p>MySQL中最常用到的存储引擎是InnoDB和MyISAM</p>
<h2 id="数据库系统"><a class="markdownIt-Anchor" href="#数据库系统"></a> 数据库系统</h2>
<p>​ 在关系型数据库领域中，通常认为数据库系统涉及的软件主要由操作系统、数据库、数据库管理系统、以数据库管理系统为核心的应用开发工具和应用程序等几部分组成。</p>
<ul>
<li>操作系统（Operating System，OS）：直接运行于计算机硬件上的系统，为计算机中运行的各种软件提供基础环境支持。主流的操作系统包括Windows、UNIX/Linux和Mac<br />
OS等。</li>
<li>通常由某种或某几种高级编程语言编写，描述用户应用需求的应用程序、软件或某种管理系统。</li>
<li>数据库（DataBase，DB）：主要负责数据的存放，并在一定程度上保证数据的安全性、完整性和可靠性</li>
<li>数据库管理系统（DataBase Management<br />
System，DBMS）：主要用来对数据库进行管理，是数据库系统的核心组成部分。在实际工作中，人们往往不会直接面对数据库，而是通过数据库管理系统对数据库中的数据进行管理和维护。</li>
</ul>
<p>​ 数据库管理员（DataBase<br />
Administrator，DBA）：控制数据库整体结构的人，需要承担创建、管理、监控和维护整个数据库的责任，并保证数据库的安全、完整、高可用性与高可靠性。</p>
<h2 id="sql语言"><a class="markdownIt-Anchor" href="#sql语言"></a> SQL语言</h2>
<p>关系型数据库中专门提供了一种对数据库进行操作和查询的语言，叫作结构化查询语言，英文为Structured Query<br />
Language，简称SQL。</p>
<h3 id="sql语言分类"><a class="markdownIt-Anchor" href="#sql语言分类"></a> SQL语言分类</h3>
<ul>
<li>
<p>DDL（Data Definition Language，数据定义语言）：用于定义数据库、数据表和列，可以用来创建、删除、修改数据库和数据表的结构，包含CREATE、DROP和ALTER等语句。</p>
</li>
<li>
<p>DML（Data Manipulation<br />
Language，数据操作语言）：用于操作数据记录，可以对数据库中数据表的数据记录进行增加、删除和修改等操作，包含INSERT、DELETE和UPDATE等语句。</p>
</li>
<li>
<p>DCL（Data Control Language，数据控制语言）：用于定义数据库的访问权限和安全级别，主要包含GRANT、REVOKE、COMMIT和ROLLBACK等语句。</p>
</li>
<li>
<p>DQL（Data Query Language，数据查询语言）：用于查询数据表中的数据记录，主要包含SELECT语句。</p>
</li>
</ul>
<p>​<br />
关系型数据库提供了SQL语言，使应用程序开发人员与数据库管理和维护人员能够与数据库进行交互。但是在创建数据库和数据表之前，需要对数据库中的数据表进行设计，并能够正确设计出各数据表之间的关联关系。通常使用ER图（Entity<br />
Relationship Diagram），也就是实体-关系模型，来进行数据表的设计。ER图是用来描述现实世界的概念模型，在这个模型中有3个基本要素，分别为实体、属性和关系。</p>
<h3 id="er图"><a class="markdownIt-Anchor" href="#er图"></a> ER图</h3>
<p>​<br />
关系型数据库提供了SQL语言，使应用程序开发人员与数据库管理和维护人员能够与数据库进行交互。但是在创建数据库和数据表之前，需要对数据库中的数据表进行设计，并能够正确设计出各数据表之间的关联关系。通常使用ER图（Entity<br />
Relationship Diagram），也就是实体-关系模型，来进行数据表的设计。ER图是用来描述现实世界的概念模型，在这个模型中有3个基本要素，分别为实体、属性和关系。</p>
<h2 id="范式"><a class="markdownIt-Anchor" href="#范式"></a> 范式</h2>
<p>​ MySQL的三大范式能够规范开发人员对数据表的设计，使得开发人员能够设计出简洁、优雅的数据表结构。</p>
<h3 id="第一范式"><a class="markdownIt-Anchor" href="#第一范式"></a> 第一范式</h3>
<p>​ 主要是确保数据表中每个字段的值必须具有原子性，也就是说数据表中每个字段的值为<strong>不可再次拆分</strong>的*<br />
<em>最小数据单元</em>*。</p>
<h3 id="第二范式"><a class="markdownIt-Anchor" href="#第二范式"></a> 第二范式</h3>
<p>指在第一范式的基础上，确保数据表中除了<strong>主键之外的每个字段</strong>都必须<strong>依赖主键</strong>。</p>
<h3 id="第三范式"><a class="markdownIt-Anchor" href="#第三范式"></a> 第三范式</h3>
<p>在第二范式的基础上，确保数据表中的每一列都和主键字段直接相关</p>
<blockquote>
<p>也就是说要求数据表中的所有非主键字段不能依赖于其他非主键字段</p>
</blockquote>
<h3 id="反范式"><a class="markdownIt-Anchor" href="#反范式"></a> 反范式</h3>
<p>​<br />
当数据库中的数据量比较大且系统的UV和PV访问频次比较高，若完全按照MySQL的三大范式设计数据表，读数据时会产生大量的关联查询，在一定程度上会影响数据库的读性能。此时，可以通过在数据表中增加冗余字段减少关联来提高数据库的读性能。</p>
<h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2>
<p>MySQL技术大全 – 冰河</p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>DBMS</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库体系结构</title>
    <url>/55553.html</url>
    <content><![CDATA[<h2 id="mysql体系结构"><a class="markdownIt-Anchor" href="#mysql体系结构"></a> MySQL体系结构</h2>
<h3 id="csclientserver模型"><a class="markdownIt-Anchor" href="#csclientserver模型"></a> C/S(Client/Server)模型</h3>
<p>​ C/S结构是一种软件系统体系结构，</p>
<p>​ C是英文单词“Client”的首字母，即客户端的意思，C/S就是“Client/Server”的缩写，即“客户端/服务器”模式。MySQL<br />
C/S 可如下图所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gto7tgqgp1j60js0a8jrl02.jpg" alt="" /></p>
<h4 id="mysql-连接"><a class="markdownIt-Anchor" href="#mysql-连接"></a> MySQL 连接</h4>
<p>实现MySQL连接的方式主要有两种，</p>
<ul>
<li>基于TCP/IP的连接，适用于远程、本地</li>
<li>基于Socket方式连接，仅限于本地连接</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># TCP/IP方式（远程、本地）</span></span><br><span class="line">mysql -h 192.168.0.51 -P 3306 -u root -p paynepasswd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Socket方式(仅本地)</span></span><br><span class="line">mysql -S /tmp/mysql.sock -u root -p paynepasswd</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>在Linux中<code>/etc/my.cnf</code>文件中显示（已完成MySQL的安装）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">socket=/tmp/mysql.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/my.cnf    示例如下                                                                                    </span></span><br><span class="line">[client]</span><br><span class="line"><span class="comment">#password       = your_password</span></span><br><span class="line">port            = 3306</span><br><span class="line">socket          = /tmp/mysql.sock</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">port            = 3306</span><br><span class="line">socket          = /tmp/mysql.sock</span><br><span class="line">datadir = /www/server/data</span><br><span class="line">default_storage_engine = InnoDB</span><br><span class="line">performance_schema_max_table_instances = 400</span><br><span class="line">table_definition_cache = 400</span><br><span class="line">skip-external-locking</span><br><span class="line">key_buffer_size = 1024M</span><br><span class="line"></span><br><span class="line">---略</span><br></pre></td></tr></table></figure>
<h2 id="服务器端实例"><a class="markdownIt-Anchor" href="#服务器端实例"></a> 服务器端(实例)</h2>
<p>实例：My sqld + 工作线程 + 预分配内存</p>
<p>功能：管理数据(增删改查等)</p>
<h3 id="mysqld逻辑结构"><a class="markdownIt-Anchor" href="#mysqld逻辑结构"></a> mysqld逻辑结构</h3>
<p>mysqld的工作模型可分为两块，<code>server</code>层，<code>引擎层</code>，server层可细分为<code>连接层</code>、<code>SQL层</code></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gtoa5gogpej60fv0dhjs202.jpg" alt="" /></p>
<h4 id="连接层"><a class="markdownIt-Anchor" href="#连接层"></a> 连接层</h4>
<ul>
<li>提供连接协议（socket、TCP/IP）</li>
<li>验证用户（账号名、密码、权限）</li>
<li>提供用户专用线程</li>
</ul>
<h4 id="sql层"><a class="markdownIt-Anchor" href="#sql层"></a> SQL层</h4>
<ul>
<li>接收上层传送的SQL语句</li>
<li>语法验证模块：验证语句语法,是否满足SQL_MODE</li>
<li>语义检查：判断SQL语句的类型(DDL、DCL、DML、DQL)</li>
<li>执行权限检查：对语句执行前,进行预处理，生成解析树(执行计划)</li>
<li>优化器：根据解析器得出的多种执行计划，进行判断，选择最优的执行计划 代价模型：资源（CPU IO MEM）的耗损评估性能好坏</li>
<li>执行器：根据最优执行计划，执行SQL语句，产生执行结果</li>
<li>提供查询缓存（默认是没开启的）常使用redis、tair替代查询缓存功能</li>
<li>提供日志记录（日志管理章节）：binlog，默认是没开启的。</li>
</ul>
<h4 id="存储引擎层"><a class="markdownIt-Anchor" href="#存储引擎层"></a> 存储引擎层</h4>
<blockquote>
<p>类似于Linux中的文件系统</p>
</blockquote>
<ul>
<li>负责根据SQL层执行的结果，从磁盘上拿数据</li>
<li>将16进制的磁盘数据，交由SQL结构化化成表</li>
<li>连接层的专用线程返回给用户</li>
</ul>
<h2 id="数据库逻辑结构"><a class="markdownIt-Anchor" href="#数据库逻辑结构"></a> 数据库逻辑结构</h2>
<p><img data-src="https://upload-images.jianshu.io/upload_images/16956686-127fff46fdb7fea9.png" alt="" /></p>
<ul>
<li>库：库名，库属性</li>
<li>表：表名、属性、
<ul>
<li>列:列名(字段),列属性(数据类型,约束等)</li>
<li>数据行(记录)</li>
</ul>
</li>
</ul>
<p><img data-src="https://upload-images.jianshu.io/upload_images/16956686-bfd40838aef7971b.png" alt="物理结构" /></p>
<p>库的物理存储结构</p>
<ul>
<li>用文件系统的目录来存储</li>
</ul>
<p>表的物理存储结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyISAM（一种引擎）的表：</span><br><span class="line">-rw-r----- 1 mysql mysql   10816 Apr 18 8:37 user.frm</span><br><span class="line">-rw-r----- 1 mysql mysql     396 Apr 18 11:20  user.MYD</span><br><span class="line">-rw-r----- 1 mysql mysql    4096 Apr 18 17:48 user.MYI</span><br><span class="line"></span><br><span class="line">InnoDB(默认的存储引擎)的表：</span><br><span class="line">-rw-r----- 1 mysql mysql    8636 Apr 18 9:37 time_zone.frm</span><br><span class="line">-rw-r----- 1 mysql mysql   98304 Apr 18 1:37 time_zone.ibd</span><br><span class="line">time_zone.frm：存储列相关信息</span><br><span class="line">time_zone.ibd：数据行+索引</span><br></pre></td></tr></table></figure>
<p>表的段、区、页（16k）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">页：最小的存储单元，默认16k</span><br><span class="line">区：64个连续的页，共1M</span><br><span class="line">段：一个表就是一个段，包含一个或多个区</span><br></pre></td></tr></table></figure>
<h2 id="执行sql流程"><a class="markdownIt-Anchor" href="#执行sql流程"></a> 执行SQL流程</h2>
<blockquote>
<p>假设忽略权限验证、表操作验证</p>
</blockquote>
<ol>
<li>
<p>客户端发送一条SQL语句给MySQL服务器。</p>
</li>
<li>
<p>MySQL服务器先检查查询缓存，如果查询缓存中存在待查询的结果数据，则会立刻返回查询缓存中的结果数据，否则执行下一阶段的处理。</p>
</li>
<li>
<p>MySQL服务器通过解析器和预处理器对SQL语句进行解析和预处理，并将生成的SQL语句解析树传递给查询优化器。</p>
</li>
<li>
<p>查询优化器将SQL解析树进行进一步处理，生成对应的执行计划。</p>
</li>
<li>
<p>MySQL服务器根据查询优化器生成的执行计划，通过查询执行引擎调用存储引擎的API来执行查询操作。</p>
</li>
<li>
<p>存储引擎查询数据库中的数据，并将结果返回给查询执行引擎。</p>
</li>
<li>
<p>查询执行引擎将结果保存在查询缓存中，并通过数据库连接/线程处理返回给客户端。</p>
</li>
</ol>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gtoc99udhyj60bw0ma0tu02.jpg" alt="" /></p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>DBMS</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的SQL使用之上</title>
    <url>/39916.html</url>
    <content><![CDATA[<h2 id="sql介绍"><a class="markdownIt-Anchor" href="#sql介绍"></a> SQL介绍</h2>
<p>结构化查询语言,5.7 以后符合SQL92严格模式,通过sql_mode参数来控制</p>
<p>DDL（Data Definition Language，数据定义语言）：用于定义数据库、数据表和列，可以用来创建、删除、修改数据库和数据表的结构，包含CREATE、DROP和ALTER等语句。</p>
<p>DML（Data Manipulation<br />
Language，数据操作语言）：用于操作数据记录，可以对数据库中数据表的数据记录进行增加、删除和修改等操作，包含INSERT、DELETE和UPDATE等语句。</p>
<p>DCL（Data Control Language，数据控制语言）：用于定义数据库的访问权限和安全级别，主要包含GRANT、REVOKE、COMMIT和ROLLBACK等语句。</p>
<p>DQL（Data Query Language，数据查询语言）：用于查询数据表中的数据记录，主要包含SELECT语句。</p>
<span id="more"></span>
<h2 id="ddl的应用"><a class="markdownIt-Anchor" href="#ddl的应用"></a> DDL的应用</h2>
<h3 id="库"><a class="markdownIt-Anchor" href="#库"></a> 库</h3>
<h4 id="增"><a class="markdownIt-Anchor" href="#增"></a> 增</h4>
<p>建库规范：</p>
<ol>
<li>库名要和业务相关</li>
<li>库名不能有<strong>大写字母</strong>、<strong>数字</strong>开头</li>
<li>建库要加字符集</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">create database [<span class="keyword">if</span> not exists] 数据库名 [charset 字符编码名称(utf8mb4)] [collate 排序规则(utf8mb4_general_ci)];</span><br></pre></td></tr></table></figure>
<h4 id="删"><a class="markdownIt-Anchor" href="#删"></a> 删</h4>
<blockquote>
<p>生产中禁止使用</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">drop database 数据库名</span><br></pre></td></tr></table></figure>
<h4 id="改"><a class="markdownIt-Anchor" href="#改"></a> 改</h4>
<blockquote>
<p>先查在改</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">SHOW CREATE DATABASE 数据库名;</span><br><span class="line">ALTER DATABASE 数据库名 [charset 字符编码名称] [collate 排序规则];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：修改字符集，修改后的字符集一定是原字符集的严格超集</p>
</blockquote>
<h4 id="查dql"><a class="markdownIt-Anchor" href="#查dql"></a> 查（DQL）</h4>
<p>显示所有数据库 形式:show databases;</p>
<p>显示一个数据库的创建语句: show create database 数据库名;</p>
<p>其他:show charset; show collation;</p>
<p>当前选择的数据库:\s、select database();</p>
<h3 id="表"><a class="markdownIt-Anchor" href="#表"></a> 表</h3>
<p><strong>创建表规范</strong></p>
<ol>
<li>库名需与业务相关，且小写与非数字开头，表、列均需有注释</li>
<li>注意字符集和存储引擎</li>
<li>选择<strong>合适</strong>的<strong>数据类型</strong></li>
<li>每个列设置为非空，若无法保证非空，用0来填充。</li>
</ol>
<h4 id="增-2"><a class="markdownIt-Anchor" href="#增-2"></a> 增</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> [if <span class="keyword">not</span> <span class="keyword">exists</span>] 表名</span><br><span class="line">(</span><br><span class="line">    字段<span class="number">1</span></span><br><span class="line">    数据类型 [</span><br><span class="line">    约束条件] [</span><br><span class="line">    默认值],</span><br><span class="line">    字段<span class="number">2</span></span><br><span class="line">    数据类型 [</span><br><span class="line">    约束条件] [</span><br><span class="line">    默认值],</span><br><span class="line">[</span><br><span class="line">    表约束条件]</span><br><span class="line">) [表选项<span class="number">1</span>,表选项<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    # example</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `ch_people_msg`</span><br><span class="line">(</span><br><span class="line">    `p_id`</span><br><span class="line">    SERIAL</span><br><span class="line">    <span class="keyword">NOT</span></span><br><span class="line"><span class="keyword">    NULL</span></span><br><span class="line">    AUTO_INCREMENT</span><br><span class="line">    COMMENT</span><br><span class="line">    <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">    `p_uic`</span><br><span class="line">    <span class="type">CHAR</span></span><br><span class="line">(</span><br><span class="line">    <span class="number">18</span></span><br><span class="line">) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;用户身份证&#x27;</span>,</span><br><span class="line">    `p_nickname` <span class="type">VARCHAR</span></span><br><span class="line">(</span><br><span class="line">    <span class="number">50</span></span><br><span class="line">) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;用户昵称&#x27;</span>,</span><br><span class="line">    `p_gender` ENUM</span><br><span class="line">(</span><br><span class="line">    <span class="string">&#x27;m&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;n&#x27;</span></span><br><span class="line">) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;n&#x27;</span> COMMENT <span class="string">&#x27;用户性别&#x27;</span>,</span><br><span class="line">    `p_age` TINYINT UNSIGNED <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;用户年龄&#x27;</span>,</span><br><span class="line">    `p_pnum` <span class="type">CHAR</span></span><br><span class="line">(</span><br><span class="line">    <span class="number">11</span></span><br><span class="line">) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;用户电话&#x27;</span>,</span><br><span class="line">    `p_address` <span class="type">VARCHAR</span></span><br><span class="line">(</span><br><span class="line">    <span class="number">100</span></span><br><span class="line">) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;用户地址&#x27;</span>,</span><br><span class="line">    `p_email` <span class="type">VARCHAR</span></span><br><span class="line">(</span><br><span class="line">    <span class="number">50</span></span><br><span class="line">) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;用户邮箱&#x27;</span>,</span><br><span class="line">    `p_add_time` <span class="type">TIMESTAMP</span> <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> NOW</span><br><span class="line">(</span><br><span class="line">) COMMENT <span class="string">&#x27;统计用户时间&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span></span><br><span class="line">(</span><br><span class="line">    `p_id`</span><br><span class="line">),</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `p_uic`</span><br><span class="line">(</span><br><span class="line">    `p_uic`</span><br><span class="line">)</span><br><span class="line">    ) ENGINE <span class="operator">=</span> InnoDB CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci COMMENT <span class="operator">=</span> <span class="string">&#x27;中国成员信息表&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：字段结束为<code>,</code>分隔， 整体结束为<code>)</code>分隔</p>
</blockquote>
<h4 id="删除生产中禁用命令"><a class="markdownIt-Anchor" href="#删除生产中禁用命令"></a> 删除(生产中禁用命令)</h4>
<p>DROP TABLE table_name</p>
<h3 id="改-2"><a class="markdownIt-Anchor" href="#改-2"></a> 改</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> table_name [<span class="keyword">ADD</span>、<span class="keyword">DROP</span>、MODIFY]</span><br><span class="line"># 增加字段<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 在表首列加入p_num列</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ALTER TABLE `ch_people_msg` ADD p_num INT NOT NULL COMMENT &#x27;</span>数字<span class="string">&#x27; FIRST;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 在列p_nickname 后增加 p_wechat列</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ALTER TABLE `ch_people_msg` ADD p_wechat VARCHAR(64) NOT NULL UNIQUE  COMMENT &#x27;</span>微信号<span class="string">&#x27; AFTER `p_nickname`;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 在表中(最后)增加p_qq列</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ALTER TABLE `ch_people_msg` ADD p_qq VARCHAR(20) NOT NULL UNIQUE COMMENT &#x27;</span>用户qq号<span class="string">&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 删除字段</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ALTER TABLE table_name DROP 字段名</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 修改</span></span><br><span class="line"><span class="string">ALTER TABLE `table_name` MODIFY 字段名 约束条件 默认值</span></span><br></pre></td></tr></table></figure>
<h4 id="表属性查询dql"><a class="markdownIt-Anchor" href="#表属性查询dql"></a> 表属性查询（DQL）</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">罗列所有表</span><br><span class="line"><span class="keyword">show</span> tables</span><br><span class="line">；</span><br><span class="line"></span><br><span class="line"># 查看表状态</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> status [<span class="keyword">from</span> db_name] [<span class="keyword">like</span> table_name];</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">查看表结构</span><br><span class="line"><span class="keyword">desc</span> `table_name`;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">查看创建表语句</span><br><span class="line"><span class="keyword">show</span></span><br><span class="line"><span class="keyword">create table</span> `table_name`;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">创建相同类型的表</span><br><span class="line"><span class="keyword">CREATE TABLE</span> `db_name_2` <span class="keyword">LIKE</span> `db_name_1`;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>DBMS</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据类型</title>
    <url>/62617.html</url>
    <content><![CDATA[<h2 id="mysql数据类型"><a class="markdownIt-Anchor" href="#mysql数据类型"></a> MySQL数据类型</h2>
<p>MySQL支持丰富的数据类型，总体上可以分为数值类型、日期和时间类型、字符串类型。</p>
<p>数值类型包括整数类型、浮点数类型和定点数类型；字符串类型包括文本字符串类型和二进制字符串类型;</p>
<p>具体入下所示</p>
<p>主要包括以下几大类： 数值类型：</p>
<ul>
<li>
<p>BIT、BOOL、TINYINT、SMALLINT、MEDIUM INT、 INT、 BIG INT、</p>
</li>
<li>
<p>FLOAT、DOUBLE、DECIMAL(浮点数类型)</p>
</li>
</ul>
<p>字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG<br />
BLOB、ENUM、SET</p>
<p>日期类型：Date、DateTime、TimeStamp、Time、Year</p>
<p>空间类型：Geometry、Point、LineString、MultiPoint、MultiLineString、MultiPolyGon、Polygon、GeometryCollection</p>
<p>其他类型：JSON</p>
<span id="more"></span>
<h3 id="数值类型"><a class="markdownIt-Anchor" href="#数值类型"></a> 数值类型</h3>
<blockquote>
<p>一个字节是8位</p>
<p>无符号（UNSIGNED）为翻倍</p>
</blockquote>
<h4 id="整型"><a class="markdownIt-Anchor" href="#整型"></a> 整型</h4>
<p>MySQL中的整数类型包括TINYINT、SMALLINT、MEDIUMINT、INT(INTEGER)和BIGINT。不同的整数类型，其所需要的存储空间和数值范围不尽相同</p>
<table>
<thead>
<tr>
<th style="text-align:center">数值类型</th>
<th style="text-align:center">类型名称</th>
<th style="text-align:center">存储空间</th>
<th style="text-align:center">取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">TINY INT</td>
<td style="text-align:center">非常小的整数</td>
<td style="text-align:center">1个字节</td>
<td style="text-align:center">- 2 ^ 7 ~ 2 ^ 7 -1</td>
</tr>
<tr>
<td style="text-align:center">SMALL INT</td>
<td style="text-align:center">小整数</td>
<td style="text-align:center">2个字节</td>
<td style="text-align:center">- 2 ^ 15 ~ 2 ^ 15 -1</td>
</tr>
<tr>
<td style="text-align:center">MEDIUM INT</td>
<td style="text-align:center">中型的整数</td>
<td style="text-align:center">3个字节</td>
<td style="text-align:center">- 2 ^ 23 ~ 2 ^ 23 -1</td>
</tr>
<tr>
<td style="text-align:center">INT</td>
<td style="text-align:center">整数</td>
<td style="text-align:center">4个字节</td>
<td style="text-align:center">- 2 ^ 31 ~ 2 ^ 31 -1</td>
</tr>
<tr>
<td style="text-align:center">BIG INT</td>
<td style="text-align:center">大整数</td>
<td style="text-align:center">8个字节</td>
<td style="text-align:center">- 2 ^ 63 ~ 2 ^ 63 - 1</td>
</tr>
</tbody>
</table>
<blockquote>
<p>整数类型的显示宽度与数据类型的取值范围无关。</p>
<p>显示宽度只是指定最大显示的数字个数，如果在数据表中插入了大于显示宽度，但是并没有超过整数类型的数值范围的数据，依然可以正确地插入数据，并且能够正确地显示</p>
</blockquote>
<h4 id="浮点型"><a class="markdownIt-Anchor" href="#浮点型"></a> 浮点型</h4>
<table>
<thead>
<tr>
<th style="text-align:center">数值类型</th>
<th style="text-align:center">类型名称</th>
<th style="text-align:center">存储空间</th>
<th style="text-align:center">取值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DECIMAL(M,D)</td>
<td style="text-align:center">定点数类型</td>
<td style="text-align:center">M + 1 <br />或 <br />M + 2</td>
<td style="text-align:center">~</td>
<td>未打包的浮点数，用法类似于FLOAT与DOUBLE<br />浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。</td>
</tr>
<tr>
<td style="text-align:center">FLOAT</td>
<td style="text-align:center">单精度浮点类型</td>
<td style="text-align:center">4 个字节</td>
<td style="text-align:center">2 ^ 31 ~2 ^ 31 - 1</td>
<td>~</td>
</tr>
<tr>
<td style="text-align:center">DOUBLE</td>
<td style="text-align:center">双精度浮点类型</td>
<td style="text-align:center">8 个字节</td>
<td style="text-align:center">2 ^61 ~2 ^ 61 - 1</td>
<td>~</td>
</tr>
</tbody>
</table>
<blockquote></blockquote>
<p>浮点数类型中的FLOAT和DOUBLE类型在不指定数据精度时，默认会按照实际的计算机硬件和操作系统决定的数据精度进行显示。如果用户指定的精度超出了浮点数类型的数据精度，则MySQL会自动进行四舍五入操作。</p>
<h4 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> 补充</h4>
<table>
<thead>
<tr>
<th style="text-align:center">数值类型</th>
<th style="text-align:center">类型名称</th>
<th style="text-align:center">存储空间</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">BOOL</td>
<td style="text-align:center">布尔类型</td>
<td style="text-align:center">1字节</td>
<td style="text-align:center">TINY INT(1)的别名</td>
</tr>
<tr>
<td style="text-align:center">BIT</td>
<td style="text-align:center">位类型</td>
<td style="text-align:center"></td>
<td style="text-align:center">位类型(M), 每个值存储M位，默认为1，最大64</td>
</tr>
<tr>
<td style="text-align:center">SERIAL</td>
<td style="text-align:center">无符号大整数</td>
<td style="text-align:center">8 个字节</td>
<td style="text-align:center">BIG INT UNSIGNED NOT NULL AUTO_INCREMEINT UNIQUE</td>
</tr>
</tbody>
</table>
<p>浮点数类型中的FLOAT类型和DOUBLE类型在不指定精度时，默认会按照计算机硬件和操作系统决定的精度进行表示；而定点数类型中的DECIMAL类型不指定精度时，默认为DECIMAL(<br />
10,0)。</p>
<p>当数据类型的长度一定时，浮点数能够表示的数据范围更大，但是浮点数会引起精度问题，不适合存储高精度类型的数据。</p>
<h3 id="文本类型"><a class="markdownIt-Anchor" href="#文本类型"></a> 文本类型</h3>
<h4 id="字符类型"><a class="markdownIt-Anchor" href="#字符类型"></a> 字符类型</h4>
<table>
<thead>
<tr>
<th style="text-align:center">字符类型</th>
<th style="text-align:center">类型名称</th>
<th style="text-align:center">存储空间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CHAR</td>
<td style="text-align:center">字符类型</td>
<td style="text-align:center">固定长度字符串，最多为255字符</td>
</tr>
<tr>
<td style="text-align:center">VARCHAR</td>
<td style="text-align:center">可变字符类型</td>
<td style="text-align:center">可变长字符串，最多为65,535字符</td>
</tr>
<tr>
<td style="text-align:center">TINYTEXT</td>
<td style="text-align:center">短文本类型</td>
<td style="text-align:center">可变长度字符串，最多为255字符</td>
</tr>
<tr>
<td style="text-align:center">TEXT</td>
<td style="text-align:center">文本类型</td>
<td style="text-align:center">可变长度字符串，最多为65,535字符</td>
</tr>
<tr>
<td style="text-align:center">MEDIUMTEXT</td>
<td style="text-align:center">中等文本类型</td>
<td style="text-align:center">可变长度，最多为16,777,215 字符</td>
</tr>
<tr>
<td style="text-align:center">LONGTEXT</td>
<td style="text-align:center">长文本类型</td>
<td style="text-align:center">可变长度，最多为4,294,967,295字符</td>
</tr>
</tbody>
</table>
<p><strong>char和varchar</strong></p>
<ol>
<li>
<p>char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以char类型存储的字符串末尾不能有空格，varchar不限于此。</p>
</li>
<li>
<p>char(n) 固定长度，char(4)不管是存入几个字符，都将占用4个字节，varchar是存入的实际字符数+1个字节（n&lt;<br />
=255）或2个字节(n&gt;255)，所以varchar(4),存入3个字符将占用4个字节。</p>
</li>
<li>
<p>char类型的字符串检索速度要比varchar类型的快。</p>
</li>
</ol>
<p><strong>varchar和text</strong></p>
<ol>
<li>
<p>varchar可指定n，text不能指定，内部存储varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)<br />
，text是实际字符数+2个字节。</p>
</li>
<li>
<p>text类型不能有默认值。</p>
</li>
<li>
<p>varchar可直接创建索引，text创建索引要指定前多少个字符。varchar查询速度快于text,在都创建索引的情况下，text的索引似乎不起作用。</p>
</li>
</ol>
<h4 id="二进制类型"><a class="markdownIt-Anchor" href="#二进制类型"></a> 二进制类型</h4>
<p>| 类型 | 类型名称 | 占位 | 说明 | | :---------: | :------------------: | :–: | :<br />
----------------------------------------------------------: | | BINARY | 二进制字符 | |<br />
类似于CHAR（固定长度）类型，但存储的是<strong>二进制字节字符串</strong>  |<br />
| VARBINARY | 可变二进制字符 | | 类似于VARCHAR（可变长度）类型，但存储的是<strong>二进制字节字符串</strong> | |<br />
TINYBLOB | 较小的大二进制对象 | 1 | 最大长度255的字节的BLOB序列<br /><br />
存储时在内容前将使用1个字节表示内容的大小 | | BLOB | 大二进制对象 | 2 |<br />
最大长度63535的字节的BLOB序列<br />存储时在内容前将使用2个字节表示内容的大小 | | MEDIUM BLOB |<br />
中等大的大二进制对象 | 3 | 最大长度1677215的字节的BLOB序列<br /><br />
存储时在内容前将使用3个字节表示内容的大小 | | LONG BLOB | 大的大二进制对象 | 4 |<br />
最大长度4294967296的字节的BLOB序列<br />存储时在内容前将使用4个字节表示内容的大小 |</p>
<p>二进制数据(Blob)</p>
<p>1._BLOB和_text存储方式不同，_TEXT以文本方式存储，英文存储区分大小写，而_Blob是以二进制方式存储，不分大小写。</p>
<p>2._BLOB存储的数据只能整体读出。</p>
<p>3._TEXT可以指定字符集，_BLO不用指定字符集。</p>
<h4 id="补充-2"><a class="markdownIt-Anchor" href="#补充-2"></a> 补充</h4>
<p>| 类型 | 类型名称 | 说明 | | :–: | :------: | :--------------------------: | | ENUM | 枚举类型 |<br />
由一组固定的合法值组成的枚举 | | SET | 集合类型 |<br />
由一组固定的合法值组成的集合 |</p>
<h3 id="日期类型"><a class="markdownIt-Anchor" href="#日期类型"></a> 日期类型</h3>
<p>MySQL提供了表示日期和时间的数据类型，主要有YEAR类型、TIME类型、DATE类型、DATETIME类型和TIMESTAMP类型。</p>
<ul>
<li>
<p>DATE类型通常用来表示年月日；</p>
</li>
<li>
<p>DATETIME类型通常用来表示年、月、日、时、分、秒；</p>
</li>
<li>
<p>TIME类型通常用来表示时、分、秒。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">时间/日期类型</th>
<th style="text-align:center">类型名称</th>
<th style="text-align:center">占位</th>
<th style="text-align:center">日期格式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">YEAR</td>
<td style="text-align:center">年</td>
<td style="text-align:center">1个字节</td>
<td style="text-align:center">YYYY</td>
</tr>
<tr>
<td style="text-align:center">TIME</td>
<td style="text-align:center">时间</td>
<td style="text-align:center">3个字节</td>
<td style="text-align:center">HH:MM:SS</td>
</tr>
<tr>
<td style="text-align:center">DATE</td>
<td style="text-align:center">日期</td>
<td style="text-align:center">3个字节</td>
<td style="text-align:center">YYYY–MM-DD</td>
</tr>
<tr>
<td style="text-align:center">TIMESTEAMP</td>
<td style="text-align:center">日期时间</td>
<td style="text-align:center">4个字节</td>
<td style="text-align:center">YYYY–MM-DD HH:MM:SS</td>
</tr>
<tr>
<td style="text-align:center">DATETIME</td>
<td style="text-align:center">日期时间</td>
<td style="text-align:center">8个字节</td>
<td style="text-align:center">YYYY–MM-DD HH:MM:SS</td>
</tr>
</tbody>
</table>
<blockquote>
<p>若定义一个字段为timestamp，这个字段里的时间数据会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间</p>
<p>每种日期和时间类型都有一个有效值范围，如果超出这个有效值范围，则会以0进行存储</p>
</blockquote>
<h3 id="空间类型"><a class="markdownIt-Anchor" href="#空间类型"></a> 空间类型</h3>
<p>Geometry：存储任意几何体类型 Point：存储二维中的点类型 LineString：存储点之间的线型插值曲线类型<br />
MultiPoint：存储点的集合类型 MultiLineString：存储点之间的线型插值曲线集合类型<br />
MultiPolyGon：存储多边形集合类型 Polygon：存储多边形类型 GeometryCollection：存储任意类型集合体的集合类型</p>
<h3 id="数据类型的属性"><a class="markdownIt-Anchor" href="#数据类型的属性"></a> 数据类型的属性</h3>
<h4 id="mysql关键字-含义"><a class="markdownIt-Anchor" href="#mysql关键字-含义"></a> MySQL关键字 含义</h4>
<p>NULL 数据列可包含NULL值 NOT NULL 数据列不允许包含NULL值 DEFAULT 默认值 PRIMARY KEY 主键<br />
AUTO_INCREMENT 自动递增，适用于整数类型 UNSIGNED 无符号 CHARACTER<br />
SET name 指定一个字符集</p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>DBMS</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的SQL使用之下</title>
    <url>/23341.html</url>
    <content><![CDATA[<h2 id="mysql用户管理"><a class="markdownIt-Anchor" href="#mysql用户管理"></a> mysql用户管理</h2>
<blockquote>
<p>DCL（Data Control Language，数据控制语言）：用于定义数据库的访问权限和安全级别，主要包含GRANT、REVOKE、COMMIT和ROLLBACK等语句。</p>
</blockquote>
<p><strong>mysql用户管理主要涉及到用户的增删改查与权限管理</strong></p>
<p>mysql中存在4个控制权限的表，分别为user表，db表，tables_priv表，columns_priv表</p>
<p><strong>权限表的验证过程</strong></p>
<ol>
<li>先从user表中的Host,User,Password这3个字段中判断连接的ip、用户名、密码是否存在，存在则通过验证。</li>
<li></li>
</ol>
<p>通过身份认证后，进行权限分配，按照user，db，tables_priv，columns_priv的顺序进行验证。即先检查全局权限表user，如果user中对应的权限为Y，则此用户对所有数据库的权限都为Y，将不再检查db,<br />
tables_priv,columns_priv；如果为N，则到db表中检查此用户对应的具体数据库，并得到db中为Y的权限；如果db中为N，则检查tables_priv中此数据库对应的具体表，取得表中的权限Y，以此类推。</p>
<p><strong>MySQL 权限级别</strong><br />
全局性的管理权限： 作用于整个MySQL实例级别 数据库级别的权限： 作用于某个指定的数据库上或者所有的数据库上<br />
数据库对象级别的权限：作用于指定的数据库对象上（表、视图等）或者所有的数据库对象上</p>
<h3 id="用户操作"><a class="markdownIt-Anchor" href="#用户操作"></a> 用户操作</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建用户</span><br><span class="line">create user user_name@&#x27;host&#x27; identified by &#x27;password&#x27;;</span><br><span class="line"># example: </span><br><span class="line"># create user acs@&#x27;10.0.0.%&#x27; identified by &#x27;123123&#x27;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除用户</span><br><span class="line">drop user user_name@&#x27;host&#x27;;</span><br><span class="line"># example:</span><br><span class="line"># drop user acs@&#x27;10.0.0.%&#x27;</span><br><span class="line"># DELETE FROM `user` WHERE `user`.`Host` = &#x27;10.0.0.%&#x27; AND `user`.`User` = &#x27;acs&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改用户</span><br><span class="line">alter user user_name@&#x27;host&#x27; identified by &#x27;password&#x27;;</span><br><span class="line"># example</span><br><span class="line">## 修改密码</span><br><span class="line">alter user acs@&#x27;10.0.0.%&#x27; identified by &#x27;321312312123&#x27;;</span><br><span class="line">## 修改 host</span><br><span class="line">UPDATE `user`</span><br><span class="line">SET `Host` = &#x27;%&#x27;</span><br><span class="line">WHERE `user`.`Host` = &#x27;10.0.0.%&#x27;</span><br><span class="line">  AND `user`.`User` = &#x27;acs&#x27;</span><br><span class="line">## 修改权限</span><br><span class="line">UPDATE `user`</span><br><span class="line">SET `Select_priv` = &#x27;Y&#x27;</span><br><span class="line">WHERE `user`.`Host` = &#x27;%&#x27;</span><br><span class="line">  AND `user`.`User` = &#x27;acs&#x27;</span><br><span class="line">UPDATE `user`</span><br><span class="line">SET `Select_priv` = &#x27;Y&#x27;,</span><br><span class="line">    `Delete_priv` = &#x27;Y&#x27;</span><br><span class="line">WHERE `user`.`Host` = &#x27;%&#x27;</span><br><span class="line">  AND `user`.`User` = &#x27;acs&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除用户</span><br><span class="line">drop user user_name@&#x27;host&#x27;;</span><br><span class="line"># example</span><br><span class="line">drop user acs@&#x27;%&#x27;</span><br><span class="line">DELETE</span><br><span class="line">FROM `user`</span><br><span class="line">WHERE `user`.`Host` = &#x27;10.0.0.%&#x27;</span><br><span class="line">  AND `user`.`User` = &#x27;acs&#x27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>user_name：用户名</p>
<p>host ：可允许连接ip(Localhost代表本机， 127.0.0.1代表ipv4本机地址， ::1代表ipv6的本机地址,)</p>
<p>password：用户密码</p>
</blockquote>
<h2 id="权限管理"><a class="markdownIt-Anchor" href="#权限管理"></a> 权限管理</h2>
<p>权限可细分为操作权限与操作范围</p>
<p>常用权限介绍</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ALL: SELECT,INSERT, UPDATE, DELETE, CREATE, DROP, RELOAD, SHUTDOWN, PROCESS, FILE, REFERENCES, INDEX, ALTER, SHOW DATABASES, SUPER, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, REPLICATION SLAVE, REPLICATION CLIENT, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, CREATE USER, EVENT, TRIGGER, CREATE TABLESPACE</span><br><span class="line">ALL : 所有权限，一般是普通管理员拥有的</span><br><span class="line"><span class="keyword">with</span> grant option：给别的用户授权的功能</span><br></pre></td></tr></table></figure>
<p>权限作用范围</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">*.*               ----&gt;所有：管理员用户</span><br><span class="line">dbname.*          ----&gt;指定库下所有：开发和应用用户</span><br><span class="line">dbname.t1   ----&gt;指定表</span><br></pre></td></tr></table></figure>
<p><strong>开发人员用户授权流程</strong></p>
<ol>
<li>你从哪来</li>
<li>对谁操作</li>
<li>权限</li>
<li>密码要求</li>
</ol>
<h3 id="权限"><a class="markdownIt-Anchor" href="#权限"></a> 权限</h3>
<p>可以使用GRANT给用户添加权限，权限会自动叠加，不会覆盖之前授予的权限，比如你先给用户添加一个SELECT权限，后来又给用户添加了一个INSERT权限，那么该用户就同时拥有了SELECT和INSERT权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看MYSQL有哪些用户</span><br><span class="line">select user, host</span><br><span class="line">from mysql.user;</span><br><span class="line"># 查看权限</span><br><span class="line">show grants for user_name@&#x27;host&#x27;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 授权</span><br><span class="line">grant 权限 on 权限范围 to 用户 identified by 密码 with grant option;</span><br></pre></td></tr></table></figure>
<p>**all privileges：**表示将所有权限授予给用户。也可指定具体的权限，如：SELECT、CREATE、DROP等。<br />
**on：*<em>表示这些权限对哪些数据库和表生效，格式：数据库名.表名，这里写“</em><br />
”表示所有数据库，所有表。如果我要指定将权限应用到test库的user表中，可以这么写：test.user<br />
<strong>to：</strong><br />
将权限授予哪个用户。格式：”用户名”@”登录IP或域名”。%表示没有限制，在任何主机都可以登录。比如：”payne”@”192.168.0%”，表示yangxin这个用户只能在192.168.0IP段登录<br />
**•identified by：**指定用户的登录密码<br />
**•with grant option：**表示允许用户将自己的权限授权给其它用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 收回权限</span><br><span class="line">revoke delete on 权限范围 from 用户@‘host’</span><br><span class="line">revoke delete on app.* from app@&#x27;10.0.0.%&#x27;；</span><br></pre></td></tr></table></figure>
<h3 id="如何授权"><a class="markdownIt-Anchor" href="#如何授权"></a> 如何授权</h3>
<p>用户的权限一定是与业务分离不开的，但通常普通用户会</p>
<ul>
<li>禁用删除权限</li>
<li>规定范围</li>
</ul>
<h2 id="如何做好用户管理"><a class="markdownIt-Anchor" href="#如何做好用户管理"></a> 如何做好用户管理</h2>
<ul>
<li>密码系数足够高</li>
<li>root禁用远程登录</li>
<li>分级别，类似于公司管理。</li>
</ul>
<h2 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8.0在grant命令添加新特性</span><br><span class="line">建用户和授权分开了</span><br><span class="line">grant 不再支持自动创建用户了，不支持改密码</span><br><span class="line">授权之前，必须要提前创建用户。</span><br></pre></td></tr></table></figure>
<ul>
<li>执行Grant,revoke,set password,rename user命令修改权限之后， MySQL会自动将修改后的权限信息同步加载到系统内存中</li>
<li></li>
</ul>
<p>如果执行insert/update/delete操作上述的系统权限表之后，则必须再执行刷新权限命令才能同步到系统内存中，刷新权限命令包括： <code>flush privileges</code><br />
/mysqladmin flush-privileges /<br />
mysqladmin reload</p>
<ul>
<li>如果是修改tables和columns级别的权限，则客户端的下次操作新权限就会生效</li>
<li>如果是修改database级别的权限，则新权限在客户端执行use database命令后生效</li>
<li>如果是修改global级别的权限，则需要重新创建连接新权限才能生效</li>
<li>如果是修改global级别的权限，则需要重新创建连接新权限才能生效 (例如修改密码)</li>
</ul>
<p>mysql user表</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>名字</strong></th>
<th style="text-align:left"><strong>类型</strong></th>
<th style="text-align:left">Null</th>
<th style="text-align:left">主键</th>
<th style="text-align:left">默认</th>
<th style="text-align:left"></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Host</td>
<td style="text-align:left">char(255)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left">PRI</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">User</td>
<td style="text-align:left">char(32)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left">PRI</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Select_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Insert_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Update_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Delete_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Create_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Drop_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Reload_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Shutdown_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Process_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">File_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Grant_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">References_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Index_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Alter_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Show_db_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Super_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Create_tmp_table_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Lock_tables_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Execute_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Repl_slave_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Repl_client_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Create_view_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Show_view_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Create_routine_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Alter_routine_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Create_user_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Event_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Trigger_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Create_tablespace_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">ssl_type</td>
<td style="text-align:left">enum(‘’,‘ANY’,‘X509’,‘SPECIFIED’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">ssl_cipher</td>
<td style="text-align:left">blob</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left"><em>NULL</em></td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">x509_issuer</td>
<td style="text-align:left">blob</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left"><em>NULL</em></td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">x509_subject</td>
<td style="text-align:left">blob</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left"><em>NULL</em></td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">max_questions</td>
<td style="text-align:left">int unsigned</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">0</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">max_updates</td>
<td style="text-align:left">int unsigned</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">0</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">max_connections</td>
<td style="text-align:left">int unsigned</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">0</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">max_user_connections</td>
<td style="text-align:left">int unsigned</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">0</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">plugin</td>
<td style="text-align:left">char(64)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">caching_sha2_password</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">authentication_string</td>
<td style="text-align:left">text</td>
<td style="text-align:left">YES</td>
<td style="text-align:left"></td>
<td style="text-align:left"><em>NULL</em></td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">password_expired</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">password_last_changed</td>
<td style="text-align:left">timestamp</td>
<td style="text-align:left">YES</td>
<td style="text-align:left"></td>
<td style="text-align:left"><em>NULL</em></td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">password_lifetime</td>
<td style="text-align:left">smallint unsigned</td>
<td style="text-align:left">YES</td>
<td style="text-align:left"></td>
<td style="text-align:left"><em>NULL</em></td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">account_locked</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Create_role_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Drop_role_priv</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">NO</td>
<td style="text-align:left"></td>
<td style="text-align:left">N</td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Password_reuse_history</td>
<td style="text-align:left">smallint unsigned</td>
<td style="text-align:left">YES</td>
<td style="text-align:left"></td>
<td style="text-align:left"><em>NULL</em></td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Password_reuse_time</td>
<td style="text-align:left">smallint unsigned</td>
<td style="text-align:left">YES</td>
<td style="text-align:left"></td>
<td style="text-align:left"><em>NULL</em></td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Password_require_current</td>
<td style="text-align:left">enum(‘N’,‘Y’)</td>
<td style="text-align:left">YES</td>
<td style="text-align:left"></td>
<td style="text-align:left"><em>NULL</em></td>
<td style="text-align:left"></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">User_attributes</td>
<td style="text-align:left">json</td>
<td style="text-align:left">YES</td>
<td style="text-align:left"></td>
<td style="text-align:left"><em>NULL</em></td>
<td style="text-align:left"></td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>DBMS</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的SQL使用之中</title>
    <url>/33196.html</url>
    <content><![CDATA[<h2 id="dml的使用"><a class="markdownIt-Anchor" href="#dml的使用"></a> DML的使用</h2>
<p>对表中的数据行进行增、删、改</p>
<h3 id="增"><a class="markdownIt-Anchor" href="#增"></a> 增</h3>
<blockquote>
<p>向数据表内插入数据</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># INSERT语法</span><br><span class="line">INSERT [INTO] table_name [(field_name_1, field_name_2...)]</span><br><span class="line">VALUES (value1, value2...),[(value1, value2...)...]</span><br><span class="line"># 常见示例</span><br><span class="line">## 插入</span><br><span class="line">INSERT INTO ch_people_msg(`p_uic`, `p_nickname`, `p_gender`, `p_age`, `p_pnum`, `p_address`, `p_email`)</span><br><span class="line">VALUES (&quot;431122200008868162&quot;, &quot;payne&quot;, &quot;m&quot;, 22, 17672655132, &quot;湖南省xx市xx区雨花a世界&quot;, &quot;127xxxx261&quot;),</span><br><span class="line">       (&quot;431122200002148162&quot;, &quot;tom&quot;, &quot;m&quot;, 25, 17672655132, &quot;湖南省xx市xx区雨花a世界&quot;, &quot;127xxxx221&quot;),</span><br><span class="line">       (&quot;431122200002168163&quot;, &quot;tom&quot;, &quot;m&quot;, 25, 17672655132, &quot;湖南省xx市xx区雨花a世界&quot;, &quot;127xxxx221&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `ch_people_msg` ( </span><br><span class="line">  `p_id`  SERIAL NOT NULL AUTO_INCREMENT COMMENT &#x27;用户id&#x27; , </span><br><span class="line">  `p_uic` CHAR(18) NOT NULL COMMENT &#x27;用户身份证&#x27;,</span><br><span class="line">  `p_nickname` VARCHAR(50) NOT NULL COMMENT &#x27;用户昵称&#x27;, </span><br><span class="line">  `p_gender` ENUM(&#x27;m&#x27;,&#x27;f&#x27;, &#x27;n&#x27;) NOT NULL DEFAULT &#x27;n&#x27; COMMENT &#x27;用户性别&#x27;, </span><br><span class="line">  `p_age` TINYINT UNSIGNED NOT NULL DEFAULT 0 COMMENT &#x27;用户年龄&#x27;, </span><br><span class="line">  `p_pnum` CHAR(11) NOT NULL COMMENT &#x27;用户电话&#x27;, </span><br><span class="line">  `p_address` VARCHAR(100) NOT NULL COMMENT &#x27;用户地址&#x27;, </span><br><span class="line">  `p_email` VARCHAR(50) NOT NULL COMMENT &#x27;用户邮箱&#x27;, </span><br><span class="line">  `p_add_time` TIMESTAMP NOT NULL DEFAULT NOW() COMMENT &#x27;统计用户时间&#x27;,</span><br><span class="line">   PRIMARY KEY (`p_id`),</span><br><span class="line">   UNIQUE KEY `p_uic`(`p_uic`)</span><br><span class="line">) ENGINE = InnoDB CHARSET=utf8mb4 COLLATE utf8mb4_general_ci COMMENT = &#x27;中国成员信息表&#x27;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="删"><a class="markdownIt-Anchor" href="#删"></a> 删</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM table_name</span><br><span class="line">truncate table table_name;</span><br><span class="line">DROP table table_name</span><br><span class="line"></span><br><span class="line">delete: DML操作, 是逻辑性质删除,逐行进行删除,速度慢.</span><br><span class="line">truncate: DDL操作,对与表段中的数据页进行清空,速度快.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，</p>
<p>DELETE操作不会减少表或索引所占用的空间。</p>
<p>drop语句将表所占用的空间全释放掉。</p>
<p>释放空间与速度：drop &gt; truncate &gt; delete</p>
</blockquote>
<p><strong>delete</strong></p>
<ul>
<li></li>
</ul>
<p>delete是DML，执行delete操作时，每次从表中删除一行，并且同时将该行的的删除操作记录在redo和undo表空间中以便进行回滚（rollback）和重做操作，但要注意表空间要足够大，需要手动提交（commit）操作才能生效，可以通过rollback撤消操作。</p>
<ul>
<li>
<p>delete可根据条件删除表中满足条件的数据，如果不指定where子句，那么删除表中所有记录。</p>
</li>
<li>
<p>delete语句不影响表所占用的extent，高水线(high watermark)保持原位置不变。</p>
</li>
</ul>
<p><strong>truncate</strong></p>
<ul>
<li>
<p>truncate是DDL，会隐式提交，所以，不能回滚，不会触发触发器。</p>
</li>
<li>
<p>truncate会删除表中所有记录，并且将重新设置高水线和所有的索引，缺省情况下将空间释放到minextents个extent，除非使用reuse<br />
storage，。不会记录日志，所以执行速度很快，但不能通过rollback撤消操作（如果一不小心把一个表truncate掉，也是可以恢复的，只是不能通过rollback来恢复）。</p>
</li>
<li>
<p>对于外键（foreignkey ）约束引用的表，不能使用 truncate table，而应使用不带 where 子句的 delete 语句。</p>
</li>
<li>
<p>truncatetable不能用于参与了索引视图的表。</p>
</li>
</ul>
<p><strong>drop</strong></p>
<ul>
<li>
<p>drop是DDL，会隐式提交，所以，不能回滚，不会触发触发器。</p>
</li>
<li>
<p>drop语句删除表结构及所有数据，并将表所占用的空间全部释放。</p>
</li>
<li>
<p>drop语句将删除表的结构所依赖的约束，触发器，索引，依赖于该表的存储过程/函数将保留,但是变为invalid状态。</p>
</li>
</ul>
<blockquote>
<ul>
<li>
<p>如果想删除表，当然用drop；</p>
</li>
<li>
<p>如果想保留表而将所有数据删除，如果和事务无关，用truncate即可；</p>
</li>
<li>
<p>如果和事务有关，或者想触发trigger，还是用delete；</p>
</li>
<li>
<p>如果是整理表内部的碎片，可以用truncate跟上reuse stroage，再重新导入/插入数据。</p>
</li>
</ul>
</blockquote>
<p>伪删除：用update来替代delete，最终保证业务中查不到（select）即可</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>添加状态列</span><br><span class="line"><span class="keyword">ALTER TABLE</span> ch_people_msg</span><br><span class="line">    <span class="keyword">ADD</span> state TINYINT <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> ch_people_msg;</span><br><span class="line"><span class="number">2.</span></span><br><span class="line"><span class="keyword">UPDATE</span> 替代</span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">UPDATE</span> ch_people_msg</span><br><span class="line"><span class="keyword">SET</span> state<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="number">3.</span> 业务语句查询</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> ch_people_msg</span><br><span class="line"><span class="keyword">WHERE</span> state <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="改"><a class="markdownIt-Anchor" href="#改"></a> 改</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE ch_people_msg SET p_nickname=&#x27;zero&#x27; WHERE id=2;</span><br></pre></td></tr></table></figure>
<h3 id="查"><a class="markdownIt-Anchor" href="#查"></a> 查</h3>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"># 基本语法</span><br><span class="line">select--from--[where]--[group by]--[having]--[order by]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>FROM：对FROM子句中的前两个表执行笛卡尔积（Cartesian product)(交叉联接），生成虚拟表VT1<br />
ON：对VT1应用ON筛选器。只有那些使&lt;join_condition&gt;为真的行才被插入VT2<br />
OUTER(JOIN)：如果指定了OUTER JOIN（相对于CROSS JOIN 或(INNER JOIN),保留表（preserved<br />
table：左外部联接把左表标记为保留表，右外部联接把右表标记为保留表，完全外部联接把两个表都标记为保留表）中未找到匹配的行将作为外部行添加到<br />
VT2,生成VT3.如果FROM子句包含两个以上的表，则对上一个联接生成的结果表和下一个表重复执行步骤1到步骤3，直到处理完所有的表为止。<br />
WHERE：对VT3应用WHERE筛选器。只有使&lt;where_condition&gt;为true的行才被插入VT4.<br />
GROUP BY：按GROUP BY子句中的列列表对VT4中的行分组，生成VT5.<br />
CUBE|ROLLUP：把超组(Suppergroups)插入VT5,生成VT6.<br />
HAVING：对VT6应用HAVING筛选器。只有使&lt;having_condition&gt;为true的组才会被插入VT7.<br />
SELECT：处理SELECT列表，产生VT8.<br />
DISTINCT：将重复的行从VT8中移除，产生VT9.<br />
ORDER BY：将VT9中的行按ORDER BY 子句中的列列表排序，生成游标（VC10).<br />
TOP：从VC10的开始处选择指定数量或比例的行，生成表VT11,并返回调用者。</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"># 单表子句-from</span><br><span class="line">SELECT 列<span class="number">1</span>,列<span class="number">2</span> FROM 表</span><br><span class="line">SELECT  *  FROM 表</span><br></pre></td></tr></table></figure>
<h4 id="where"><a class="markdownIt-Anchor" href="#where"></a> where</h4>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"># 等值查询</span><br><span class="line"> SELECT  *  FROM 表 where 列 = 值</span><br><span class="line"> SELECT 列<span class="number">1</span>,列<span class="number">2</span> FROM 表 where 列 = 值</span><br><span class="line">  </span><br><span class="line"># 比较运算符</span><br><span class="line">&gt;、&lt;、&gt;=、&lt;=、!=、=</span><br><span class="line"> SELECT * FROM 表 where 列 &gt;= 值</span><br><span class="line"> SELECT 列,... FROM 表 where 列 &lt;= 值</span><br><span class="line">  </span><br><span class="line"># 模糊查询</span><br><span class="line"> %代表任何个数的任何字符 _:它代表一个任何字符</span><br><span class="line"> 注意：%不能放在前面,因为不走索引,要找%或_,转义就行了\%和\_</span><br><span class="line">  </span><br><span class="line"># or、and</span><br><span class="line">   SELECT * FROM 表 where 列 &gt;= 值 or 列 &lt; 值</span><br><span class="line">  </span><br><span class="line"># where配合<span class="keyword">in</span>语句</span><br><span class="line">  SELECT * FROM 表 WHERE 列 IN (VALUES, VALUES);</span><br><span class="line"></span><br><span class="line"># where配合between and</span><br><span class="line">  SELECT * FROM city  WHERE population &gt;<span class="number">1000000</span> AND population &lt;<span class="number">2000000</span>;</span><br><span class="line"> SELECT * FROM city  WHERE population BETWEEN <span class="number">1000000</span> AND <span class="number">2000000</span>;</span><br></pre></td></tr></table></figure>
<h4 id="group-by"><a class="markdownIt-Anchor" href="#group-by"></a> group by</h4>
<p>根据 by后面的条件进行<strong>分组</strong>，方便统计，by后面跟一个列或多个列</p>
<blockquote>
<p><strong>max()</strong>                ：最大值<br />
<strong>min()</strong>                   ：最小值<br />
<strong>avg()</strong>                   ：平均值<br />
<strong>sum()</strong>                  ：总和<br />
<strong>count()</strong>                ：个数<br />
<strong>group_concat()</strong> : 列转行</p>
</blockquote>
<p><strong>having</strong></p>
<p>​ having语句是分组后过滤的条件，在group by之后使用，也就是如果要用having语句，必须要先有group by语句。</p>
<h4 id="order-by"><a class="markdownIt-Anchor" href="#order-by"></a> order by</h4>
<p>实现先排序，by后添加条件列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># distinct：去重复查询</span><br><span class="line">SELECT 列 FROM ;</span><br><span class="line">SELECT DISTINCT(列) FROM city  ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 联合查询- union all</span><br><span class="line">  SELECT * FROM city </span><br><span class="line">WHERE countrycode IN (&#x27;CHN&#x27; ,&#x27;USA&#x27;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM city WHERE countrycode=&#x27;CHN&#x27;</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT * FROM city WHERE countrycode=&#x27;USA&#x27;</span><br><span class="line"></span><br><span class="line">说明:一般情况下,我们会将 IN 或者 OR 语句 改写成 UNION ALL,来提高性能</span><br><span class="line">UNION     去重复</span><br><span class="line">UNION ALL 不去重复</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>DBMS</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的安装与配置</title>
    <url>/21899.html</url>
    <content><![CDATA[<h2 id="linux平台下mysql的安装"><a class="markdownIt-Anchor" href="#linux平台下mysql的安装"></a> Linux平台下MySQL的安装</h2>
<p>LSB Version:    :core-4.1-amd64:core-4.1-noarch</p>
<p>Distributor ID:    CentOS</p>
<p>Description:    CentOS Linux release 7.9.2009 (Core)</p>
<p>Release:    7.9.2009</p>
<p>Codename:    Core</p>
<p>ldd (GNU libc) :2.17</p>
<h3 id="前置工作"><a class="markdownIt-Anchor" href="#前置工作"></a> 前置工作</h3>
<h4 id="删除mariadb"><a class="markdownIt-Anchor" href="#删除mariadb"></a> 删除mariadb</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum remove -y mariadb-libs.x86_64</span><br></pre></td></tr></table></figure>
<h3 id="yum"><a class="markdownIt-Anchor" href="#yum"></a> yum</h3>
<h4 id="安装rpm"><a class="markdownIt-Anchor" href="#安装rpm"></a> 安装rpm</h4>
<p>进入MySQL的<span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2Rvd25sb2Fkcy9yZXBvL3l1bS8=">yum仓库<i class="fa fa-external-link-alt"></i></span>，如下图所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gu50sz34orj616r0u079a02.jpg" alt="image-20210904233814767" /></p>
<p>官方rpm包:    <span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2dldC9teXNxbDgwLWNvbW11bml0eS1yZWxlYXNlLWVsNy0zLm5vYXJjaC5ycG0=">https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm<i class="fa fa-external-link-alt"></i></span></p>
<p>清华镜像rpm包:    <span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL215c3FsL3l1bS9teXNxbDgwLWNvbW11bml0eS1lbDcvbXlzcWw4MC1jb21tdW5pdHktcmVsZWFzZS1lbDctMy5ub2FyY2gucnBt">https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql80-community-el7/mysql80-community-release-el7-3.noarch.rpm<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -c rpm地址</span><br></pre></td></tr></table></figure>
<h4 id="安装yum仓库文件"><a class="markdownIt-Anchor" href="#安装yum仓库文件"></a> 安装yum仓库文件</h4>
<blockquote>
<p>可使用rpm -ivh或是yum localinstall 去安装，两者实质是一样的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql80-community-release-el7-3.noarch.rpm</span><br></pre></td></tr></table></figure>
<h4 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y  mysql-community-server</span><br></pre></td></tr></table></figure>
<h3 id="二进制"><a class="markdownIt-Anchor" href="#二进制"></a> 二进制</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb3dubG9hZHMubXlzcWwuY29tL2FyY2hpdmVzL2NvbW11bml0eS8=">https://downloads.mysql.com/archives/community/<i class="fa fa-external-link-alt"></i></span></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gu5lm5v8toj61aq06wdik02.jpg" alt="image-20210905113818649" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下</span></span><br><span class="line">wget -c https://downloads.mysql.com/archives/get/p/23/file/mysql-8.0.20-linux-glibc2.12-x86_64.tar.xz</span><br><span class="line">tar zf mysql-8.0.20-linux-glibc2.12-x86_64.tar.xz</span><br></pre></td></tr></table></figure>
<h4 id="建立用户与授权"><a class="markdownIt-Anchor" href="#建立用户与授权"></a> 建立用户与授权</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useradd mysql &amp;&amp; usermod -s /sbin/nologin mysql</span><br><span class="line">mkdir -p /opt/databases/mysql &amp;&amp; chown -R mysql. /opt/databases/mysql</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim /etc/my.cnf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For advice on how to change settings please see</span></span><br><span class="line"><span class="comment"># http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html</span></span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># Remove leading # and set to the amount of RAM for the most important data</span></span><br><span class="line"><span class="comment"># cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_size = 128M</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Remove leading # to turn on a very important data integrity option: logging</span></span><br><span class="line"><span class="comment"># changes to the binary log between backups.</span></span><br><span class="line"><span class="comment"># log_bin</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Remove leading # to set options mainly useful for reporting servers.</span></span><br><span class="line"><span class="comment"># The server defaults are faster for transactions and fast SELECTs.</span></span><br><span class="line"><span class="comment"># Adjust sizes as needed, experiment to find the optimal values.</span></span><br><span class="line"><span class="comment"># join_buffer_size = 128M</span></span><br><span class="line"><span class="comment"># sort_buffer_size = 2M</span></span><br><span class="line"><span class="comment"># read_rnd_buffer_size = 2M</span></span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disabling symbolic-links is recommended to prevent assorted security risks</span></span><br><span class="line">symbolic-links=0</span><br><span class="line">log-error=/var/log/mysqld.log</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line"></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">character-set-server = utf8mb4</span><br><span class="line">collation-server = utf8mb4_general_ci</span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line">secure_file_priv=<span class="string">&#x27;&#x27;</span></span><br><span class="line">user = mysql</span><br><span class="line">port=8916</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8mb4</span><br></pre></td></tr></table></figure>
<h3 id="获取初始root密码"><a class="markdownIt-Anchor" href="#获取初始root密码"></a> 获取初始root密码</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br></pre></td></tr></table></figure>
<h3 id="创建用户与授权"><a class="markdownIt-Anchor" href="#创建用户与授权"></a> 创建用户与授权</h3>
<p>根据业务、公司情况创建管理员，若公司成员较少，管理员管全局。反之管单库</p>
<blockquote>
<ol>
<li>root不允许远程连接</li>
<li>修改root密码</li>
</ol>
</blockquote>
<h3 id="远程连接"><a class="markdownIt-Anchor" href="#远程连接"></a> 远程连接</h3>
<p>授权</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">远程登录还需要授权远程登录Mysql默认不允许远程登录，我们需要设置关闭selinux或者防火墙，不关防火墙就开放3306端口；</span><br><span class="line"><span class="comment">#放开3306端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>DBMS</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引</title>
    <url>/33592.html</url>
    <content><![CDATA[<h2 id="索引是什么"><a class="markdownIt-Anchor" href="#索引是什么"></a> 索引是什么</h2>
<p>索引（在MySQL中也叫<strong>键（key）</strong><br />
）是存储引擎用于快速查找记录的一种数据结构。索引对于性能拥有至关重要的地位。尤其是当表中的数据量越来越大，索引对于性能的影响愈发重要。反之不恰当的索引对于性能也会急剧下降。</p>
<p><strong>索引是一把双刃剑</strong></p>
<h2 id="索引的优与劣"><a class="markdownIt-Anchor" href="#索引的优与劣"></a> 索引的优与劣</h2>
<h3 id="索引的优点"><a class="markdownIt-Anchor" href="#索引的优点"></a> 索引的优点</h3>
<p>索引提高数据检索的效率</p>
<ul>
<li>
<p>降低数据库的<code>I/O</code> 成本（将随机IO变为顺序<code>I/O</code> ）</p>
</li>
<li>
<p>减少扫描行数</p>
</li>
</ul>
<p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p>
<h3 id="索引的缺点"><a class="markdownIt-Anchor" href="#索引的缺点"></a> 索引的缺点</h3>
<h4 id="时间方面"><a class="markdownIt-Anchor" href="#时间方面"></a> 时间方面</h4>
<p>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</p>
<h4 id="空间方面"><a class="markdownIt-Anchor" href="#空间方面"></a> 空间方面</h4>
<p>索引需要占物理空间，如果要建立聚簇索引，那么需要的空间就会更大</p>
<p>当对表中的数据进行增加、删除、修改的时索引也要动态的维护，这样就降低了数据的维护速度。</p>
<h4 id="应用方面"><a class="markdownIt-Anchor" href="#应用方面"></a> 应用方面</h4>
<p>锁竞争</p>
<h2 id="索引的类型"><a class="markdownIt-Anchor" href="#索引的类型"></a> 索引的类型</h2>
<p>索引有很多种类，可以为不同场景提供更好的性能。索引在存储引擎层实现的，故并没有<strong>统一的</strong>索引标准</p>
<blockquote>
<p>不同的存储引擎的索引工作方式也不尽相同</p>
</blockquote>
<h3 id="索引分类"><a class="markdownIt-Anchor" href="#索引分类"></a> 索引分类</h3>
<p>按照不同的维度可以区分索引类型</p>
<p>按照物理村粗可以划分为：聚簇索引与二级索引（辅助索引）</p>
<p>按照数据结构可以划分为： B+ Tree、Hash、Full-Text、Geographic Information System等</p>
<p>按照字段个数可以划分为：单列索引和联合索引</p>
<p>按照字段特效可以划分为：主键索引、唯一索引、普通索引、前缀索引</p>
<h4 id="物理顺序与键值的索引逻辑顺序关系"><a class="markdownIt-Anchor" href="#物理顺序与键值的索引逻辑顺序关系"></a> 物理顺序与键值的索引逻辑顺序关系</h4>
<p>聚集索引：数据行的物理顺序与列值（一般为主键的那一列）的逻辑顺序相同，一个表中只能拥有<strong>一个聚集索引</strong>。</p>
<p>非聚集索引(辅助索引)：逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有<strong>多个非聚集索引</strong>。</p>
<p><strong>聚簇索引与非聚簇索引异同</strong></p>
<p>在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引，即将数据存储与索引放到了一块，找到索引也就找到了数据。</p>
<p>而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引、二级索引。</p>
<p>聚簇索引与非聚簇索引的区别：</p>
<ul>
<li>非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键（行号）</li>
<li>对于InnoDB来说，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为<br />
<strong>回表</strong><br />
。第一次索引一般是顺序IO，回表的操作属于随机IO。需要回表的次数越多，即随机IO次数越多，我们就越倾向于使用全表扫描 。</li>
<li>通常情况下， 主键索引（聚簇索引）查询只会查一次，而非主键索引（非聚簇索引）需要回表查询多次。当然，如果是覆盖索引的话，查一次即可</li>
</ul>
<p><strong>注意：</strong></p>
<p>MyISAM无论主键索引还是二级索引都是非聚簇索引</p>
<p>InnoDB的主键索引是聚簇索引，二级索引是非聚簇索引。</p>
<h3 id="存储结构"><a class="markdownIt-Anchor" href="#存储结构"></a> 存储结构</h3>
<blockquote>
<p>这里所描述的是索引存储时保存的形式</p>
</blockquote>
<ul>
<li>
<p>B<br />
Tree索引（B-Tree或B+Tree索引）BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是**<br />
MySQL里默认和最常用的索引类型。**</p>
</li>
<li>
<p>Hash索引，HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高</p>
</li>
<li>
<p>full index 全文索引，其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过只有 CHAR、VARCHAR<br />
，TEXT 列上可以创建全文索引</p>
</li>
<li>
<p>R-Tree索引。RTREE在MySQL很少使用，<strong>仅支持geometry数据类型</strong>，相对于BTREE，RTREE的优势在于范围查找。</p>
</li>
</ul>
<h4 id="b-tree-索引"><a class="markdownIt-Anchor" href="#b-tree-索引"></a> B + Tree 索引</h4>
<p>通常意味着所有的值都是顺序存储的，并且每个叶子页到根的距离相同</p>
<p><strong>适用范围</strong></p>
<p>全键值、键值范围、前缀查找</p>
<p><strong>应用场景</strong></p>
<p>全值匹配、匹配最左前缀、匹配列前缀、匹配范围值、精确匹配某一列并范围匹配另一列、值访问索引的查询</p>
<p><strong>限制</strong></p>
<ul>
<li>必须为最左开始（最左前缀原则），否则不使用索引</li>
<li>无法跳跃查询索引中的列</li>
<li>范围查询影响，右边的无法使用索引</li>
</ul>
<h4 id="hash-索引"><a class="markdownIt-Anchor" href="#hash-索引"></a> Hash 索引</h4>
<p>基于Hash表实现，只有<strong>精确匹配</strong>索引<strong>所有列</strong>的查询<strong>才有效</strong></p>
<p>对于每一行数据存储引擎都会对所有的索引计算一个hash code。hash code 较小的值，并且不同键值的行计算出来的hash<br />
code页不一样。hash索引将所有的hash code存储在索引中，同时在hash<br />
table中保存指向每个数据的指针</p>
<p><strong>hash索引查询步骤</strong></p>
<ol>
<li>先计算数据的hashcode，并使用该值查找对应的记录指针</li>
<li>查找在hash table中的指向</li>
<li>值比较确认</li>
</ol>
<p><strong>特点</strong></p>
<p>因为索引自身只需要存储对应的hash code，所有索引结构<strong>非常紧凑</strong>，这也让hash索引查找速度非常快</p>
<p><strong>限制</strong></p>
<ul>
<li>
<p>hash index 只包含hash值和行指针，而不存储字段值，所以不能使用hash<br />
index来避免读取行。同时访问内存中的数据速度非常快，所以对于大部分情况下这一点对于性能影响并不明显</p>
</li>
<li>
<p>hash index数据并不是按照索引顺序存储的，所以无法用于排序</p>
</li>
<li>
<p>hash index 也不支持部分索引列匹配查找</p>
</li>
<li>
<p>hash index 只支持<strong>等值比较</strong>查询，包括=、IN、&lt;=、=&gt;。也不支持任何范围查询</p>
</li>
<li>
<p>hash index访问数据非常快，除非有很多hash冲突。同时hash冲突很多，索引维护代价较高昂</p>
</li>
</ul>
<h4 id="r-tree索引"><a class="markdownIt-Anchor" href="#r-tree索引"></a> R Tree索引</h4>
<blockquote>
<p>空间数据索引</p>
</blockquote>
<p>这类索引无需前缀查询，空间索引将会从所有的维度来进行索引数据</p>
<h4 id="full-index"><a class="markdownIt-Anchor" href="#full-index"></a> Full index</h4>
<blockquote>
<p>全文索引</p>
</blockquote>
<p>全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而非比较索引中的值</p>
<p>全文搜索和其他几种类型的索引的匹配方式完全不同，如停用词、词干、复数、布尔搜索等</p>
<p>全文索引更类似于搜索引擎所做的事情，而不是简单的where条件匹配，而是MATCH<br />
AGAINST操作。支持Char、VARCHAR、TEXT类型、自然语言搜索、bool搜索</p>
<h4 id="gis"><a class="markdownIt-Anchor" href="#gis"></a> GIS</h4>
<blockquote>
<p>Geographic Information System</p>
</blockquote>
<h3 id="应用层次"><a class="markdownIt-Anchor" href="#应用层次"></a> 应用层次</h3>
<ul>
<li>主键索引： 加速查询 + 列值唯一（不可以有null）+ 单表中只有一个主键索引（主键索引可以是多个字段）</li>
<li>普通索引： 仅加速查询</li>
<li>唯一索引:    加速查询 + 列值唯一（建立在UNIQUE上的索引，字段可以为null）</li>
<li>复合索引:    多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li>
<li>全文索引： 对文本的内容进行分词，进行搜索</li>
<li>覆盖索引:    query 的索引字段在二级索引中就能找到（<strong>不需回表</strong>）</li>
<li>前缀索引：仅加速查询（对字符类型的前几个字段或二进制类型字段的前几个bytes建立的索引而不是在整个字段上建立索引）</li>
</ul>
<blockquote>
<p>索引合并，使用多个单列索引组合搜索</p>
</blockquote>
<h2 id="索引创建"><a class="markdownIt-Anchor" href="#索引创建"></a> 索引创建</h2>
<p>正确的创建索引是实现高性能查询的基础</p>
<blockquote>
<p>其核心的选择因素是 <code>特征</code> , 借助索引实现尽可能少的行扫描（最多<strong>业务场景</strong>）</p>
</blockquote>
<h3 id="索引设计原则"><a class="markdownIt-Anchor" href="#索引设计原则"></a> 索引设计原则</h3>
<blockquote>
<p>为了使索引的使用效率更高，在创建索引时，必须考虑</p>
<ul>
<li><strong>什么时候创建索引</strong></li>
<li><strong>在哪个(些)字段上创建索引</strong></li>
<li><strong>创建什么类型的索引</strong></li>
<li><strong>索引设计原则</strong></li>
</ul>
</blockquote>
<ol>
<li>必须要有主键,如果没有可以做为主键条件的列,创建无关列</li>
<li>经常做为where条件列 order by group by join on, distinct 的条件(业务:产品功能+用户行为)</li>
<li>最好使用唯一值多的列作为索引,如果索引列重复值较多,可以考虑使用联合索引</li>
<li>列值长度较长的索引列,建议使用前缀索引.</li>
<li>降低索引条目,一方面不要创建没用索引,不常使用的索引清理,percona toolkit(xxxxx)</li>
<li>索引维护要避开业务繁忙期</li>
</ol>
<p><strong>CREATE TABLE创建索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `ch_people_msg`</span><br><span class="line">(</span><br><span class="line">    `p_id`       SERIAL              NOT NULL AUTO_INCREMENT COMMENT &#x27;用户id&#x27;,</span><br><span class="line">    `p_uic`      CHAR(18)            NOT NULL COMMENT &#x27;用户身份证&#x27;,</span><br><span class="line">    `p_nickname` VARCHAR(50)         NOT NULL COMMENT &#x27;用户昵称&#x27;,</span><br><span class="line">    `p_gender`   ENUM (&#x27;m&#x27;,&#x27;f&#x27;, &#x27;n&#x27;) NOT NULL DEFAULT &#x27;n&#x27; COMMENT &#x27;用户性别&#x27;,</span><br><span class="line">    `p_age`      TINYINT UNSIGNED    NOT NULL DEFAULT 0 COMMENT &#x27;用户年龄&#x27;,</span><br><span class="line">    `p_pnum`     CHAR(11)            NOT NULL COMMENT &#x27;用户电话&#x27;,</span><br><span class="line">    `p_address`  VARCHAR(100)        NOT NULL COMMENT &#x27;用户地址&#x27;,</span><br><span class="line">    `p_email`    VARCHAR(50)         NOT NULL COMMENT &#x27;用户邮箱&#x27;,</span><br><span class="line">    `p_add_time` TIMESTAMP           NOT NULL DEFAULT NOW() COMMENT &#x27;统计用户时间&#x27;,</span><br><span class="line">    PRIMARY KEY (`p_id`),</span><br><span class="line">    UNIQUE KEY `p_uic` (`p_uic`)</span><br><span class="line">) ENGINE = InnoDB</span><br><span class="line">  CHARSET = utf8mb4</span><br><span class="line">  COLLATE utf8mb4_general_ci COMMENT = &#x27;中国成员信息表&#x27;;</span><br></pre></td></tr></table></figure>
<p><strong>增加索引</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name</span><br><span class="line">    ADD INDEX index_name (column_list);</span><br><span class="line">CREATE INDEX (index_type) index_name ON TABEL_NAME(COLUMN_NAME)</span><br></pre></td></tr></table></figure>
<h3 id="创建索引时注意点"><a class="markdownIt-Anchor" href="#创建索引时注意点"></a> 创建索引时注意点</h3>
<ul>
<li>非空字段：应该指定列为NOT<br />
NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li>
<li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过<code>count()</code><br />
函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li>
<li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li>
</ul>
<h3 id="索引命名规范"><a class="markdownIt-Anchor" href="#索引命名规范"></a> 索引命名规范</h3>
<ul>
<li>按照列组合命名：Idx_id_name_sex</li>
<li>按照功能命名：ldx_check_user_info</li>
<li>按照列和功能组合命名：ldx_id_name_sex_checklist</li>
</ul>
<p>但是需要注意，索引名称长度限制64，单个表最大索引数16，超过的话就创建失败。</p>
<h2 id="索引失效"><a class="markdownIt-Anchor" href="#索引失效"></a> 索引失效</h2>
<p><strong>函数导致的索引失效</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM `user`</span><br><span class="line">WHERE DATE(create_time) = &#x27;2012-11-03&#x27;;</span><br></pre></td></tr></table></figure>
<p><strong>运算符导致的索引失效</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 如果对列进行了（+，-，*，/，!）运算, 那么都将不会走索引。</span><br><span class="line">select p_id</span><br><span class="line">from xxx</span><br><span class="line">where p_id + 10 = 12</span><br></pre></td></tr></table></figure>
<p><strong>OR引起的索引失效</strong></p>
<blockquote>
<p>OR导致索引是在特定情况下的，并不是所有的OR都是使索引失效</p>
<p>如果OR连接的是同一个字段，那么索引不会失效，反之索引失效。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM `xxx`</span><br><span class="line">WHERE `name` = &#x27;xxx&#x27;</span><br><span class="line">   OR age = 20;</span><br></pre></td></tr></table></figure>
<p><strong>模糊搜索导致的索引失效</strong></p>
<blockquote>
<p>当模糊查询<code>%</code>在匹配字段前缀不走索引，放在后面才会走索引。</p>
</blockquote>
<p><strong>使用!= 或者 &lt;&gt; 导致索引失效</strong></p>
<p><strong>类型不一致导致的索引失效</strong></p>
<p><strong>NOT IN、NOT EXISTS导致索引失效</strong></p>
<p><strong>避免索引失效总结</strong></p>
<ol>
<li>尽量采用确认的、顺序的、逐步的</li>
<li>模糊查询<code>%</code>不在前</li>
<li>索引列不运算</li>
</ol>
<h2 id="索引下推"><a class="markdownIt-Anchor" href="#索引下推"></a> 索引下推</h2>
<p>自5.6引入了索引下推优化。默认开启</p>
<blockquote>
<p>可使用<code>SET optimizer_switch = ‘index_condition_pushdown=off;</code>将其关闭。</p>
</blockquote>
<ul>
<li>有了索引下推优化，可以在<strong>减少回表次数</strong></li>
<li>在InnoDB中只针对二级索引有效</li>
</ul>
<p>官方文档中给的例子和解释如下：</p>
<p>在 people_table中有一个二级索引(zipcode，lastname，firstname)，查询是SELECT * FROM people WHERE<br />
zipcode=’95054′ AND lastname LIKE<br />
‘%etrunia%’ AND address LIKE ‘%Main Street%’;</p>
<ul>
<li>如果没有使用索引下推技术，则MySQL会通过zipcode=’95054’从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname<br />
LIKE ‘%etrunia%’ and address LIKE<br />
‘%Main Street%’来判断数据是否符合条件</li>
<li>如果使用了索引下推技术，则MYSQL首先会返回符合zipcode=’95054’的索引，然后根据lastname LIKE<br />
‘%etrunia%’ and address LIKE ‘%Main<br />
Street%’来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。</li>
</ul>
<h2 id="默认使用btree的优势"><a class="markdownIt-Anchor" href="#默认使用btree的优势"></a> 默认使用B+Tree的优势</h2>
<blockquote>
<p>为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？</p>
</blockquote>
<p>B-tree：</p>
<ul>
<li>B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B(😎<br />
树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对<code>IO读写次数就降低</code><br />
了。</li>
<li></li>
</ul>
<p>由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在<code>区间查询</code><br />
的情况，所以通常B+树用于数据库索引。</p>
<p>Hash：</p>
<ul>
<li>
<p>虽然可以快速定位，但是没有顺序，IO复杂度高；</p>
</li>
<li>
<p>基于Hash表实现，只有Memory存储引擎显式支持哈希索引 ；</p>
</li>
<li>
<p>适合<strong>等值查询</strong>，如=、in()、&lt;=&gt;，不支持范围查询 ；</p>
</li>
<li>
<p>因为不是按照索引值顺序存储的，就不能像B+Tree索引一样利用索引完成排序 ；</p>
</li>
<li>
<p>Hash索引在查询等值时非常快 ；</p>
</li>
<li>
<p>因为Hash索引始终索引的<strong>所有列的全部内容</strong>，所以不支持部分索引列的匹配查找 ；</p>
</li>
<li>
<p>如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题 。</p>
</li>
</ul>
<p>二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。</p>
<p>红黑树：树的高度随着数据量增加而增加，IO代价高。</p>
<h2 id="referer"><a class="markdownIt-Anchor" href="#referer"></a> Referer</h2>
<p>《高性能MySQL》</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0k74vx2p6j220d0u00x6.jpg" alt="image-20220323224244082" /></p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>DBMS</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJS 相关镜像源设置</title>
    <url>/27695.html</url>
    <content><![CDATA[<h2 id="npm-查看镜像源"><a class="markdownIt-Anchor" href="#npm-查看镜像源"></a> <code>npm</code> 查看镜像源</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm config (set | get | delete | list | edit)</span></span><br><span class="line">npm config get (registry|sass_binary_site)</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3>
<p><strong>临时使用镜像</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --registry=https://registry.npmmirror.com pkg_name -g cnpm</span><br><span class="line"><span class="comment"># 创建别名</span></span><br><span class="line"><span class="built_in">alias</span> npmc=<span class="string">&quot;npm --registry=https://registry.npmmirror.com&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>全局配置</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line">npm config <span class="built_in">set</span> sass_binary_site=https://npm.taobao.org/mirrors/node-sass/phantomjs_cdn</span><br></pre></td></tr></table></figure>
<h2 id="yarn-查看镜像源"><a class="markdownIt-Anchor" href="#yarn-查看镜像源"></a> <code>yarn</code> 查看镜像源</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yarn config (set | get | delete | list | current)</span></span><br><span class="line">yarn config get (registry|sass_binary_site)</span><br></pre></td></tr></table></figure>
<h3 id="使用-2"><a class="markdownIt-Anchor" href="#使用-2"></a> 使用</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># **临时使用镜像**</span></span><br><span class="line">yarn add --registry=https://registry.npm.taobao.org</span><br><span class="line">yarn config <span class="built_in">set</span> registry https://registry.npm.taobao.org -g</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>yarn</code>使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化项目</span></span><br><span class="line">yarn init [-y]</span><br><span class="line"><span class="comment"># 添加依赖</span></span><br><span class="line">yarn [global] add </span><br><span class="line">-D, --dev                           <span class="comment"># save package to your `devDependencies`(开发依赖)</span></span><br><span class="line">-P, --peer                          <span class="comment"># save package to your `peerDependencies`(对等依赖)</span></span><br><span class="line">-O, --optional                      <span class="comment"># save package to your `optionalDependencies`(可选依赖)</span></span><br><span class="line"><span class="comment"># 安装项目所有依赖 `yarn` or </span></span><br><span class="line">yarn install [--update-checksums]</span><br><span class="line"><span class="comment"># 更新</span></span><br><span class="line">yarn upgrade</span><br><span class="line"><span class="comment"># 移除</span></span><br><span class="line">yarn remove</span><br></pre></td></tr></table></figure>
<h2 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> 补充</h2>
<h3 id="常用淘宝镜像"><a class="markdownIt-Anchor" href="#常用淘宝镜像"></a> 常用淘宝镜像</h3>
<p><strong><code>npm</code></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install phantomjs --phantomjs_cdnurl=http://npm.taobao.org/mirrors/phantomjs</span><br><span class="line">npm install chromedriver --chromedriver_cdnurl=http://npm.taobao.org/mirrors/chromedriver</span><br><span class="line">npm install operadriver --operadriver_cdnurl=http://npm.taobao.org/mirrors/operadriver</span><br><span class="line">npm config <span class="built_in">set</span> disturl https://npm.taobao.org/dist</span><br><span class="line">npm config <span class="built_in">set</span> electron_mirror https://npm.taobao.org/mirrors/electron/</span><br><span class="line">npm config <span class="built_in">set</span> sass_binary_site https://npm.taobao.org/mirrors/node-sass/</span><br><span class="line">npm config <span class="built_in">set</span> phantomjs_cdnurl https://npm.taobao.org/mirrors/phantomjs/</span><br></pre></td></tr></table></figure>
<p><strong><code>yarn</code></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn config <span class="built_in">set</span> disturl https://npm.taobao.org/dist -g</span><br><span class="line">yarn config <span class="built_in">set</span> electron_mirror https://npm.taobao.org/mirrors/electron/ -g</span><br><span class="line">yarn config <span class="built_in">set</span> sass_binary_site https://npm.taobao.org/mirrors/node-sass/ -g</span><br><span class="line">yarn config <span class="built_in">set</span> phantomjs_cdnurl https://npm.taobao.org/mirrors/phantomjs/ -g</span><br><span class="line">yarn config <span class="built_in">set</span> chromedriver_cdnurl https://cdn.npm.taobao.org/dist/chromedriver -g</span><br><span class="line">yarn config <span class="built_in">set</span> operadriver_cdnurl https://cdn.npm.taobao.org/dist/operadriver -g</span><br><span class="line">yarn config <span class="built_in">set</span> fse_binary_host_mirror https://npm.taobao.org/mirrors/fsevents -g</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="npm与yarn安装命令的对比"><a class="markdownIt-Anchor" href="#npm与yarn安装命令的对比"></a> npm与yarn安装命令的对比</h3>
<table>
<thead>
<tr>
<th>npm</th>
<th>yarn</th>
</tr>
</thead>
<tbody>
<tr>
<td>npm install</td>
<td>yarn [install]</td>
</tr>
<tr>
<td>npm ci</td>
<td>yarn [install] --frozen-lockfile</td>
</tr>
<tr>
<td>npm install --save</td>
<td>yarn add</td>
</tr>
<tr>
<td>npm install --save-dev</td>
<td>yarn add -dev/[-D]</td>
</tr>
<tr>
<td>npm install --save-peer</td>
<td>yarn add --peer/[-P]</td>
</tr>
<tr>
<td>npm install --save-peer</td>
<td>yarn add --optional/[-O]</td>
</tr>
<tr>
<td>npm uninstall --save</td>
<td>yarn remove</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>nodejs</category>
        <category>npm</category>
        <category>yarn</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>Python之GIL</title>
    <url>/4170211.html</url>
    <content><![CDATA[<h2 id="1-什么是gil"><a class="markdownIt-Anchor" href="#1-什么是gil"></a> 1 什么是GIL</h2>
<p>GIL（Global Interpreter Lock，即全局解释器锁），是最流行的 Python 解释器 CPython 中的一个技术术语。它的意思是全局解释器锁，本质上是<br />
<strong>类似操作系统的 Mutex</strong>，它可以帮助CPython解决其在内存管理中存在的线程不安全问题。</p>
<p>每一个 Python 线程，在 CPython 解释器中执行时，都会先锁住自己的线程，阻止别的线程执行。</p>
<p>简而言之就是<strong>任意时刻，Python 只有一个线程在同时运行</strong>。</p>
<h2 id="2-为什么需要gil"><a class="markdownIt-Anchor" href="#2-为什么需要gil"></a> 2 为什么需要GIL</h2>
<p>在CPython中，<strong>全局解释器锁</strong>（GIL）是一个互斥体，用于保护对Python对象的访问，防止多个线程同时执行Python bytecodes。GIL的存在可<br />
<strong>防止竞争确保线程安全</strong>。</p>
<p>所以说，CPython 引进 GIL 主要原因:</p>
<ul>
<li>设计者为了规避类似于内存管理这样的复杂的竞争风险问题（race condition）；</li>
<li>因为 CPython 大量使用 C 语言库，但大部分 C 语言库都不是原生线程安全的（线程安全会降低性能和增加复杂度）。</li>
</ul>
<p>为什么 CPython 需要 GIL 呢？这其实和 CPython 的实现有关。Python 的内存管理机制，<br />
CPython 使用引用计数来管理内存，所有 Python 脚本中创建的实例，都会有一个引用计数，来记录有多少个指针指向它。当引用计数只有 0<br />
时，则会自动释放内存。</p>
<h2 id="3-gil工作原理"><a class="markdownIt-Anchor" href="#3-gil工作原理"></a> 3 GIL工作原理</h2>
<ol>
<li>某个线程拿到GIL</li>
<li>该线程执行代码，直到达到了check_interval*</li>
<li>解释器让当前线程释放GIL</li>
<li>所有的线程开始竞争GIL</li>
<li>竞争到GIL锁的线程又从第1步开始执行</li>
</ol>
<blockquote>
<p>Python2中，check_interavl是当前线程遇见IO操作或者ticks计数达到100 <em>。</em><br />
在Python3中是执行时间达到阈值（默认为15毫秒）</p>
</blockquote>
<h2 id="4-gil存在的利弊"><a class="markdownIt-Anchor" href="#4-gil存在的利弊"></a> 4 GIL存在的利弊</h2>
<h3 id="41-利"><a class="markdownIt-Anchor" href="#41-利"></a> 4.1 利</h3>
<p>GIL 的设计，主要是为了方便 CPython 解释器层面的编写者</p>
<ul>
<li>在单线程任务中更快；</li>
<li>在多线程任务中，对于I/O密集型程序运行更快；</li>
<li>在多线程任务中，对于用C语言包来实现CPU密集型任务的程序运行更快；</li>
<li>在写C扩展的时候更加容易，因为除非你在扩展中允许，否则Python解释器不会切换线程；</li>
<li>在打包C库时更加容易。我们不用担心线程安全性。，因为如果该库不是线程安全的，则只需在调用GIL时将其锁定即可。</li>
</ul>
<h3 id="42-弊"><a class="markdownIt-Anchor" href="#42-弊"></a> 4.2 弊</h3>
<p>这种 GIL 锁的设计对于只使用单线程运行的code来说其实没有什么影响。但是对于计算密集型的程序（CPU-bound）和基于多线程的程序来说，Python<br />
的 GIL 设计<strong>很有可能会</strong>造成性能瓶颈。</p>
<p>例子：</p>
<p>因为有GIL的存在，由CPython做解释器（虚拟机）的多线程Python程序只能利用多核处理器的一个核来运行。</p>
<p>例如，我们将一个8线程的JAVA程序运行在4核的处理器上，那么每个核会运行1个线程，然后利用时间片轮转，轮流运行每一个线程。</p>
<p>但是，我们将一个8线程的Python程序（由CPython作解释器）运行在一个4核处理器上，那么总共只会有1个核在工作，8个线程都要在这一个核上面时间片轮转。</p>
<h2 id="5-python-的线程安全"><a class="markdownIt-Anchor" href="#5-python-的线程安全"></a> 5 Python 的线程安全</h2>
<p>有了 GIL，并不意味着我们 Python 编程者就不用去考虑线程安全了。即使我们知道，GIL 仅允许一个 Python 线程执行，但前面我也讲到了，Python<br />
还有 <strong>check interval</strong> 这样的抢占机制。</p>
<p>所以有了 GIL 并不意味着你的Python程序就可以高枕无忧了，我们仍然需要去注意线程安全。</p>
<p>GIL 的设计，主要是为了方便 CPython 解释器层面的编写者，而不是 Python 应用层面的程序员。作为 Python 的使用者，我们还是需要<br />
lock 等锁，来确保线程安全。</p>
<h2 id="6-python多线程"><a class="markdownIt-Anchor" href="#6-python多线程"></a> 6 Python多线程</h2>
<p>Cython 会做一些<strong>小把戏</strong>，轮流执行 Python 线程。这样一来，用户看到的就是“伪并行”——Python 线程在交错执行，来模拟真正并行的线程。<br />
<strong>所以说Python的多线程是伪多线程</strong></p>
<h3 id="61-gil-到底锁的是什么"><a class="markdownIt-Anchor" href="#61-gil-到底锁的是什么"></a> 6.1 GIL 到底锁的是什么？</h3>
<p>GIL 的全称是 Global Interpreter Lock, 全局解释器锁。它锁的是解释器而不是你的 Python 代码。它防止多线程同时执行 Python<br />
的字节码(bytecodes)，防止多线程同时访问 Python 的对象。</p>
<p>在 Python 官方文档Releasing the GIL from extension code<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>中，有这样一段话：</p>
<p>Here is how these functions work: <strong>the global interpreter lock is used to protect the pointer to the current thread<br />
state.</strong> When releasing the lock and saving the thread state, the current thread state pointer must be retrieved before<br />
the lock is released (since another thread could immediately acquire the lock and store its own thread state in the<br />
global variable). Conversely, when acquiring the lock and restoring the thread state, the lock must be acquired before<br />
storing the thread state pointer.</p>
<p>其中加黑的这一句话是说：GIL 锁用来保护指向当前进程<strong>状态的指针</strong>。</p>
<p>再看文档Thread State and the Global Interpreter Lock<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>中提到的这样一句话：</p>
<p>Without the lock, even the simplest operations could cause problems in a multi-threaded program: for example, when two<br />
threads simultaneously increment the <strong>reference count</strong> of the same object, the reference count could end up being<br />
incremented only once instead of twice.</p>
<p>当两个线程同时提高同一个对象的引用计数时，（如果没有 GIL 锁）那么引用计数只会被提高了 1 次而不是 2 次。</p>
<p>大家注意这两段应用中的<code>指针</code>和<code>引用计数</code>。其中指针是 C 语言的概念，Python 没有指针；引用计数是 Python 底层的概念。你平时写的<br />
Python 代码，引用计数是在你调用变量的时候自动增加的，不需要你去手动加 1.</p>
<p>所以 GIL 锁住的东西，都是不需要你的代码直接交互的东西。</p>
<p>Python 的解释器通过切换线程来模拟多线程并发的情况，如上面举的例子，虽然同一个时间只有一个线程在活动，但仍然可以导致并发冲突。</p>
<h2 id="7-gil-对-python-多线程开发的影响"><a class="markdownIt-Anchor" href="#7-gil-对-python-多线程开发的影响"></a> 7 GIL 对 Python 多线程开发的影响</h2>
<p>在提到开发性能瓶颈的时候，我们经常把对资源的限制分为两类，</p>
<ul>
<li>一类是计算密集型（CPU-bound）</li>
<li>一类是 I/O 密集型（I/O-bound）。</li>
</ul>
<p>计算密集型的程序是指的是把 CPU 资源耗尽的程序，也就是说想要提高性能速度，就需要提供更多更强的 CPU，比如矩阵运算，图片处理这类程序。</p>
<p>I/O 密集型的程序只的是那些花费大量时间在等待 I/O 运行结束的程序，比如从用户指定的文件中读取数据，从数据库或者从网络中读取数据，I/O<br />
密集型的程序对 CPU 的资源需求不是很高。</p>
<h3 id="71-如何加速"><a class="markdownIt-Anchor" href="#71-如何加速"></a> 7.1 如何加速？</h3>
<p>一般来说 IO 密集型用muti-Thread、协程来加速，CPU 密集型用muti-Process来加速。</p>
<p>结合来看IO密集型使用协程 + 多进程 不失为“最佳”方案：</p>
<p>aiomultiprocess：<span class="exturl" data-url="aHR0cHM6Ly9weXBpLm9yZy9wcm9qZWN0L2Fpb211bHRpcHJvY2Vzcy8=">https://pypi.org/project/aiomultiprocess/<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>如何绕过GIL？</strong></p>
<p>你并不需要过多考虑 GIL。因为如果多线程计算成为性能瓶颈，往往已经有 Python 库来解决这个问题了。</p>
<p>绕过 GIL 的大致思路有这么两种：</p>
<ul>
<li>绕过 CPython，使用 JPython（Java 实现的 Python 解释器）等别的实现；</li>
<li>把关键性能代码，放到别的语言（一般是 C++）中实现。</li>
</ul>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Releasing the GIL from extension<br />
code: <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9jLWFwaS9pbml0Lmh0bWwjcmVsZWFzaW5nLXRoZS1naWwtZnJvbS1leHRlbnNpb24tY29kZQ==">https://docs.python.org/3/c-api/init.html#releasing-the-gil-from-extension-code<i class="fa fa-external-link-alt"></i></span> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>Thread State and the Global Interpreter<br />
Lock: <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9jLWFwaS9pbml0Lmh0bWwjdGhyZWFkLXN0YXRlLWFuZC10aGUtZ2xvYmFsLWludGVycHJldGVyLWxvY2s=">https://docs.python.org/3/c-api/init.html#thread-state-and-the-global-interpreter-lock<i class="fa fa-external-link-alt"></i></span> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>GIL</category>
        <category>thread</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Python</tag>
        <tag>py</tag>
        <tag>GIL</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Python连接redis多种姿势</title>
    <url>/40723.html</url>
    <content><![CDATA[<p>示例环境</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">python <span class="number">3.10</span></span><br><span class="line">redis <span class="number">6.2</span></span><br><span class="line">python redis <span class="number">4.1</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>本实例所有包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis, ConnectionPool</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"><span class="keyword">from</span> concurrent.futures.process <span class="keyword">import</span> ProcessPoolExecutor</span><br></pre></td></tr></table></figure>
<h2 id="basic"><a class="markdownIt-Anchor" href="#basic"></a> Basic</h2>
<h3 id="basic-client"><a class="markdownIt-Anchor" href="#basic-client"></a> Basic Client</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rds = StrictRedis(</span><br><span class="line">    host=<span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    port=<span class="number">3218</span>,</span><br><span class="line">    <span class="comment"># redis 6.0 以后需要加入，默认为 default</span></span><br><span class="line">    username=<span class="string">&#x27;default&#x27;</span>,</span><br><span class="line">    password=<span class="string">&#x27;xxxxwadsad&#x27;</span>,</span><br><span class="line">    decode_responses=<span class="literal">True</span>,</span><br><span class="line">    db=<span class="number">1</span>,</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="basic-client-based-on-url"><a class="markdownIt-Anchor" href="#basic-client-based-on-url"></a> Basic Client Based On URL</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rds_url = <span class="string">&#x27;redis://default:xxxxwadsad@127.0.0.1:3218/1&#x27;</span></span><br><span class="line">rds = StrictRedis.from_url(rds_url)</span><br><span class="line">pprint(rds.info())</span><br></pre></td></tr></table></figure>
<h2 id="connection-pool"><a class="markdownIt-Anchor" href="#connection-pool"></a> Connection Pool</h2>
<h3 id="connection-pool-class"><a class="markdownIt-Anchor" href="#connection-pool-class"></a> Connection Pool class</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">connection_pool = ConnectionPool(</span><br><span class="line">    host=<span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    port=<span class="number">3218</span>,</span><br><span class="line">    <span class="comment"># redis 6.0 以后需要加入，默认为 default</span></span><br><span class="line">    username=<span class="string">&#x27;default&#x27;</span>,</span><br><span class="line">    password=<span class="string">&#x27;xxxxwadsad&#x27;</span>,</span><br><span class="line">    decode_responses=<span class="literal">True</span>,</span><br><span class="line">    db=<span class="number">1</span>,</span><br><span class="line">)</span><br><span class="line">connection_pool_client = StrictRedis(connection_pool=connection_pool)</span><br><span class="line">pprint(connection_pool_client.info())</span><br></pre></td></tr></table></figure>
<h3 id="connection-pool-class-base-on-url"><a class="markdownIt-Anchor" href="#connection-pool-class-base-on-url"></a> Connection Pool class Base on URL</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rds_url = <span class="string">&#x27;redis://default:xxxxwadsad@127.0.0.1:3218/1&#x27;</span></span><br><span class="line">connection_pool = ConnectionPool.from_url(rds_url)</span><br><span class="line">connection_pool_client = StrictRedis(connection_pool=connection_pool)</span><br><span class="line">pprint(connection_pool_client.info())</span><br></pre></td></tr></table></figure>
<h2 id="pipeline"><a class="markdownIt-Anchor" href="#pipeline"></a> Pipeline</h2>
<blockquote>
<p>Batch process, Don’t forget to use <code>pipeline.execute()</code> after the batch is finished</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pipeline = rds.pipeline(transaction=<span class="literal">True</span>)</span><br><span class="line">pipeline = connection_pool_client.pipeline(transaction=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>multiprocessing batch</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_item</span>():</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pipeline process logic</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">with</span> ProcessPoolExecutor(max_workers=<span class="number">6</span>) <span class="keyword">as</span> p:</span><br><span class="line"></span><br><span class="line">　　　　 <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    p.submit(process_item)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips: IO密集型用线程、协程，CPU密集型用进程</p>
</blockquote>
]]></content>
      <categories>
        <category>redis</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis:在集合中复制键</title>
    <url>/38075.html</url>
    <content><![CDATA[<p><strong>问题描述: 由于某种原因，我必须需要将某个集合的键（Key）复制一份副本。并移动到目标库</strong></p>
<p>拿到这个问题，脑海里一共有两种方式</p>
<ul>
<li>将所有的此集合中的所有的值从redis里面读取出来，然后再存进去。</li>
<li>使用集合的思想进行取差集或并集。如果二者有一个且仅有一个为空那么他们返回的结果为有值的集合</li>
</ul>
<span id="more"></span>
<h2 id="redis在集合中复制键"><a class="markdownIt-Anchor" href="#redis在集合中复制键"></a> Redis:在集合中复制键</h2>
<h3 id="方案一"><a class="markdownIt-Anchor" href="#方案一"></a> 方案一</h3>
<p>将所有的此集合中的所有的值从redis里面读取出来，然后再存到目标库中。</p>
<blockquote>
<p>思路清晰，不再过多赘述。</p>
</blockquote>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gr5bko8fz0j309m02k744.jpg" alt="" /></p>
<blockquote>
<p>如果数据较少可以使用SMEMBERS</p>
</blockquote>
<p>类型为set,其中有26781027个</p>
<p>由于直接使用redis命令不是那么方便，故Python代码入下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">conn_redis</span>(<span class="params">db</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    link redis</span></span><br><span class="line"><span class="string">    :param db:</span></span><br><span class="line"><span class="string">    :return: Redis Link object</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    REDIS_URL = <span class="string">f&#x27;redis://:<span class="subst">&#123;RedisPASSWD&#125;</span>@<span class="subst">&#123;RedisHOST&#125;</span>:<span class="subst">&#123;RedisPORT&#125;</span>/<span class="subst">&#123;db&#125;</span>&#x27;</span></span><br><span class="line">    redis_client = redis.from_url(REDIS_URL)</span><br><span class="line">    <span class="comment"># 验证是否连接</span></span><br><span class="line">    <span class="comment"># print(redis_client.info())</span></span><br><span class="line">    <span class="keyword">return</span> redis_client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_val</span>(<span class="params">key: <span class="built_in">str</span>, step</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    get values</span></span><br><span class="line"><span class="string">    :param step:</span></span><br><span class="line"><span class="string">    :param key:str</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        redis_client = conn_redis(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">#  获取键的大小</span></span><br><span class="line">        key_size = redis_client.scard(key)</span><br><span class="line">        key_type = redis_client.<span class="built_in">type</span>(key)</span><br><span class="line">        logger.info(<span class="string">f&#x27;Key Name: <span class="subst">&#123;key&#125;</span>, key Type: <span class="subst">&#123;key_type&#125;</span> Key Size: <span class="subst">&#123;key_size&#125;</span>&#x27;</span>)</span><br><span class="line">        page = <span class="built_in">int</span>(key_size // step) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, page + <span class="number">1</span>):</span><br><span class="line">            result = redis_client.sscan(key, i, <span class="string">&#x27;*&#x27;</span>, step)[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">yield</span> result</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_newVal</span>(<span class="params">db</span>):</span><br><span class="line">    redis_client = conn_redis(db)</span><br><span class="line">    redis_client.sadd(<span class="string">&quot;NewKey&quot;</span>, result)</span><br></pre></td></tr></table></figure>
<p><strong>方案一优化</strong></p>
<blockquote>
<p>sadd(“NewKey”,result)还是比较慢。使用pipeline</p>
</blockquote>
<h3 id="方案二"><a class="markdownIt-Anchor" href="#方案二"></a> 方案二</h3>
<p>由于是集合，可以使用集合的操作。</p>
<blockquote>
<p>任何集合的本身的补、并、差都是本身</p>
<p>1.集合的交集&amp; ,set.intersection()</p>
<p>2.集合的并集 | ,set. union()</p>
<p>3.集合的差集 set.difference(s2) 将集合s1里去掉和s2交集的部分</p>
<p>4.集合的交叉补集 set.symmetric_difference() 并集里去掉交集的部分</p>
</blockquote>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gr5exvf9xmj30q30aywej.jpg" alt="" /></p>
<p>创建集合 1，2，3</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gr5f96nq49j30fs055mx0.jpg" alt="" /></p>
<p>取给定集合的并集存储在目标集合中</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gr5fbdbwbsj30ct06gt8m.jpg" alt="" /></p>
<p>取给差集合的并集存储在目标集合中</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gr5fe8xoj1j30dz043mx0.jpg" alt="" /></p>
<p>这样就可以实现类似于copy的效果</p>
<p>所使用到的Redis命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">help</span> SMEMBERS</span></span><br><span class="line">SMEMBERS key</span><br><span class="line">summary: Get all the members in a set</span><br><span class="line">since: 1.0.0</span><br><span class="line">group: set</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">help</span> SSCAN</span></span><br><span class="line">SSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">summary: Incrementally iterate Set elements 增量迭代集合元素</span><br><span class="line">since: 2.8.0</span><br><span class="line">group: set</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">help</span> SUNIONSTORE</span></span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br><span class="line">summary: Add multiple sets and store the resulting set in a key 添加多个集合并将生成的集合存储在一个键中</span><br><span class="line">since: 1.0.0</span><br><span class="line">group: set</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">help</span> SDIFFSTORE</span></span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br><span class="line">summary: Subtract multiple sets and store the resulting set in a key 减去多个集合并将得到的集合存储在一个键中</span><br><span class="line">since: 1.0.0</span><br><span class="line">group: set</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>采用先取后存，以及集合的本身是本身的特性对于集合实现复制操作</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis服务与连接那些事儿</title>
    <url>/51496.html</url>
    <content><![CDATA[<h2 id="启动示例"><a class="markdownIt-Anchor" href="#启动示例"></a> 启动示例</h2>
<p>当我们需要使用Redis的时候需要把redis的服务开启。如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server</span><br><span class="line"><span class="comment"># 守护进程方式启动</span></span><br><span class="line">redis-server &amp;</span><br><span class="line"><span class="comment"># 使用自定义redis.conf启动</span></span><br><span class="line">redis-server path</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><code>redis-server</code>如图</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmoqnuejzfj31so0mitc6.jpg" alt="" /></p>
<p>这样虽然是启动了，但是这个终端却用不了了，我个人并不是很喜欢。那么有没有可以让他既可以运行，而且保证不会占用我们的终端呢</p>
<p>这里有两种方法</p>
<ul>
<li>
<p>使用<code>redis-server &amp;</code>明显启动示例即可</p>
</li>
<li>
<p>redis-server ----daemonize yes (以守护进程的方式运行redis)</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmpopzvxl4j30s40cq0u4.jpg" alt="" /></p>
</li>
</ul>
<blockquote>
<p>小技巧：</p>
<p>redis-server --配置名 配置的值</p>
<p>例如：redis-server --port 8765 此时你就可以在你的8765端口上运行redis</p>
<p>这样就可以无需修改redis.conf,就可以定制化的运行redis</p>
</blockquote>
<h3 id="redisconf"><a class="markdownIt-Anchor" href="#redisconf"></a> Redis.conf</h3>
<p>既然看过redis的配置文档，不自己亲手试一试怎么能行。话不多说直接开干。以下为给出最基本的的redis.conf，当然如果有需要也按需添加一些。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /database/6379</span><br><span class="line">cat &gt; /database/6379/redis.conf&lt;&lt;EOF</span><br><span class="line">daemonize yes</span><br><span class="line">port 6379</span><br><span class="line">logfile /database/6379/redis.log</span><br><span class="line">dir /database/6379</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<blockquote>
<p>守护进程(后台)运行:daemonize yes<br />
配置端口号 port 6379<br />
配置日志 logfile /database/6379/redis.log<br />
持久化文件存储位置 dir /database/6379<br />
RDB持久化数据文件 dbfilename dump.rdb</p>
</blockquote>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmppbthbjgj31c80kktbr.jpg" alt="" /></p>
<p>以上就已经完成了redis服务启动的部分，那么我们接下来看看redis的连接部分</p>
<h2 id="连接"><a class="markdownIt-Anchor" href="#连接"></a> 连接</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地连接</span></span><br><span class="line">redis-cli <span class="comment"># 相当于 redis-cli -h 127.0.0.1 -p 6379</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程连接</span></span><br><span class="line">redis-cli -h host -p port -a passwd</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmq0bbke7zj30e0044745.jpg" alt="" /></p>
<p>如图：出现此“unicode”编码显示问题，改如何解决？</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmq0dsx7o1j30zw06adft.jpg" alt="" /></p>
<p>本地连接直接使用<code>redis-cli</code>，直接在本地连接即可。此过不多赘述</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmq0glrkj0j31pc07udgu.jpg" alt="" /></p>
<blockquote>
<p>DENIED Redis is running in protected mode because protected mode is enabled, no bind address was<br />
specified, no authentication password is requested to clients. In this mode connections are only<br />
accepted from the loopback interface. If you want to connect from external computers to Redis you<br />
may adopt one of the following solutions:</p>
<ol>
<li>Just disable protected mode sending the command ‘CONFIG SET protected-mode no’ from the<br />
loopback interface by connecting to Redis from the same host the server is running, however<br />
MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to<br />
make this change permanent.</li>
<li>Alternatively you can just disable the protected mode by editing the Redis configuration file,<br />
and setting the protected mode option to ‘no’, and then restarting the server.</li>
<li>If you started the server manually just for testing, restart it with the ‘–protected-mode no’<br />
option.</li>
<li>Setup a bind address or an authentication password. NOTE: You only need to do one of the above<br />
things in order for the server to start accepting connections from the outside.</li>
</ol>
<p>译文：DENIED Redis正在保护模式下运行，因为已启用保护模式、未指定绑定地址、未向客户端请求身份验证密码。在这种模式下，只接受来自环回接口的连接。如果您想从外部计算机连接到Redis</p>
<p>只需通过从服务器运行的同一主机连接到Redis，从环回接口发送命令’CONFIG SET protected mode no’<br />
来禁用保护模式，但是如果这样做，请确保Redis不能从internet公开访问。使用CONFIG REWRITE将此更改永久化</p>
<p>您可以通过编辑Redis配置文件，将protectedmode选项设置为no，然后重新启动服务器来禁用protectedmode。</p>
<p>如果只是为了测试而手动启动服务器，请使用“-protected mode no”选项重新启动服务器</p>
<p>设置绑定地址或身份验证密码。</p>
<p>服务器就可以开始接受来自外部的连接。</p>
</blockquote>
<p>那么从以上得知，redis是默认关闭远程连接以及开启保护模式。开启远程连接的方式有以下几种</p>
<ol>
<li>在本地(打开redis服务)的机器，采用回环地址连接(即是127.0.0.1)<br />
，连接redis，后使用<code>CONFIG SET protected mode no</code>就可以允许远程连接(推荐)，使用CONFIG<br />
REWRITE将此更改永久化</li>
<li>在配置文件中关闭保护模式<code>protected mode no</code>,重启redis服务(不推荐)</li>
<li>关闭redis服务，使用<code>redis-server -protected mode no</code>，启动服务</li>
<li>配置ip访问或密码(最推荐)</li>
</ol>
<p>综上，我们来配置一下我们的<code>redis.conf</code>，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">port 6379</span><br><span class="line">logfile /database/6379/redis.log</span><br><span class="line">dir /database/6379</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">requirepass 123321</span><br></pre></td></tr></table></figure>
<h2 id="性能测试"><a class="markdownIt-Anchor" href="#性能测试"></a> 性能测试</h2>
<p>说到性能与测试这两个都是，大家一直关心的问题。那么redis的性能测试该怎么做呢。咋这里我们了解一下<code>redis-brnchmark</code></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmq49jlh69j31ao0nmjw9.jpg" alt="" /></p>
<p>具体参数如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Usage: redis-benchmark [-h &lt;host&gt;] [-p &lt;port&gt;] [-c &lt;clients&gt;] [-n &lt;requests&gt;] [-k &lt;boolean&gt;]</span><br><span class="line"></span><br><span class="line"> -h &lt;hostname&gt;      Server hostname (default 127.0.0.1)</span><br><span class="line"> -p &lt;port&gt;          Server port (default 6379)</span><br><span class="line"> -s &lt;socket&gt;        Server socket (overrides host and port)</span><br><span class="line"> -a &lt;password&gt;      Password <span class="keyword">for</span> Redis Auth</span><br><span class="line"> --user &lt;username&gt;  Used to send ACL style <span class="string">&#x27;AUTH username pass&#x27;</span>. Needs -a.</span><br><span class="line"> -c &lt;clients&gt;       Number of parallel connections (default 50)</span><br><span class="line"> -n &lt;requests&gt;      Total number of requests (default 100000)</span><br><span class="line"> -d &lt;size&gt;          Data size of SET/GET value <span class="keyword">in</span> bytes (default 3)</span><br><span class="line"> --dbnum &lt;db&gt;       SELECT the specified db number (default 0)</span><br><span class="line"> --threads &lt;num&gt;    Enable multi-thread mode.</span><br><span class="line"> --cluster          Enable cluster mode.</span><br><span class="line"> --enable-tracking  Send CLIENT TRACKING on before starting benchmark.</span><br><span class="line"> -k &lt;boolean&gt;       1=keep alive 0=reconnect (default 1)</span><br><span class="line"> -r &lt;keyspacelen&gt;   Use random keys <span class="keyword">for</span> SET/GET/INCR, random values <span class="keyword">for</span> SADD,</span><br><span class="line">                    random members and scores <span class="keyword">for</span> ZADD.</span><br><span class="line">  Using this option the benchmark will <span class="built_in">expand</span> the string __rand_int__</span><br><span class="line">  inside an argument with a 12 digits number <span class="keyword">in</span> the specified range</span><br><span class="line">  from 0 to keyspacelen-1. The substitution changes every <span class="keyword">time</span> a <span class="built_in">command</span></span><br><span class="line">  is executed. Default tests use this to hit random keys <span class="keyword">in</span> the</span><br><span class="line">  specified range.</span><br><span class="line"> -P &lt;numreq&gt;        Pipeline &lt;numreq&gt; requests. Default 1 (no pipeline).</span><br><span class="line"> -e                 If server replies with errors, show them on stdout.</span><br><span class="line">                    (no more than 1 error per second is displayed)</span><br><span class="line"> -q                 Quiet. Just show query/sec values</span><br><span class="line"> --precision        Number of decimal places to display <span class="keyword">in</span> latency output (default 0)</span><br><span class="line"> --csv              Output <span class="keyword">in</span> CSV format</span><br><span class="line"> -l                 Loop. Run the tests forever</span><br><span class="line"> -t &lt;tests&gt;         Only run the comma separated list of tests. The <span class="built_in">test</span></span><br><span class="line">                    names are the same as the ones produced as output.</span><br><span class="line"> -I                 Idle mode. Just open N idle connections and <span class="built_in">wait</span>.</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line"></span><br><span class="line"> Run the benchmark with the default configuration against 127.0.0.1:6379:</span><br><span class="line">   $ redis-benchmark</span><br><span class="line"></span><br><span class="line"> Use 20 parallel clients, <span class="keyword">for</span> a total of 100k requests, against 192.168.1.1:</span><br><span class="line">   $ redis-benchmark -h 192.168.1.1 -p 6379 -n 100000 -c 20</span><br><span class="line"></span><br><span class="line"> Fill 127.0.0.1:6379 with about 1 million keys only using the SET <span class="built_in">test</span>:</span><br><span class="line">   $ redis-benchmark -t <span class="built_in">set</span> -n 1000000 -r 100000000</span><br><span class="line"></span><br><span class="line"> Benchmark 127.0.0.1:6379 <span class="keyword">for</span> a few commands producing CSV output:</span><br><span class="line">   $ redis-benchmark -t ping,<span class="built_in">set</span>,get -n 100000 --csv</span><br><span class="line"></span><br><span class="line"> Benchmark a specific <span class="built_in">command</span> line:</span><br><span class="line">   $ redis-benchmark -r 10000 -n 10000 <span class="built_in">eval</span> <span class="string">&#x27;return redis.call(&quot;ping&quot;)&#x27;</span> 0</span><br><span class="line"></span><br><span class="line"> Fill a list with 10000 random elements:</span><br><span class="line">   $ redis-benchmark -r 10000 -n 10000 lpush mylist __rand_int__</span><br><span class="line"></span><br><span class="line"> On user specified <span class="built_in">command</span> lines __rand_int__ is replaced with a random <span class="built_in">integer</span></span><br><span class="line"> with a range of values selected by the -r option.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="在线修改配置"><a class="markdownIt-Anchor" href="#在线修改配置"></a> 在线修改配置</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CONFIG GET *(配置名，例如daemonize，protected-mode等)    <span class="comment"># 查看配置</span></span><br><span class="line">CONFIG RESETSTAT <span class="comment"># 命令用于重置 INFO 命令中的某些统计数据</span></span><br><span class="line">CONFIG REWRITE  <span class="comment"># 将修改的设置回写配置文件</span></span><br><span class="line">CONFIG SET     <span class="comment"># 设置参数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CONFIG GET *</span><br><span class="line"><span class="comment"># 输出结果如下</span></span><br><span class="line">  1) <span class="string">&quot;rdbchecksum&quot;</span>                                                                                                           </span><br><span class="line">  2) <span class="string">&quot;yes&quot;</span>                                                                                                                   </span><br><span class="line">  3) <span class="string">&quot;daemonize&quot;</span>                                                                                                             </span><br><span class="line">  4) <span class="string">&quot;yes&quot;</span>                                                                                                                   </span><br><span class="line">  5) <span class="string">&quot;io-threads-do-reads&quot;</span>                                                                                                   </span><br><span class="line">  6) <span class="string">&quot;no&quot;</span>                                                                                                                    </span><br><span class="line">  7) <span class="string">&quot;lua-replicate-commands&quot;</span>                                                                                                </span><br><span class="line">  8) <span class="string">&quot;yes&quot;</span>                                                                                                                   </span><br><span class="line">  9) <span class="string">&quot;always-show-logo&quot;</span>                                                                                                      </span><br><span class="line"> 10) <span class="string">&quot;no&quot;</span>                                                                                                                    </span><br><span class="line"> 11) <span class="string">&quot;protected-mode&quot;</span>                                                                                                        </span><br><span class="line"> 12) <span class="string">&quot;yes&quot;</span>                                                                                                                   </span><br><span class="line"> 13) <span class="string">&quot;rdbcompression&quot;</span>                                                                                                        </span><br><span class="line"> 14) <span class="string">&quot;yes&quot;</span>                                                                                                                   </span><br><span class="line"> 15) <span class="string">&quot;rdb-del-sync-files&quot;</span>                                                                                                    </span><br><span class="line"> 16) <span class="string">&quot;no&quot;</span>                                                                                                                    </span><br><span class="line"> 17) <span class="string">&quot;activerehashing&quot;</span>                                                                                                       </span><br><span class="line"> 18) <span class="string">&quot;yes&quot;</span>                                                                                                                   </span><br><span class="line"> 19) <span class="string">&quot;stop-writes-on-bgsave-error&quot;</span>                                                                                           </span><br><span class="line"> 20) <span class="string">&quot;yes&quot;</span>                                                                                                                   </span><br><span class="line"> 21) <span class="string">&quot;dynamic-hz&quot;</span>                                                                                                            </span><br><span class="line"> 22) <span class="string">&quot;yes&quot;</span>                                                                                                                   </span><br><span class="line"> 23) <span class="string">&quot;lazyfree-lazy-eviction&quot;</span>                                                                                                </span><br><span class="line"> 24) <span class="string">&quot;no&quot;</span>                                                                                                                    </span><br><span class="line"> 25) <span class="string">&quot;lazyfree-lazy-expire&quot;</span>                                                                                                  </span><br><span class="line"> 26) <span class="string">&quot;no&quot;</span>                                                                                                                    </span><br><span class="line"> 27) <span class="string">&quot;lazyfree-lazy-server-del&quot;</span>                                                                                              </span><br><span class="line"> 28) <span class="string">&quot;no&quot;</span>                                                                                                                    </span><br><span class="line"> 29) <span class="string">&quot;lazyfree-lazy-user-del&quot;</span>                                                                                                </span><br><span class="line"> 30) <span class="string">&quot;no&quot;</span>                                                                                                                    </span><br><span class="line"> 31) <span class="string">&quot;repl-disable-tcp-nodelay&quot;</span>                                                                                              </span><br><span class="line"> 32) <span class="string">&quot;no&quot;</span>                                                                                                                    </span><br><span class="line"> 33) <span class="string">&quot;repl-diskless-sync&quot;</span>                                                                                                    </span><br><span class="line"> 34) <span class="string">&quot;no&quot;</span>                                                                                                                    </span><br><span class="line"> 35) <span class="string">&quot;gopher-enabled&quot;</span>                                                                                                        </span><br><span class="line"> 36) <span class="string">&quot;no&quot;</span>                                                                                                                    </span><br><span class="line"> 37) <span class="string">&quot;aof-rewrite-incremental-fsync&quot;</span></span><br><span class="line"> 38) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 39) <span class="string">&quot;no-appendfsync-on-rewrite&quot;</span></span><br><span class="line"> 40) <span class="string">&quot;no&quot;</span></span><br><span class="line"> 41) <span class="string">&quot;cluster-require-full-coverage&quot;</span></span><br><span class="line"> 42) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 43) <span class="string">&quot;rdb-save-incremental-fsync&quot;</span></span><br><span class="line"> 44) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 45) <span class="string">&quot;aof-load-truncated&quot;</span></span><br><span class="line"> 46) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 47) <span class="string">&quot;aof-use-rdb-preamble&quot;</span></span><br><span class="line"> 48) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 49) <span class="string">&quot;cluster-replica-no-failover&quot;</span></span><br><span class="line"> 50) <span class="string">&quot;no&quot;</span></span><br><span class="line"> 51) <span class="string">&quot;cluster-slave-no-failover&quot;</span></span><br><span class="line"> 52) <span class="string">&quot;no&quot;</span></span><br><span class="line"> 53) <span class="string">&quot;replica-lazy-flush&quot;</span></span><br><span class="line"> 54) <span class="string">&quot;no&quot;</span></span><br><span class="line"> 55) <span class="string">&quot;slave-lazy-flush&quot;</span></span><br><span class="line"> 56) <span class="string">&quot;no&quot;</span></span><br><span class="line"> 57) <span class="string">&quot;replica-serve-stale-data&quot;</span></span><br><span class="line"> 58) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 59) <span class="string">&quot;slave-serve-stale-data&quot;</span></span><br><span class="line"> 60) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 61) <span class="string">&quot;replica-read-only&quot;</span></span><br><span class="line"> 62) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 63) <span class="string">&quot;slave-read-only&quot;</span></span><br><span class="line"> 64) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 65) <span class="string">&quot;replica-ignore-maxmemory&quot;</span></span><br><span class="line"> 66) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 67) <span class="string">&quot;slave-ignore-maxmemory&quot;</span></span><br><span class="line"> 68) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 69) <span class="string">&quot;jemalloc-bg-thread&quot;</span></span><br><span class="line"> 70) <span class="string">&quot;yes&quot;</span></span><br><span class="line"> 71) <span class="string">&quot;activedefrag&quot;</span></span><br><span class="line"> 72) <span class="string">&quot;no&quot;</span></span><br><span class="line"> 73) <span class="string">&quot;syslog-enabled&quot;</span></span><br><span class="line"> 74) <span class="string">&quot;no&quot;</span></span><br><span class="line"> 75) <span class="string">&quot;cluster-enabled&quot;</span></span><br><span class="line"> 76) <span class="string">&quot;no&quot;</span></span><br><span class="line"> 77) <span class="string">&quot;appendonly&quot;</span></span><br><span class="line"> 78) <span class="string">&quot;no&quot;</span></span><br><span class="line"> 79) <span class="string">&quot;cluster-allow-reads-when-down&quot;</span></span><br><span class="line"> 80) <span class="string">&quot;no&quot;</span></span><br><span class="line"> 81) <span class="string">&quot;aclfile&quot;</span></span><br><span class="line"> 82) <span class="string">&quot;&quot;</span></span><br><span class="line"> 83) <span class="string">&quot;unixsocket&quot;</span></span><br><span class="line"> 84) <span class="string">&quot;&quot;</span></span><br><span class="line"> 85) <span class="string">&quot;pidfile&quot;</span></span><br><span class="line"> 86) <span class="string">&quot;/var/run/redis.pid&quot;</span></span><br><span class="line"> 87) <span class="string">&quot;replica-announce-ip&quot;</span></span><br><span class="line"> 88) <span class="string">&quot;&quot;</span></span><br><span class="line"> 89) <span class="string">&quot;slave-announce-ip&quot;</span></span><br><span class="line"> 90) <span class="string">&quot;&quot;</span></span><br><span class="line"> 91) <span class="string">&quot;masteruser&quot;</span></span><br><span class="line"> 92) <span class="string">&quot;&quot;</span></span><br><span class="line"> 93) <span class="string">&quot;masterauth&quot;</span></span><br><span class="line"> 94) <span class="string">&quot;&quot;</span></span><br><span class="line"> 95) <span class="string">&quot;cluster-announce-ip&quot;</span></span><br><span class="line"> 96) <span class="string">&quot;&quot;</span></span><br><span class="line"> 97) <span class="string">&quot;syslog-ident&quot;</span></span><br><span class="line"> 98) <span class="string">&quot;redis&quot;</span></span><br><span class="line"> 99) <span class="string">&quot;dbfilename&quot;</span></span><br><span class="line">100) <span class="string">&quot;dump.rdb&quot;</span></span><br><span class="line">101) <span class="string">&quot;appendfilename&quot;</span></span><br><span class="line">102) <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line">103) <span class="string">&quot;server_cpulist&quot;</span></span><br><span class="line">104) <span class="string">&quot;&quot;</span></span><br><span class="line">105) <span class="string">&quot;bio_cpulist&quot;</span></span><br><span class="line">106) <span class="string">&quot;&quot;</span></span><br><span class="line">107) <span class="string">&quot;aof_rewrite_cpulist&quot;</span></span><br><span class="line">108) <span class="string">&quot;&quot;</span></span><br><span class="line">109) <span class="string">&quot;bgsave_cpulist&quot;</span></span><br><span class="line">110) <span class="string">&quot;&quot;</span></span><br><span class="line">111) <span class="string">&quot;ignore-warnings&quot;</span></span><br><span class="line">112) <span class="string">&quot;ARM64-COW-BUG&quot;</span></span><br><span class="line">113) <span class="string">&quot;supervised&quot;</span></span><br><span class="line">114) <span class="string">&quot;no&quot;</span></span><br><span class="line">115) <span class="string">&quot;syslog-facility&quot;</span></span><br><span class="line">116) <span class="string">&quot;local0&quot;</span></span><br><span class="line">117) <span class="string">&quot;repl-diskless-load&quot;</span></span><br><span class="line">118) <span class="string">&quot;disabled&quot;</span></span><br><span class="line">119) <span class="string">&quot;loglevel&quot;</span></span><br><span class="line">120) <span class="string">&quot;notice&quot;</span></span><br><span class="line">121) <span class="string">&quot;maxmemory-policy&quot;</span></span><br><span class="line">122) <span class="string">&quot;noeviction&quot;</span></span><br><span class="line">123) <span class="string">&quot;appendfsync&quot;</span></span><br><span class="line">124) <span class="string">&quot;everysec&quot;</span></span><br><span class="line">125) <span class="string">&quot;oom-score-adj&quot;</span></span><br><span class="line">126) <span class="string">&quot;no&quot;</span></span><br><span class="line">127) <span class="string">&quot;databases&quot;</span></span><br><span class="line">128) <span class="string">&quot;16&quot;</span></span><br><span class="line">129) <span class="string">&quot;port&quot;</span></span><br><span class="line">130) <span class="string">&quot;6379&quot;</span></span><br><span class="line">131) <span class="string">&quot;io-threads&quot;</span></span><br><span class="line">132) <span class="string">&quot;1&quot;</span></span><br><span class="line">133) <span class="string">&quot;auto-aof-rewrite-percentage&quot;</span></span><br><span class="line">134) <span class="string">&quot;100&quot;</span></span><br><span class="line">135) <span class="string">&quot;cluster-replica-validity-factor&quot;</span></span><br><span class="line">136) <span class="string">&quot;10&quot;</span></span><br><span class="line">137) <span class="string">&quot;cluster-slave-validity-factor&quot;</span></span><br><span class="line">138) <span class="string">&quot;10&quot;</span></span><br><span class="line">139) <span class="string">&quot;list-max-ziplist-size&quot;</span></span><br><span class="line">140) <span class="string">&quot;-2&quot;</span></span><br><span class="line">141) <span class="string">&quot;tcp-keepalive&quot;</span></span><br><span class="line">142) <span class="string">&quot;300&quot;</span></span><br><span class="line">143) <span class="string">&quot;cluster-migration-barrier&quot;</span></span><br><span class="line">144) <span class="string">&quot;1&quot;</span></span><br><span class="line">145) <span class="string">&quot;active-defrag-cycle-min&quot;</span></span><br><span class="line">146) <span class="string">&quot;1&quot;</span></span><br><span class="line">147) <span class="string">&quot;active-defrag-cycle-max&quot;</span></span><br><span class="line">148) <span class="string">&quot;25&quot;</span></span><br><span class="line">149) <span class="string">&quot;active-defrag-threshold-lower&quot;</span></span><br><span class="line">150) <span class="string">&quot;10&quot;</span></span><br><span class="line">151) <span class="string">&quot;active-defrag-threshold-upper&quot;</span></span><br><span class="line">152) <span class="string">&quot;100&quot;</span></span><br><span class="line">153) <span class="string">&quot;lfu-log-factor&quot;</span></span><br><span class="line">154) <span class="string">&quot;10&quot;</span></span><br><span class="line">155) <span class="string">&quot;lfu-decay-time&quot;</span></span><br><span class="line">156) <span class="string">&quot;1&quot;</span></span><br><span class="line">157) <span class="string">&quot;replica-priority&quot;</span></span><br><span class="line">158) <span class="string">&quot;100&quot;</span></span><br><span class="line">159) <span class="string">&quot;slave-priority&quot;</span></span><br><span class="line">160) <span class="string">&quot;100&quot;</span></span><br><span class="line">161) <span class="string">&quot;repl-diskless-sync-delay&quot;</span></span><br><span class="line">162) <span class="string">&quot;5&quot;</span></span><br><span class="line">163) <span class="string">&quot;maxmemory-samples&quot;</span></span><br><span class="line">164) <span class="string">&quot;5&quot;</span></span><br><span class="line">165) <span class="string">&quot;timeout&quot;</span></span><br><span class="line">166) <span class="string">&quot;0&quot;</span></span><br><span class="line">167) <span class="string">&quot;replica-announce-port&quot;</span></span><br><span class="line">168) <span class="string">&quot;0&quot;</span></span><br><span class="line">169) <span class="string">&quot;slave-announce-port&quot;</span></span><br><span class="line">170) <span class="string">&quot;0&quot;</span></span><br><span class="line">171) <span class="string">&quot;tcp-backlog&quot;</span></span><br><span class="line">172) <span class="string">&quot;511&quot;</span></span><br><span class="line">173) <span class="string">&quot;cluster-announce-bus-port&quot;</span></span><br><span class="line">174) <span class="string">&quot;0&quot;</span></span><br><span class="line">175) <span class="string">&quot;cluster-announce-port&quot;</span></span><br><span class="line">176) <span class="string">&quot;0&quot;</span></span><br><span class="line">177) <span class="string">&quot;repl-timeout&quot;</span></span><br><span class="line">178) <span class="string">&quot;60&quot;</span></span><br><span class="line">179) <span class="string">&quot;repl-ping-replica-period&quot;</span></span><br><span class="line">180) <span class="string">&quot;10&quot;</span></span><br><span class="line">181) <span class="string">&quot;repl-ping-slave-period&quot;</span></span><br><span class="line">182) <span class="string">&quot;10&quot;</span></span><br><span class="line">183) <span class="string">&quot;list-compress-depth&quot;</span></span><br><span class="line">184) <span class="string">&quot;0&quot;</span></span><br><span class="line">185) <span class="string">&quot;rdb-key-save-delay&quot;</span></span><br><span class="line">186) <span class="string">&quot;0&quot;</span></span><br><span class="line">187) <span class="string">&quot;key-load-delay&quot;</span></span><br><span class="line">188) <span class="string">&quot;0&quot;</span></span><br><span class="line">189) <span class="string">&quot;active-expire-effort&quot;</span></span><br><span class="line">190) <span class="string">&quot;1&quot;</span></span><br><span class="line">191) <span class="string">&quot;hz&quot;</span></span><br><span class="line">192) <span class="string">&quot;10&quot;</span></span><br><span class="line">193) <span class="string">&quot;min-replicas-to-write&quot;</span></span><br><span class="line">194) <span class="string">&quot;0&quot;</span></span><br><span class="line">195) <span class="string">&quot;min-slaves-to-write&quot;</span></span><br><span class="line">196) <span class="string">&quot;0&quot;</span></span><br><span class="line">197) <span class="string">&quot;min-replicas-max-lag&quot;</span></span><br><span class="line">198) <span class="string">&quot;10&quot;</span></span><br><span class="line">199) <span class="string">&quot;min-slaves-max-lag&quot;</span></span><br><span class="line">200) <span class="string">&quot;10&quot;</span></span><br><span class="line">201) <span class="string">&quot;maxclients&quot;</span></span><br><span class="line">202) <span class="string">&quot;10000&quot;</span></span><br><span class="line">203) <span class="string">&quot;active-defrag-max-scan-fields&quot;</span></span><br><span class="line">204) <span class="string">&quot;1000&quot;</span></span><br><span class="line">205) <span class="string">&quot;slowlog-max-len&quot;</span></span><br><span class="line">206) <span class="string">&quot;128&quot;</span></span><br><span class="line">207) <span class="string">&quot;acllog-max-len&quot;</span></span><br><span class="line">208) <span class="string">&quot;128&quot;</span></span><br><span class="line">209) <span class="string">&quot;lua-time-limit&quot;</span></span><br><span class="line">210) <span class="string">&quot;5000&quot;</span></span><br><span class="line">211) <span class="string">&quot;cluster-node-timeout&quot;</span></span><br><span class="line">212) <span class="string">&quot;15000&quot;</span></span><br><span class="line">213) <span class="string">&quot;slowlog-log-slower-than&quot;</span></span><br><span class="line">214) <span class="string">&quot;10000&quot;</span></span><br><span class="line">215) <span class="string">&quot;latency-monitor-threshold&quot;</span></span><br><span class="line">216) <span class="string">&quot;0&quot;</span></span><br><span class="line">217) <span class="string">&quot;proto-max-bulk-len&quot;</span></span><br><span class="line">218) <span class="string">&quot;536870912&quot;</span></span><br><span class="line">219) <span class="string">&quot;stream-node-max-entries&quot;</span></span><br><span class="line">220) <span class="string">&quot;100&quot;</span></span><br><span class="line">221) <span class="string">&quot;repl-backlog-size&quot;</span></span><br><span class="line">222) <span class="string">&quot;1048576&quot;</span></span><br><span class="line">223) <span class="string">&quot;maxmemory&quot;</span></span><br><span class="line">224) <span class="string">&quot;0&quot;</span></span><br><span class="line">225) <span class="string">&quot;hash-max-ziplist-entries&quot;</span></span><br><span class="line">226) <span class="string">&quot;512&quot;</span></span><br><span class="line">227) <span class="string">&quot;set-max-intset-entries&quot;</span></span><br><span class="line">228) <span class="string">&quot;512&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>小技巧：</p>
<p>config get 支持模糊匹配，例如包含所有re开头的配置名，<code>config get re*</code>,</p>
<p>所有配置名包含<code>re</code>的配置，可以使用<code>config get *re*</code></p>
</blockquote>
<h3 id="在线修改密码"><a class="markdownIt-Anchor" href="#在线修改密码"></a> 在线修改密码</h3>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmqn2c3zruj31e00943zd.jpg" alt="" /></p>
<p>原本的密码是<code>123321</code>,这里我们将它修改为<code>123123123</code>,再一次去连接它。发现此时的密码已经修改</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmqn3y1i0ej30wy0agdgx.jpg" alt="" /></p>
]]></content>
      <categories>
        <category>redis</category>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis概览与安装</title>
    <url>/16021.html</url>
    <content><![CDATA[<h2 id="redis概览"><a class="markdownIt-Anchor" href="#redis概览"></a> Redis概览</h2>
<p>Redis是一个开源（BSD许可）的内存数据结构存储，用作数据库、缓存和消息代理。Redis提供诸如字符串、哈希、列表、集合、带范围查询的排序集合、位图、超日志、地理空间索引和流等数据结构。Redis具有内置的复制、Lua脚本、LRU逐出、事务和不同级别的磁盘持久性，并通过Redis<br />
Sentinel和Redis Cluster的自动分区提供高可用性</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据类型丰富            （笔试、面试）*****</span><br><span class="line">支持持久化               （笔试、面试）*****</span><br><span class="line">多种内存分配及回收策略</span><br><span class="line">支持事务                  （面试） ****</span><br><span class="line">消息队列、消息订阅 </span><br><span class="line">支持高可用                             ****</span><br><span class="line">支持分布式分片集群        （面试）*****</span><br><span class="line">缓存穿透\雪崩（笔试、面试）          *****</span><br><span class="line">Redis API                        **</span><br></pre></td></tr></table></figure>
<h2 id="redis使用场景介绍"><a class="markdownIt-Anchor" href="#redis使用场景介绍"></a> Redis使用场景介绍</h2>
<p>Memcached：多核的缓存服务，更加适合于多用户并发访问次数较少的应用场景<br />
Redis：单核的缓存服务，单节点情况下，更加适合于少量用户，多次访问的应用场景。Redis一般是单机多实例架构，配合redis集群出现。</p>
<h2 id="redis-安装"><a class="markdownIt-Anchor" href="#redis-安装"></a> Redis 安装</h2>
<h3 id="编译安装"><a class="markdownIt-Anchor" href="#编译安装"></a> 编译安装</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 官方示例</span></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">yum -y install gcc automake autoconf libtool make</span><br><span class="line"><span class="comment"># 安装源码包</span></span><br><span class="line">wget https://download.redis.io/releases/redis-6.0.10.tar.gz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar xzf redis-6.0.10.tar.gz</span><br><span class="line"><span class="comment"># 进入文件</span></span><br><span class="line"><span class="built_in">cd</span> redis-6.0.10</span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定制</span></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">yum -y install gcc automake autoconf libtool make</span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> /database &amp;&amp; <span class="built_in">cd</span> /database</span><br><span class="line"><span class="comment"># 下载源码</span></span><br><span class="line">wget https://download.redis.io/releases/redis-6.0.10.tar.gz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar xzf redis-6.0.10.tar.gz</span><br><span class="line"><span class="comment"># 进入目录</span></span><br><span class="line"><span class="built_in">cd</span> redis-6.0.10</span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export PATH=/databases/redis-6.0.10/src:<span class="variable">$PATH</span>&quot;</span> &gt;&gt; /etc/profile  &amp;&amp; <span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
<p>安装成功，如下图</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmmgwgimywj30tu050jrs.jpg" alt="" /></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># src/redis-server &amp; </span></span><br><span class="line">src/redis-cli</span><br><span class="line">redis&gt; <span class="built_in">set</span> foo bar</span><br><span class="line">OK</span><br><span class="line">redis&gt; get foo</span><br><span class="line"><span class="string">&quot;bar&quot;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmmhgt73evj30ji07gq3a.jpg" alt="" /></p>
<blockquote>
<p>温馨提示：</p>
<p>若编译失败，请检查<code>gcc</code>版本(可使用<code>gcc -v</code>)查看</p>
<p>我这里的是9.0.1</p>
</blockquote>
<h3 id="包管理工具安装"><a class="markdownIt-Anchor" href="#包管理工具安装"></a> 包管理工具安装</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get -y update &amp;&amp; apt-get -y upgrade &amp;&amp; apt-get -y dist-upgrade </span><br><span class="line">apt install -y  software-properties-common</span><br><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:redislabs/redis</span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install redis</span><br></pre></td></tr></table></figure>
<p>Referer</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9yZWRpcy5pby8=">Redis官网<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5yZWRpcy5jbi8=">Redis中文文档<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>redis</category>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Reset VsCode config</title>
    <url>/54811.html</url>
    <content><![CDATA[<h2 id="重置-visual-studio-code所有配置"><a class="markdownIt-Anchor" href="#重置-visual-studio-code所有配置"></a> 重置 Visual Studio Code所有配置</h2>
<p>随着使用期限的增长，各种问题便逐渐出现啦。当我们对于Visual Studio Code因为配置问题而造成使用不适，此处有一剂良药——初始化配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf ~/.vscode</span><br><span class="line">rm -rf ~/Library/Application\ Support/Code</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mac</category>
        <category>vscode</category>
        <category>Visual Studio Code</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL,何必在忆之一(索引与执行计划篇)</title>
    <url>/18675.html</url>
    <content><![CDATA[<h2 id="b-tree"><a class="markdownIt-Anchor" href="#b-tree"></a> B Tree</h2>
<h3 id="b树的种类"><a class="markdownIt-Anchor" href="#b树的种类"></a> B树的种类</h3>
<ul>
<li>B Tree</li>
<li>B+ Tree</li>
<li>B* Tree</li>
</ul>
<h3 id="b-树的定义"><a class="markdownIt-Anchor" href="#b-树的定义"></a> B 树的定义</h3>
<span id="more"></span>
<p><strong>B树</strong><br />
（英语：B-tree）是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk3JUI2JUU5JTk3JUI0JUU1JUE0JThEJUU2JTlEJTgyJUU1JUJBJUE2IyVFNSVBRiVCOSVFNiU5NSVCMCVFNiU5NyVCNiVFOSU5NyVCNA==">对数时间<i class="fa fa-external-link-alt"></i></span><br />
内完成。B树，概括来说是一个一般化的<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJBJThDJUU1JTg1JTgzJUU2JTkwJTlDJUU1JUIwJThCJUU2JUE4JUI5">二叉查找树<i class="fa fa-external-link-alt"></i></span>（binary<br />
search<br />
tree）一个节点可以拥有2个以上的子节点。与<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JTg3JUFBJUU1JUI5JUIzJUU4JUExJUExJUU0JUJBJThDJUU1JThGJTg5JUU2JTlGJUE1JUU2JTg5JUJFJUU2JUEwJTkx">自平衡二叉查找树<i class="fa fa-external-link-alt"></i></span><br />
不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk1JUIwJUU2JThEJUFFJUU1JUJBJTkz">数据库<i class="fa fa-external-link-alt"></i></span><br />
和<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk2JTg3JUU0JUJCJUI2JUU3JUIzJUJCJUU3JUJCJTlG">文件系统<i class="fa fa-external-link-alt"></i></span>的实现上。</p>
<p>三阶B树如下图所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmk5199byij313u0g6mzl.jpg" alt="" /></p>
<p>采用树形状结构，采用链表进行划分，这样就可以大量减少查询IO(且平均)，以上图为例子，等值的查询，需要三次IO，且仅要三次。</p>
<p>增加、删除、插入、搜索其之间的关系如下表所示</p>
<p>| 算法 |  <strong>平均</strong>  |  <strong>最差</strong>  | | :–: | :--------: | :--------: | | 空间 | O(<em>n</em>)   | O(<br />
<em>n</em>)   | | 搜索 | O(log <em>n</em>) | O(log *<br />
n*) | | 插入 | O(log <em>n</em>) | O(log <em>n</em>) | | 删除 | O(log <em>n</em>) | O(log <em>n</em>) |</p>
<p><strong>B树运用的理念</strong></p>
<ul>
<li>保持键值有序，以顺序遍历</li>
<li>使用层次化的索引来最小化磁盘读取</li>
<li>使用不完全填充的块来加速插入和删除</li>
<li>通过优雅的遍历算法来保持索引平衡</li>
</ul>
<p>另外，B树通过保证内部节点至少半满来最小化空间浪费。一棵B树可以处理任意数目的插入和删除。</p>
<p><strong>B树的弊端</strong></p>
<ul>
<li>除非完全重建数据库，否则无法改变键值的最大长度。这使得许多数据库系统将人名截断到70字符之内。</li>
</ul>
<h3 id="b树"><a class="markdownIt-Anchor" href="#b树"></a> B+树</h3>
<p>B+树是B树的一种变形，比B树具有更广泛的应用，m阶 B+树有如下特征:</p>
<ol>
<li>每个结点的关键字个数与孩子个数相等，所有非最下层的内层结点的关键字是对应子树上的最大关键字，最下层内部结点包含了全部关键字.</li>
<li>除根结点以外，每个内部结点有<code>M/2</code> 到m个孩子.</li>
<li>所有叶结点在树结构的同一层，并且不含任何信息(可看成是外部结点或查找失败的结点)，因此，树结构总是树高平衡的。</li>
</ol>
<p>在B+树，这些键值的拷贝被存储在内部节点；键值和记录存储在叶子节点；另外，一个叶子节点可以包含一个指针，指向另一个叶子节点以加速顺序存取。</p>
<p>如图</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmk5zbc02dj30ta0cmaa0.jpg" alt="" /></p>
<p>一颗m阶的B+树和m阶的B_树的差异在于：</p>
<p>1.有n棵子树的结点中含有n个关键字； (而B树是n棵子树有n-1个关键字)</p>
<p>2.所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。(<br />
而B树的叶子节点并没有包括全部需要查找的信息)</p>
<p>3.<em><strong>*所有的非终端结点可以看成是索引部分*</strong></em>，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B<br />
树的非终节点也包含需要查找的有效信息)</p>
<blockquote></blockquote>
<p>B＋树的主要优点：非终端结点仅仅起高层索引作用，而B树非终端结点的关键字除作子树分界外，本身还是实际记录的有效关键字（含记录指针），因此相同的结点空间，B＋树可以设计的阶树比B树大，相同的索引，B＋树的索引层数比B树少，因此检索速度比B树快。此外，B＋树叶子结点包含完整的索引信息，可以较方便地表示文件的稀疏索引。最后，B＋树的检索、插入和删除都在叶子结点进行，比B树相对简单</p>
<h3 id="b树比b树更适合数据库索引"><a class="markdownIt-Anchor" href="#b树比b树更适合数据库索引"></a> B+树比B树更适合数据库索引？</h3>
<p>1、B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</p>
<p>2、B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
<p>3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。</p>
<h3 id="b树-2"><a class="markdownIt-Anchor" href="#b树-2"></a> B*树</h3>
<p><img data-src="http://static.oschina.net/uploads/space/2011/0509/171056_sAnR_135650.jpg" alt="" /></p>
<p>B<em>树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；B</em>树定义了非叶子结点关键字个数至少为(<br />
2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）。</p>
<blockquote></blockquote>
<p>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</p>
<blockquote>
<p>B*</p>
</blockquote>
<p>树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；</p>
<h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3>
<p>B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；</p>
<p>B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p>
<p>B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p>
<p>B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3</p>
<blockquote>
<p>这里更加具体的有待探究，欢迎大佬批评与指点</p>
</blockquote>
<h2 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h2>
<h3 id="索引的概念"><a class="markdownIt-Anchor" href="#索引的概念"></a> 索引的概念</h3>
<p>为了更快与查询，例如寻找书中的一页内容，我们可以先从目录进行塞选、从而加快查找的效率</p>
<h3 id="索引的种类算法"><a class="markdownIt-Anchor" href="#索引的种类算法"></a> 索引的种类(算法)</h3>
<ul>
<li>B树索引 --&gt; B+Tree --&gt; B* Tree</li>
<li>Hash索引</li>
<li>R树</li>
<li>Full text</li>
<li>GIS</li>
</ul>
<h3 id="聚簇索引b树结构"><a class="markdownIt-Anchor" href="#聚簇索引b树结构"></a> 聚簇索引B树结构</h3>
<p>区 extend =&gt; 簇 =&gt; 64 pages -&gt; 1MB</p>
<p><strong>构建前提</strong></p>
<ul>
<li>建表时，指定了主键列，MySQL InnoDB会将主键作为聚簇索引列，比如 ID NOT NULL Primary Key</li>
<li>如果没有主键,会选择唯一(unique)的列，作为聚集索引.</li>
<li>以上均没有会生成隐藏的聚簇索引</li>
</ul>
<p><strong>作用</strong></p>
<ul>
<li>有了聚簇索引后，将插入的数据行，都会按照Id值的顺序，<code>有序</code>在磁盘存储数据</li>
</ul>
<h3 id="辅助索引b树结构"><a class="markdownIt-Anchor" href="#辅助索引b树结构"></a> 辅助索引B树结构</h3>
<blockquote>
<p>使用普通的列作为条件构建的索引，需要认为创建</p>
</blockquote>
<p><strong>种类</strong></p>
<ul>
<li>
<p>普通的单列辅助索引</p>
</li>
<li>
<p>联合索引（多个列作为索引条件,生成索引树,理论上设计的好的,可以减少大量的回表查询)</p>
<ul>
<li>注意最左原则</li>
<li>建立联合索引时，选择重复值少的列。作为最左列</li>
</ul>
</li>
<li>
<p>唯一索引（索引列的值都是唯一的.）</p>
</li>
</ul>
<p><strong>作用</strong></p>
<p>优化非聚簇索引列之外的查询优化</p>
<p><strong>构建过程</strong></p>
<ol>
<li>索引是基于表中,列(索引键)的值生成的B树结构</li>
<li>首先提取此列所有的值,进行自动排序</li>
<li>将排好序的值,均匀的分布到索引树的叶子节点中(16K)</li>
<li>然后生成此索引键值所对应得后端数据页的指针</li>
<li>生成枝节点和根节点,根据数据量级和索引键长度,生成合适的索引树高度</li>
</ol>
<p><strong>前缀索引</strong></p>
<p>当选取的索引列值过长，造成索引树增高，此时我们就需要使用前缀索引</p>
<h3 id="索引管理"><a class="markdownIt-Anchor" href="#索引管理"></a> 索引管理</h3>
<p><strong>什么时候创建索引？</strong></p>
<p>按业务所需创建合适的索引，并不是索引越多越好，将索引建立在经常<code>where</code>\<code>group by</code>\<code>order by</code>\<code>join on</code><br />
的条件</p>
<p><strong>为什么随意建立索引？</strong></p>
<p>如果冗余索引过多，表的数据发生变化的时候，导致索引频繁更新，造成锁</p>
<p>索引过多会造成优化器选择偏差</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查询表索引</span><br><span class="line">desc table_name</span><br><span class="line">show index from table_name</span><br><span class="line"># PRI 聚簇索引、MUL辅助索引、 UNI索引</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建索引</span><br><span class="line">create index idx_name1 on city(name);</span><br><span class="line">alter table student add index idx_name(name)</span><br><span class="line"></span><br><span class="line"># 联合索引</span><br><span class="line">alter table city add index idx_co_po(countrycode,population);</span><br><span class="line"># 前缀索引</span><br><span class="line">alter table city add index idx_di(district(5));</span><br><span class="line"># 唯一索引</span><br><span class="line">alter table city add unique index idx_uni1(name);</span><br><span class="line"></span><br><span class="line"># 删除索引</span><br><span class="line">alter table city drop index Index_Name</span><br></pre></td></tr></table></figure>
<h3 id="小结-2"><a class="markdownIt-Anchor" href="#小结-2"></a> 小结</h3>
<ul>
<li>聚集索引只能有一个,非空唯一,一般时主键</li>
<li>辅助索引,可以有多个,时配合聚集索引使用的</li>
<li>聚集索引叶子节点,就是磁盘的数据行存储的数据页</li>
<li>MySQL是根据聚集索引,组织存储数据,数据存储时就是按照聚集索引的顺序进行存储数据</li>
<li>辅助索引,只会提取索引键值,进行自动排序生成B树结构</li>
</ul>
<p><strong>建索引原则</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>) 必须要有主键,如果没有可以做为主键条件的列,创建无关列</span><br><span class="line">(<span class="number">2</span>) 经常做为<span class="keyword">where</span>条件列  order <span class="keyword">by</span>  <span class="keyword">group</span> <span class="keyword">by</span>  <span class="keyword">join</span> <span class="keyword">on</span>, distinct 的条件(业务:产品功能+用户行为)</span><br><span class="line">(<span class="number">3</span>) 最好使用唯一值多的列作为索引,如果索引列重复值较多,可以考虑使用联合索引</span><br><span class="line">(<span class="number">4</span>) 列值长度较长的索引列,我们建议使用前缀索引.</span><br><span class="line">(<span class="number">5</span>) 降低索引条目,一方面不要创建没用索引,不常使用的索引清理,<span class="function">percona <span class="title">toolkit</span>(<span class="params">xxxxx</span>)</span></span><br><span class="line"><span class="function">(<span class="params"><span class="number">6</span></span>) 索引维护要避开业务繁忙期</span></span><br></pre></td></tr></table></figure>
<p><strong>关于索引树的高度受什么影响</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 数据量级, 解决方法:分表,分库,分布式</span><br><span class="line"><span class="number">2.</span> 索引列值过长 , 解决方法:前缀索引</span><br><span class="line"><span class="number">3.</span> 数据类型:</span><br><span class="line">变长长度字符串,使用了<span class="built_in">char</span>,解决方案:变长字符串使用varchar</span><br><span class="line"><span class="built_in">enum</span>类型的使用<span class="built_in">enum</span> (<span class="string">&#x27;山东&#x27;</span>,<span class="string">&#x27;河北&#x27;</span>,<span class="string">&#x27;黑龙江&#x27;</span>,<span class="string">&#x27;吉林&#x27;</span>,<span class="string">&#x27;辽宁&#x27;</span>,<span class="string">&#x27;陕西&#x27;</span>......)</span><br><span class="line">                                         <span class="number">1</span>      <span class="number">2</span>      <span class="number">3</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<h2 id="执行计划获取及分析"><a class="markdownIt-Anchor" href="#执行计划获取及分析"></a> 执行计划获取及分析</h2>
<blockquote>
<p>执行计划： 优化器按照内置的cost计算，选择执行的方案</p>
<p>cost：IO、CPU、MEM</p>
</blockquote>
<p>获取到的是优化器选择完成认为代价最小的执行计划. 作用: 语句执行前,先看执行计划信息,可以有效的防止性能较差的语句带来的性能问题.<br />
如果业务中出现了慢语句，我们也需要借助此命令进行语句的评估，分析优化方案。</p>
<p><strong>select 获取数据的方法</strong></p>
<p>全表扫描(应当尽量避免,因为性能低)</p>
<p>索引扫描</p>
<p>获取不到数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看执行计划</span><br><span class="line">desc </span><br><span class="line">explain  </span><br><span class="line"># desc(explain) select * from sr_paper</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmlbo3s5wmj319e02sgln.jpg" alt="" /></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"># 需关注点</span><br><span class="line">table      ：此次查询涉及的表</span><br><span class="line">type      : 查询类型：全表(一般来说有问题，重点关注)、索引(详细探究)</span><br><span class="line">possible_keys  ：可能会用的索引</span><br><span class="line">key       : 最后选择的索引</span><br><span class="line">key_len     ： 索引覆盖长度</span><br><span class="line">rows      : 此次查询需要扫描的行数</span><br><span class="line">Extra      ：额外的信息</span><br><span class="line"></span><br><span class="line"># 输出介绍</span><br><span class="line">type： ALL(全表扫描) &gt; index(全索引扫描) &gt; range(索引范围查询) &gt; ref(辅助索引等值查询\非唯一索引扫描) &gt; eq_ref(唯一索引扫描) &gt; <span class="keyword">const</span>(system)结果只有一条主键或唯一索引扫描</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0k838iw2ij223g0s6adu.jpg" alt="image-20220323231549044" /></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2Vycnljb2RlL3AvOTkwOTA5My5odG1s">https://www.cnblogs.com/kerrycode/p/9909093.html<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>DBMS</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Supervisor-程序管理更加得心应手</title>
    <url>/9129.html</url>
    <content><![CDATA[<h2 id="supervisor初探篇"><a class="markdownIt-Anchor" href="#supervisor初探篇"></a> Supervisor初探篇</h2>
<h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3>
<p>Supervisor是一个客户机/服务器系统(也就是非常经典的C/S结构)，它允许用户在类UNIX操作系统上<code>控制</code>许多进程。</p>
<span id="more"></span>
<h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3>
<ul>
<li>
<p><strong>简单便捷</strong></p>
<blockquote>
<p>通过简单易懂的配置文件配置Supervisor，即可对任务的管理与监控，它提供了重新启动失败的进程和自动日志轮换等功能。</p>
</blockquote>
</li>
<li>
<p><strong>集中</strong></p>
<blockquote>
<p>提供了一个开始，停止和监视的地方。可以单独或成组控制过程。配置Supervisor以提供本地或远程命令行和Web界面。</p>
</blockquote>
</li>
<li>
<p><strong>高效</strong></p>
<blockquote>
<p>通过fork / exec启动其子进程，并且子进程不守护。进程终止时，操作系统会立即向Supervisor发送信号</p>
</blockquote>
</li>
<li>
<p>可扩展</p>
<blockquote>
<p>Supervisor具有一个简单的事件通知协议，该协议可以使用任何语言编写的程序对其进行监视，并且具有用于控制的XML-RPC接口</p>
</blockquote>
</li>
<li>
<p>兼容强</p>
<blockquote>
<p>除Windows之外，Supervisor几乎适用于所有事物。它已在Linux，Mac OS<br />
X，Solaris和FreeBSD上经过测试和支持。它完全用Python编写</p>
</blockquote>
</li>
<li>
<p>久经考验</p>
<blockquote>
<p>尽管Supervisor如今非常活跃，但它不是新软件。Supervisor已经存在了很多年，并且已经在许多服务器上使用</p>
</blockquote>
</li>
</ul>
<p>听我说了这么多，相信你也和我一样迫不及待想了解它。嘿呀，不要着急。在学习使用它之前，我们对它的基础组成有个了解，以便于稍后更加得心应手的使用</p>
<h3 id="主要组件"><a class="markdownIt-Anchor" href="#主要组件"></a> 主要组件</h3>
<ul>
<li>supervisord</li>
<li>supervisorctl</li>
<li>Web Server</li>
<li>XML-RPC Interface</li>
</ul>
<p>在简介中提到<code>Supervisor是一个客户机/服务器系统(也就是非常经典的C/S结构)</code>,那么也在此介绍一下各个组件</p>
<p><strong>Supervisord:</strong> 服务端的主管被称为<strong>supervisord</strong><br />
。它负责自行调用启动子程序，响应来自客户端的命令，重新启动崩溃或退出的子进程，记录其子进程<code>stdout</code><br />
和<code>stderr</code><br />
输出以及生成和处理与子进程生存期中的点相对应的“事件”。</p>
<blockquote>
<p>服务器进程使用的配置文件位于<code>/etc/supervisord.conf中</code>，通过适当的文件系统权限确保此文件的安全(<br />
它包含未加密的用户名和密码,它可能是我们服务器的root密码)</p>
</blockquote>
<p><strong>Supervisorctl</strong>:客户端的主管被称为 <strong>supervisorctl</strong>,<br />
它提供了类似于shell的界面,以便于我们使用命令对服务端的主管进行管理与控制。从supervisorctl我们可以连接到不同的supervisord进程（一次一个），获取受其控制的子进程的状态，停止和启动子进程，以及获取正在运行的supervisord进程的列表</p>
<blockquote></blockquote>
<p>命令行客户机通过UNIX域套接字或internet（TCP）套接字与服务器通信。服务器可以断言客户端的用户应该在允许他执行命令之前提供身份验证凭据。客户机进程通常使用与服务器相同的配置文件，但是任何带有[supervisorctl]<br />
节的配置文件都可以工作。</p>
<p>如果在internet套接字上启动supervisord，则可以通过浏览器访问功能类似于supervisorctl<br />
web用户界面。访问服务器URL（例如。<span class="exturl" data-url="aHR0cDovL2lwJUVGJUJDJTlBcHJvdCVFRiVCQyU4OSVFNiVCRiU4MCVFNiVCNCVCQiVFOSU4NSU4RCVFNyVCRCVBRSVFNiU5NiU4NyVFNCVCQiVCNiVFNyU5QSU4NCU1QmluZXQ=">http://ip：prot）激活配置文件的[inet<i class="fa fa-external-link-alt"></i></span> http server]<br />
部分后，通过web界面查看和控制进程状态。</p>
<p><strong>XML-RPC接口</strong>：服务于Web<br />
UI的同一HTTP服务器提供XML-RPC接口，该接口可用于询问和控制管理程序及其运行的程序。<a href="http://supervisord.org/api.html#xml-rpc"><em>XML-RPC<br />
API文档</em></a>。</p>
<hr />
<h2 id="supervisor使用技巧篇"><a class="markdownIt-Anchor" href="#supervisor使用技巧篇"></a> Supervisor使用技巧篇</h2>
<h3 id="supervisor的安装"><a class="markdownIt-Anchor" href="#supervisor的安装"></a> Supervisor的安装</h3>
<p>supervisor支持了大多包管理工具进行安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pip(推荐)</span></span><br><span class="line">pip install supervisor</span><br><span class="line"><span class="comment"># mac </span></span><br><span class="line">brew install supervisor</span><br><span class="line"><span class="comment"># ubantu</span></span><br><span class="line">apt install supervisor</span><br><span class="line"><span class="comment"># centos</span></span><br><span class="line">yum install supervisor</span><br></pre></td></tr></table></figure>
<h3 id="supervisor的使用"><a class="markdownIt-Anchor" href="#supervisor的使用"></a> Supervisor的使用</h3>
<p>这里我们建立一个测试用的py文件，如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> uniform</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        logger.info(i)</span><br><span class="line">        randomTime = uniform(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        logger.info(<span class="string">f&#x27;Sleep <span class="subst">&#123;randomTime&#125;</span>s&#x27;</span>)</span><br><span class="line">        time.sleep(randomTime)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">10</span>:</span><br><span class="line">            sys.exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此时可以正常运行</p>
<blockquote>
<p>温馨提示：这样的死循环记得一定要给休眠或者退出条件，要不将会有快乐的事情发生哦</p>
</blockquote>
<p>运行如下</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gml27kbhxdj30z20u0tbj.jpg" alt="" /></p>
<p><strong>对接Supervisor</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># supervisord.conf</span></span><br><span class="line">[supervisord]</span><br><span class="line">nodaemon=<span class="literal">true</span>         ;守护进程，默认fales</span><br><span class="line">logfile_maxbytes=50MB        ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小</span><br><span class="line">logfile_backups=10           ;日志文件保留备份数量默认10，设为0表示不备份</span><br><span class="line">loglevel=debug               ;日志级别，默认info，其它: debug,warn,trace</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[program:demo]</span><br><span class="line">process_name=tester</span><br><span class="line"><span class="built_in">command</span>=python3 demo.py</span><br><span class="line">autostart=<span class="literal">true</span>       ; 在supervisord启动的时候也自动启动</span><br><span class="line">startsecs=10         ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒</span><br></pre></td></tr></table></figure>
<p>使用<code>supervisord -c supervisord.conf</code>，运行程序。</p>
<p>输出日志入下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-01-12 17:57:21,705 INFO supervisord started with pid 1257</span><br><span class="line">2021-01-12 17:57:22,712 INFO spawned: &#x27;tester&#x27; with pid 1260</span><br><span class="line">2021-01-12 17:57:22,856 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:22.855 | INFO     | __main__:test:10 - 0</span><br><span class="line">2021-01-12 17:57:22.856 | INFO     | __main__:test:12 - Sleep 0.681474110840254s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:23,542 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:23.541 | INFO     | __main__:test:10 - 1</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:23,542 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:23.541 | INFO     | __main__:test:12 - Sleep 0.34284895238537105s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:23,887 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:23.886 | INFO     | __main__:test:10 - 2</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:23,887 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:23.887 | INFO     | __main__:test:12 - Sleep 0.08220508414530214s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:23,970 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:23.969 | INFO     | __main__:test:10 - 3</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:23,971 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:23.970 | INFO     | __main__:test:12 - Sleep 0.39740491822333646s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:24,372 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:24.371 | INFO     | __main__:test:10 - 4</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:24,372 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:24.371 | INFO     | __main__:test:12 - Sleep 0.9054854146830564s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:25,280 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:25.279 | INFO     | __main__:test:10 - 5</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:25,281 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:25.280 | INFO     | __main__:test:12 - Sleep 0.4563320839294708s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:25,742 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:25.741 | INFO     | __main__:test:10 - 6</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:25,742 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:25.741 | INFO     | __main__:test:12 - Sleep 0.19482948337371853s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:25,939 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:25.938 | INFO     | __main__:test:10 - 7</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:25,940 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:25.939 | INFO     | __main__:test:12 - Sleep 0.7755167696398192s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:26,719 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:26.718 | INFO     | __main__:test:10 - 8</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:26,719 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:26.718 | INFO     | __main__:test:12 - Sleep 0.24748008436152524s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:26,972 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:26.971 | INFO     | __main__:test:10 - 9</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:26,973 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:26.972 | INFO     | __main__:test:12 - Sleep 0.6178291278890581s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:27,607 DEBG fd 13 closed, stopped monitoring &lt;POutputDispatcher at 140666266690064 for &lt;Subprocess at 140666266191824 with name tester in state STARTING&gt; (stderr)&gt;</span><br><span class="line">2021-01-12 17:57:27,607 DEBG fd 11 closed, stopped monitoring &lt;POutputDispatcher at 140666266190928 for &lt;Subprocess at 140666266191824 with name tester in state STARTING&gt; (stdout)&gt;</span><br><span class="line">2021-01-12 17:57:27,608 INFO exited: tester (exit status 0; not expected)</span><br><span class="line">2021-01-12 17:57:27,608 DEBG received SIGCHLD indicating a child quit</span><br><span class="line">2021-01-12 17:57:28,613 INFO spawned: &#x27;tester&#x27; with pid 1263</span><br><span class="line">2021-01-12 17:57:28,720 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:28.719 | INFO     | __main__:test:10 - 0</span><br><span class="line">2021-01-12 17:57:28.720 | INFO     | __main__:test:12 - Sleep 0.8226218737496696s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:29,543 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:29.542 | INFO     | __main__:test:10 - 1</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:29,544 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:29.543 | INFO     | __main__:test:12 - Sleep 0.6507710747677439s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:30,195 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:30.195 | INFO     | __main__:test:10 - 2</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:30,196 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:30.195 | INFO     | __main__:test:12 - Sleep 0.3645783421505362s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:30,565 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:30.564 | INFO     | __main__:test:10 - 3</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:30,565 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:30.565 | INFO     | __main__:test:12 - Sleep 0.47083797385643844s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:31,037 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:31.036 | INFO     | __main__:test:10 - 4</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:31,037 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:31.037 | INFO     | __main__:test:12 - Sleep 0.4875197581833751s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:31,531 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:31.530 | INFO     | __main__:test:10 - 5</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:31,531 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:31.530 | INFO     | __main__:test:12 - Sleep 0.9094546698090918s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:32,444 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:32.443 | INFO     | __main__:test:10 - 6</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:32,445 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:32.444 | INFO     | __main__:test:12 - Sleep 0.47064821128443857s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:32,921 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:32.920 | INFO     | __main__:test:10 - 7</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:32,922 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:32.921 | INFO     | __main__:test:12 - Sleep 0.7673175029063347s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:33,691 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:33.690 | INFO     | __main__:test:10 - 8</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:33,692 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:33.691 | INFO     | __main__:test:12 - Sleep 0.9317641783846109s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:34,625 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:34.624 | INFO     | __main__:test:10 - 9</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:34,625 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:34.625 | INFO     | __main__:test:12 - Sleep 0.2558276039626808s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:34,899 DEBG fd 13 closed, stopped monitoring &lt;POutputDispatcher at 140666266690000 for &lt;Subprocess at 140666266191824 with name tester in state STARTING&gt; (stderr)&gt;</span><br><span class="line">2021-01-12 17:57:34,899 DEBG fd 11 closed, stopped monitoring &lt;POutputDispatcher at 140666266689872 for &lt;Subprocess at 140666266191824 with name tester in state STARTING&gt; (stdout)&gt;</span><br><span class="line">2021-01-12 17:57:34,899 INFO exited: tester (exit status 0; not expected)</span><br><span class="line">2021-01-12 17:57:34,900 DEBG received SIGCHLD indicating a child quit</span><br><span class="line">2021-01-12 17:57:36,912 INFO spawned: &#x27;tester&#x27; with pid 1264</span><br><span class="line">2021-01-12 17:57:37,022 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:37.021 | INFO     | __main__:test:10 - 0</span><br><span class="line">2021-01-12 17:57:37.021 | INFO     | __main__:test:12 - Sleep 0.5475564566091946s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:37,572 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:37.571 | INFO     | __main__:test:10 - 1</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:37,573 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:37.572 | INFO     | __main__:test:12 - Sleep 0.6326087978849619s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:38,207 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:38.206 | INFO     | __main__:test:10 - 2</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:38,207 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:38.207 | INFO     | __main__:test:12 - Sleep 0.3225720045649825s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:38,531 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:38.530 | INFO     | __main__:test:10 - 3</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:38,531 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:38.530 | INFO     | __main__:test:12 - Sleep 0.5121026075892807s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:39,044 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:39.043 | INFO     | __main__:test:10 - 4</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:39,045 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:39.044 | INFO     | __main__:test:12 - Sleep 0.6613469797067474s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:39,710 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:39.709 | INFO     | __main__:test:10 - 5</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:39,710 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:39.709 | INFO     | __main__:test:12 - Sleep 0.5058071583137449s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:40,220 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:40.219 | INFO     | __main__:test:10 - 6</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:40,220 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:40.219 | INFO     | __main__:test:12 - Sleep 0.2779679640725812s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:40,502 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:40.502 | INFO     | __main__:test:10 - 7</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:40,503 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:40.502 | INFO     | __main__:test:12 - Sleep 0.7282026322383534s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:41,231 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:41.231 | INFO     | __main__:test:10 - 8</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:41,232 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:41.231 | INFO     | __main__:test:12 - Sleep 0.37634579152866654s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:41,610 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:41.610 | INFO     | __main__:test:10 - 9</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:41,610 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:41.610 | INFO     | __main__:test:12 - Sleep 0.02539488384007338s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:41,660 DEBG fd 13 closed, stopped monitoring &lt;POutputDispatcher at 140666266690256 for &lt;Subprocess at 140666266191824 with name tester in state STARTING&gt; (stderr)&gt;</span><br><span class="line">2021-01-12 17:57:41,660 DEBG fd 11 closed, stopped monitoring &lt;POutputDispatcher at 140666266689872 for &lt;Subprocess at 140666266191824 with name tester in state STARTING&gt; (stdout)&gt;</span><br><span class="line">2021-01-12 17:57:41,660 INFO exited: tester (exit status 0; not expected)</span><br><span class="line">2021-01-12 17:57:41,660 DEBG received SIGCHLD indicating a child quit</span><br><span class="line">2021-01-12 17:57:44,666 INFO spawned: &#x27;tester&#x27; with pid 1265</span><br><span class="line">2021-01-12 17:57:44,775 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:44.774 | INFO     | __main__:test:10 - 0</span><br><span class="line">2021-01-12 17:57:44.774 | INFO     | __main__:test:12 - Sleep 0.540035521075991s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:45,315 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:45.315 | INFO     | __main__:test:10 - 1</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:45,316 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:45.315 | INFO     | __main__:test:12 - Sleep 0.6011099895313317s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:45,922 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:45.921 | INFO     | __main__:test:10 - 2</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:45,923 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:45.922 | INFO     | __main__:test:12 - Sleep 0.5954410741418728s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:46,521 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:46.520 | INFO     | __main__:test:10 - 3</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:46,521 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:46.521 | INFO     | __main__:test:12 - Sleep 0.10471143983800468s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:46,631 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:46.630 | INFO     | __main__:test:10 - 4</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:46,632 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:46.631 | INFO     | __main__:test:12 - Sleep 0.12704017263351186s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:46,759 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:46.758 | INFO     | __main__:test:10 - 5</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:46,760 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:46.759 | INFO     | __main__:test:12 - Sleep 0.26222866859817395s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:47,025 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:47.025 | INFO     | __main__:test:10 - 6</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:47,026 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:47.025 | INFO     | __main__:test:12 - Sleep 0.31215837276333647s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:47,343 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:47.343 | INFO     | __main__:test:10 - 7</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:47,344 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:47.343 | INFO     | __main__:test:12 - Sleep 0.8863919731268238s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:48,230 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:48.230 | INFO     | __main__:test:10 - 8</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:48,230 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:48.230 | INFO     | __main__:test:12 - Sleep 0.6220607701794121s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:48,858 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:48.857 | INFO     | __main__:test:10 - 9</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:48,858 DEBG &#x27;tester&#x27; stderr output:</span><br><span class="line">2021-01-12 17:57:48.858 | INFO     | __main__:test:12 - Sleep 0.9545468958914863s</span><br><span class="line"></span><br><span class="line">2021-01-12 17:57:49,835 DEBG fd 13 closed, stopped monitoring &lt;POutputDispatcher at 140666266690128 for &lt;Subprocess at 140666266191824 with name tester in state STARTING&gt; (stderr)&gt;</span><br><span class="line">2021-01-12 17:57:49,835 DEBG fd 11 closed, stopped monitoring &lt;POutputDispatcher at 140666266689872 for &lt;Subprocess at 140666266191824 with name tester in state STARTING&gt; (stdout)&gt;</span><br><span class="line">2021-01-12 17:57:49,835 INFO exited: tester (exit status 0; not expected)</span><br><span class="line">2021-01-12 17:57:49,835 DEBG received SIGCHLD indicating a child quit</span><br><span class="line">2021-01-12 17:57:50,836 INFO gave up: tester entered FATAL state, too many start retries too quickly</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gml2i44gvnj327y0icwg0.jpg" alt="" /></p>
<h2 id="supervisor番外篇"><a class="markdownIt-Anchor" href="#supervisor番外篇"></a> Supervisor番外篇</h2>
<h3 id="supervisorctl常用命令"><a class="markdownIt-Anchor" href="#supervisorctl常用命令"></a> <strong>Supervisorctl常用命令</strong></h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># supervisorctl status：查看进程的状态</span></span><br><span class="line">supervisorctl status</span><br><span class="line">status &lt;name&gt;           Get status <span class="keyword">for</span> a single process</span><br><span class="line">status &lt;gname&gt;:*        Get status <span class="keyword">for</span> all processes <span class="keyword">in</span> a group</span><br><span class="line">status &lt;name&gt; &lt;name&gt;    Get status <span class="keyword">for</span> multiple named processes</span><br><span class="line">status                  Get all process status info</span><br><span class="line"></span><br><span class="line"><span class="comment"># supervisorctl start 启动进程</span></span><br><span class="line">start &lt;name&gt;            Start a process</span><br><span class="line">start &lt;gname&gt;:*         Start all processes <span class="keyword">in</span> a group</span><br><span class="line">start &lt;name&gt; &lt;name&gt;     Start multiple processes or <span class="built_in">groups</span></span><br><span class="line">start all               Start all processes</span><br><span class="line"></span><br><span class="line"><span class="comment"># supervisorctl stop 停止进程</span></span><br><span class="line">stop &lt;name&gt;             Stop a process</span><br><span class="line">stop &lt;gname&gt;:*          Stop all processes <span class="keyword">in</span> a group</span><br><span class="line">stop &lt;name&gt; &lt;name&gt;      Stop multiple processes or <span class="built_in">groups</span></span><br><span class="line">stop all                Stop all processes</span><br><span class="line"></span><br><span class="line"><span class="comment"># supervisorctl restart 重启进程</span></span><br><span class="line">restart &lt;name&gt;          Restart a process</span><br><span class="line">restart &lt;gname&gt;:*       Restart all processes <span class="keyword">in</span> a group</span><br><span class="line">restart &lt;name&gt; &lt;name&gt;   Restart multiple processes or <span class="built_in">groups</span></span><br><span class="line">restart all             Restart all processes</span><br><span class="line">Note: restart does not reread config files. For that, see reread and update.</span><br><span class="line"></span><br><span class="line"><span class="comment"># supervisorctl update 配置文件修改后可以使用该命令加载新的配置</span></span><br><span class="line">update                  Reload config and add/remove as necessary, and will restart affected programs</span><br><span class="line">update all              Reload config and add/remove as necessary, and will restart affected programs</span><br><span class="line">update &lt;gname&gt; [...]    Update specific <span class="built_in">groups</span></span><br><span class="line"></span><br><span class="line">supervisorctl reload: 重新启动配置中的所有程序</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多命令可 supervisorctl 进入终端。输入help(?)进行查看</span></span><br></pre></td></tr></table></figure>
<h3 id="supervisorctl-参数列表"><a class="markdownIt-Anchor" href="#supervisorctl-参数列表"></a> Supervisorctl 参数列表</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">supervisorctl -- control applications run by supervisord from the cmd line.</span><br><span class="line"></span><br><span class="line">Usage: /Users/stringle-004/opt/miniconda3/envs/Proxypool/bin/supervisorctl [options] [action [arguments]]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-c/--configuration FILENAME -- configuration file path (searches if not given)</span><br><span class="line">-h/--help -- print usage message and exit</span><br><span class="line">-i/--interactive -- start an interactive shell after executing commands</span><br><span class="line">-s/--serverurl URL -- URL on which supervisord server is listening</span><br><span class="line">     (default &quot;http://localhost:9001&quot;).</span><br><span class="line">-u/--username USERNAME -- username to use for authentication with server</span><br><span class="line">-p/--password PASSWORD -- password to use for authentication with server</span><br><span class="line">-r/--history-file -- keep a readline history (if readline is available)</span><br><span class="line"></span><br><span class="line">action [arguments] -- see below</span><br><span class="line"></span><br><span class="line">Actions are commands like &quot;tail&quot; or &quot;stop&quot;.  If -i is specified or no action is</span><br><span class="line">specified on the command line, a &quot;shell&quot; interpreting actions typed</span><br><span class="line">interactively is started.  Use the action &quot;help&quot; to find out about available</span><br><span class="line">actions.</span><br></pre></td></tr></table></figure>
<h3 id="supervisordconf配置文件示例"><a class="markdownIt-Anchor" href="#supervisordconf配置文件示例"></a> supervisord.conf配置文件示例</h3>
<p>使命令用<code>sudo echo_supervisord_conf &gt; supervisord.conf</code> 进行创建</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">; Sample supervisor config file.</span><br><span class="line">;</span><br><span class="line">; For more information on the config file, please see:</span><br><span class="line">; http://supervisord.org/configuration.html</span><br><span class="line">;</span><br><span class="line">; Notes:</span><br><span class="line">;  - Shell expansion (<span class="string">&quot;~&quot;</span> or <span class="string">&quot;<span class="variable">$HOME</span>&quot;</span>) is not supported.  Environment</span><br><span class="line">;    variables can be expanded using this syntax: <span class="string">&quot;%(ENV_HOME)s&quot;</span>.</span><br><span class="line">;  - Quotes around values are not supported, except <span class="keyword">in</span> the <span class="keyword">case</span> of</span><br><span class="line">;    the environment= options as shown below.</span><br><span class="line">;  - Comments must have a leading space: <span class="string">&quot;a=b ;comment&quot;</span> not <span class="string">&quot;a=b;comment&quot;</span>.</span><br><span class="line">;  - Command will be truncated <span class="keyword">if</span> it looks like a config file comment, e.g.</span><br><span class="line">;    <span class="string">&quot;command=bash -c &#x27;foo ; bar&#x27;&quot;</span> will <span class="built_in">truncate</span> to <span class="string">&quot;command=bash -c &#x27;foo &quot;</span>.</span><br><span class="line">;</span><br><span class="line">; Warning:</span><br><span class="line">;  Paths throughout this example file use /tmp because it is available on most</span><br><span class="line">;  systems.  You will likely need to change these to locations more appropriate</span><br><span class="line">;  <span class="keyword">for</span> your system.  Some systems periodically delete older files <span class="keyword">in</span> /tmp.</span><br><span class="line">;  Notably, <span class="keyword">if</span> the socket file defined <span class="keyword">in</span> the [unix_http_server] section below</span><br><span class="line">;  is deleted, supervisorctl will be unable to connect to supervisord.</span><br><span class="line"></span><br><span class="line">[unix_http_server]</span><br><span class="line">file=/tmp/supervisor.sock   ; the path to the socket file</span><br><span class="line">;<span class="built_in">chmod</span>=0700                 ; socket file mode (default 0700)</span><br><span class="line">;<span class="built_in">chown</span>=nobody:nogroup       ; socket file uid:gid owner</span><br><span class="line">;username=user              ; default is no username (open server)</span><br><span class="line">;password=123               ; default is no password (open server)</span><br><span class="line"></span><br><span class="line">; Security Warning:</span><br><span class="line">;  The inet HTTP server is not enabled by default.  The inet HTTP server is</span><br><span class="line">;  enabled by uncommenting the [inet_http_server] section below.  The inet</span><br><span class="line">;  HTTP server is intended <span class="keyword">for</span> use within a trusted environment only.  It</span><br><span class="line">;  should only be bound to localhost or only accessible from within an</span><br><span class="line">;  isolated, trusted network.  The inet HTTP server does not support any</span><br><span class="line">;  form of encryption.  The inet HTTP server does not use authentication</span><br><span class="line">;  by default (see the username= and password= options to add authentication).</span><br><span class="line">;  Never expose the inet HTTP server to the public internet.</span><br><span class="line"></span><br><span class="line">;[inet_http_server]         ; inet (TCP) server disabled by default</span><br><span class="line">;port=9001        ; ip_address:port specifier, *:port <span class="keyword">for</span> all iface</span><br><span class="line">;username=user              ; default is no username (open server)</span><br><span class="line">;password=123               ; default is no password (open server)</span><br><span class="line"></span><br><span class="line">[supervisord]</span><br><span class="line">logfile=/tmp/supervisord.log ; main <span class="built_in">log</span> file; default <span class="variable">$CWD</span>/supervisord.log</span><br><span class="line">logfile_maxbytes=50MB        ; max main logfile bytes b4 rotation; default 50MB</span><br><span class="line">logfile_backups=10           ; of main logfile backups; 0 means none, default 10</span><br><span class="line">loglevel=info                ; <span class="built_in">log</span> level; default info; others: debug,warn,trace</span><br><span class="line">pidfile=/tmp/supervisord.pid ; supervisord pidfile; default supervisord.pid</span><br><span class="line">nodaemon=<span class="literal">false</span>               ; start <span class="keyword">in</span> foreground <span class="keyword">if</span> <span class="literal">true</span>; default <span class="literal">false</span></span><br><span class="line">minfds=1024                  ; min. avail startup file descriptors; default 1024</span><br><span class="line">minprocs=200                 ; min. avail process descriptors;default 200</span><br><span class="line">;<span class="built_in">umask</span>=022                   ; process file creation <span class="built_in">umask</span>; default 022</span><br><span class="line">;user=supervisord            ; setuid to this UNIX account at startup; recommended <span class="keyword">if</span> root</span><br><span class="line">;identifier=supervisor       ; supervisord identifier, default is <span class="string">&#x27;supervisor&#x27;</span></span><br><span class="line">;directory=/tmp              ; default is not to <span class="built_in">cd</span> during start</span><br><span class="line">;nocleanup=<span class="literal">true</span>              ; don<span class="string">&#x27;t clean up tempfiles at start; default false</span></span><br><span class="line"><span class="string">;childlogdir=/tmp            ; &#x27;</span>AUTO<span class="string">&#x27; child log dir, default $TEMP</span></span><br><span class="line"><span class="string">;environment=KEY=&quot;value&quot;     ; key value pairs to add to environment</span></span><br><span class="line"><span class="string">;strip_ansi=false            ; strip ansi escape codes in logs; def. false</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">; The rpcinterface:supervisor section must remain in the config file for</span></span><br><span class="line"><span class="string">; RPC (supervisorctl/web interface) to work.  Additional interfaces may be</span></span><br><span class="line"><span class="string">; added by defining them in separate [rpcinterface:x] sections.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[rpcinterface:supervisor]</span></span><br><span class="line"><span class="string">supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">; The supervisorctl section configures how supervisorctl will connect to</span></span><br><span class="line"><span class="string">; supervisord.  configure it match the settings in either the unix_http_server</span></span><br><span class="line"><span class="string">; or inet_http_server section.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[supervisorctl]</span></span><br><span class="line"><span class="string">serverurl=unix:///tmp/supervisor.sock ; use a unix:// URL  for a unix socket</span></span><br><span class="line"><span class="string">;serverurl=http://127.0.0.1:9001 ; use an http:// url to specify an inet socket</span></span><br><span class="line"><span class="string">;username=chris              ; should be same as in [*_http_server] if set</span></span><br><span class="line"><span class="string">;password=123                ; should be same as in [*_http_server] if set</span></span><br><span class="line"><span class="string">;prompt=mysupervisor         ; cmd line prompt (default &quot;supervisor&quot;)</span></span><br><span class="line"><span class="string">;history_file=~/.sc_history  ; use readline history if available</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">; The sample program section below shows all possible program subsection values.</span></span><br><span class="line"><span class="string">; Create one or more &#x27;</span>real<span class="string">&#x27; program: sections to be able to control them under</span></span><br><span class="line"><span class="string">; supervisor.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;[program:theprogramname]</span></span><br><span class="line"><span class="string">;command=/bin/cat              ; the program (relative uses PATH, can take args)</span></span><br><span class="line"><span class="string">;process_name=%(program_name)s ; process_name expr (default %(program_name)s)</span></span><br><span class="line"><span class="string">;numprocs=1                    ; number of processes copies to start (def 1)</span></span><br><span class="line"><span class="string">;directory=/tmp                ; directory to cwd to before exec (def no cwd)</span></span><br><span class="line"><span class="string">;umask=022                     ; umask for process (default None)</span></span><br><span class="line"><span class="string">;priority=999                  ; the relative start priority (default 999)</span></span><br><span class="line"><span class="string">;autostart=true                ; start at supervisord start (default: true)</span></span><br><span class="line"><span class="string">;startsecs=1                   ; # of secs prog must stay up to be running (def. 1)</span></span><br><span class="line"><span class="string">;startretries=3                ; max # of serial start failures when starting (default 3)</span></span><br><span class="line"><span class="string">;autorestart=unexpected        ; when to restart if exited after running (def: unexpected)</span></span><br><span class="line"><span class="string">;exitcodes=0                   ; &#x27;</span>expected<span class="string">&#x27; exit codes used with autorestart (default 0)</span></span><br><span class="line"><span class="string">;stopsignal=QUIT               ; signal used to kill process (default TERM)</span></span><br><span class="line"><span class="string">;stopwaitsecs=10               ; max num secs to wait b4 SIGKILL (default 10)</span></span><br><span class="line"><span class="string">;stopasgroup=false             ; send stop signal to the UNIX process group (default false)</span></span><br><span class="line"><span class="string">;killasgroup=false             ; SIGKILL the UNIX process group (def false)</span></span><br><span class="line"><span class="string">;user=chrism                   ; setuid to this UNIX account to run the program</span></span><br><span class="line"><span class="string">;redirect_stderr=true          ; redirect proc stderr to stdout (default false)</span></span><br><span class="line"><span class="string">;stdout_logfile=/a/path        ; stdout log path, NONE for none; default AUTO</span></span><br><span class="line"><span class="string">;stdout_logfile_maxbytes=1MB   ; max # logfile bytes b4 rotation (default 50MB)</span></span><br><span class="line"><span class="string">;stdout_logfile_backups=10     ; # of stdout logfile backups (0 means none, default 10)</span></span><br><span class="line"><span class="string">;stdout_capture_maxbytes=1MB   ; number of bytes in &#x27;</span>capturemode<span class="string">&#x27; (default 0)</span></span><br><span class="line"><span class="string">;stdout_events_enabled=false   ; emit events on stdout writes (default false)</span></span><br><span class="line"><span class="string">;stdout_syslog=false           ; send stdout to syslog with process name (default false)</span></span><br><span class="line"><span class="string">;stderr_logfile=/a/path        ; stderr log path, NONE for none; default AUTO</span></span><br><span class="line"><span class="string">;stderr_logfile_maxbytes=1MB   ; max # logfile bytes b4 rotation (default 50MB)</span></span><br><span class="line"><span class="string">;stderr_logfile_backups=10     ; # of stderr logfile backups (0 means none, default 10)</span></span><br><span class="line"><span class="string">;stderr_capture_maxbytes=1MB   ; number of bytes in &#x27;</span>capturemode<span class="string">&#x27; (default 0)</span></span><br><span class="line"><span class="string">;stderr_events_enabled=false   ; emit events on stderr writes (default false)</span></span><br><span class="line"><span class="string">;stderr_syslog=false           ; send stderr to syslog with process name (default false)</span></span><br><span class="line"><span class="string">;environment=A=&quot;1&quot;,B=&quot;2&quot;       ; process environment additions (def no adds)</span></span><br><span class="line"><span class="string">;serverurl=AUTO                ; override serverurl computation (childutils)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">; The sample eventlistener section below shows all possible eventlistener</span></span><br><span class="line"><span class="string">; subsection values.  Create one or more &#x27;</span>real<span class="string">&#x27; eventlistener: sections to be</span></span><br><span class="line"><span class="string">; able to handle event notifications sent by supervisord.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;[eventlistener:theeventlistenername]</span></span><br><span class="line"><span class="string">;command=/bin/eventlistener    ; the program (relative uses PATH, can take args)</span></span><br><span class="line"><span class="string">;process_name=%(program_name)s ; process_name expr (default %(program_name)s)</span></span><br><span class="line"><span class="string">;numprocs=1                    ; number of processes copies to start (def 1)</span></span><br><span class="line"><span class="string">;events=EVENT                  ; event notif. types to subscribe to (req&#x27;</span>d)</span><br><span class="line">;buffer_size=10                ; event buffer queue size (default 10)</span><br><span class="line">;directory=/tmp                ; directory to cwd to before <span class="built_in">exec</span> (def no cwd)</span><br><span class="line">;<span class="built_in">umask</span>=022                     ; <span class="built_in">umask</span> <span class="keyword">for</span> process (default None)</span><br><span class="line">;priority=-1                   ; the relative start priority (default -1)</span><br><span class="line">;autostart=<span class="literal">true</span>                ; start at supervisord start (default: <span class="literal">true</span>)</span><br><span class="line">;startsecs=1                   ; <span class="comment"># of secs prog must stay up to be running (def. 1)</span></span><br><span class="line">;startretries=3                ; max <span class="comment"># of serial start failures when starting (default 3)</span></span><br><span class="line">;autorestart=unexpected        ; autorestart <span class="keyword">if</span> exited after running (def: unexpected)</span><br><span class="line">;exitcodes=0                   ; <span class="string">&#x27;expected&#x27;</span> <span class="built_in">exit</span> codes used with autorestart (default 0)</span><br><span class="line">;stopsignal=QUIT               ; signal used to <span class="built_in">kill</span> process (default TERM)</span><br><span class="line">;stopwaitsecs=10               ; max num secs to <span class="built_in">wait</span> b4 SIGKILL (default 10)</span><br><span class="line">;stopasgroup=<span class="literal">false</span>             ; send stop signal to the UNIX process group (default <span class="literal">false</span>)</span><br><span class="line">;killasgroup=<span class="literal">false</span>             ; SIGKILL the UNIX process group (def <span class="literal">false</span>)</span><br><span class="line">;user=chrism                   ; setuid to this UNIX account to run the program</span><br><span class="line">;redirect_stderr=<span class="literal">false</span>         ; redirect_stderr=<span class="literal">true</span> is not allowed <span class="keyword">for</span> eventlisteners</span><br><span class="line">;stdout_logfile=/a/path        ; stdout <span class="built_in">log</span> path, NONE <span class="keyword">for</span> none; default AUTO</span><br><span class="line">;stdout_logfile_maxbytes=1MB   ; max <span class="comment"># logfile bytes b4 rotation (default 50MB)</span></span><br><span class="line">;stdout_logfile_backups=10     ; <span class="comment"># of stdout logfile backups (0 means none, default 10)</span></span><br><span class="line">;stdout_events_enabled=<span class="literal">false</span>   ; emit events on stdout writes (default <span class="literal">false</span>)</span><br><span class="line">;stdout_syslog=<span class="literal">false</span>           ; send stdout to syslog with process name (default <span class="literal">false</span>)</span><br><span class="line">;stderr_logfile=/a/path        ; stderr <span class="built_in">log</span> path, NONE <span class="keyword">for</span> none; default AUTO</span><br><span class="line">;stderr_logfile_maxbytes=1MB   ; max <span class="comment"># logfile bytes b4 rotation (default 50MB)</span></span><br><span class="line">;stderr_logfile_backups=10     ; <span class="comment"># of stderr logfile backups (0 means none, default 10)</span></span><br><span class="line">;stderr_events_enabled=<span class="literal">false</span>   ; emit events on stderr writes (default <span class="literal">false</span>)</span><br><span class="line">;stderr_syslog=<span class="literal">false</span>           ; send stderr to syslog with process name (default <span class="literal">false</span>)</span><br><span class="line">;environment=A=<span class="string">&quot;1&quot;</span>,B=<span class="string">&quot;2&quot;</span>       ; process environment additions</span><br><span class="line">;serverurl=AUTO                ; override serverurl computation (childutils)</span><br><span class="line"></span><br><span class="line">; The sample group section below shows all possible group values.  Create one</span><br><span class="line">; or more <span class="string">&#x27;real&#x27;</span> group: sections to create <span class="string">&quot;heterogeneous&quot;</span> process <span class="built_in">groups</span>.</span><br><span class="line"></span><br><span class="line">;[group:thegroupname]</span><br><span class="line">;programs=progname1,progname2  ; each refers to <span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> [program:x] definitions</span><br><span class="line">;priority=999                  ; the relative start priority (default 999)</span><br><span class="line"></span><br><span class="line">; The [include] section can just contain the <span class="string">&quot;files&quot;</span> setting.  This</span><br><span class="line">; setting can list multiple files (separated by whitespace or</span><br><span class="line">; newlines).  It can also contain wildcards.  The filenames are</span><br><span class="line">; interpreted as relative to this file.  Included files *cannot*</span><br><span class="line">; include files themselves.</span><br><span class="line"></span><br><span class="line">;[include]</span><br><span class="line">;files = relative/directory/*.ini</span><br></pre></td></tr></table></figure>
<p>常用配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[unix_http_server]</span><br><span class="line">file=/tmp/supervisor.sock   ;UNIX socket 文件，supervisorctl 会使用</span><br><span class="line">;chmod=0700                 ;socket文件的mode，默认是0700</span><br><span class="line">;chown=nobody:nogroup       ;socket文件的owner，格式：uid:gid</span><br><span class="line"> </span><br><span class="line">;[inet_http_server]         ;HTTP服务器，提供web管理界面</span><br><span class="line">;port=9001             ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性</span><br><span class="line">;username=user              ;登录管理后台的用户名</span><br><span class="line">;password=123               ;登录管理后台的密码</span><br><span class="line"> </span><br><span class="line">[supervisord]</span><br><span class="line">logfile=/tmp/supervisord.log ;日志文件，默认是 $CWD/supervisord.log</span><br><span class="line">logfile_maxbytes=50MB        ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小</span><br><span class="line">logfile_backups=10           ;日志文件保留备份数量默认10，设为0表示不备份</span><br><span class="line">loglevel=info                ;日志级别，默认info，其它: debug,warn,trace</span><br><span class="line">pidfile=/tmp/supervisord.pid ;pid 文件</span><br><span class="line">nodaemon=false               ;是否在前台启动，默认是false，即以 daemon 的方式启动</span><br><span class="line">minfds=1024                  ;可以打开的文件描述符的最小值，默认 1024</span><br><span class="line">minprocs=200                 ;可以打开的进程数的最小值，默认 200</span><br><span class="line"> </span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:///tmp/supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致</span><br><span class="line">;serverurl=http://127.0.0.1:9001 ; 通过HTTP的方式连接supervisord</span><br><span class="line"> </span><br><span class="line">; [program:xx]是被管理的进程配置参数，xx是进程的名称</span><br><span class="line">[program:xx]</span><br><span class="line">command=/opt/apache-tomcat-8.0.35/bin/catalina.sh run  ; 程序启动命令</span><br><span class="line">autostart=true       ; 在supervisord启动的时候也自动启动</span><br><span class="line">startsecs=10         ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒</span><br><span class="line">autorestart=true     ; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启</span><br><span class="line">startretries=3       ; 启动失败自动重试次数，默认是3</span><br><span class="line">user=tomcat          ; 用哪个用户启动进程，默认是root</span><br><span class="line">priority=999         ; 进程启动优先级，默认999，值小的优先启动</span><br><span class="line">redirect_stderr=true ; 把stderr重定向到stdout，默认false</span><br><span class="line">stdout_logfile_maxbytes=20MB  ; stdout 日志文件大小，默认50MB</span><br><span class="line">stdout_logfile_backups = 20   ; stdout 日志文件备份数，默认是10</span><br><span class="line">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span><br><span class="line">stdout_logfile=/opt/apache-tomcat-8.0.35/logs/catalina.out</span><br><span class="line">stopasgroup=false     ;默认为false,进程被杀死时，是否向这个进程组发送stop信号，包括子进程</span><br><span class="line">killasgroup=false     ;默认为false，向进程组发送kill信号，包括子进程</span><br><span class="line"> </span><br><span class="line">;包含其它配置文件</span><br><span class="line">[include]</span><br><span class="line">files = relative/directory/*.ini    ;可以指定一个或多个以.ini结束的配置文件</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<ul>
<li>我们从<code>supervisor</code>基础模型，组成、再到到使用进行了介绍</li>
<li>验证了<code>supervisor</code>确实可以监控我们的任务，且给予了简单的控制面板，更加便于我们控制、监控</li>
<li><code>supervisor</code>的配置文件十分重要，是熟练使用的前提与基石</li>
</ul>
<p>自从又了它，相信你对于任务的管理再也不会迷路了，冲冲冲～</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmjvtjiqtdj31c20mggp8.jpg" alt="" /></p>
]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
      <tags>
        <tag>技术杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Tampermonkey安装与使用</title>
    <url>/7658.html</url>
    <content><![CDATA[<h2 id="tampermonkey"><a class="markdownIt-Anchor" href="#tampermonkey"></a> Tampermonkey</h2>
<p><strong>Tampermonkey</strong> 是一款免费的浏览器扩展和最为流行的用户脚本管理器，虽然有些受支持的浏览器拥有原生的用户脚本支持，但<br />
Tampermonkey 将在您的用户脚本管理方面提供更多的便利。<br />
它提供了诸如便捷脚本安装、自动更新检查、标签中的脚本运行状况速览、内置的编辑器等众多功能，<br />
同时Tampermonkey还有可能正常运行原本并不兼容的脚本。</p>
<span id="more"></span>
<h3 id="tampermonkey的安装"><a class="markdownIt-Anchor" href="#tampermonkey的安装"></a> Tampermonkey的安装</h3>
<h4 id="方式一-chrome商店直接下载"><a class="markdownIt-Anchor" href="#方式一-chrome商店直接下载"></a> 方式一 Chrome商店直接下载</h4>
<p>Chrome商店 -&gt; 搜索 Tampermonkey -&gt; Tampermonkey 安装即可</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gr4arkuzzmj30yd08jdge.jpg" alt="" /></p>
<p>一般情况下是无法下载的，除非你能。。。</p>
<h4 id="方式二第三方网站进行插件文件下载"><a class="markdownIt-Anchor" href="#方式二第三方网站进行插件文件下载"></a> 方式二：第三方网站进行插件文件下载</h4>
<p>进入<span class="exturl" data-url="aHR0cHM6Ly93d3cuY3J4NGNocm9tZS5jb20vY3J4Lzc1NS8lRTglQkYlOUIlRTglQTElOEMlRTUlQUUlODklRTglQTMlODUlRTYlOTYlODclRTQlQkIlQjYlRTclOUElODQlRTQlQjglOEIlRTglQkQlQkQlRUYlQkMlOEMlRTQlQjglOEIlRTglQkQlQkQlRTUlQUUlOEMlRTYlODglOTAlRTUlOTAlOEUlRTMlODAlODIlRTYlODklOTMlRTUlQkMlODAlRTYlOEIlOTMlRTUlQjElOTUlRTclQTglOEIlRTUlQkElOEYoQ2hyb21lJUU3JTk0JUE4JUU2JTg4JUI3JUU5JTgwJTg5JUU5JUExJUI5JUU2JUExJTg2">https://www.crx4chrome.com/crx/755/进行安装文件的下载，下载完成后。打开拓展程序(Chrome用户选项框<i class="fa fa-external-link-alt"></i></span> -&gt;<br />
更多工具 -&gt; 拓展程序)</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gr4ay74m2aj30kd0fkt95.jpg" alt="" /></p>
<p>进入如下图所示的界面</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gr4ayxb6y3j31fo0mgwgp.jpg" alt="" /></p>
<p>打开右上角的 <strong>开发者模式</strong>，将已经下载的文件拖拽至上图所示的界面。即可完成安装。</p>
<h3 id="使用第三方脚本"><a class="markdownIt-Anchor" href="#使用第三方脚本"></a> 使用第三方脚本</h3>
<p>进入greasyfork <span class="exturl" data-url="aHR0cHM6Ly9ncmVhc3lmb3JrLm9yZy96aC1DTi9zY3JpcHRz">https://greasyfork.org/zh-CN/scripts<i class="fa fa-external-link-alt"></i></span> 获取需要的插件脚本即可</p>
<h3 id="自定义开发脚本"><a class="markdownIt-Anchor" href="#自定义开发脚本"></a> 自定义开发脚本</h3>
<p>鼠标点击<strong>Tampermonkey</strong>图标呼出其选项卡，点击添加脚本。即可进入新建脚本界面。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gr4baf3mybj31fj0i3gmi.jpg" alt="" /></p>
<h4 id="语法规则"><a class="markdownIt-Anchor" href="#语法规则"></a> 语法规则</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @key value</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br></pre></td></tr></table></figure>
<h4 id="字段释意"><a class="markdownIt-Anchor" href="#字段释意"></a> 字段释意</h4>
<h5 id="基本信息"><a class="markdownIt-Anchor" href="#基本信息"></a> 基本信息</h5>
<p>@name：脚本的名字(自定义)</p>
<p>@author 作者。该脚本的作者。可使用默认的you，或者你的名字</p>
<p>@description 脚本描述（类似于编程中的注释，阐述该脚本的作用等）</p>
<h5 id="命名空间"><a class="markdownIt-Anchor" href="#命名空间"></a> 命名空间</h5>
<p>@namespace 脚本的命名空间(通常使用默认<span class="exturl" data-url="aHR0cDovL3RhbXBlcm1vbmtleS5uZXQvJUVGJUJDJThDJUU0JUI5JTlGJUU1JThGJUFGJUU2JThDJTg3JUU1JUFFJTlBKQ==">http://tampermonkey.net/，也可指定)<i class="fa fa-external-link-alt"></i></span></p>
<p>@homepage, @homepageURL, @website and @source 在选项页面使用的作者主页，用于从脚本名称链接到给定页面。如果@namespace<br />
标记以“<span class="exturl" data-url="aHR0cDovLw==">http://<i class="fa fa-external-link-alt"></i></span>”开头，则其内容也将用于此目的。</p>
<h5 id="版本控制"><a class="markdownIt-Anchor" href="#版本控制"></a> 版本控制</h5>
<p>@version 脚本版本号</p>
<p>@updateURL：用户脚本的更新 URL。 注意：需要一个@version 标签才能使更新检查工作</p>
<p>@downloadURL：URL定义检测到更新时下载脚本的 URL。如果使用值 none，则不会进行更新检查。</p>
<p>@supportURL 定义用户可以报告问题并获得个人支持的 URL。</p>
<h5 id="访问限制"><a class="markdownIt-Anchor" href="#访问限制"></a> 访问限制</h5>
<p>@include</p>
<p>脚本允许运行的页面，可以是多个标签实例。 支持正则语句</p>
<blockquote>
<p>注意：</p>
<p>@include 不支持 URL 哈希参数，必须匹配没有哈希参数的路径并使用</p>
</blockquote>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         New Userscript</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  try to take over the world!</span></span><br><span class="line"><span class="comment">// @author       You</span></span><br><span class="line"><span class="comment">// @include      https://www.tampermonkey.net/documentation.php?ext=dhdg</span></span><br><span class="line"><span class="comment">// @icon         https://www.google.com/s2/favicons?domain=tampermonkey.net</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// Your code here...</span></span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;HEllo&#x27;</span>)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>保存后，当我们访问<span class="exturl" data-url="aHR0cHM6Ly93d3cudGFtcGVybW9ua2V5Lm5ldC9kb2N1bWVudGF0aW9uLnBocD9leHQ9ZGhkZyVFNyU5QSU4NCVFNiU5NyVCNiVFNSU4MCU5OSVFNSVCMCU4NiVFNCVCQyU5QSVFNSVCQyVCOSVFNSU4NyVCQUhlbGxvJUUzJTgwJTgyJUU1JUE2JTgyJUU0JUI4JThCJUU1JTlCJUJFJUU2JTg5JTgwJUU3JUE0JUJB">https://www.tampermonkey.net/documentation.php?ext=dhdg的时候将会弹出Hello。如下图所示<i class="fa fa-external-link-alt"></i></span></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gr4c8ojzwij30x204njre.jpg" alt="" /></p>
<p>当@match 为 ***** 时，当访问任何一个页面都会alter出对应的内容来。如下图所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gr4c9uenmkj30wy04nglk.jpg" alt="" /></p>
<p>@match</p>
<p>@match 与 @include 非常相似，然而@match更安全。它对 * 字符的含义设置了更严格的规则。</p>
<p>@match 与 @include他们都是匹配基于一组由匹配模式定义的 URL。匹配模式本质上是以允许的方案开头的<br />
URL。匹配模式本质上是以允许的方案（http、https、file 或 ftp，并且可以包含“*”字符）开头的<br />
URL。特殊模式匹配以允许的方案开头的任何 URL。</p>
<p>'<em>’ 的含义取决于它是在方案、主机还是路径部分。如果方案是</em>，则它匹配 http 或 https，而不匹配 file、ftp 或<br />
urn。如果主机只是 <em>，那么它匹配任何主机。如果主机是</em>.<em>hostname</em><br />
，则它匹配指定的主机或其任何子域。在路径部分，每个 ‘*’ 匹配 0 个或多个字符。</p>
<blockquote>
<p>@match 与 @include区别请参考</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmdyZWFzZXNwb3QubmV0L01ldGFkYXRhX0Jsb2NrIy40MG1hdGNo">https://wiki.greasespot.net/Metadata_Block#.40match<i class="fa fa-external-link-alt"></i></span></p>
<p>匹配规则</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9kb2NzL2V4dGVuc2lvbnMvbXYzL21hdGNoX3BhdHRlcm5zLw==">https://developer.chrome.com/docs/extensions/mv3/match_patterns/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p><strong>简单来说推荐使用@match</strong></p>
<p>@exclude</p>
<p>不匹配，相当于访问黑名单。如果访问了@exclude中与之匹配的内容则不执行自定义的JavaScript代码</p>
<p>@exclude优先权大于match和@include。如果二者都匹配了，那么默认执行@exclude规则。也就是说即是’白名单‘也是’黑名单‘那么默认为’黑名单‘</p>
<h5 id="第三方链接"><a class="markdownIt-Anchor" href="#第三方链接"></a> 第三方链接</h5>
<p>@require</p>
<p>指向在脚本本身开始运行之前加载和执行的 JavaScript 文件。</p>
<blockquote>
<p>脚本中可以有任意数量的@require 键。每个 @require 在安装脚本时下载一次，并与脚本一起存储在用户的硬盘驱动器上。指定的<br />
URL 可能与安装脚本的 URL 相关。</p>
</blockquote>
<p>@resource</p>
<p>预加载可由脚本通过 GM_getResourceURL 和 GM_getResourceText 访问的资源。</p>
<blockquote>
<p>虽然 resourceName 是非语义的，但它应该符合 JavaScript 标识符限制。每个@resource 必须有一个唯一的名称。</p>
<p>每个@resource 在安装脚本时下载一次，并与脚本一起存储在用户的硬盘驱动器上。指定的 URL 可能与安装脚本的<br />
URL 相关。</p>
<p>这些命名资源可以分别通过<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmdyZWFzZXNwb3QubmV0L0dNX2dldFJlc291cmNlVGV4dA==">GM_getResourceText<i class="fa fa-external-link-alt"></i></span><br />
和<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmdyZWFzZXNwb3QubmV0L0dNX2dldFJlc291cmNlVVJM">GM_getResourceURL<i class="fa fa-external-link-alt"></i></span>访问。</p>
</blockquote>
<p>@connect</p>
<p>此标签定义域（无顶级域），包括允许通过 GM_xmlhttpRequest 检索的子域</p>
<blockquote>
<p>可以简单的理解为发送请求。GET、POST、HEAD</p>
</blockquote>
<p>@run-at</p>
<p>定义脚本被注入的时刻，与其他脚本处理程序相反， <strong>@run-at</strong> 定义了脚本想要运行的第一个可能时刻。这意味着可能会发生，使用<br />
<strong>@require</strong><br />
标签的脚本可能会在文档加载后执行，导致获取所需脚本需要很长时间。无论如何，在给定注入时刻之后发生的所有<br />
DOMNodeInserted 和 DOMContentLoaded 事件都被缓存并在注入时传递给脚本。</p>
<p>@run-at document-start 脚本将尽快注入。 @run-at document-body 如果 body 元素存在，脚本将被注入 @run-at<br />
document-end 该脚本将在调度 DOMContentLoaded<br />
事件时或之后注入。 @run-at document-idle 脚本将在 DOMContentLoaded 事件被调度后注入。如果没有给出@run-at<br />
标签，这是默认值。 @run-at context-menu<br />
如果在浏览器上下文菜单中单击该脚本（仅限基于 Chrome 的桌面浏览器），则会注入该脚本。</p>
<blockquote>
<p>建议使用@run-at document-start</p>
</blockquote>
<p>@grant</p>
<p>@grant 用于将 GM_* 函数、unsafeWindow 对象和一些强大的窗口函数列入白名单。如果没有给出@grant 标签，TM<br />
猜测脚本需要。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// @grant GM_setValue</span><br><span class="line">// @grant GM_getValue</span><br><span class="line">// @grant GM_setClipboard</span><br><span class="line">// @grant unsafeWindow</span><br><span class="line">// @grant window.close</span><br><span class="line">// @grant window.focus</span><br><span class="line">// @grant window.onurlchange</span><br></pre></td></tr></table></figure>
<p>由于关闭和聚焦选项卡是一项强大的功能，因此也需要将其添加到 @grant 语句中。</p>
<p>如果脚本在单页应用程序上运行，那么它可以使用 window.onurlchange 来监听 URL 更改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ==UserScript==...</span><br><span class="line">// @grant window.onurlchange</span><br><span class="line">// ==/UserScript==if (window.onurlchange === null) &#123;  </span><br><span class="line">// feature is supported  window.addEventListener(&#x27;urlchange&#x27;, (info) =&gt; ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果@grant 后跟“none”，则沙箱将被禁用，脚本将直接在页面上下文中运行。在此模式下，没有 GM_* 功能，但<br />
GM_info 属性将可用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// @grant none</span><br></pre></td></tr></table></figure>
<blockquote>
<p>推荐使用@grant none</p>
</blockquote>
<p>@noframes</p>
<p>此标记使脚本在主页上运行，但不在 iframe 上运行。</p>
<div align="center">
  <font color=red size=5px style="font-family: cursive">
      Reference
  </font>
</div>
<ul>
<li>
<p>Tampermonkey官方地址：<span class="exturl" data-url="aHR0cHM6Ly93d3cudGFtcGVybW9ua2V5Lm5ldC8=">https://www.tampermonkey.net/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li>
<p>Tampermonkey官方文档：<span class="exturl" data-url="aHR0cHM6Ly93d3cudGFtcGVybW9ua2V5Lm5ldC9kb2N1bWVudGF0aW9uLnBocD9leHQ9ZGhkZw==">https://www.tampermonkey.net/documentation.php?ext=dhdg<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li>
<p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmdyZWFzZXNwb3QubmV0L01ldGFkYXRhX0Jsb2NrIy40MG1hdGNo">https://wiki.greasespot.net/Metadata_Block#.40match<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>chrome</category>
        <category>Tampermonkey</category>
        <category>edge</category>
      </categories>
      <tags>
        <tag>Tampermonkey</tag>
      </tags>
  </entry>
  <entry>
    <title>android投屏工具</title>
    <url>/44413.html</url>
    <content><![CDATA[<ul>
<li>
<p><strong>scrcpy</strong>: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0dlbnltb2JpbGUvc2NyY3B5Lw==">https://github.com/Genymobile/scrcpy/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li>
<p><strong>vysor</strong>: <span class="exturl" data-url="aHR0cHM6Ly93d3cudnlzb3IuaW8v">https://www.vysor.io/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li>
<p><strong>QtScrcpy</strong>: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JhcnJ5LXJhbi9RdFNjcmNweQ==">https://github.com/barry-ran/QtScrcpy<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li>
<p><strong>Total Control</strong>: <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2lnbWEtcnQuY29tLw==">https://www.sigma-rt.com/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li>
<p><strong>Appetizer</strong>:<span class="exturl" data-url="aHR0cHM6Ly93d3cubm90aW9uLnNvL2FwcGV0aXplcmlvL0FwcGV0aXplcklPLTEzODNkOTcxZGVkOTQzODhiOGU3NmYzMjM2ZmUxZjRm">https://www.notion.so/appetizerio/AppetizerIO-1383d971ded94388b8e76f3236fe1f4f<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>VsCode初始化配置</title>
    <url>/29679.html</url>
    <content><![CDATA[<h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2>
<figure class="highlight json"><figcaption><span>lines</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;workbench.colorTheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Solarized Light&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;files.autoSave&quot;</span><span class="punctuation">:</span> <span class="string">&quot;afterDelay&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.formatOnSave&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.fontSize&quot;</span><span class="punctuation">:</span> <span class="number">14</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.fontFamily&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JetBrains Mono, Menlo, Monaco, &#x27;Courier New&#x27;, monospace&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;editor.fontLigatures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;search.exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;**/node_modules&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;**/bower_components&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;**/target&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;**/logs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;**/.git&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;**/.svn&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;**/.hg&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;**/CVS&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;**/.DS_Store&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;**/*.js&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;when&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$(basename).ts&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;**/.idea&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;files.exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;**/node_modules&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;**/bower_components&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;**/target&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;**/logs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;**/.git&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;**/.svn&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;**/.hg&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;**/CVS&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;**/.DS_Store&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;**/*.js&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;when&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$(basename).ts&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;**/.idea&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="代码提示配置"><a class="markdownIt-Anchor" href="#代码提示配置"></a> 代码提示配置</h3>
<p>settings -搜索-&gt; prevent -&gt; none</p>
<h2 id="插件"><a class="markdownIt-Anchor" href="#插件"></a> 插件</h2>
<h3 id="program-language"><a class="markdownIt-Anchor" href="#program-language"></a> Program Language</h3>
<h4 id="python"><a class="markdownIt-Anchor" href="#python"></a> Python</h4>
<ul>
<li>Python Docstring Generator</li>
<li>Python</li>
<li>Python Environment Manager</li>
<li>Visual Studio IntelliCode</li>
<li>Python Indent</li>
</ul>
<h4 id="php"><a class="markdownIt-Anchor" href="#php"></a> PHP</h4>
<ul>
<li>php-extension-pack</li>
</ul>
<h4 id="cloud"><a class="markdownIt-Anchor" href="#cloud"></a> Cloud</h4>
<ul>
<li>DevOps Cloud Extension pack</li>
</ul>
<h4 id="reception"><a class="markdownIt-Anchor" href="#reception"></a> Reception</h4>
<ul>
<li>VS Code JavaScript (ES6) snippets</li>
<li>open in browser</li>
<li>auto complete Tag</li>
<li>auto rename Tag</li>
<li>auto close Tag</li>
<li>Import Cost</li>
</ul>
<h4 id="other"><a class="markdownIt-Anchor" href="#other"></a> Other</h4>
<ul>
<li>vscode-icons</li>
<li>vsc-essentials</li>
<li>gitlens:    <code>git config pull.rebase false</code></li>
</ul>
<p>code studio pack</p>
<h2 id="常用快捷键"><a class="markdownIt-Anchor" href="#常用快捷键"></a> 常用快捷键</h2>
<h3 id="window"><a class="markdownIt-Anchor" href="#window"></a> Window</h3>
<p><code>Alt + →</code> ：代码前进下一级</p>
<p><code>Alt + ←</code> ：代码返回上一级</p>
<hr />
<p><code>Ctrl + K + 0</code>:    收缩所有代码(0是代码折叠级别，同理可以换用1，2，3等)</p>
<p><code>Ctrl + K + J</code>:    取消收缩所有代码</p>
<hr />
<p><code>Ctrl + K + S</code>：快捷键文档</p>
<p><code>Alt + Shift + F</code> ：代码格式化</p>
<p><code>Ctrl + Shift + P</code>： 显示所有命令</p>
<p><code>Ctrl + P</code>： 显示所有命令</p>
<h3 id="mac"><a class="markdownIt-Anchor" href="#mac"></a> Mac</h3>
<ul>
<li>
<p><code>Ctrl + -</code>：代码返回上一级</p>
</li>
<li>
<p><code>Ctrl + Shift + -</code>： 代码前进下一级</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><code>Command + K + 0</code>:    收缩所有代码(0是代码折叠级别，同理可以换用1，2，3等)</p>
</li>
<li>
<p><code>Command + K + J</code> 取消收缩所有代码</p>
</li>
</ul>
<hr />
<ul>
<li>
<p><code>Command + K + S</code>：快捷键文档</p>
</li>
<li>
<p><code>Opt + Shift + F</code> ：代码格式化</p>
</li>
<li>
<p><code>Command + Shift + P</code>： 显示所有命令</p>
</li>
<li>
<p><code>Command + p</code> ：打开最近文件</p>
</li>
</ul>
]]></content>
      <categories>
        <category>mac</category>
        <category>vscode</category>
        <category>Visual Studio Code</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 底层原理探究</title>
    <url>/54288.html</url>
    <content><![CDATA[<p>Docker is written in the <span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcub3JnLw==">Go programming language<i class="fa fa-external-link-alt"></i></span> and takes advantage of<br />
several features of the<br />
Linux kernel to deliver its functionality.</p>
<span id="more"></span>
<p>Docker用<code>Go编程语言</code>编写，并利用Linux内核的多个功能来实现其功能。</p>
<h2 id="namespaces命名空间"><a class="markdownIt-Anchor" href="#namespaces命名空间"></a> Namespaces(命名空间)</h2>
<p>Docker uses a technology called <code>namespaces</code> to provide the isolated workspace called the<br />
<em>container</em>. When you run a<br />
container, Docker creates a set of <em>namespaces</em> for that container.</p>
<blockquote>
<p>Docker使用<code>命名空间</code>的技术实现容器(虚拟)独立的工作区</p>
</blockquote>
<p><strong>理解<code>Namespaces</code></strong></p>
<p><strong>Namespaces</strong>,可以理解为虚拟化隔离</p>
<p>当我们在系统上运行程序时，系统会为我们分配<code>pid</code>,<code>net</code>,<code>ipc</code>,<code>mnt</code>,<code>uts</code>等资源，当我们在Linux中运行时这些都是全局的。</p>
<p>当我们使用命名空间即可实现隔离的机制，每个分配<code>pid</code>,<code>net</code>,<code>ipc</code>,<code>mnt</code>,<code>uts</code>都是独立的，这样我们就可以实现权限管理等</p>
<p>These namespaces provide a layer of isolation. Each aspect of a container runs in a separate<br />
namespace and its access is<br />
limited to that namespace.</p>
<p>Docker Engine uses namespaces such as the following on Linux:</p>
<ul>
<li><strong>The <code>pid</code> namespace:</strong> Process isolation (PID: Process ID).</li>
<li><strong>The <code>net</code> namespace:</strong> Managing network interfaces (NET: Networking).</li>
<li><strong>The <code>ipc</code> namespace:</strong> Managing access to IPC resources (IPC: InterProcess Communication).</li>
<li><strong>The <code>mnt</code> namespace:</strong> Managing filesystem mount points (MNT: Mount).</li>
<li><strong>The <code>uts</code> namespace:</strong> Isolating kernel and version identifiers. (UTS: Unix Timesharing System).</li>
</ul>
<p><strong>进程ID（pid）</strong></p>
<p>进程的<code>PID</code><br />
命名空间提供与一组独立的从其他命名空间进程ID（PID）的处理。PID名称空间是嵌套的，这意味着在创建新进程时，它将为每个名称空间从当前名称空间到初始PID名称空间都有一个PID。因此，初始PID名称空间能够查看所有进程，尽管与其他名称空间看到的PID不同。</p>
<p>在PID名称空间中创建的第一个进程被分配了编号为1的进程，并获得与常规进程相同的大多数特殊处理，最值得注意的是，名称空间内的<code>孤立进程</code><br />
。这也意味着此PID 1进程的终止将立即终止其PID名称空间中的所有进程以及所有后代。</p>
<p><strong>网络（网络）</strong></p>
<p>网络名称空间可虚拟化<code>网络堆栈</code>。创建时，网络名称空间仅包含<code>回送</code>接口。</p>
<p>每个<code>网络接口</code>（物理或虚拟）都存在于1个名称空间中，并且可以在名称空间之间移动。</p>
<p>每个名称空间都有一组专用的<code>P地址</code>，自己的<code>路由表</code>，<code>套接字</code>列表，连接跟踪表，防火墙和其他与网络相关的资源。</p>
<p>销毁网络名称空间会破坏其中的任何虚拟接口，并将其中的任何物理接口移回到初始网络名称空间。</p>
<p><strong>进程间通信（ipc）</strong></p>
<p>IPC名称空间将进程与<code>SysV</code><br />
样式的进程间通信隔离开。这样可以防止不同IPC名称空间中的进程使用例如SHM系列功能在两个进程之间建立一定范围的共享内存。相反，每个进程将能够对共享内存区域使用相同的标识符，并产生两个这样的不同区域。</p>
<p><strong>挂载（mnt）</strong></p>
<p>安装名称空间控制安装点。创建后，会将当前安装名称空间中的安装复制到新的名称空间，但是之后创建的安装点不会在名称空间之间传播（使用共享子树，可以在名称空间之间传播安装点。</p>
<p>用于创建这种类型的新名称空间的克隆标志是CLONE_NEWNS-“ NEW<br />
NameSpace”的缩写。该术语不是描述性的（因为它没有告诉您要创建哪种类型的名称空间），因为挂载名称空间是第一类名称空间，设计人员并不预期会有其他名称空间。</p>
<p><strong>UTS (UNIX <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGltZS1zaGFyaW5n">Time-Sharing<i class="fa fa-external-link-alt"></i></span>)</strong></p>
<p>命名空间允许单个系统对不同的进程使用不同的主机名和域名。</p>
<h2 id="control-groups"><a class="markdownIt-Anchor" href="#control-groups"></a> Control groups</h2>
<p>Docker Engine on Linux also relies on another technology called <em>control groups</em> (<code>cgroups</code>). A<br />
cgroup limits an<br />
application to a specific set of resources. Control groups allow Docker Engine to share available<br />
hardware resources to<br />
containers and optionally enforce limits and constraints. For example, you can limit the memory<br />
available to a specific<br />
container.</p>
<blockquote>
<p>Linux上的Docker引擎还依赖另一种称为<em>控制组</em>（<code>cgroups</code><br />
）的技术。cgroup将应用程序限制为一组特定的资源。控制组允许Docker引擎将可用的硬件资源共享给容器，并可以选择性地实施限制和约束。例如，可以限制特定容器的可用内存。</p>
</blockquote>
<h2 id="union-file-systems"><a class="markdownIt-Anchor" href="#union-file-systems"></a> Union file systems</h2>
<p>Union file systems, or UnionFS, are file systems that operate by creating layers, making them very<br />
lightweight and fast.<br />
Docker Engine uses UnionFS to provide the building blocks for containers. Docker Engine can use<br />
multiple UnionFS<br />
variants, including AUFS, btrfs, vfs, and DeviceMapper.</p>
<blockquote>
<p>Union文件系统（UnionFS）是通过<code>创建层</code></p>
</blockquote>
<p>来操作的文件系统，使它们非常轻量级和快速。Docker引擎使用UnionFS为容器提供构建块。Docker引擎可以使用多种UnionFS变体，包括AUFS、btrfs、vfs和DeviceMapper。</p>
<h2 id="container-format"><a class="markdownIt-Anchor" href="#container-format"></a> Container format</h2>
<p>Docker Engine combines the namespaces, control groups, and UnionFS into a wrapper called a container<br />
format. The default<br />
container format is <code>libcontainer</code>. In the future, Docker may support other container formats by<br />
integrating with<br />
technologies such as BSD Jails or Solaris Zones.</p>
<blockquote></blockquote>
<p>Docker引擎将名称空间、控制组和UnionFS组合成一个称为容器格式的包装器。默认容器格式为“libcontainer”。将来，Docker可以通过集成BSD监狱或Solaris区域等技术来支持其他容器格式。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>docker使用go语言编写，基于<strong>Namespaces</strong>进行虚拟化隔离，Control groups进行对资源的限制，联合文件Union<br />
file systems来快速构建（可复用的镜像层）</p>
]]></content>
      <categories>
        <category>docker</category>
        <category>Docker</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker分层构建</title>
    <url>/16093.html</url>
    <content><![CDATA[<h2 id="引子"><a class="markdownIt-Anchor" href="#引子"></a> 引子</h2>
<p>在构建、部署、测试等情景中下不知你也是否遇到过这么几个问题，构建慢、依赖安装慢、重复性构建。<br />
以至于每一次采用docker来构建时，都需要等上那么几分钟。</p>
<p>有时候是非常的浪费时间， 那么是否有方法进行一次分离构建呢。当然正如docker口号所说的那般&quot;<br />
<strong>Build once，Run anywher</strong>&quot;，</p>
<p>那么该如何解决“<strong>构建慢、依赖安装慢、重复性构建</strong>”的问题呢， 看似三个或者更多问题，其实归根结底是一个问题——分层构建</p>
<h2 id="分层构建"><a class="markdownIt-Anchor" href="#分层构建"></a> 分层构建</h2>
<p>想深层理解docker的分层构建，不得不从docker的设计特性出发。虚拟机与docker结构，如下图所示。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gu2gf5gk5aj60kn0c40tr02.jpg" alt="image-20210902182150947" /></p>
<p><strong>一层一层的分层结构</strong>，那么所谓分层构建只需要将<strong>环境依赖</strong>与<strong>业务代码</strong>分开构建即可。实现如下</p>
<ul>
<li>
<p>短时间内环境依赖构建一次且仅构建一次</p>
</li>
<li>
<p>业务代码触发构建</p>
</li>
</ul>
<h2 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h2>
<h3 id="python"><a class="markdownIt-Anchor" href="#python"></a> python</h3>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#构建环境依赖</span></span><br><span class="line"><span class="comment">## 拉取pythoo镜像</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span></span><br><span class="line"><span class="comment">## 设置环境变量，相当于linux的export</span></span><br><span class="line"><span class="keyword">ENV</span> PATH /usr/local/bin:$PATH</span><br><span class="line"><span class="comment">## 在容器中进入根目录code（如果没有code目录则创建）相当于cd</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /code</span></span><br><span class="line"><span class="comment">## 将执行docker build 路径下的所有文件copy到容器内所在的目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt .</span></span><br><span class="line"><span class="comment">## 执行shell命令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> python3 -m pip install -U pip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    python3 -m pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建</span></span><br><span class="line">docker build -t user/img_name:version .</span><br><span class="line"><span class="comment"># 发布</span></span><br><span class="line">docker push user/img_name:version</span><br></pre></td></tr></table></figure>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#项目构建</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span>/img_name:version</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;supervisord&quot;</span>,<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;supervisord.conf&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<h4 id="golang"><a class="markdownIt-Anchor" href="#golang"></a> golang</h4>
<p>两层： 1.依赖构建 2.编译与项目构建</p>
<p>三层： 1.依赖构建 2.编译构建 3.运行文件构建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM golang:1.16 as builder</span><br><span class="line"><span class="comment"># Setting environment variables</span></span><br><span class="line">ENV GOPROXY=<span class="string">&quot;https://goproxy.cn,direct&quot;</span> \</span><br><span class="line">    GO111MODULE=<span class="string">&quot;on&quot;</span> \</span><br><span class="line">    CGO_ENABLED=<span class="string">&quot;0&quot;</span> \</span><br><span class="line">    GOOS=<span class="string">&quot;linux&quot;</span> \</span><br><span class="line">    GOARCH=<span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Switch to workspace</span></span><br><span class="line">WORKDIR /go/src/github.com/gowebspider/goproxies/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load file</span></span><br><span class="line">COPY . .</span><br><span class="line"></span><br><span class="line"><span class="comment">## add rely</span></span><br><span class="line">go mod tidy</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Build and place the results in /tmp/goproxies</span></span><br><span class="line">RUN go build -o /tmp/goproxies .</span><br><span class="line"></span><br><span class="line">FROM alpine:latest</span><br><span class="line">WORKDIR /root/</span><br><span class="line">COPY --from=builder /tmp/goproxies .</span><br><span class="line">CMD [<span class="string">&quot;./goproxies&quot;</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
        <category>Docker</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>frida hook</title>
    <url>/21429.html</url>
    <content><![CDATA[<h2 id="frida启动方式"><a class="markdownIt-Anchor" href="#frida启动方式"></a> frida启动方式</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># frida -h</span></span><br><span class="line">usage: frida [options] target</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  args                  extra arguments and/or target</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>            show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">  -D ID, --device ID    connect to device with the given ID</span><br><span class="line">  -U, --usb             connect to USB device</span><br><span class="line">  -R, --remote          connect to remote frida-server</span><br><span class="line">  -H HOST, --host HOST  connect to remote frida-server on HOST</span><br><span class="line">  --certificate CERTIFICATE</span><br><span class="line">                        speak TLS with HOST, expecting CERTIFICATE</span><br><span class="line">  --origin ORIGIN       connect to remote server with “Origin” header <span class="built_in">set</span> to ORIGIN</span><br><span class="line">  --token TOKEN         authenticate with HOST using TOKEN</span><br><span class="line">  --keepalive-interval INTERVAL</span><br><span class="line">                        <span class="built_in">set</span> keepalive interval <span class="keyword">in</span> seconds, or 0 to <span class="built_in">disable</span> (defaults to -1 to auto-select based on transport)</span><br><span class="line">  --p2p                 establish a peer-to-peer connection with target</span><br><span class="line">  --stun-server ADDRESS</span><br><span class="line">                        <span class="built_in">set</span> STUN server ADDRESS to use with --p2p</span><br><span class="line">  --relay address,username,password,turn-&#123;udp,tcp,tls&#125;</span><br><span class="line">                        add relay to use with --p2p</span><br><span class="line">  -f TARGET, --file TARGET</span><br><span class="line">                        spawn FILE</span><br><span class="line">  -F, --attach-frontmost</span><br><span class="line">                        attach to frontmost application</span><br><span class="line">  -n NAME, --attach-name NAME</span><br><span class="line">                        attach to NAME</span><br><span class="line">  -p PID, --attach-pid PID</span><br><span class="line">                        attach to PID</span><br><span class="line">  -W PATTERN, --await PATTERN</span><br><span class="line">                        await spawn matching PATTERN</span><br><span class="line">  --stdio &#123;inherit,pipe&#125;</span><br><span class="line">                        stdio behavior when spawning (defaults to “inherit”)</span><br><span class="line">  --aux option          <span class="built_in">set</span> aux option when spawning, such as “uid=(int)42” (supported types are: string, bool, int)</span><br><span class="line">  --realm &#123;native,emulated&#125;</span><br><span class="line">                        realm to attach <span class="keyword">in</span></span><br><span class="line">  --runtime &#123;qjs,v8&#125;    script runtime to use</span><br><span class="line">  --debug               <span class="built_in">enable</span> the Node.js compatible script debugger</span><br><span class="line">  --squelch-crash       <span class="keyword">if</span> enabled, will not dump crash report to console</span><br><span class="line">  -O FILE, --options-file FILE</span><br><span class="line">                        text file containing additional <span class="built_in">command</span> line options</span><br><span class="line">  --version             show program<span class="string">&#x27;s version number and exit</span></span><br><span class="line"><span class="string">  -l SCRIPT, --load SCRIPT</span></span><br><span class="line"><span class="string">                        load SCRIPT</span></span><br><span class="line"><span class="string">  -P PARAMETERS_JSON, --parameters PARAMETERS_JSON</span></span><br><span class="line"><span class="string">                        parameters as JSON, same as Gadget</span></span><br><span class="line"><span class="string">  -C USER_CMODULE, --cmodule USER_CMODULE</span></span><br><span class="line"><span class="string">                        load CMODULE</span></span><br><span class="line"><span class="string">  --toolchain &#123;any,internal,external&#125;</span></span><br><span class="line"><span class="string">                        CModule toolchain to use when compiling from source code</span></span><br><span class="line"><span class="string">  -c CODESHARE_URI, --codeshare CODESHARE_URI</span></span><br><span class="line"><span class="string">                        load CODESHARE_URI</span></span><br><span class="line"><span class="string">  -e CODE, --eval CODE  evaluate CODE</span></span><br><span class="line"><span class="string">  -q                    quiet mode (no prompt) and quit after -l and -e</span></span><br><span class="line"><span class="string">  -t TIMEOUT, --timeout TIMEOUT</span></span><br><span class="line"><span class="string">                        seconds to wait before terminating in quiet mode</span></span><br><span class="line"><span class="string">  --no-pause            automatically start main thread after startup</span></span><br><span class="line"><span class="string">  -o LOGFILE, --output LOGFILE</span></span><br><span class="line"><span class="string">                        output to log file</span></span><br><span class="line"><span class="string">  --eternalize          eternalize the script before exit</span></span><br><span class="line"><span class="string">  --exit-on-error       exit with code 1 after encountering any exception in the SCRIPT</span></span><br><span class="line"><span class="string">  --auto-perform        wrap entered code with Java.perform</span></span><br><span class="line"><span class="string">  --auto-reload         Enable auto reload of provided scripts and c module (on by default, will be required in the future)</span></span><br><span class="line"><span class="string">  --no-auto-reload      Disable auto reload of provided scripts and c module</span></span><br></pre></td></tr></table></figure>
<h2 id="injection"><a class="markdownIt-Anchor" href="#injection"></a> Injection</h2>
<blockquote>
<p>attach hook: 这种模式建立在app已经启动的情况下，frida利用ptrace的原理注入app进而完成Hook<br />
spawn hook： 将app启动权限交与frida 来控制。使用spawn实现hook时会由frida将app重启在进行hook<br />
注意：由于attach hook 基于ptrace原理进行完成，因此无法在IDA正在调试的目标app以attach注入进程中，当然若先用frida<br />
attach注入<br />
在使用IDA进行调试则正常</p>
</blockquote>
<h3 id="shell"><a class="markdownIt-Anchor" href="#shell"></a> Shell</h3>
<h4 id="attach"><a class="markdownIt-Anchor" href="#attach"></a> attach</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">frida -Ul script_hook.js [-n] app_name</span><br><span class="line">frida -Ul script_hook.js -p pid</span><br></pre></td></tr></table></figure>
<h4 id="spawn"><a class="markdownIt-Anchor" href="#spawn"></a> spawn</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">frida -Ul script_hook.js -f Identifier(package name) --no-pause</span><br></pre></td></tr></table></figure>
<h3 id="python-script"><a class="markdownIt-Anchor" href="#python-script"></a> Python script</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">from</span> pptrint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">message_callback</span>(<span class="params">message, data</span>):</span><br><span class="line">    logger.info(<span class="string">f&quot;[*] <span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">device = frida.get_use_device(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># attach</span></span><br><span class="line">process = device.attach(<span class="string">&#x27;className&#x27;</span>)</span><br><span class="line">script = process.create_script(<span class="string">&#x27;hook_script&#x27;</span>)</span><br><span class="line">script.on(<span class="string">&#x27;message&#x27;</span>, message_callback)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># spawn</span></span><br><span class="line">device = frida.get_use_device(-<span class="number">1</span>)</span><br><span class="line">pid = devices.spawn([<span class="string">&#x27;packageName&#x27;</span>])</span><br><span class="line">process = device.attach(pid)</span><br><span class="line">script = process.create_script(<span class="string">&#x27;hook_script&#x27;</span>)</span><br><span class="line">script.on(<span class="string">&#x27;message&#x27;</span>, message_callback)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure>
<h2 id="frida-api"><a class="markdownIt-Anchor" href="#frida-api"></a> frida api</h2>
<p>JavaScript-api : <span class="exturl" data-url="aHR0cHM6Ly9mcmlkYS5yZS9kb2NzL2phdmFzY3JpcHQtYXBp">https://frida.re/docs/javascript-api<i class="fa fa-external-link-alt"></i></span></p>
<p>JavaScript-api-java: <span class="exturl" data-url="aHR0cHM6Ly9mcmlkYS5yZS9kb2NzL2phdmFzY3JpcHQtYXBpLyNqYXZh">https://frida.re/docs/javascript-api/#java<i class="fa fa-external-link-alt"></i></span></p>
<p>JavaScript-api-module: <span class="exturl" data-url="aHR0cHM6Ly9mcmlkYS5yZS9kb2NzL2phdmFzY3JpcHQtYXBpLyNtb2R1bGU=">https://frida.re/docs/javascript-api/#module<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="hook"><a class="markdownIt-Anchor" href="#hook"></a> Hook</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perfrom</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script successfully loaded, start hook...&#x27;</span>);</span><br><span class="line">  <span class="comment">// hook script</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="hook-类方法"><a class="markdownIt-Anchor" href="#hook-类方法"></a> Hook 类方法</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perfrom</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script successfully loaded, start hook...&#x27;</span>);</span><br><span class="line">  <span class="comment">// hook class script</span></span><br><span class="line">  <span class="keyword">let</span> class_name = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.xxx.xxx.class_name&#x27;</span>);</span><br><span class="line">  class_name.<span class="property">method</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// this.xx</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>this.成员变量名.value</p>
</blockquote>
<h3 id="hook-内部匿名类方法"><a class="markdownIt-Anchor" href="#hook-内部匿名类方法"></a> Hook 内部(匿名)类方法</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perfrom</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script successfully loaded, start hook...&#x27;</span>);</span><br><span class="line">  <span class="comment">// hook class script</span></span><br><span class="line">  <span class="comment">// 类路径$内部类名 在smail找</span></span><br><span class="line">  <span class="keyword">let</span> class_name = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.xxx.xxx.class_name$xx&#x27;</span>);</span><br><span class="line">  class_name.<span class="property">method</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// this.xx</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从匿名类/内部类访问外部类的属性写法： this.this$0.value.外部类的属性名.value</p>
</blockquote>
<h2 id="hook-重载方法"><a class="markdownIt-Anchor" href="#hook-重载方法"></a> Hook 重载方法</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perfrom</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script successfully loaded, start hook...&#x27;</span>);</span><br><span class="line">  <span class="comment">// hook class script</span></span><br><span class="line">  <span class="comment">// 类路径$内部类名 在smail找</span></span><br><span class="line">  <span class="keyword">let</span> class_name = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.xxx.xxx.class_name&#x27;</span>);</span><br><span class="line">  class_name.<span class="property">method</span>.<span class="title function_">overload</span>(参数<span class="number">1</span>, 参数<span class="number">2</span></span><br><span class="line">...).</span><br><span class="line">  implementation = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// this.xx</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// overload(参数1，参数2...) 可以根据报错来确定</span></span><br></pre></td></tr></table></figure>
<h2 id="hook-构造方法"><a class="markdownIt-Anchor" href="#hook-构造方法"></a> Hook 构造方法</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perfrom</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script successfully loaded, start hook...&#x27;</span>);</span><br><span class="line">  <span class="comment">// hook class script</span></span><br><span class="line">  <span class="comment">// 类路径$内部类名 在smail找</span></span><br><span class="line">  <span class="keyword">let</span> class_name = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.xxx.xxx.class_name&#x27;</span>);</span><br><span class="line">  class_name.$init().<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// this.xx</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="hook-实例"><a class="markdownIt-Anchor" href="#hook-实例"></a> Hook 实例</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perfrom</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script successfully loaded, start hook...&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> variable = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.xxx.xxx.class_name&#x27;</span>).$new(参数);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>frida</category>
        <category>hook</category>
        <category>sec</category>
      </categories>
      <tags>
        <tag>frida</tag>
      </tags>
  </entry>
  <entry>
    <title>docker部署控制</title>
    <url>/4479.html</url>
    <content><![CDATA[<h2 id="docker-swarm部署控制"><a class="markdownIt-Anchor" href="#docker-swarm部署控制"></a> Docker swarm部署控制</h2>
<p>还记得我之前写过一片文章叫做<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpnMk16TTROVGczTUE9PSZhbXA7dGVtcGtleT1NVEE1TUY5UmNGWjVjMUI0UVRGbVNuWkhkMlF4YTNoTU5XaHBMWEZvT0VKWVdWQkJhVVp5TUUxc1JtVkJRblIxUVdOM1YzRlVaMWhmYTFCbmVtZHRPV3BMWTFvMFJUbHpWbkUyT1V0UmJsWlBTMVpEVjJwRFNrOVFVM0JhZERVekxUTkphM1JIWW14RlFYTnFNalF5UTFkU05VbHJjRGRmVEcxc2NEUlRXVmcyVURkaUxUSTVlV280ZEU5SFNISTRUbFZLT1ZsdFpFZHRWelpPYlc5TlQxOUdOMkk1ZUY5WWJ6ZEJmbjQlM0QmYW1wO2Noa3NtPTRlNzgyMjZiNzkwZmFiN2QxZmIwMjgzZjhiNjI5NGM0MDQ1NmRmN2FlYmY1OGQ5NDc0MTJlZDAzZDBjM2ZjM2FhMTg4ZGU3OWYxMzAjcmQ=">《Docker快速部署项目，极速搭建分布式》<i class="fa fa-external-link-alt"></i></span><br />
，在那里讲述了如何去使用docker<br />
swarm，如何构建自己的私人镜像仓库。随着最近的业务量的增长，机子加多。对于docker<br />
swarm管理难度有上升的趋势。主要的问题有以下几个</p>
<ul>
<li>物理机配置不同（比如 CPU、内存等）</li>
<li>部署着不同类型的服务（比如 Web服务、Job服务等）</li>
<li>Swarm 集群中的节点跨机房，为了内部服务间通信更快，该如何分组部署</li>
<li>。。。</li>
</ul>
<p>为了解决以上问题,以求更合理、更科学的管理部署所以有了今天这篇文章。</p>
<p>docker 节点的部署调度一共有三种机制，随机部署、平衡部署、先满部署</p>
<blockquote>
<p>随机部署：active中随机选择<br />
平衡部署：尽可能先平均填满所有的节点<br />
先满部署：与平衡部署相反，先部署至上限，然后在部署对应的</p>
</blockquote>
<p>那么该如何管理呢？下面我介绍几种方式，如下</p>
<ul>
<li>NodeId</li>
<li>HOSTNAME</li>
<li>Node role</li>
<li>node labels</li>
<li>engine.labels</li>
</ul>
<p>首先我们查看一下节点列表信息，直接使用<code>docker node ls</code>，即可</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1glgia65xg6j31jo0b8dgn.jpg" alt="" /></p>
<p>首先我们先解读一下，docker 的限制指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker service create --help</span></span><br><span class="line">--constraint list                    Placement constraints</span><br><span class="line">--container-label list               Container labels</span><br></pre></td></tr></table></figure>
<p>他们的 后面跟随的参数都是list，具体使用如以下示例</p>
<h3 id="nodeid"><a class="markdownIt-Anchor" href="#nodeid"></a> NodeId</h3>
<p>根据NodeId来指定部署节点，以下以搭建私人镜像仓库为示例。</p>
<h4 id="docker-service"><a class="markdownIt-Anchor" href="#docker-service"></a> docker service</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">--name registry \</span><br><span class="line">--publish published=5000,target=5000 \</span><br><span class="line">--constraint node.id==ytsyvuhfs60spr361y6irpynm \</span><br><span class="line">registry:2</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1glgiv5qw30j31le03i0sr.jpg" alt="" /></p>
<p>命令解读</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在docker swarm中创建服务</span></span><br><span class="line">docker service create  \</span><br><span class="line"><span class="comment"># --name 服务别名</span></span><br><span class="line"><span class="comment"># 指定node的id，ytsyvuhfs60spr361y6irpynm这个是我这里的node.id，你使用的时候需按照需求替换即可</span></span><br><span class="line">--constraint node.id==ytsyvuhfs60spr361y6irpynm \</span><br><span class="line"><span class="comment"># 暴露公开的接口，可以让节点中的其他node可以访问</span></span><br><span class="line">--publish published=5000,target=5000 \</span><br><span class="line"><span class="comment"># 镜像名：版本号</span></span><br><span class="line">registry:2</span><br></pre></td></tr></table></figure>
<p>这样我们就实现了指定节点的部署，是不是很简单呢。</p>
<h4 id="docker-stack"><a class="markdownIt-Anchor" href="#docker-stack"></a> docker stack</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yaml </span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="string">registry:2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">target:</span> <span class="number">8080</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">published:</span> <span class="number">8080</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">tcp</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">mode:</span> <span class="string">ingress</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">global</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span> <span class="comment"># 添加条件约束</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.id==ytsyvuhfs60spr361y6irpynm</span></span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">on-failure</span></span><br><span class="line">        <span class="attr">max_attempts:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="hostname"><a class="markdownIt-Anchor" href="#hostname"></a> HOSTNAME</h3>
<p>​ 除此之外我们还可以指定hostname<br />
去将应用部署到指定的hostname上，操作与以上差不多。那让我们来实现一下，首先我们需要查看对应节点的信息，在manager节点上使用<code>docker node ls</code><br />
查看，如下</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1glmhr7pa7oj31yo07ewfw.jpg" alt="" /></p>
<h4 id="docker-service-2"><a class="markdownIt-Anchor" href="#docker-service-2"></a> docker service</h4>
<p><strong>创建命令如下</strong>,以nginx为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">--name nginx \</span><br><span class="line">--constraint node.hostname==ecs-dc8a-0003 \</span><br><span class="line">-p 80:80 nginx</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1glmi66uraij31y405mt9f.jpg" alt="" /></p>
<p>这样我们就将nginx服务部署至对应的节点了，并且扩容也仅会在此节点进行部署。示例如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker service scale nginx=3</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1glmidvm1g1j31y60pwtcy.jpg" alt="" /></p>
<h4 id="docker-stack-2"><a class="markdownIt-Anchor" href="#docker-stack-2"></a> docker stack</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yaml </span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">target:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">published:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">tcp</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">mode:</span> <span class="string">ingress</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">global</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span> <span class="comment"># 添加条件约束</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.hostname==ecs-dc8a-0003</span></span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">on-failure</span></span><br><span class="line">        <span class="attr">max_attempts:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="node-role"><a class="markdownIt-Anchor" href="#node-role"></a> Node role</h3>
<p>前面我们了解到了根据<code>node.id</code>,<code>node.hostname</code><br />
进行指定节点的部署，但指定的却是唯一的。那么该如何实现同一类进行随机的部署呢？到这里我们继续深入了解，更具节点关系的进行约束。可部署节点中的关系有leader，work。</p>
<p>例如，我想实现不在主节点上部署，虽然我们可以使用使用限制中的条件，避开。例如这样</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="string">docker</span> <span class="string">service</span> <span class="string">create</span> <span class="string">\</span></span><br><span class="line"><span class="string">--name</span> <span class="string">registry</span> <span class="string">\</span></span><br><span class="line"><span class="string">--publish</span> <span class="string">published=5000,target=5000</span> <span class="string">\</span></span><br><span class="line"><span class="string">--constraint</span> <span class="string">node.id!=ytsyvuhfs60spr361y6irpynm</span> <span class="string">\</span> <span class="comment"># 修改处</span></span><br><span class="line"><span class="string">registry:2</span></span><br></pre></td></tr></table></figure>
<p>只需要将<code>==</code>,改为<code>!=</code>,即可。</p>
<h4 id="docker-service-3"><a class="markdownIt-Anchor" href="#docker-service-3"></a> docker service</h4>
<p>但终究还是感觉很不喜欢，其实我们也可以这样,根据节点关系进行约束部署，示例如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">--name nginx \</span><br><span class="line">--publish published=80,target=80 \</span><br><span class="line">--constraint node.role!=manager nginx</span><br></pre></td></tr></table></figure>
<h4 id="docker-stack-3"><a class="markdownIt-Anchor" href="#docker-stack-3"></a> docker stack</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yaml </span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">target:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">published:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">tcp</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">mode:</span> <span class="string">ingress</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">global</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span> <span class="comment"># 添加条件约束</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">node.role!=manager</span></span><br><span class="line">      <span class="attr">restart_policy:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">on-failure</span></span><br><span class="line">        <span class="attr">max_attempts:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="node-lables"><a class="markdownIt-Anchor" href="#node-lables"></a> Node lables</h3>
<p>讲了这么多，照顾新手的就已经过去了，接下来我们晚点更常用的部署，更具lables，来部署。只要是同一个lable，就会可以被部署到，切后续还可以根据label进行更得心应手的管理，例如加入一个label，进行节点驱逐、然后在新加入lables，扩容</p>
<h4 id="添加标签与检查标签"><a class="markdownIt-Anchor" href="#添加标签与检查标签"></a> 添加标签与检查标签</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加标签</span></span><br><span class="line">docker node update --label-add role=web hostname</span><br><span class="line"><span class="comment"># 检查标签</span></span><br><span class="line">docker node inspect hostname </span><br><span class="line"><span class="comment"># 删除标签</span></span><br><span class="line">docker node update --label-rm role hostname</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;ID&quot;</span>: <span class="string">&quot;ttdku9ch37pknxu7b9sxknimb&quot;</span>,                                                                                   </span><br><span class="line">        <span class="string">&quot;Version&quot;</span>: &#123;                                                                                                         </span><br><span class="line">            <span class="string">&quot;Index&quot;</span>: 852                                                                                                     </span><br><span class="line">        &#125;,                                                                                                                   </span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2020-12-08T11:10:53.322771866Z&quot;</span>,                                                                       </span><br><span class="line">        <span class="string">&quot;UpdatedAt&quot;</span>: <span class="string">&quot;2020-12-13T13:24:57.009816659Z&quot;</span>,                                                                       </span><br><span class="line">        <span class="string">&quot;Spec&quot;</span>: &#123;                                                                                                            </span><br><span class="line">            <span class="string">&quot;Labels&quot;</span>: &#123;                                                                                                      </span><br><span class="line">                <span class="string">&quot;role&quot;</span>: <span class="string">&quot;web&quot;</span>              <span class="comment"># 这样我们就实现了添加标签                                                                                  </span></span><br><span class="line">            &#125;,                                                                                                               </span><br><span class="line">            <span class="string">&quot;Role&quot;</span>: <span class="string">&quot;manager&quot;</span>,                                                                                               </span><br><span class="line">            <span class="string">&quot;Availability&quot;</span>: <span class="string">&quot;active&quot;</span>                                                                                         </span><br><span class="line">        &#125;,                 </span><br><span class="line">        <span class="comment"># 略</span></span><br></pre></td></tr></table></figure>
<h4 id="docker-service-4"><a class="markdownIt-Anchor" href="#docker-service-4"></a> docker Service</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --name nginx_2 \</span><br><span class="line">  --constraint <span class="string">&#x27;node.labels.role == web&#x27;</span> \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure>
<h4 id="docker-stack-4"><a class="markdownIt-Anchor" href="#docker-stack-4"></a> docker Stack</h4>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">    mycat:</span><br><span class="line">         image: nginx</span><br><span class="line">         ports:</span><br><span class="line">           - target: <span class="number">8080</span></span><br><span class="line">             published: <span class="number">8080</span></span><br><span class="line">             protocol: tcp</span><br><span class="line">             mode: ingress</span><br><span class="line">         deploy:</span><br><span class="line">           mode: <span class="keyword">global</span></span><br><span class="line">           placement:</span><br><span class="line">              constraints:                      <span class="meta"># 添加条件约束</span></span><br><span class="line">                - node.labels.role==web</span><br><span class="line">           restart_policy:</span><br><span class="line">             condition: <span class="keyword">on</span>-failure</span><br><span class="line">             max_attempts: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><code>constraints</code> 为数组，填写多个约束时，它们之间的关系是 <code>AND</code>。也就是说我们可以进行组合使用</p>
<h3 id="更多请参考下表"><a class="markdownIt-Anchor" href="#更多请参考下表"></a> 更多请参考下表</h3>
<table>
<thead>
<tr>
<th style="text-align:left">node attribute</th>
<th style="text-align:left">matches</th>
<th style="text-align:left">example</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>node.id</code></td>
<td style="text-align:left">Node ID</td>
<td style="text-align:left"><code>node.id==2ivku8v2gvtg4</code></td>
</tr>
<tr>
<td style="text-align:left"><code>node.hostname</code></td>
<td style="text-align:left">Node hostname</td>
<td style="text-align:left"><code>node.hostname!=node-2</code></td>
</tr>
<tr>
<td style="text-align:left"><code>node.role</code></td>
<td style="text-align:left">Node role (<code>manager</code>/<code>worker</code>)</td>
<td style="text-align:left"><code>node.role==manager</code></td>
</tr>
<tr>
<td style="text-align:left"><code>node.platform.os</code></td>
<td style="text-align:left">Node operating system</td>
<td style="text-align:left"><code>node.platform.os==windows</code></td>
</tr>
<tr>
<td style="text-align:left"><code>node.platform.arch</code></td>
<td style="text-align:left">Node architecture</td>
<td style="text-align:left"><code>node.platform.arch==x86_64</code></td>
</tr>
<tr>
<td style="text-align:left"><code>node.labels</code></td>
<td style="text-align:left">User-defined node labels</td>
<td style="text-align:left"><code>node.labels.security==high</code></td>
</tr>
<tr>
<td style="text-align:left"><code>engine.labels</code></td>
<td style="text-align:left">Docker Engine’s labels</td>
<td style="text-align:left"><code>engine.labels.operatingsystem==ubuntu-14.04</code></td>
</tr>
</tbody>
</table>
<h3 id="推荐阅读"><a class="markdownIt-Anchor" href="#推荐阅读"></a> 推荐阅读</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9zZXJ2aWNlX2NyZWF0ZS8jc2V0LXNlcnZpY2UtbW9kZS0tLW1vZGU=">此部分的官方文档<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>docker</category>
        <category>Docker</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>frida-rpc</title>
    <url>/11141.html</url>
    <content><![CDATA[<h2 id="frida-主动调用"><a class="markdownIt-Anchor" href="#frida-主动调用"></a> frida 主动调用</h2>
<p>主动调用: 强制去调用函数执行</p>
<p>被动调用: 由app主导,按照正常的执行顺序执行函数. 函数执行完全依靠与用户交互完成从而间接的调用到关键函数</p>
<p>在Java中,类的函数可以分为两种: 类函数与实例方法, 也可以称之为静态方法和动态方法.</p>
<p>类函数使用关键字<code>static</code> 修饰,与对应的类绑定, 当然如果该类函数还被<code>public</code> 修饰,则在外部就可以直接通过类去调用</p>
<p>实例方法没有被 <code>staic</code> 修饰,在外部只能通过实例化对应的类,在通过该实例调用对应的方法.</p>
<p>在frida中主动调用的类型会根据方法的类型区分开来, 类函数的直接调用使用<code>Java.use</code><br />
即可,实例方法则需要先找到对应的实例后对方法进行调用, 通常使用<code>Java.choose</code>.</p>
<p>示例代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setImmediate</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Script loaded successfully, start hook...&#x27;</span>);</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Inside java perform function...&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态(类)函数 主动调用</span></span><br><span class="line">    <span class="keyword">let</span> class_name = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.xxx.xxx.xxx&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> result1 = class_name.<span class="title function_">method</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态(实例)方法 主动调用</span></span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&#x27;com.xxx.xxx.xxx&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">onMatch</span>: <span class="keyword">function</span> (<span class="params">instance</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;instance found &#x27;</span>, instance);</span><br><span class="line">        <span class="keyword">let</span> result2 = instance.<span class="title function_">method</span>();</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">onComplete</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;search complete&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="frida-rpc"><a class="markdownIt-Anchor" href="#frida-rpc"></a> frida-rpc</h2>
<p>通过exports 将结果导出,以便于python 结合frida模块直接调用.</p>
<p>js脚本与hook脚本写法基本一致,示例代码如下所示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rpc.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Script loaded successfully, start hook...&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> xxx_result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Inside java perform function...&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> class_name = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.xxx.xxx.xxx&#x27;</span>);</span><br><span class="line">    xxx_result = class_name.<span class="title function_">method_name</span>(<span class="string">&#x27;参数&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> xxx_result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Script loaded successfully, start hook...&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> xxx_result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Inside java perform function...&#x27;</span>);</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&#x27;com.xxx.xxx&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">onMatch</span>: <span class="keyword">function</span> (<span class="params">instance</span>) &#123;</span><br><span class="line">        xxx_result = class_name.<span class="title function_">method_name</span>(<span class="string">&#x27;参数&#x27;</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">onComplete</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;search complete&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> xxx_result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rpc.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">rpc_func1</span>: func1,</span><br><span class="line">  <span class="attr">rpc_func2</span>: func2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rpc.py</span></span><br><span class="line"><span class="comment"># File: proc.py</span></span><br><span class="line"><span class="comment"># User: Payne-Wu</span></span><br><span class="line"><span class="comment"># Date: 2022/6/26 17:33</span></span><br><span class="line"><span class="comment"># Desc:</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"></span><br><span class="line">device = frida.get_usb_device()</span><br><span class="line">script_path = <span class="string">&quot;HookScript/example.js&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">message_call_back</span>(<span class="params">message, data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    message call back</span></span><br><span class="line"><span class="string">    :param message:</span></span><br><span class="line"><span class="string">    :param data:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    logger.info(message)</span><br><span class="line">    logger.info(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">attach_hook</span>(<span class="params">app_name</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param app_name:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    process = device.attach(app_name)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(script_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        script = process.create_script(f.read())</span><br><span class="line">    script.on(<span class="string">&#x27;message&#x27;</span>, message_call_back)</span><br><span class="line">    script.load()</span><br><span class="line">    sys.stdin.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spawn</span>(<span class="params">package_name</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param package_name:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    pid = device.spawn(package_name)</span><br><span class="line">    process = device.attach(pid)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(script_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        script = process.create_script(f.read())</span><br><span class="line">    script.on(<span class="string">&#x27;message&#x27;</span>, message_call_back)</span><br><span class="line">    script.load()</span><br><span class="line">    <span class="comment"># rpc </span></span><br><span class="line">    <span class="comment"># script.exports.func_name</span></span><br><span class="line">    device.resume(pid)</span><br><span class="line">    sys.stdin.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    spawn(<span class="string">&#x27;com.xxx.xxx&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>frida</category>
        <category>hook</category>
        <category>sec</category>
      </categories>
      <tags>
        <tag>frida</tag>
      </tags>
  </entry>
  <entry>
    <title>git 使用总结</title>
    <url>/28574.html</url>
    <content><![CDATA[<h2 id="git安装"><a class="markdownIt-Anchor" href="#git安装"></a> git安装</h2>
<h3 id="mac"><a class="markdownIt-Anchor" href="#mac"></a> mac</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install git git-lfs</span><br></pre></td></tr></table></figure>
<h3 id="linuxcentos"><a class="markdownIt-Anchor" href="#linuxcentos"></a> Linux(centos)</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y git git-lfs</span><br></pre></td></tr></table></figure>
<h2 id="git配置初始化"><a class="markdownIt-Anchor" href="#git配置初始化"></a> git配置初始化</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;paynewu&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;wuzhipeng1289690157@gmail.com&quot;</span></span><br><span class="line">git config --global credential.helper store</span><br><span class="line">git config --global core.longpaths <span class="literal">true</span></span><br><span class="line">git config --global core.quotepath off</span><br><span class="line">git lfs install --skip-repo</span><br></pre></td></tr></table></figure>
<h2 id="实践"><a class="markdownIt-Anchor" href="#实践"></a> 实践</h2>
<h3 id="初始化repo"><a class="markdownIt-Anchor" href="#初始化repo"></a> 初始化repo</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建空的git仓库或重新初始化一个现有的仓库</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure>
<h3 id="添加文件到本地仓库暂存区"><a class="markdownIt-Anchor" href="#添加文件到本地仓库暂存区"></a> 添加文件到本地仓库暂存区</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将文件添加到暂存区</span></span><br><span class="line">git add demofile</span><br><span class="line"><span class="comment"># 将所有文件添加到暂存区</span></span><br><span class="line">git add --all</span><br><span class="line"><span class="comment"># 保存所有改动的文件和删除的文件，不包括新的文件</span></span><br><span class="line">git add -u</span><br></pre></td></tr></table></figure>
<h3 id="添加到本地仓库"><a class="markdownIt-Anchor" href="#添加到本地仓库"></a> 添加到本地仓库</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此命令代表确认提交到本地仓库。</span></span><br><span class="line">git commit -m <span class="string">&#x27;v1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有暂存区提交到本地仓库。</span></span><br><span class="line">git commit -am <span class="string">&#x27;v1&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以使用 <code>git status</code> 查看状态</p>
</blockquote>
<h3 id="查看提交日志"><a class="markdownIt-Anchor" href="#查看提交日志"></a> 查看提交日志</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看日志</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一行展示</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参考日志（Reference logs），记录每一次操作</span></span><br><span class="line">git relog</span><br></pre></td></tr></table></figure>
<h3 id="版本回退"><a class="markdownIt-Anchor" href="#版本回退"></a> 版本回退</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 回退到上一版</span></span><br><span class="line">git reset --hard HEAD^</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回退到上上个版本</span></span><br><span class="line">git reset --hard HEAD^^</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果回退的版本过多则不用加那么多的 ^ 号 </span></span><br><span class="line"><span class="comment"># 比如回退到上 10 版本，则可以用</span></span><br><span class="line">git reset --hard HEAD~10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回退到指定hash的分支</span></span><br><span class="line">git reset --hard <span class="built_in">hash</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="撤销修改"><a class="markdownIt-Anchor" href="#撤销修改"></a> 撤销修改</h3>
<p>总结：</p>
<ul>
<li>
<p>场景 1：当改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 git checkout — file。</p>
</li>
<li>
<p>场景 2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令 git<br />
reset HEAD file，就回到了场景 1，第二步按场景 1 操作。</p>
</li>
<li>
<p>场景 3：已经提交了不合适的修改到版本库时，想要撤销本次提交，进行版本回退，不过前提是没有推送到远程库。<br />
8. 删除文件 假如现在你新建了一个 hello.txt 文件，你已经 add 并 commit 到了本地分支之中。<br />
现在你想删除，如果直接执行</p>
</li>
</ul>
<h3 id="分支"><a class="markdownIt-Anchor" href="#分支"></a> 分支</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建本地分支</span></span><br><span class="line">git branch dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 dev 分支</span></span><br><span class="line">git checkout dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并切换到该分支</span></span><br><span class="line">git checkout -b dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并分支</span></span><br><span class="line">git merge</span><br></pre></td></tr></table></figure>
<h3 id="push"><a class="markdownIt-Anchor" href="#push"></a> push</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push -u origin branch-name</span><br></pre></td></tr></table></figure>
<h3 id="tag"><a class="markdownIt-Anchor" href="#tag"></a> tag</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加一个标签</span></span><br><span class="line">git tag -a <span class="string">&quot;v1.0.0&quot;</span> -m <span class="string">&quot;Version 1.0.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个标签</span></span><br><span class="line">git tag -d v1.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程标签</span></span><br><span class="line">git push --delete origin v1.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有标签</span></span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>
<h3 id="删除未监视文件"><a class="markdownIt-Anchor" href="#删除未监视文件"></a> 删除未监视文件</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git clean -f</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 连 untracked 的目录也一起删掉</span></span><br><span class="line">git clean -fd</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 连 gitignore 的untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）</span></span><br><span class="line">git clean -xfd</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在用上述 git clean 前，墙裂建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删</span></span><br><span class="line">git clean -nxfd</span><br><span class="line">git clean -nf</span><br><span class="line">git clean -nfd</span><br></pre></td></tr></table></figure>
<h3 id="子模块"><a class="markdownIt-Anchor" href="#子模块"></a> 子模块</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;repository&gt; --recursive 递归的方式克隆整个项目</span><br><span class="line">git submodule add &lt;repository&gt; &lt;path&gt; 添加子模块</span><br><span class="line">git submodule init 初始化子模块</span><br><span class="line">git submodule update 更新子模块</span><br><span class="line">git submodule foreach git pull 拉取所有子模块</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>git</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>gitbook的使用</title>
    <url>/62778.html</url>
    <content><![CDATA[<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2>
<blockquote>
<p>前置条件：node版本必须为12.x</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g gitbook-cli@latest</span><br></pre></td></tr></table></figure>
<p><strong>handle error</strong></p>
<p>执行gitbook -V的时候出现如下错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/data/soft/nodejs/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287</span><br><span class="line">      <span class="keyword">if</span> (cb) cb.apply(this, arguments)</span><br><span class="line">                 ^</span><br><span class="line"></span><br><span class="line">TypeError: cb.apply is not a <span class="keyword">function</span></span><br><span class="line">    at /data/soft/nodejs/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18</span><br><span class="line">    at FSReqCallback.oncomplete (fs.js:169:5)</span><br></pre></td></tr></table></figure>
<p>遇到<code>TypeError: cb.apply is not a function</code>, 这个错误直接打开如下链接中的js文件</p>
<p><code>/data/soft/nodejs/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js</code></p>
<p>将<strong>在第62-64行如下代码进行注释即可</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.<span class="property">stat</span> = <span class="title function_">statFix</span>(fs.<span class="property">stat</span>)</span><br><span class="line">fs.<span class="property">fstat</span> = <span class="title function_">statFix</span>(fs.<span class="property">fstat</span>)</span><br><span class="line">fs.<span class="property">lstat</span> = <span class="title function_">statFix</span>(fs.<span class="property">lstat</span>)</span><br></pre></td></tr></table></figure>
<p>btw,<br />
需要说明的是<code>/data/soft/nodejs/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js</code><br />
这<br />
个路径并不是绝对的，会因为Node.js安装路径的不同而改变。 所以，视具体的报错进行修改即可</p>
]]></content>
      <categories>
        <category>gitbook</category>
        <category>github-pages</category>
      </categories>
      <tags>
        <tag>gitbook</tag>
      </tags>
  </entry>
  <entry>
    <title>github项目搜索技巧</title>
    <url>/51976.html</url>
    <content><![CDATA[<h2 id="搜项目大全"><a class="markdownIt-Anchor" href="#搜项目大全"></a> 搜项目大全</h2>
<p>awesome-xxx</p>
<p>例如想了解python的所有技术体系,我们就可以搜索 awesome-python ,当然Java\spider\datascience等等</p>
<h2 id="搜索样例"><a class="markdownIt-Anchor" href="#搜索样例"></a> 搜索样例</h2>
<p>xxx simple 或者 xxx demo</p>
<h2 id="空项目结构"><a class="markdownIt-Anchor" href="#空项目结构"></a> 空项目结构</h2>
<p>xxx starter</p>
<p>例如</p>
<p>springboot starter</p>
<p>springboot+mybatis starter</p>
<h2 id="教程与学习路线"><a class="markdownIt-Anchor" href="#教程与学习路线"></a> 教程与学习路线</h2>
<p>xxx tutorial</p>
<p>例如: python tutorial</p>
<blockquote>
<p>当然结合 <code>awesome-xxx</code> 更香哦</p>
</blockquote>
<h2 id="常用快捷键"><a class="markdownIt-Anchor" href="#常用快捷键"></a> 常用快捷键</h2>
<p>s: 快速定位到搜索框进行搜索</p>
<p>t: 项目文件树</p>
<p><code>ctrl + K</code> : 快速查看文件</p>
<p><code>.</code>: 在线预览\运行项目</p>
<p>快捷键: <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vY24vZ2V0LXN0YXJ0ZWQvdXNpbmctZ2l0aHViL2tleWJvYXJkLXNob3J0Y3V0cw==">https://docs.github.com/cn/get-started/using-github/keyboard-shortcuts<i class="fa fa-external-link-alt"></i></span></p>
<p>GitHub Search: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NlYXJjaC9hZHZhbmNlZA==">https://github.com/search/advanced<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>go-concurrency</title>
    <url>/60799.html</url>
    <content><![CDATA[<h2 id="process-and-thread"><a class="markdownIt-Anchor" href="#process-and-thread"></a> Process And Thread</h2>
<p>操作系统会为应用程序创建一个进程, 作为应用程序. 它是一个为应用程序所有资源而运行的容器,<br />
这些资源包含内存地址, 文件句柄, 设备和线程. 每个进程中都包含了一个主进程</p>
<p>线程是操作系统调度的一种执行路径, 用于在处理器中执行我们编写的代码.</p>
<p>一个进程从一个线程开始, 即主线程, 当该线程终止时，进程终止。这是因为主线程是应用程序的原点。然后，主线程可以依次启动更多的线程，而这些线程可以启动更多的线程。</p>
<blockquote>
<p>无论线程属于哪个进程，操作系统都会安排线程在可用处理器上运行。每个操作系统都有自己的算法来做出这些决定。</p>
</blockquote>
<h2 id="goroutines-and-parallelism"><a class="markdownIt-Anchor" href="#goroutines-and-parallelism"></a> Goroutines and Parallelism</h2>
<p>Go 语言层面支持的 go 关键字，可以快速的让一个函数创建为 goroutine，我们可以认为 main 函数就是作为<br />
goroutine 执行的。操作系统调度线程在可用处理器上运行，Go运行时调度 goroutine<br />
在绑定到单个操作系统线程的逻辑处理器中运行（P）。即使使用这个单一的逻辑处理器和操作系统线程，也可以调度数十万<br />
goroutine 以惊人的效率和性能并发运行。</p>
<blockquote>
<p>Concurrency is not Parallelism.</p>
</blockquote>
<p>​ 并发不是并行。并行是指两个或多个线程同时在不同的处理器执行代码。如果将运行时配置为使用多个逻辑处理器，则调度程序将在这些逻辑处理器之间分配<br />
goroutine，这将导致 goroutine 在不同的操作系统线程上运行。但是，要获得真正的并行性，您需要在具有多个物理处理器的计算机上运行程序。否则，goroutine<br />
将针对单个物理处理器并发运行，即使 Go 运行时使用多个逻辑处理器。</p>
<p><strong>Keep yourself busy or do the work yourself</strong></p>
<p><strong>Leave concurrency to the caller</strong></p>
<p><strong>Never start a goroutine without knowning when it will stop</strong></p>
<p>Any time you start a Goroutine you must ask yourself:</p>
<ul>
<li>
<p>When will it terminate?</p>
</li>
<li>
<p>What could prevent it from terminating?</p>
</li>
</ul>
<p>小结: 由开发者管理goroutine的生命周期, 将并发性交给调用方</p>
]]></content>
      <categories>
        <category>go</category>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go code tips</title>
    <url>/37698.html</url>
    <content><![CDATA[<h2 id="go-code-tips"><a class="markdownIt-Anchor" href="#go-code-tips"></a> Go code tips</h2>
<h3 id="使用-pkgerrors"><a class="markdownIt-Anchor" href="#使用-pkgerrors"></a> 使用 pkg/errors</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9wa2cuZ28uZGV2L2dpdGh1Yi5jb20vcGtnL2Vycm9ycw==">https://pkg.go.dev/github.com/pkg/errors<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>我们在一个项目中使用错误机制，最核心的几个需求是什么？我觉得主要是这两点：</p>
<ul>
<li>附加信息：我们希望错误出现的时候能附带一些描述性的错误信息，甚至这些信息是可以嵌套的</li>
<li>附加堆栈：我们希望错误不仅仅打印出错误信息，也能打印出这个错误的堆栈信息，可以知道出错的具体代码。</li>
</ul>
<p>在 Go 语言的演进过程中，error 传递的信息太少一直是被诟病的一点。使用官方的 error<br />
库，只能打印一条简单的错误信息，而没有更多的信息辅助快速定位错误。所以，推荐在应用层使用 <code>github.com/pkg/errors</code><br />
来替换官方的 error 库。因为使用 <code>pkg/errors</code>，我们不仅能传递出标准库 error 的错误信息，还能传递出抛出<br />
error 的堆栈信息。</p>
<p>官方示例代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"> <span class="string">&quot;github.com/pkg/errors&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line"> e1 := errors.New(<span class="string">&quot;error&quot;</span>)</span><br><span class="line"> e2 := errors.Wrap(e1, <span class="string">&quot;inner&quot;</span>)</span><br><span class="line"> e3 := errors.Wrap(e2, <span class="string">&quot;middle&quot;</span>)</span><br><span class="line"> <span class="keyword">return</span> errors.Wrap(e3, <span class="string">&quot;outer&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">type</span> stackTracer <span class="keyword">interface</span> &#123;</span><br><span class="line">  StackTrace() errors.StackTrace</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> err, ok := errors.Cause(fn()).(stackTracer)</span><br><span class="line"> <span class="keyword">if</span> !ok &#123;</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;oops, err does not implement stackTracer&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> st := err.StackTrace()</span><br><span class="line"> fmt.Printf(<span class="string">&quot;%+v&quot;</span>, st[<span class="number">0</span>:<span class="number">2</span>]) <span class="comment">// top two frames</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Example output:</span></span><br><span class="line"> <span class="comment">// github.com/pkg/errors_test.fn</span></span><br><span class="line"> <span class="comment">// /home/dfc/src/github.com/pkg/errors/example_test.go:47</span></span><br><span class="line"> <span class="comment">// github.com/pkg/errors_test.Example_stackTrace</span></span><br><span class="line"> <span class="comment">// /home/dfc/src/github.com/pkg/errors/example_test.go:127</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="在初始化-slice-的时候尽量补全-cap"><a class="markdownIt-Anchor" href="#在初始化-slice-的时候尽量补全-cap"></a> 在初始化 slice 的时候尽量补全 cap</h3>
<blockquote>
<p>当我们要创建一个 slice 结构，并且往 slice 中 append 元素的时候，我们可能有两种写法来初始化这个<br />
slice。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接使用[]int 的方式来初始化</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    arr = <span class="built_in">append</span>(arr, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    fmt.Println(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 make 关键字来初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   arr := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">   arr = <span class="built_in">append</span>(arr, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">   fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二相较于方法一，就只有一个区别：在初始化[]int slice 的时候在 make 中设置了 cap 的长度，就是 slice<br />
的大小。</p>
<p>而且，这两种方法对应的功能和输出结果是没有任何差别的，但是实际运行的时候，方法二会比方法一少运行了一个<br />
growslice 的命令，能够提升我们程序的运行性能。具体我们可以打印汇编码查看一下。</p>
<blockquote>
<p>这个 growslice 的作用就是扩充 slice 容量，每当我们的 slice 容量小于我们需要使用的 slice<br />
大小，这个函数就会被触发。</p>
</blockquote>
<p>它的机制就好比是原先我们没有定制容量，系统给了我们一个能装两个鞋子的盒子，但是当我们装到第三个鞋子的时候，这个盒子就不够了，我们就要换一个盒子，而换这个盒子，我们势必还需要将原先的盒子里面的鞋子也拿出来放到新的盒子里面。</p>
<blockquote>
<p>而 growsslice 的操作是一个比较复杂的操作，它的表现和复杂度会高于最基本的初始化 make<br />
方法。对追求性能的程序来说，应该能避免就尽量避免。如果你对 growsslice 函数的具体实现感兴趣，你可以参考源码<br />
src 的 runtime/slice.go 。</p>
</blockquote>
<p>当然，并不是每次都能在 slice 初始化的时候，就准确预估到最终的使用容量，所以我这里说的是“尽量补全<br />
cap”。明白是否设置 slice 容量的区别后，我们在能预估容量的时候，请尽量使用方法二那种预估容量后的 slice<br />
初始化方式。</p>
<h3 id="初始化一个类的时候如果类的构造参数较多尽量使用-option-写法"><a class="markdownIt-Anchor" href="#初始化一个类的时候如果类的构造参数较多尽量使用-option-写法"></a> 初始化一个类的时候，如果类的构造参数较多，尽量使用 Option 写法</h3>
<p>遇到一定要初始化一个类的时候，大部分时候都会使用类似下列的 New 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">   name <span class="type">string</span></span><br><span class="line">   id <span class="type">int</span></span><br><span class="line">   age <span class="type">int</span></span><br><span class="line"></span><br><span class="line">   db <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFoo</span><span class="params">(name <span class="type">string</span>, id <span class="type">int</span>, age <span class="type">int</span>, db <span class="keyword">interface</span>&#123;&#125;)</span></span> *Foo &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;Foo&#123;</span><br><span class="line">      name: name,</span><br><span class="line">      id:   id,</span><br><span class="line">      age:  age,</span><br><span class="line">      db:   db,</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们定义一个 NewFoo 方法，其中存放初始化 Foo 结构所需要的各种字段属性。这个写法乍看之下是没啥问题的，但是一旦<br />
Foo 结构内部的字段发生了变化，增加或者减少了，那么这个初始化函数 NewFoo<br />
就怎么看怎么别扭了。参数继续增加？那么所有调用了这个 NewFoo 方法的地方也都需要进行修改，且按照代码整洁的逻辑，参数多于<br />
5 个，这个函数就很难使用了。而且，如果这 5 个参数都是可有可无的参数，就是有的参数可以不填写，有默认值，比如<br />
age 这个字段，即使我们不填写，在后续的业务逻辑中可能也没有很多影响，那么我在实际调用 NewFoo 的时候，age<br />
这个字段还需要传递 0 值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">foo := NewFoo(<span class="string">&quot;payne&quot;</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>乍看这行代码，你可能会以为我创建了一个 Foo，它的年龄为 0，但是实际上是希望表达这里使用了一个“缺省值”，这种代码的语义逻辑就不对了。</p>
<p>这里其实有一种更好的写法：<strong>使用 Option 写法来进行改造</strong></p>
<p>Option 写法，顾名思义，就是将所有可选的参数作为一个可选方式，一般我们会设计一个“函数类型”来代表这个<br />
Option，然后配套将所有可选字段设计为一个这个函数类型的具体实现。在具体的使用的时候，使用可变字段的方式来控制有多少个函数类型会被执行。比如上述的代码，我们会改造为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    id <span class="type">int</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    db <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FooOption 代表可选参数</span></span><br><span class="line"><span class="keyword">type</span> FooOption <span class="function"><span class="keyword">func</span><span class="params">(foo *Foo)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WithName 代表Name为可选参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithName</span><span class="params">(name <span class="type">string</span>)</span></span> FooOption &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(foo *Foo)</span></span> &#123;</span><br><span class="line">      foo.name = name</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WithAge 代表age为可选参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithAge</span><span class="params">(age <span class="type">int</span>)</span></span> FooOption &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(foo *Foo)</span></span> &#123;</span><br><span class="line">      foo.age = age</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WithDB 代表db为可选参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDB</span><span class="params">(db <span class="keyword">interface</span>&#123;&#125;)</span></span> FooOption &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(foo *Foo)</span></span> &#123;</span><br><span class="line">      foo.db = db</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewFoo 代表初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFoo</span><span class="params">(id <span class="type">int</span>, options ...FooOption)</span></span> *Foo &#123;</span><br><span class="line">   foo := &amp;Foo&#123;</span><br><span class="line">      name: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">      id:   id,</span><br><span class="line">      age:  <span class="number">10</span>,</span><br><span class="line">      db:   <span class="literal">nil</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> _, option := <span class="keyword">range</span> options &#123;</span><br><span class="line">      option(foo)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> foo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们创建了一个 FooOption 的函数类型，这个函数类型代表的函数结构是 func(foo *Foo) 。</p>
<p>这个结构很简单，就是将 foo 指针传递进去，能让内部函数进行修改。然后我们针对三个初始化字段 name，age，db<br />
定义了三个返回了 FooOption 的函数，负责修改它们：</p>
<ul>
<li>WithName</li>
<li>WithAge</li>
<li>WithDB</li>
</ul>
<p>以 WithName 为例，这个函数参数为 string，返回值为 FooOption。在返回值的 FooOption 中，根据参数修改了 Foo<br />
指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WithName 代表Name为可选参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithName</span><span class="params">(name <span class="type">string</span>)</span></span> FooOption &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(foo *Foo)</span></span> &#123;</span><br><span class="line">      foo.name = name</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有兴趣可以看看知名爬虫框架colly-<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvY29sbHkvY29sbHkvYmxvYi9tYXN0ZXIvY29sbHkuZ28jTDU1JUVGJUJDJThDJUU2JTlFJTg0JUU5JTgwJUEw">https://github.com/gocolly/colly/blob/master/colly.go#L55，构造<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="巧用大括号控制变量作用域"><a class="markdownIt-Anchor" href="#巧用大括号控制变量作用域"></a> 巧用大括号控制变量作用域</h3>
<p>在写 Go 的过程中，你一定有过为 := 和 =<br />
烦恼的时刻。一个变量，到写的时候，我还要记得前面是否已经定义过了，如果没有定义过，使用 :=<br />
，如果已经定义过，使用 =。</p>
<p>当然很多时候你可能并不会犯这种错误，如果变量命名得比较好的话，我们是很容易记得这个变量前面是否有定义过的。但是更多时候，对于<br />
err 这种通用的变量名字，你可能就不一定记得了。</p>
<p><strong>这个时候，巧妙使用大括号，就能很好避免这个问题。</strong></p>
<h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3>
<ul>
<li>使用 pkg/error 而不是官方 error 库</li>
<li>在初始化 slice 的时候尽量补全 cap</li>
<li>初始化一个类的时候，如果类的构造参数较多，尽量使用 Option 写法</li>
<li>巧用大括号控制变量作用域</li>
</ul>
<p>这几种写法和注意事项都是我在工作和阅读开源项目中的一些总结和经验，每个经验都是对应为了解决不同的问题。虽然说<br />
Go 已经对代码做了不少的规范和优化，但是好的代码和不那么好的代码还是有一些差距的，这些写法优化点就是其中一部分。</p>
]]></content>
      <categories>
        <category>go</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go-reflect</title>
    <url>/30190.html</url>
    <content><![CDATA[<h2 id="反射简介"><a class="markdownIt-Anchor" href="#反射简介"></a> 反射简介</h2>
<p>Go在标准库中提供的reflect包让Go程序具备运行时的反射能力（reflection）。反射是程序在运行时访问、检测和修改它本身状态或行为的一种能力，各种编程语言所实现的反射机制各有不同。</p>
<p>Go语言的<code>interface&#123;&#125;</code><br />
类型变量具有析出任意类型变量的类型信息（type）和值信息（value）的能力，Go的反射本质上就是利用<code>interface&#123;&#125;</code><br />
的这种能力在运行时对任意变量的类型和值信息进行检视甚至是对值进行修改的机制。</p>
<p>反射让静态类型语言Go在运行时具备了某种基于类型信息的动态特性。利用这种特性，fmt.Println在无法提前获知传入参数的真正类型的情况下依旧可以对其进行正确的格式化输出</p>
<h2 id="反射三大法则"><a class="markdownIt-Anchor" href="#反射三大法则"></a> 反射三大法则</h2>
<p>Rob Pike还为Go反射的规范使用定义了三大法则，如果经过评估，你必须使用反射才能实现你要的功能特性，那么你在使用反射时需要牢记这三条法则。</p>
<ul>
<li>反射世界的入口：经由接口（interface{}）类型变量值进入反射的世界并获得对应的反射对象（reflect.Value或reflect.Type）。</li>
<li>反射世界的出口：反射对象（reflect.Value）通过化身为一个接口（interface{}）类型变量值的形式走出反射世界。</li>
<li>修改反射对象的前提：反射对象对应的reflect.Value必须是可设置的（Settable）。</li>
</ul>
<p>reflect.TypeOf和reflect.ValueOf是进入反射世界仅有的两扇“大门”。通过reflect.TypeOf这扇“门”进入反射世界，你将得到一个reflect.Type对象，该对象中包含了被反射的Go变量实例的所有类型信息；</p>
<p>而通过reflect.ValueOf这扇“门”进入反射世界，你将得到一个reflect.Value对象。Value对象是反射世界的核心，不仅该对象中包含了被反射的Go变量实例的值信息，而且通过调用该对象的Type方法，我们还可以得到Go变量实例的类型信息，这与通过reflect.TypeOf获得类型信息是等价的：</p>
<p>reflect.Value.Interface()是reflect.ValueOf()<br />
的逆过程，通过Interface方法我们可以将reflect.Value对象恢复成一个interface{}类型的变量值。这个离开反射世界的过程实质是将reflect.Value中的类型信息和值信息重新打包成一个interface{}的内部表示。</p>
<h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2>
<p>reflect包所提供的Go反射能力是一把“双刃剑”，它既可以被用于优雅地解决一类特定的问题，但也会带来逻辑不清晰、性能问题以及难于发现问题和调试等困惑。<br />
因此，我们应谨慎使用这种能力，在做出使用的决定之前，认真评估反射是不是问题的唯一解决方案；在确定要使用反射能力后，也要遵循上述三个反射法则的要求。</p>
]]></content>
      <categories>
        <category>go</category>
        <category>reflect</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go-unsafe</title>
    <url>/9591.html</url>
    <content><![CDATA[<h2 id="go标准库"><a class="markdownIt-Anchor" href="#go标准库"></a> Go标准库</h2>
<p>Go标准库中的unsafe包非常简洁，如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于获取一个表达式值的大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sizeof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于获取结构体中某字段段地址偏移量（相对于结构体变量的地址）</span></span><br><span class="line"><span class="comment">// Offsetof函数应用面较窄，仅用于结构体某字段的偏移值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Offsetof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Alignof用于获取一个表达式的内存补齐系数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Alignof</span><span class="params">(x ArbitraryType)</span></span> <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 将 len 添加到 ptr 并返回更新后的指针 Pointer(uintptr(ptr) + uintptr(len))。</span></span><br><span class="line"><span class="comment">// len 参数必须是整数类型或无类型常量。</span></span><br><span class="line"><span class="comment">// 一个常量 len 参数必须可以用一个 int 类型的值来表示；</span></span><br><span class="line"><span class="comment">// 如果它是一个无类型常量，它被赋予 int 类型。 Pointer 的有效使用规则仍然适用。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(ptr Pointer, <span class="built_in">len</span> IntegerType)</span></span> Pointer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数 Slice 返回一个切片，其底层数组从 ptr 开始，长度和容量为 len。 </span></span><br><span class="line"><span class="comment">// Slice(ptr, len) 等价于 ([len]ArbitraryType)(unsafe.Pointer(ptr))[:] ，</span></span><br><span class="line"><span class="comment">// 除了作为特殊情况，如果 ptr 为 nil 且 len 为零，Slice 返回 nil。 </span></span><br><span class="line"><span class="comment">// len 参数必须是整数类型或无类型常量。</span></span><br><span class="line"><span class="comment">// 一个常量 len 参数必须是非负的并且可以用一个int类型的值来表示；</span></span><br><span class="line"><span class="comment">// 如果它是一个无类型常量，它被赋予int类型。在运行时，</span></span><br><span class="line"><span class="comment">// 如果len为负数，或者ptr为nil且len不为零，则会发生运行时恐慌</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slice</span><span class="params">(ptr *ArbitraryType, <span class="built_in">len</span> IntegerType)</span></span> []ArbitraryType</span><br></pre></td></tr></table></figure>
<h3 id="典型使用"><a class="markdownIt-Anchor" href="#典型使用"></a> 典型使用</h3>
<p>怎么理解Go核心团队在尽力保证go类型安全的情况下，又提供了可以打破安全屏障的<code>unsafe.Pointer</code> 这一行为？</p>
<p>首先被广泛应用于Go标准库和Go 运行时的实现当中，reflect、sync、syscall、runtime都是unsafe包的重度用户。</p>
<h4 id="reflect"><a class="markdownIt-Anchor" href="#reflect"></a> reflect</h4>
<p>ValueOf<br />
和TypeOf函数是reflect包中用得最多的两个API，他们是进入运行时反射层、获取发射层信息的入口。这两个函数均将任意类型变量转化为一个<code>interface&#123;&#125;</code><br />
类型变量，再利用<code>unsafe.Pointer</code><br />
将这个变量绑定的内存区域重新解释为reflect.emptyInterface类型，以获得传入变量的类型和值类的信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/reflect/values.go</span></span><br><span class="line"><span class="comment">// emptyInterface is the header for an interface&#123;&#125; value.</span></span><br><span class="line"><span class="keyword">type</span> emptyInterface <span class="keyword">struct</span> &#123;</span><br><span class="line"> typ  *rtype</span><br><span class="line"> word unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// unpackEface converts the empty interface i to a Value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unpackEface</span><span class="params">(i any)</span></span> Value &#123;</span><br><span class="line"> e := (*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line"> <span class="comment">// <span class="doctag">NOTE:</span> don&#x27;t read e.word until we know whether it is really a pointer or not.</span></span><br><span class="line"> t := e.typ</span><br><span class="line"> <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> f := flag(t.Kind())</span><br><span class="line"> <span class="keyword">if</span> ifaceIndir(t) &#123;</span><br><span class="line">  f |= flagIndir</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> Value&#123;t, e.word, f&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $GOROOT/src/reflect/type.go</span></span><br><span class="line"><span class="comment">// If i is a nil interface value, TypeOf returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i any)</span></span> Type &#123;</span><br><span class="line"> eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line"> <span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sync"><a class="markdownIt-Anchor" href="#sync"></a> sync</h4>
<p>sync.Pool 是个并发安全的高性能临时对象缓冲池。Pool<br />
为每个P分配了一个本地缓冲池，并通过下列函数为每个P分配啦一个本地的缓冲池，并通过如下函数实现快速定位P的本地缓冲池。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexLocal</span><span class="params">(l unsafe.Pointer, i <span class="type">int</span>)</span></span> *poolLocal &#123;</span><br><span class="line"> lp := unsafe.Pointer(<span class="type">uintptr</span>(l) + <span class="type">uintptr</span>(i)*unsafe.Sizeof(poolLocal&#123;&#125;))</span><br><span class="line"> <span class="keyword">return</span> (*poolLocal)(lp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// indexLocal函数的本地缓冲池快速定位时通过结合unsafe.Pointer包与uinptr的指针运算实现</span></span><br></pre></td></tr></table></figure>
<p>标准库中的saycall包封装了与操作系统交互的系统调用接口，比如Statfs、Listen、Select</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/syscall/zsyscall_linux_amd64.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Statfs</span><span class="params">(path <span class="type">string</span>, buf *Statfs_t)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> _p0 *<span class="type">byte</span></span><br><span class="line"> _p0, err = BytePtrFromString(path)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> _, _, e1 := Syscall(SYS_STATFS, <span class="type">uintptr</span>(unsafe.Pointer(_p0)), <span class="type">uintptr</span>(unsafe.Pointer(buf)), <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">if</span> e1 != <span class="number">0</span> &#123;</span><br><span class="line">  err = errnoErr(e1)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Listen</span><span class="params">(s <span class="type">int</span>, n <span class="type">int</span>)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line"> _, _, e1 := Syscall(SYS_LISTEN, <span class="type">uintptr</span>(s), <span class="type">uintptr</span>(n), <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">if</span> e1 != <span class="number">0</span> &#123;</span><br><span class="line">  err = errnoErr(e1)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Select</span><span class="params">(nfd <span class="type">int</span>, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"> r0, _, e1 := Syscall6(SYS_SELECT, <span class="type">uintptr</span>(nfd), <span class="type">uintptr</span>(unsafe.Pointer(r)), <span class="type">uintptr</span>(unsafe.Pointer(w)), <span class="type">uintptr</span>(unsafe.Pointer(e)), <span class="type">uintptr</span>(unsafe.Pointer(timeout)), <span class="number">0</span>)</span><br><span class="line"> n = <span class="type">int</span>(r0)</span><br><span class="line"> <span class="keyword">if</span> e1 != <span class="number">0</span> &#123;</span><br><span class="line">  err = errnoErr(e1)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这类的高级调用的最终都会落到调用函数下面一系列的Syscall和RawSyscall函数上面。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Syscall</span><span class="params">(trap, a1, a2, a3 <span class="type">uintptr</span>)</span></span> (r1, r2 <span class="type">uintptr</span>, err Errno)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Syscall6</span><span class="params">(trap, a1, a2, a3, a4, a5, a6 <span class="type">uintptr</span>)</span></span> (r1, r2 <span class="type">uintptr</span>, err Errno)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RawSyscall</span><span class="params">(trap, a1, a2, a3 <span class="type">uintptr</span>)</span></span> (r1, r2 <span class="type">uintptr</span>, err Errno)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RawSyscall6</span><span class="params">(trap, a1, a2, a3, a4, a5, a6 <span class="type">uintptr</span>)</span></span> (r1, r2 <span class="type">uintptr</span>, err Errno)</span><br></pre></td></tr></table></figure>
<p>这些Saycall系列的函数接受的参数类型均为uintptr，这样当封装的系统调用的参数为指针类型时（比如上面Select的参数r、w、e等）。只能只能通过unsafe.uintptr值，就像上面Select函数实现中那样。因此，syscall包是unsafe重度使用者，它的实现离不开的unsafe.Pointer。</p>
<h4 id="runtime包中的unsafe包的典型应用"><a class="markdownIt-Anchor" href="#runtime包中的unsafe包的典型应用"></a> runtime包中的unsafe包的典型应用</h4>
<p>runtime 包实现的goroutine调度和内存管理（包括GC）都有unsafe包的身影以goroutine的栈管理为例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/runtime/stack.go</span></span><br><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;</span><br><span class="line"> lo <span class="type">uintptr</span></span><br><span class="line"> hi <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $GOROOT/src/runtime/runtime.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stackalloc</span><span class="params">(n <span class="type">uint32</span>)</span></span> stack &#123;</span><br><span class="line"> <span class="comment">// Stackalloc must be called on scheduler stack, so that we</span></span><br><span class="line"> <span class="comment">// never try to grow the stack during the code that stackalloc runs.</span></span><br><span class="line"> <span class="comment">// Doing so would cause a deadlock (issue 1547).</span></span><br><span class="line"> thisg := getg()</span><br><span class="line"> <span class="keyword">if</span> thisg != thisg.m.g0 &#123;</span><br><span class="line">  throw(<span class="string">&quot;stackalloc not on scheduler stack&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> n&amp;(n<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">  throw(<span class="string">&quot;stack size not a power of 2&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> stackDebug &gt;= <span class="number">1</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;stackalloc &quot;</span>, n, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> debug.efence != <span class="number">0</span> || stackFromSystem != <span class="number">0</span> &#123;</span><br><span class="line">  n = <span class="type">uint32</span>(alignUp(<span class="type">uintptr</span>(n), physPageSize))</span><br><span class="line">  v := sysAlloc(<span class="type">uintptr</span>(n), &amp;memstats.stacks_sys)</span><br><span class="line">  <span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">   throw(<span class="string">&quot;out of memory (stackalloc)&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack&#123;<span class="type">uintptr</span>(v), <span class="type">uintptr</span>(v) + <span class="type">uintptr</span>(n)&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Small stacks are allocated with a fixed-size free-list allocator.</span></span><br><span class="line"> <span class="comment">// If we need a stack of a bigger size, we fall back on allocating</span></span><br><span class="line"> <span class="comment">// a dedicated span.</span></span><br><span class="line"> <span class="keyword">var</span> v unsafe.Pointer</span><br><span class="line"> <span class="keyword">if</span> n &lt; _FixedStack&lt;&lt;_NumStackOrders &amp;&amp; n &lt; _StackCacheSize &#123;</span><br><span class="line">  order := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line">  n2 := n</span><br><span class="line">  <span class="keyword">for</span> n2 &gt; _FixedStack &#123;</span><br><span class="line">   order++</span><br><span class="line">   n2 &gt;&gt;= <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> x gclinkptr</span><br><span class="line">  <span class="keyword">if</span> stackNoCache != <span class="number">0</span> || thisg.m.p == <span class="number">0</span> || thisg.m.preemptoff != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">   <span class="comment">// thisg.m.p == 0 can happen in the guts of exitsyscall</span></span><br><span class="line">   <span class="comment">// or procresize. Just get a stack from the global pool.</span></span><br><span class="line">   <span class="comment">// Also don&#x27;t touch stackcache during gc</span></span><br><span class="line">   <span class="comment">// as it&#x27;s flushed concurrently.</span></span><br><span class="line">   lock(&amp;stackpool[order].item.mu)</span><br><span class="line">   x = stackpoolalloc(order)</span><br><span class="line">   unlock(&amp;stackpool[order].item.mu)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   c := thisg.m.p.ptr().mcache</span><br><span class="line">   x = c.stackcache[order].list</span><br><span class="line">   <span class="keyword">if</span> x.ptr() == <span class="literal">nil</span> &#123;</span><br><span class="line">    stackcacherefill(c, order)</span><br><span class="line">    x = c.stackcache[order].list</span><br><span class="line">   &#125;</span><br><span class="line">   c.stackcache[order].list = x.ptr().next</span><br><span class="line">   c.stackcache[order].size -= <span class="type">uintptr</span>(n)</span><br><span class="line">  &#125;</span><br><span class="line">  v = unsafe.Pointer(x)</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> s *mspan</span><br><span class="line">  npage := <span class="type">uintptr</span>(n) &gt;&gt; _PageShift</span><br><span class="line">  log2npage := stacklog2(npage)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Try to get a stack from the large stack cache.</span></span><br><span class="line">  lock(&amp;stackLarge.lock)</span><br><span class="line">  <span class="keyword">if</span> !stackLarge.free[log2npage].isEmpty() &#123;</span><br><span class="line">   s = stackLarge.free[log2npage].first</span><br><span class="line">   stackLarge.free[log2npage].remove(s)</span><br><span class="line">  &#125;</span><br><span class="line">  unlock(&amp;stackLarge.lock)</span><br><span class="line"></span><br><span class="line">  lockWithRankMayAcquire(&amp;mheap_.lock, lockRankMheap)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="comment">// Allocate a new stack from the heap.</span></span><br><span class="line">   s = mheap_.allocManual(npage, spanAllocStack)</span><br><span class="line">   <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;out of memory&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   osStackAlloc(s)</span><br><span class="line">   s.elemsize = <span class="type">uintptr</span>(n)</span><br><span class="line">  &#125;</span><br><span class="line">  v = unsafe.Pointer(s.base())</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">  racemalloc(v, <span class="type">uintptr</span>(n))</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">  msanmalloc(v, <span class="type">uintptr</span>(n))</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> asanenabled &#123;</span><br><span class="line">  asanunpoison(v, <span class="type">uintptr</span>(n))</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> stackDebug &gt;= <span class="number">1</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;  allocated &quot;</span>, v, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> stack&#123;<span class="type">uintptr</span>(v), <span class="type">uintptr</span>(v) + <span class="type">uintptr</span>(n)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="unsafepointer-与-uintptr"><a class="markdownIt-Anchor" href="#unsafepointer-与-uintptr"></a> unsafe.Pointer 与 uintptr</h2>
<p>作为Go类型安全层上的一个“后门”，unsafe包在带来强大的低级编程能力的同时，也极容易导致代码出现错误。而出现浙西错误的原因主要就是对unsafe.Pointer和uintptr的理解不到位。因此正确理解unsafe.Pointer和uintptr对于安全使用unsafe包非常有必要。</p>
<p>Go语言内存管理是基于垃圾回收的，垃圾回收会定期进行，如歌一块内存没有被任何对象引用，他就会被垃圾回收器回收掉，而对象引用是通过指针实现的。</p>
<p>unsafe.Pointer 和其他常规类型的指针一样，可以作为对象引用。如果一个对象仍然被某个unsafe.Pointer<br />
变量引用着则该对象不会被回收（垃圾回收）。</p>
<p><strong>即使他存储的是某个对象的内存地址值，它也不会被算作该对象的被算作对该对象的引用</strong></p>
<p><strong>如果认为将对象地址存储在一个uintptr变量中，该对象就不会被垃圾回收器回收，那是对uintptr的最大误解</strong></p>
<h2 id="安全使用"><a class="markdownIt-Anchor" href="#安全使用"></a> 安全使用</h2>
<p>我们既需要unsafe.Pointer打破类型的安全屏障，又需要器能够被安全的使用。如下有几条安全法则</p>
<h3 id="t1-unsafepointer-t2"><a class="markdownIt-Anchor" href="#t1-unsafepointer-t2"></a> <code>*T1</code> -&gt; unsafe.Pointer -&gt; <code>*T2</code></h3>
<p>其本质就是内存重解释，将原本解释为T1的类型内存重新解释为T2类型。</p>
<blockquote>
<p>这是unsafe.Pointer 突破Go类型安全的屏障的基本使用模式</p>
</blockquote>
<p>注意：转换后类型T2, 对对其系数不能比转换前类型T1的对其系数<strong>更严格</strong>，即Alignof(T1) =&gt; Alignof(T2)</p>
<h3 id="unsafepointer-uintptr"><a class="markdownIt-Anchor" href="#unsafepointer-uintptr"></a> unsafe.Pointer -&gt; uintptr</h3>
<p>将unsafe.Pointer 显示转换为uinptr，并且转换后的uintptr类型不会在转换回unsafe.Pointer<br />
只用于打印输出，并不参与其他操作。</p>
<h3 id="模拟指针运算"><a class="markdownIt-Anchor" href="#模拟指针运算"></a> 模拟指针运算</h3>
<p>操作任意内存地址上的数据都离不开指针运算。Go常规语法不支持指针运算，但我们可以使用unsafe.Pointer的第三种安全使用模式来模拟指针运算，即在一个表达式中，将unsafe.Pointer转换为uintptr类型，使用uintptr类型的值进行算术运算后，再转换回unsafe.Pointer</p>
<p>经常用于访问结构体内字段或数组中的元素，也常用于实现对某内存对象的步进式检查</p>
<p>注意事项:</p>
<ul>
<li>不要越界offset理论上可以是任意值，这就存在算术运算之后的地址超出原内存对象边界的可能。<br />
经过转换后，p指向的地址已经超出原数组a的边界，访问这块内存区域是有风险的，尤其是当你尝试去修改它的时候。</li>
<li>unsafe.Pointer -&gt; uintptr -&gt; unsafe.Pointer的转换要在一个表达式中</li>
</ul>
<h3 id="调用syscallsyscall系列函数时指针类型到uintptr类型参数的转换"><a class="markdownIt-Anchor" href="#调用syscallsyscall系列函数时指针类型到uintptr类型参数的转换"></a> 调用syscall.Syscall系列函数时指针类型到uintptr类型参数的转换</h3>
<h3 id="将reflectvaluepointer或reflectvalueunsafeaddr转换为指针"><a class="markdownIt-Anchor" href="#将reflectvaluepointer或reflectvalueunsafeaddr转换为指针"></a> 将reflect.Value.Pointer或reflect.Value.UnsafeAddr转换为指针</h3>
<h3 id="reflectsliceheader和reflectstringheader必须通过unsafepointer-uintptr构建"><a class="markdownIt-Anchor" href="#reflectsliceheader和reflectstringheader必须通过unsafepointer-uintptr构建"></a> reflect.SliceHeader和reflect.StringHeader必须通过<code>unsafe.Pointer -&gt; uintptr</code>构建</h3>
<h2 id="tips"><a class="markdownIt-Anchor" href="#tips"></a> Tips</h2>
<p>使用unsfa包前，请牢记并理解unsafe.Pointer 的六条安全使用模式</p>
<p>如果使用了unsafe包，请使用<code>go vet</code> 等工具对代码进行unsafe包使用合规性检查</p>
]]></content>
      <categories>
        <category>go</category>
        <category>unsafe</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>golang并发模式</title>
    <url>/41600.html</url>
    <content><![CDATA[<p>并发模式并不是一种函数的运用、亦或者实际存在的东西。他是前人对于并发场景的运用总结与经验。他与23中设计模式一样。好啦，话不多说。开干</p>
<p>无论是如何厉害的架构还是编程方式，我始终相信都是从零开始，不断的抽象，不断的迭代的。抽象思维对于我们尤为重要。那么我们也带着这样的一个疑问。思考到底什么是抽象</p>
<p>首先我们将要学习的是<code>work pool</code>模式</p>
<span id="more"></span>
<h2 id="work-pool"><a class="markdownIt-Anchor" href="#work-pool"></a> work pool</h2>
<p>不知道大家是否在go并发的时候遇见过以下几个问题或者想法</p>
<ul>
<li>goroutine的数量控制可能并不是那么称心如意
<ul>
<li>goroutine，创造过多，造成资源浪费。且并发效果也并非那么好。他正如正态分布那样。到达某个极点所带来的收益将会下降</li>
</ul>
</li>
<li>goroutine复用的问题，往往一个goroutine都只处理了一个任务。不断的创建与删除</li>
<li>甚至更多。。。</li>
</ul>
<p>workpool，首先分析以上问题，我个人总结都以上其实是一个问题，groutine与任务死死的绑定，并没有进行解耦。比如像这样。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exs</span><span class="params">(accept &lt;-<span class="keyword">chan</span> <span class="type">int</span>, recipient <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> result := <span class="keyword">range</span> accept &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Received only sent channel a:&quot;</span>, result)</span><br><span class="line">  recipient &lt;- result + <span class="number">2</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//fmt.Println(&quot;Send Only&quot;, recipient)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> startTime := time.Now()</span><br><span class="line"> ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">   fmt.Println(&lt;-ch)</span><br><span class="line">  &#125;(ch)</span><br><span class="line">  ch &lt;- i</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>那么我们来改造一下，然后进行代码剖析。代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> &quot;fmt&quot;</span><br><span class="line"> &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func work(id int, jobs &lt;-chan int, result chan&lt;- int) &#123;</span><br><span class="line"> for j := range jobs &#123;</span><br><span class="line">  fmt.Println(&quot;Worker [ID]&quot;, id, &quot;Start Process JoB [Id]&quot;, j)</span><br><span class="line">  time.Sleep(time.Second * 2)</span><br><span class="line">  //fmt.Println(&quot;Working, will Spend 2 s&quot;)</span><br><span class="line">  fmt.Println(&quot;Worker [ID]&quot;, id, &quot;Carry Process JoB [Id]&quot;, j)</span><br><span class="line">  result &lt;- j * 2</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"> const jobNumber = 1000</span><br><span class="line"> const workerNumber = 100</span><br><span class="line"></span><br><span class="line"> jobs := make(chan int, workerNumber)</span><br><span class="line"> result := make(chan int, jobNumber)</span><br><span class="line"></span><br><span class="line"> // Create Worker(start Goroutines)</span><br><span class="line"> for w := 0; w &lt;= workerNumber; w++ &#123;</span><br><span class="line">  go work(w, jobs, result)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // arrange work</span><br><span class="line"> for j := 0; j &lt;= jobNumber; j ++ &#123;</span><br><span class="line">  jobs &lt;- j</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 获取结果</span><br><span class="line"> for r := 0; r &lt;= jobNumber; r ++ &#123;</span><br><span class="line">  &lt;- result</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>work pool的精髓在于将任务，与groutine进行分离。只关心初始的任务与结果。是不是与函数式编程很像呢？我也这么觉得，嘻嘻</p>
<p>来吧，我们剖析一下代码</p>
<ol>
<li>首先我们定义了两个常量（建议是常量），<code>jobNum</code>与<code>workerNumber</code>，故名思义他们分别是任务数量，以及工人数量。你可以将他们看出生产者与消费者。</li>
<li>我们定义了两个channel，他们作为我们发送指令与获取结果的通道。记得加缓存哦，否则将造成死锁</li>
<li>最后就是分别定义消费者-<code>groutine</code>，生产者jobNumber，然后传递任务进入goroutine。然后我们就只需要得到结果就好啦</li>
</ol>
<p>nice，虽然很简单。但也有无限的可能性哦。你还可以进一步抽象，变成一个通用的goroutine pool。</p>
<h2 id="pipeline-模式"><a class="markdownIt-Anchor" href="#pipeline-模式"></a> Pipeline 模式</h2>
<p>Pipeline 模式也称为流水线模式，模拟的就是现实世界中的流水线生产。</p>
<p>从技术上看，每一道工序的输出，就是下一道工序的输入，在工序之间传递的东西就是数据，这种模式称为流水线模式，而传递的数据称为数据流。下面我们用代码模拟<code>柴火烧饭的</code><br />
过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"> combust := wash(10)</span><br><span class="line"> rice := combustion(combust)</span><br><span class="line"> packs := open(rice)</span><br><span class="line"> //输出测试，看看效果</span><br><span class="line"> for p := range packs &#123;</span><br><span class="line">  fmt.Println(p)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func wash(n int) &lt;-chan string &#123;</span><br><span class="line"> out := make(chan string)</span><br><span class="line"> go func() &#123;</span><br><span class="line">  defer close(out)</span><br><span class="line">  for i := 1; i &lt;= n; i++ &#123;</span><br><span class="line">   out &lt;- fmt.Sprint(&quot;洗米&quot;, i)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"> return out</span><br><span class="line">&#125;</span><br><span class="line">func combustion(in &lt;-chan string) &lt;-chan string &#123;</span><br><span class="line"> out := make(chan string)</span><br><span class="line"> go func() &#123;</span><br><span class="line">  defer close(out)</span><br><span class="line">  for c := range in &#123;</span><br><span class="line">   out &lt;- &quot;烧饭(&quot; + c + &quot;)&quot;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"> return out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func open(in &lt;-chan string) &lt;-chan string &#123;</span><br><span class="line"> out := make(chan string)</span><br><span class="line"> go func() &#123;</span><br><span class="line">  defer close(out)</span><br><span class="line">  for c := range in &#123;</span><br><span class="line">   out &lt;- &quot;开锅(&quot; + c + &quot;)&quot;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"> return out</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>开锅(烧饭(洗米1))<br />
开锅(烧饭(洗米2))<br />
开锅(烧饭(洗米3))<br />
开锅(烧饭(洗米4))<br />
开锅(烧饭(洗米5))<br />
开锅(烧饭(洗米6))<br />
开锅(烧饭(洗米7))<br />
开锅(烧饭(洗米8))<br />
开锅(烧饭(洗米9))<br />
开锅(烧饭(洗米10))</p>
</blockquote>
<p>首先，我为什么一定强调是柴火烧饭呢，难道柴火香一点？那可不，必须的。</p>
<p>其实再这里，我们需要思考一个问题，什么是可异步的，什么是不可异步的？</p>
<blockquote>
<p>拓展：</p>
<p>可异步：例如网络请求，发送网络请求后，立马发送下一个。尽量减少网络io阻塞，从而提高效率。可前提是，网络io阻塞可以不用等待</p>
<p>不可异步：也就是说我们每一步都必须参与其中，计算机它无法独自去完成。例如柴火烧饭，没柴火咋烧饭，魔法么。当然你硬要说火烧一次就一直可以不需要人去干预，那咱也没办法了不是</p>
</blockquote>
<p>在这里，生产者与消费者可能并不像之前那么分的那么开了，首先</p>
<p>洗米（生产者）</p>
<p>烧饭（消费者、生产者）</p>
<p>开锅（消费者）</p>
<p>这种模式称为流水线模式，而传递的数据称为数据流</p>
<h2 id="分治模式"><a class="markdownIt-Anchor" href="#分治模式"></a> 分治模式</h2>
<p>就像前面所说那样，每一道必须依靠前面完成了才能进行下一步，但我们发现其中烧饭或者太慢了，我们可以分而治之，然后合并。也可以达到我们需要的效果。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;sync&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> combust := wash(<span class="number">10</span>)</span><br><span class="line"> rice1 := combustion(combust)</span><br><span class="line"> rice2 := combustion(combust)</span><br><span class="line"> rice3 := combustion(combust)</span><br><span class="line"> rice := merge(rice1, rice2, rice3)</span><br><span class="line"> packs := open(rice)</span><br><span class="line"> <span class="comment">//输出测试，看看效果</span></span><br><span class="line"> <span class="keyword">for</span> p := <span class="keyword">range</span> packs &#123;</span><br><span class="line">  fmt.Println(p)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wash</span><span class="params">(n <span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">string</span> &#123;</span><br><span class="line"> out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">   out &lt;- fmt.Sprint(<span class="string">&quot;洗米&quot;</span>, i)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"> <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combustion</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">string</span> &#123;</span><br><span class="line"> out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line">  time.Sleep(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">for</span> c := <span class="keyword">range</span> in &#123;</span><br><span class="line">   out &lt;- <span class="string">&quot;烧饭(&quot;</span> + c + <span class="string">&quot;)&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"> <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">string</span> &#123;</span><br><span class="line"> out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line">  <span class="keyword">for</span> c := <span class="keyword">range</span> in &#123;</span><br><span class="line">   out &lt;- <span class="string">&quot;开锅(&quot;</span> + c + <span class="string">&quot;)&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"> <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(ins ...&lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">string</span> &#123;</span><br><span class="line"> <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"> out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"> <span class="comment">//把一个channel中的数据发送到out中</span></span><br><span class="line"> p := <span class="function"><span class="keyword">func</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> wg.Done()</span><br><span class="line">  <span class="keyword">for</span> c := <span class="keyword">range</span> in &#123;</span><br><span class="line">   out &lt;- c</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> wg.Add(<span class="built_in">len</span>(ins))</span><br><span class="line"> <span class="comment">//扇入，需要启动多个goroutine用于处于多个channel中的数据</span></span><br><span class="line"> <span class="keyword">for</span> _, cs := <span class="keyword">range</span> ins &#123;</span><br><span class="line">  <span class="keyword">go</span> p(cs)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//等待所有输入的数据ins处理完，再关闭输出out</span></span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wg.Wait()</span><br><span class="line">  <span class="built_in">close</span>(out)</span><br><span class="line"> &#125;()</span><br><span class="line"> <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="futures-模式"><a class="markdownIt-Anchor" href="#futures-模式"></a> Futures 模式</h2>
<p>Pipeline 流水线模式中的工序是相互依赖的，上一道工序做完，下一道工序才能开始。但是在我们的实际需求中，也有大量的任务之间相互独立、没有依赖，所以为了提高性能，这些独立的任务就可以并发执行。</p>
<p>举个例子，比如我打算自己做顿火锅吃，那么就需要洗菜、烧水。洗菜、烧水这两个步骤相互之间没有依赖关系，是独立的，那么就可以同时做，但是最后做火锅这个步骤就需要洗好菜、烧好水之后才能进行。这个做火锅的场景就适用<br />
Futures 模式。</p>
<p>Futures 模式可以理解为未来模式，主协程不用等待子协程返回的结果，可以先去做其他事情，等未来需要子协程结果的时候再来取，如果子协程还没有返回结果，就一直等待</p>
<p>Futures 模式下的协程和普通协程最大的区别是可以返回结果，而这个结果会在未来的某个时间点使用。所以在未来获取这个结果的操作必须是一个阻塞的操作，要一直等到获取结果为止。</p>
<p>如果你的大任务可以拆解为一个个独立并发执行的小任务，并且可以通过这些小任务的结果得出最终大任务的结果，就可以使用<br />
Futures 模式。</p>
<h2 id="referer"><a class="markdownIt-Anchor" href="#referer"></a> Referer</h2>
<p>22讲通关go语言-飞雪无情</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>golang并发铁索连环-context</title>
    <url>/2392.html</url>
    <content><![CDATA[<p>在本文中，我首先会介绍context是什么，它有什么作用，以及如何使用，其中还会参杂一点个人的理解，以及部分源码的了解。What<br />
are you waiting for?</p>
<span id="more"></span>
<h2 id="context"><a class="markdownIt-Anchor" href="#context"></a> Context</h2>
<blockquote>
<p>来自官方文档</p>
</blockquote>
<p>Context包定义了上下文类型，该类型在API边界之间以及进程之间传递截止日期，取消信号和其他请求范围的值</p>
<p>对服务器的传入请求应创建一个Context，而对服务器的传出调用应接受一个Context。</p>
<p>它们之间的函数调用链必须传播Context，可以选择将其替换为使用WithCancel，WithDeadline，WithTimeout或WithValue创建的派生Context。取消上下文后，从该上下文派生的所有上下文也会被取消。</p>
<p>WithCancel，WithDeadline和WithTimeout函数采用Context（父级）并返回派生的Context（子级）和CancelFunc。调用CancelFunc会取消该子代及其子代，删除父代对该子代的引用，并停止所有关联的计时器。未能调用CancelFunc会使子代及其子代泄漏，直到父代被取消或计时器触发。审核工具检查所有控制流路径上是否都使用了CancelFuncs。</p>
<p>使用上下文的程序应遵循以下规则，以使各个包之间的接口保持一致，并使静态分析工具可以检查上下文传播：</p>
<p>不要将上下文存储在结构类型中；而是将上下文明确传递给需要它的每个函数。 Context应该是第一个参数，通常命名为ctx：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">(ctx context.Context, arg Arg)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">//  ... use ctx ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使函数允许，也不要传递nil Context。如果不确定使用哪个上下文，请传递context.TODO</p>
<p>仅将上下文值用于传递过程和API的请求范围数据，而不用于将可选参数传递给函数。</p>
<p>可以将相同的上下文传递给在不同goroutine中运行的函数。上下文可以安全地被多个goroutine同时使用</p>
<p>巴拉巴拉，说了一大堆，反正我一句没懂，当然我知道context是干嘛的，（尬～，不小心暴露了，学渣的本质），说说我的理解以及使用建议</p>
<ul>
<li>对服务器的传入请求应创建一个Context，而对服务器的传出响应也应接受一个Context。</li>
<li></li>
</ul>
<p>函数调用链必须传播Context，也可以选择将其替换为使用WithCancel，WithDeadline，WithTimeout或WithValue创建的派生Context(<br />
也就是子类context)<br />
。取消上下文后，从该上下文派生的所有上下文也会被取消</p>
<ul>
<li>Context 不要放在结构体中，要以参数的方式传递。</li>
<li>Context 作为函数的参数时，要放在第一位，也就是第一个参数。</li>
<li>要使用 context.Background 函数生成根节点的 Context，也就是最顶层的 Context。</li>
<li>Context 传值要传递必须的值，而且要尽可能地少，不要什么都传。</li>
<li><strong>Context 多协程安全，可以在多个协程中放心使用。</strong></li>
</ul>
<h3 id="go-context定义"><a class="markdownIt-Anchor" href="#go-context定义"></a> go Context定义</h3>
<p>Context 是Go 1.7 标准库引入 的标准库，中文译作“上下文”，准确说它是 goroutine 的上下文，包含 goroutine<br />
的运行状态、环境、现场等信息。</p>
<p>使用context，我们可以轻松优雅的做到<code>取消goroutine</code>，<code>超时时间</code>,<code>运行截止时间</code>，<code>k-v</code>存储等。**它是并发安全的<br />
**</p>
<p>随着 context 包的引入，标准库中很多接口因此加上了 context 参数，例如 database/sql 包。context<br />
几乎成为了并发控制和超时控制的标准做法。</p>
<blockquote>
<p>context.Context 类型的值可以协调多个 groutine 中的代码执行“取消”操作，并且可以存储键值对。最重要的是它是并发安全的。<br />
与它协作的 API 都可以由外部控制执行“取消”操作，例如：取消一个 HTTP 请求的执行。</p>
</blockquote>
<p>止于这些么？当然 不止,还有更多的骚操作，接下来让我们一起拿下它吧。</p>
<h2 id="引入"><a class="markdownIt-Anchor" href="#引入"></a> 引入</h2>
<blockquote>
<p>为什么需要使用context，理由一</p>
<p>一个协程启动后，大部分情况需要等待里面的代码执行完毕，然后协程会自行退出。但需要让协程提前退出怎么办呢？</p>
</blockquote>
<p>下面我们以一个小的示例，来逐渐了解context的妙用之一吧</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;sync&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">monitor</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"> <span class="comment">//开启for select循环，j进行后台监控</span></span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">   fmt.Printf(<span class="string">&quot;Time: %v 监控者:%s, 正在监控...\n&quot;</span>, time.Now().Unix(), name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// sleep 1 second</span></span><br><span class="line">  time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s 监控完成，一切正常，请指示 over...\n&quot;</span>, name)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"> <span class="comment">// Define waiting group</span></span><br><span class="line"> wg.Add(<span class="number">1</span>)</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// Execution complete</span></span><br><span class="line">  <span class="keyword">defer</span> wg.Done()</span><br><span class="line">  monitor(<span class="string">&quot;天眼&quot;</span>)</span><br><span class="line"> &#125;()</span><br><span class="line"> <span class="comment">//Exit after waiting</span></span><br><span class="line"> wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在这里实现了一个基本的groutine执行的case</p>
<blockquote>
<p>我们定义了等待组<code>wait group</code>,防止协程提前退出。关于<code>wait group</code>可参考上一篇文章，golang并发控制的心应手。</p>
</blockquote>
<p>他会周期性的运行，不断打印监控信息，例如</p>
<img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnhog0u2cbj30iy06eq33.jpg" style="zoom:50%;" />
<p>那么我们完成上述的那个需求<code>提前退出</code><br />
,那么该怎么办呢？其中一个方法就是定义一个全局的sign，其他地方可以通过修改这个sign发出停止监控的指令。然后在协程中先检查这个变量，如果发现被通知关闭就停止监控，退出当前协程。从而实现可控制提前退出。示例代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;sync&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">monitor1</span><span class="params">(signCh <span class="keyword">chan</span> <span class="type">bool</span>, MonitoringPeriod time.Duration, name <span class="type">string</span>, )</span></span> &#123;</span><br><span class="line"> <span class="comment">//开启for select循环，一直后台监控</span></span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-signCh:</span><br><span class="line">   fmt.Println(name, <span class="string">&quot;停止指令已收到，停止...&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">   fmt.Printf(<span class="string">&quot;Time: %v [监控者]:%s, 正在监控...\n&quot;</span>, time.Now().Unix(), name)</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(MonitoringPeriod * time.Second)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"> signCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>) <span class="comment">//sign 用来停止监控</span></span><br><span class="line"> <span class="keyword">const</span> MonitoringTime, MonitoringPeriod = <span class="number">20</span>, <span class="number">2</span></span><br><span class="line"> wg.Add(<span class="number">1</span>)</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> wg.Done()</span><br><span class="line">  monitor1(signCh, MonitoringPeriod, <span class="string">&quot;天眼&quot;</span>)</span><br><span class="line"> &#125;()</span><br><span class="line"> time.Sleep(MonitoringTime * time.Second) <span class="comment">//实施监控时间</span></span><br><span class="line"> signCh &lt;- <span class="literal">true</span>                           <span class="comment">//发停止指令</span></span><br><span class="line"> wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样我们就实现了，可控制话的groutine退出，但如果在新增几个定期的任务功能，那该如何是好？</p>
<p>管他的，我们先把这个弄懂了先。老夫先干为敬。首先我们先看程序运行图，如下</p>
<img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnhpa8zjtfj315k0tsmxg.jpg" style="zoom:50%;" />
<p>这个示例是使用 select+channel 的方式改造，实现了通过 channel 发送指令让监控狗停止，进而达到协程退出的目的。</p>
<p>首先我们定义了sync.WaitGroup，防止gorontine提前退出。signCh，他是一个bool值类型channel，用于发送sign后续的退出。</p>
<p>MonitoringTime，MonitoringPeriod，监控时间与监控周期。second。</p>
<p>然后创建goroutine执行select+channel。</p>
<h2 id="go-context-初试体验"><a class="markdownIt-Anchor" href="#go-context-初试体验"></a> Go Context 初试体验</h2>
<p>为 函数增加 signCh 参数，用于接收停止指令；</p>
<p>在 main 函数中，声明用于停止的 signCh，传递给 monitor1 函数，然后通过 signCh&lt;-true 发送停止指令让协程退出。</p>
<p>通过 select+channel 让协程退出的方式比较优雅，以下几个问题也随之凸显</p>
<p>但如果我们希望做到同时取消很多个协程呢？</p>
<p>如果是定时取消协程又该怎么办？</p>
<p>这时候 select+channel 的局限性就凸现出来了，即使定义了多个 channel 解决问题，当然这个方式是可行的，但代码逻辑也会非常复杂、难以维护。</p>
<p>要解决这种复杂的协程问题，必须有一种可以跟踪协程的方案，只有跟踪到每个协程，才能更好地控制它们，这种方案就是<br />
Go 语言标准库为我们提供的 Context，接下来我们体验一下它的强大之处吧。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;context&quot;</span></span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;sync&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"> <span class="keyword">const</span> MonitoringTime, MonitoringPeriod = <span class="number">20</span>, <span class="number">2</span></span><br><span class="line"> wg.Add(<span class="number">1</span>)</span><br><span class="line"> <span class="comment">// 定义一个等待的 `context`</span></span><br><span class="line"> ctx, stop := context.WithCancel(context.Background())</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> wg.Done()</span><br><span class="line">  monitor2(ctx, MonitoringPeriod, <span class="string">&quot;天眼&quot;</span>)</span><br><span class="line"> &#125;()</span><br><span class="line"> time.Sleep(MonitoringTime * time.Second) <span class="comment">//先监控5秒</span></span><br><span class="line"> stop()                                   <span class="comment">//发停止指令</span></span><br><span class="line"> wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">monitor2</span><span class="params">(ctx context.Context, MonitoringPeriod time.Duration, name <span class="type">string</span>, )</span></span> &#123;</span><br><span class="line"> <span class="comment">//开启for select循环，一直后台监控</span></span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">   fmt.Println(name, <span class="string">&quot;停止指令已收到，停止...&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">   fmt.Printf(<span class="string">&quot;Time: %v [监控者]:%s, 正在监控...\n&quot;</span>, time.Now().Unix(), name)</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(MonitoringPeriod * time.Second)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是很优雅呢？确实如此，那么为什么也可以达到上面使用<code>channel</code>，的效果呢。那么我们去看一下它的具体实现部分呢，</p>
<h3 id="withcancel"><a class="markdownIt-Anchor" href="#withcancel"></a> <code>WithCancel</code></h3>
<p>以下是WithCancel：具体实现部分代码</p>
<blockquote>
<p>WithCancel:</p>
</blockquote>
<p>返回具有新的“完成”通道的父级副本。当调用返回的cancel函数或关闭父上下文的Done通道时（以先发生的为准），将关闭返回的上下文的Done通道。取消此上下文将释放与其关联的资源，因此在此上下文中运行的操作完成后，代码应立即调用cancel。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line"> <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> c := newCancelCtx(parent)</span><br><span class="line"> propagateCancel(parent, &amp;c)</span><br><span class="line"> <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了WithCancel，之外还有<code>WithDeadline</code>,<code>WithTimeout</code>,<code>WithValue</code>,首先我们来继续看看<code>WithDeadline</code><br />
具体实现，以及使用技巧吧</p>
<h3 id="withtimeout"><a class="markdownIt-Anchor" href="#withtimeout"></a> <code>WithTimeout</code></h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line"> <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">  <span class="comment">// The current deadline is already sooner than the new one.</span></span><br><span class="line">  <span class="keyword">return</span> WithCancel(parent)</span><br><span class="line"> &#125;</span><br><span class="line"> c := &amp;timerCtx&#123;</span><br><span class="line">  cancelCtx: newCancelCtx(parent),</span><br><span class="line">  deadline:  d,</span><br><span class="line"> &#125;</span><br><span class="line"> propagateCancel(parent, c)</span><br><span class="line"> dur := time.Until(d)</span><br><span class="line"> <span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">  c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line">  <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> c.mu.Lock()</span><br><span class="line"> <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"> <span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">  c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">  &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line"> <span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>取消此上下文将释放与之关联的资源，因此在此上下文中运行的操作完成后，代码应立即调用cancel：</p>
</blockquote>
<p>来看一下具体如何使用吧，示例如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> &quot;context&quot;</span><br><span class="line"> &quot;fmt&quot;</span><br><span class="line"> &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"> // 创建一个子节点的context,3秒后自动超时</span><br><span class="line"> const MonitoringTime, MonitoringPeriod = 20, 2</span><br><span class="line"> ctx, cancel := context.WithTimeout(context.Background(), time.Second*10)</span><br><span class="line"> go func() &#123;</span><br><span class="line">  monitor4(ctx, MonitoringPeriod, &quot;天眼&quot;)</span><br><span class="line">  fmt.Println(&quot;退出时间&quot;,time.Now().Unix())</span><br><span class="line"> &#125;()</span><br><span class="line"> time.Sleep(MonitoringTime * time.Second)</span><br><span class="line"> cancel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func monitor4(ctx context.Context, MonitoringPeriod time.Duration, name string, ) &#123;</span><br><span class="line"> //开启for select循环，一直后台监控</span><br><span class="line"> for &#123;</span><br><span class="line">  select &#123;</span><br><span class="line">  case &lt;-ctx.Done():</span><br><span class="line">   fmt.Println(name, &quot;停止指令已收到，停止...&quot;)</span><br><span class="line">   return</span><br><span class="line">  default:</span><br><span class="line">   fmt.Printf(&quot;Time: %v [监控者]:%s, 正在监控...\n&quot;, time.Now().Unix(), name)</span><br><span class="line">   time.Sleep(MonitoringPeriod * time.Second)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上会有两种情况发生退出，</p>
<p>一、程序main退出，全局退出</p>
<p>二、我们定义的timeout退出</p>
</blockquote>
<p>他们的基本性质与使用我们就简单的过了一遍，下面让我们来个小结。</p>
<p>WithCancel(parent Context)：生成一个可取消的 Context。</p>
<p>WithDeadline(parent Context, d time.Time)：生成一个可定时取消的 Context，**参数 d 为定时取消的具体时间。<br />
**</p>
<p>WithTimeout(parent Context, timeout time.Duration)：生成一个可超时取消的 Context，<strong>参数 timeout<br />
用于设置多久后取消</strong></p>
<p>WithValue(parent Context, key, val interface{})：生成一个可携带 key-value 键值对的 Context。</p>
<p>是不是发现，其实也没有那么难呢？当然，它本来就很简单，接下来我们来点更刺激的，同时取消多goroutine，啥也不说了，上～</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> &quot;context&quot;</span><br><span class="line"> &quot;fmt&quot;</span><br><span class="line"> &quot;strconv&quot;</span><br><span class="line"> &quot;sync&quot;</span><br><span class="line"> &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"> const MonitoringTime, MonitoringPeriod = 20, 2</span><br><span class="line"> wg.Add(1)</span><br><span class="line"> ctx, stop := context.WithCancel(context.Background())</span><br><span class="line"> for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">  go monitor6(ctx, MonitoringPeriod, strconv.Itoa(i))</span><br><span class="line"> &#125;</span><br><span class="line"> time.Sleep(MonitoringTime * time.Second) //先监控5秒</span><br><span class="line"> stop()                                   //发停止指令</span><br><span class="line"> wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line">func monitor6(ctx context.Context, MonitoringPeriod time.Duration, name string, ) &#123;</span><br><span class="line"> defer wg.Done()</span><br><span class="line"> //开启for select循环，一直后台监控</span><br><span class="line"> for &#123;</span><br><span class="line">  select &#123;</span><br><span class="line">  case &lt;-ctx.Done():</span><br><span class="line">   fmt.Println(name, &quot;停止指令已收到，停止...&quot;)</span><br><span class="line">   return</span><br><span class="line">  default:</span><br><span class="line">   fmt.Printf(&quot;Time: %v [监控者]:天眼%s, 正在监控...\n&quot;, time.Now().Unix(), name)</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(MonitoringPeriod * time.Second)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Time: 1612948086 [监控者]:天眼0, 正在监控…<br />
Time: 1612948086 [监控者]:天眼1, 正在监控…<br />
Time: 1612948086 [监控者]:天眼2, 正在监控…<br />
… …<br />
Time: 1612948104 [监控者]:天眼2, 正在监控…<br />
Time: 1612948104 [监控者]:天眼0, 正在监控…<br />
Time: 1612948104 [监控者]:天眼1, 正在监控…<br />
2 停止指令已收到，停止…<br />
1 停止指令已收到，停止…<br />
0 停止指令已收到，停止…</p>
</blockquote>
<p>你以为这样就完了么，这只是一个小的case，它还可以管理子节点。其管理与树形结构十分的相似。</p>
<p>除此之外还可以传递值，接下来让我们来看看吧</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;context&quot;</span></span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;sync&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"> ctx, stop := context.WithCancel(context.Background())</span><br><span class="line"> ctxVal := context.WithValue(ctx, <span class="string">&quot;user&quot;</span>, <span class="string">&quot;payne&quot;</span>)</span><br><span class="line"> wg.Add(<span class="number">1</span>)</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> wg.Done()</span><br><span class="line">  getValue(ctxVal)</span><br><span class="line"> &#125;()</span><br><span class="line"> time.Sleep(<span class="number">3</span>)</span><br><span class="line"> stop()</span><br><span class="line"> wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getValue</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">   fmt.Println(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">   user := ctx.Value(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;【获取用户】&quot;</span>, <span class="string">&quot;用户为：&quot;</span>, user)</span><br><span class="line">   time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<blockquote>
<p>【获取用户】 用户为： payne<br />
exit…</p>
</blockquote>
<p>总结：</p>
<p>Context为我们主要定义四种方法<code>WithDeadline</code>,<code>WithTimeout</code>,<code>WithValue</code>,<code>WithCancel</code><br />
,从而达到控制goroutine的目的，但却不仅限于我们以上介绍的那样(<br />
只介绍了一层，其实可以是多层。形成多对多的关系)，它更深层次的使用你可以想象成多叉树的情况。</p>
<p>context，这一篇就暂且完成啦，期待下一篇。并发模式</p>
<p>并发模式，故名思义。他与设计模式一样，即使用goroutine并发的一些总结。</p>
<p>我将与你探讨</p>
<ul>
<li><code>Goroutine WorkPool</code>:让我们随影所欲的控制创建gototine的数量，且复用。</li>
<li>Pipeline 模式，他像工厂流水线一般，我们将是这将其拆分归并</li>
<li>扇出扇入模式，在pipline的基础上对耗时较长的进行处理</li>
<li>Futures 模式，Pipeline 流水线模式中的工序是相互依赖的，但是在我们的实际需求中，也有大量的任务之间相互独立、没有依赖，所以为了提高性能，这些独立的任务就可以并发执行。</li>
</ul>
<p>期待～</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>golang第三方包发布详细流程</title>
    <url>/16882.html</url>
    <content><![CDATA[<h3 id="发布golang第三方包"><a class="markdownIt-Anchor" href="#发布golang第三方包"></a> 发布golang第三方包</h3>
<p>事情是这样的，随着公司的业务的增长。各种重复的工作越来约多。CV久了就想在进一步的那啥，毕竟我懒，不是。我就想着能不能把那些重复cv的干脆写成一个第三方包，进行调用。咱不谈那些啥封装啥的，我也想过，我也做过。但无论咋封装，总不可能跨项目吧,还是需要。。。</p>
<p>所幸，还是有方法的，来吧，让我们发表第一个golang工具包</p>
<span id="more"></span>
<h3 id="创建项目仓库"><a class="markdownIt-Anchor" href="#创建项目仓库"></a> 创建项目仓库</h3>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2ghktr3vj31ml0u0abu.jpg" alt="" /></p>
<ol>
<li>首先输入仓库的名字，我这里输入simpleExample，用来做演示</li>
<li>这里选择public，公开。要不并不好拉</li>
<li>选择需要添加的文件(可选)</li>
<li>鼠标左键点击create repository创建此仓库</li>
</ol>
<p>完成后就有一个名为simpleExample的项目仓库，如下图所示。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2gnbyu4kj32620nm3zq.jpg" alt="" /></p>
<p>如果<code>第三步</code>全都没选的话就是另外一个图了</p>
<blockquote>
<p>这一步还是很简单的，毕竟github，全球最大的程序员交友网站不是。2110年了相信大家还是都会用的，是实在不会的，可自行百度，或者Google。</p>
</blockquote>
<h3 id="拉取仓库编辑示例代码"><a class="markdownIt-Anchor" href="#拉取仓库编辑示例代码"></a> 拉取仓库，编辑示例代码</h3>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2gtep6b6j31hs0nigmr.jpg" alt="" /></p>
<p>第一步，鼠标左键点击code</p>
<p>第二步，点击后面类似于粘贴板的东西，复制https的URL</p>
<p>然后在cd到GOPATH中使用git，把这个项目clone下来</p>
<p>例如，我在这里的使用的git命令如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Golzaes/simpleExample.git</span><br></pre></td></tr></table></figure>
<p>执行成功后使用 <code>ls</code>命令查看一下</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2gzfqf28j31f2032weo.jpg" alt="" /></p>
<p>使用编辑器打开<code>simpleExample</code>这个项目文件夹，如下图所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2h1zo9gjj31fy0eugm9.jpg" alt="" /></p>
<p><strong>go module初始化</strong></p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+ go mod init &quot;github.com/Golzaes/simpleExample&quot;</span></span><br><span class="line"><span class="deletion">- go mod init &quot;github.com/组织名/项目名&quot; </span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这里的一定是<code>&quot;github.com/组织名/项目名&quot;</code>这样的格式</p>
</blockquote>
<p>创建文件夹与示例代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Example/example.go</span></span><br><span class="line"><span class="keyword">package</span> exampleCode</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math/rand&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadNumber create random number</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadNumber</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line"> <span class="comment">// random number range</span></span><br><span class="line"> rnr := <span class="number">10</span></span><br><span class="line"> <span class="comment">//  returns, as an int, a non-negative pseudo-random number in [0,n)</span></span><br><span class="line"> <span class="keyword">return</span> rand.Intn(rnr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意这里的函数名<code>ReadNumber</code>，首字母必须大写！！！</p>
<p>否则无法再外部调用此函数</p>
</blockquote>
<p>来个简单的单元测试</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Example/example_test.go</span></span><br><span class="line"><span class="keyword">package</span> exampleCode</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReadNumber</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"> tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">  want <span class="type">int</span></span><br><span class="line"> &#125;&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Add test cases.</span></span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;exampleCode1&quot;</span>,</span><br><span class="line">   <span class="number">1</span>,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">   <span class="string">&quot;exampleCode2&quot;</span>,</span><br><span class="line">   <span class="number">2</span>,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">   <span class="string">&quot;exampleCode3&quot;</span>,</span><br><span class="line">   <span class="number">3</span>,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">   <span class="string">&quot;exampleCode4&quot;</span>,</span><br><span class="line">   <span class="number">4</span>,</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">   <span class="string">&quot;exampleCode5&quot;</span>,</span><br><span class="line">   <span class="number">5</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">  t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> got := ReadNumber(); got != tt.want &#123;</span><br><span class="line">    t.Errorf(<span class="string">&quot;ReadNumber() = %v, want %v&quot;</span>, got, tt.want)</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2hje5s3pj31m20u0dhw.jpg" alt="" /></p>
<p>有个测试过了，说明我们的代码没有问题，也可以外部调用</p>
<h3 id="推送与发布代码"><a class="markdownIt-Anchor" href="#推送与发布代码"></a> 推送与发布代码</h3>
<p>使用以下命令，提交与push</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add exampleCode/</span><br><span class="line">git commit -am &quot;add exampleCode&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2hmyx0dlj31ws0u0409.jpg" alt="" /></p>
<p>仔细对比就会发现，这里多了个<code>exampleCode</code><br />
文件夹。到这里我们就已经将代码push到了github，接下来我们发布一个，这样我们可以在另外一个项目中以第三方包的形式使用</p>
<p>第一步，点击releases下面的create a new releases</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2hsentogj322q0smgn2.jpg" alt="" /></p>
<p>先 填写标签号(常规格式是 x.y.z)例如我的<code>v0.0.1</code>,</p>
<p>填写发表的标题，一般是项目名</p>
<p>填写简介</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2hvvs1bsj31pk0u0tal.jpg" alt="" /></p>
<p>然后鼠标左键点击 左下方的<code>publish release</code>，进行发布，发布完成后会自动跳转到如下图所示的发布栏</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2i0che88j323z0u0zl9.jpg" alt="" /></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2i0zg0g6j327e0qm3zw.jpg" alt="" /></p>
<p>至此，发布部分就已经完成了。那么自己来测试一下这个第三方包</p>
<h3 id="使用发布的第三方包"><a class="markdownIt-Anchor" href="#使用发布的第三方包"></a> 使用发布的第三方包</h3>
<p>新建一个项目、go mod init初始化、创建文件夹就不过多赘述了</p>
<p>下载我们发布的包</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2i6hgxrnj31ai044t8u.jpg" alt="" /></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go get github.com/Golzaes/simpleExample/exampleCode</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp2ibah1b2j31gt0u0my1.jpg" alt="" /></p>
<p>在项目中import 这个包</p>
<h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3>
<p>本文从创建仓库开始到发布第三方包后到使用第三方包，这样我们就可以跨项目使用啦。</p>
<p>如果测试未完成，请重新查阅。尤其是注意点！！！</p>
]]></content>
      <categories>
        <category>go</category>
        <category>git</category>
        <category>github</category>
        <category>golang</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>golang配置神器viper</title>
    <url>/22544.html</url>
    <content><![CDATA[<h2 id="viper简介"><a class="markdownIt-Anchor" href="#viper简介"></a> Viper简介</h2>
<p>Viper是一个完整的Go语言项目的配置解决方案。它可以处理所有类型的配置需求和格式，相关链接如下</p>
<p>包文档：<span class="exturl" data-url="aHR0cHM6Ly9wa2cuZ28uZGV2L2dpdGh1Yi5jb20vc3BmMTMvdmlwZXI=">https://pkg.go.dev/github.com/spf13/viper<i class="fa fa-external-link-alt"></i></span></p>
<p>github：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NwZjEzL3ZpcGVy">https://github.com/spf13/viper<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="viper的优势"><a class="markdownIt-Anchor" href="#viper的优势"></a> Viper的优势</h2>
<p>在构建Golang程序时可以不必担心配置文件格式而更专注于实现。</p>
<p>viper主要包含以下操作：</p>
<ol>
<li>查找、加载和反序列化 “json”, “toml”, “yaml”, “yml”, “properties”, “props”, “prop”, “hcl”, &quot;<br />
tfvars&quot;, “dotenv”, “env”, “ini”</li>
<li>提供一种机制来为不同的配置选项设置默认值。</li>
<li>提供一种机制来为通过命令行参数设置指定覆盖值。</li>
<li>提供别名，以在不破坏现有代码的情况下轻松重命名参数。</li>
<li>使区分用户何时提供与默认值相同的命令行或配置文件变得容易。</li>
</ol>
<p>每个项目的优先级都高于它下面的项目，Viper优先顺序。</p>
<ul>
<li>显式调用 <code>Set</code></li>
<li>命令行参数（flag）</li>
<li>环境变量</li>
<li>配置文件</li>
<li>key/value存储</li>
<li>默认值</li>
</ul>
<blockquote>
<p><strong>重要提示：</strong> Viper 配置键不区分大小写。正在进行关于使之成为可选项的讨论。</p>
</blockquote>
<h2 id="viper使用场景"><a class="markdownIt-Anchor" href="#viper使用场景"></a> Viper使用场景</h2>
<ul>
<li>设置默认值</li>
<li>“json”, “toml”, “yaml”, “yml”, “properties”, “props”, “prop”, “hcl”, “tfvars”, “dotenv”, “env”, &quot;<br />
ini&quot;文件中读取载入</li>
<li>实时观看和重新读取配置文件（可选）</li>
<li>从环境变量中读取</li>
<li>从远程配置系统（etcd 或 Consul）读取，并观察变化</li>
<li>从命令行标志读取</li>
<li>从缓冲区读取</li>
<li>设置显式值</li>
</ul>
<blockquote>
<p>Viper 可以被认为是满足所有应用程序配置需求的注册表</p>
</blockquote>
<h2 id="viper的安装"><a class="markdownIt-Anchor" href="#viper的安装"></a> Viper的安装</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u -v github.com/spf13/viper</span><br></pre></td></tr></table></figure>
<h2 id="viper使用实例"><a class="markdownIt-Anchor" href="#viper使用实例"></a> Viper使用实例</h2>
<h3 id="使用默认值"><a class="markdownIt-Anchor" href="#使用默认值"></a> 使用默认值</h3>
<p>一个好的配置系统对于默认值拥有良好的支持，其重要性不言而喻。在Viper中的默认值使用如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> viper.SetDefault(<span class="string">`Name`</span>, <span class="string">`Payne`</span>)</span><br><span class="line"> viper.SetDefault(<span class="string">`Age`</span>, <span class="number">20</span>)</span><br><span class="line"> viper.SetDefault(<span class="string">`hobby`</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">  <span class="string">`First hobby`</span>:  <span class="string">`sing`</span>,</span><br><span class="line">  <span class="string">`Second hobby`</span>: <span class="string">`jump`</span>,</span><br><span class="line">  <span class="string">`Third hobby`</span>:  <span class="string">`Rap`</span>,</span><br><span class="line">  <span class="string">`fourth hobby`</span>: <span class="string">`Play Basketball`</span>,</span><br><span class="line"> &#125;)</span><br><span class="line"> fmt.Println(viper.Get(<span class="string">`Name`</span>))</span><br><span class="line"> fmt.Println(viper.Get(<span class="string">`Age`</span>))</span><br><span class="line"> fmt.Println(viper.Get(<span class="string">`hobby`</span>))</span><br><span class="line"> <span class="keyword">for</span> _, i := <span class="keyword">range</span> viper.GetStringMapString(<span class="string">`hobby`</span>) &#123;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="覆盖设置"><a class="markdownIt-Anchor" href="#覆盖设置"></a> 覆盖设置</h3>
<p>这些可能来自命令行标志，也可能来自你自己的应用程序逻辑。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">viper.Set(<span class="string">&quot;Verbose&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">viper.Set(<span class="string">&quot;LogFile&quot;</span>, LogFile)</span><br></pre></td></tr></table></figure>
<h3 id="注册和使用别名"><a class="markdownIt-Anchor" href="#注册和使用别名"></a> 注册和使用别名</h3>
<p>别名允许多个键引用单个值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">viper.RegisterAlias(<span class="string">&quot;loud&quot;</span>, <span class="string">&quot;Verbose&quot;</span>)  <span class="comment">// 注册别名（此处loud和Verbose建立了别名）</span></span><br><span class="line"></span><br><span class="line">viper.Set(<span class="string">&quot;verbose&quot;</span>, <span class="literal">true</span>) </span><br><span class="line">viper.Set(<span class="string">&quot;loud&quot;</span>, <span class="literal">true</span>)  </span><br><span class="line"></span><br><span class="line">viper.GetBool(<span class="string">&quot;loud&quot;</span>) <span class="comment">// true</span></span><br><span class="line">viper.GetBool(<span class="string">&quot;verbose&quot;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="配置文件使用"><a class="markdownIt-Anchor" href="#配置文件使用"></a> 配置文件使用</h2>
<h3 id="读取配置文件"><a class="markdownIt-Anchor" href="#读取配置文件"></a> 读取配置文件</h3>
<p>抽离统一化管理成为配置文件，将所有的配置写在文件中便于管理修改与编辑。Viper 支持 “json”, “toml”, &quot;<br />
yaml&quot;, “yml”, “properties”, “props”, “prop”, “hcl”, &quot;<br />
tfvars&quot;, “dotenv”, “env”, “ini” 属性文件。Viper 可以搜索多个路径，但目前单个 Viper 实例仅支持单个配置文件。Viper<br />
不会默认任何配置搜索路径，将默认决定留给应用程序。不需要任何特定路径，但应至少提供一个需要配置文件的路径。以下是如何使用<br />
Viper 搜索和读取配置文件的示例。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定配置文件路径</span></span><br><span class="line">viper.SetConfigFile(<span class="string">&quot;./config.yaml&quot;</span>)    </span><br><span class="line"><span class="comment">// 配置文件名称(无扩展名)</span></span><br><span class="line">viper.SetConfigName(<span class="string">&quot;config&quot;</span>)       </span><br><span class="line"><span class="comment">// 如果配置文件的名称中没有扩展名，则需要配置此项</span></span><br><span class="line">viper.SetConfigType(<span class="string">&quot;yaml&quot;</span>)        </span><br><span class="line"><span class="comment">// 查找配置文件所在的路径</span></span><br><span class="line">viper.AddConfigPath(<span class="string">&quot;/etc/appname/&quot;</span>)     </span><br><span class="line"><span class="comment">// 多次调用以添加多个搜索路径</span></span><br><span class="line">viper.AddConfigPath(<span class="string">&quot;$HOME/.appname&quot;</span>)    </span><br><span class="line"><span class="comment">// 还可以在工作目录中查找配置</span></span><br><span class="line">viper.AddConfigPath(<span class="string">&quot;.&quot;</span>)                 </span><br><span class="line"><span class="comment">// 查找并读取配置文件</span></span><br><span class="line">err := viper.ReadInConfig()        </span><br><span class="line"><span class="comment">// 处理读取配置文件的错误</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;              </span><br><span class="line"> <span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;Fatal error config file: %s \n&quot;</span>, err))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置文件读取异常处理</span></span><br><span class="line"><span class="keyword">if</span> err := viper.ReadInConfig(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> _, ok := err.(viper.ConfigFileNotFoundError); ok &#123;</span><br><span class="line">   <span class="comment">// Config file not found; ignore error if desired</span></span><br><span class="line">   log.Println(<span class="string">&quot;no such config file&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// Config file was found but another error was produced</span></span><br><span class="line">   log.Println(<span class="string">&quot;read config error&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  log.Fatal(err) <span class="comment">// 读取配置文件失败致命错误</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>若采用<code>setConfigName</code>则只会使用第一个配置文件夹</p>
<p>推荐使用<code>SetConfigFile(&quot;path/file_name&quot;)</code> 来完成配置文件的载入</p>
</blockquote>
<h3 id="从ioreader读取配置"><a class="markdownIt-Anchor" href="#从ioreader读取配置"></a> 从io.Reader读取配置</h3>
<p>Viper预先定义了许多配置源，如文件、环境变量、标志和远程K/V存储，但也可以实现自己所需的配置源并将其提供给viper。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;bytes&quot;</span></span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">yamlConf</span><span class="params">()</span></span> &#123;</span><br><span class="line"> viper.SetConfigType(<span class="string">&quot;yaml&quot;</span>) </span><br><span class="line"> ExampleYaml := []<span class="type">byte</span>(<span class="string">`</span></span><br><span class="line"><span class="string">name: Payne</span></span><br><span class="line"><span class="string">Age: 18</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line"> viper.ReadConfig(bytes.NewBuffer(ExampleYaml))</span><br><span class="line"> fmt.Println(viper.Get(<span class="string">&quot;NAME&quot;</span>))</span><br><span class="line"> fmt.Println(viper.Get(<span class="string">&quot;Age&quot;</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jsonConf</span><span class="params">()</span></span> &#123;</span><br><span class="line"> viper.SetConfigType(<span class="string">`json`</span>)</span><br><span class="line"></span><br><span class="line"> ExampleJSON := []<span class="type">byte</span>(<span class="string">`&#123;</span></span><br><span class="line"><span class="string">  &quot;name&quot;: &quot;payne&quot;,</span></span><br><span class="line"><span class="string">  &quot;age&quot;: 21</span></span><br><span class="line"><span class="string">&#125;`</span>)</span><br><span class="line"> viper.ReadConfig(bytes.NewBuffer(ExampleJSON))</span><br><span class="line"> fmt.Println(viper.Get(<span class="string">&quot;name&quot;</span>))</span><br><span class="line"> fmt.Println(viper.GetInt(<span class="string">&quot;age&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写入配置文件"><a class="markdownIt-Anchor" href="#写入配置文件"></a> 写入配置文件</h3>
<p>从配置文件中读取是很有用的，但有时你想存储在运行时所作的所有修改都比较繁琐。viper提供了相关功能</p>
<ul>
<li>WriteConfig - 将当前的<code>viper</code>配置写入预定义的路径并覆盖（如果存在的话）。如果没有预定义的路径，则报错。</li>
<li>SafeWriteConfig - 将当前的<code>viper</code>配置写入预定义的路径。如果没有预定义的路径，则报错。如果存在，将不会覆盖当前的配置文件。</li>
<li>WriteConfigAs - 将当前的<code>viper</code>配置写入给定的文件路径。将覆盖给定的文件(如果它存在的话)。</li>
<li>SafeWriteConfigAs - 将当前的<code>viper</code>配置写入给定的文件路径。不会覆盖给定的文件(如果它存在的话)。</li>
</ul>
<blockquote>
<p>根据经验，标记为<code>safe</code>的所有方法都不会覆盖任何文件，而是直接创建（如果不存在），而默认行为是创建或截断。</p>
</blockquote>
<h3 id="监听配置文件"><a class="markdownIt-Anchor" href="#监听配置文件"></a> 监听配置文件</h3>
<p>Viper支持在运行时实时读取配置文件的功能。</p>
<p>需要重新启动服务器以使配置生效的日子已经一去不复返了，viper驱动的应用程序可以在运行时读取配置文件的更新，而不会错过任何消息。</p>
<p>只需告诉viper实例watchConfig。可选地，你可以为Viper提供一个回调函数，以便在每次发生更改时运行。</p>
<blockquote>
<p><strong>确保在调用<code>WatchConfig()</code>之前添加了所有的配置路径。</strong></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">viper.WatchConfig()</span><br><span class="line">viper.OnConfigChange(<span class="function"><span class="keyword">func</span><span class="params">(e fsnotify.Event)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 配置文件发生变更之后会调用的回调函数</span></span><br><span class="line"> fmt.Println(<span class="string">&quot;Config file changed:&quot;</span>, e.Name)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;github.com/fsnotify/fsnotify&quot;</span></span><br><span class="line"> <span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line"> <span class="string">&quot;log&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">  viper.SetConfigFile(<span class="string">`./example/config.yaml`</span>)</span><br><span class="line">  <span class="keyword">if</span> err := viper.ReadInConfig(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> _, ok := err.(viper.ConfigFileNotFoundError); ok &#123;</span><br><span class="line">    <span class="comment">// Config file not found; ignore error if desired</span></span><br><span class="line">    log.Println(<span class="string">&quot;no such config file&quot;</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Config file was found but another error was produced</span></span><br><span class="line">    log.Println(<span class="string">&quot;read config error&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   log.Fatal(err) <span class="comment">// 读取配置文件失败致命错误</span></span><br><span class="line">  &#125;</span><br><span class="line">  viper.SetDefault(<span class="string">`a`</span>, <span class="string">`b`</span>)</span><br><span class="line">  viper.WatchConfig()</span><br><span class="line">  viper.OnConfigChange(<span class="function"><span class="keyword">func</span><span class="params">(e fsnotify.Event)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 配置文件发生变更之后会调用的回调函数</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;Config file changed:&quot;</span>, e.Name)</span><br><span class="line">  &#125;)</span><br><span class="line">  fmt.Println(viper.Get(<span class="string">`port`</span>))</span><br><span class="line">  time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="环境变量"><a class="markdownIt-Anchor" href="#环境变量"></a> 环境变量</h2>
<p>Viper完全支持环境变量。以下几种方法进行对ENV协作:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AllowEmptyEnv 告诉 Viper 将设置但为空的环境变量视为有效值，而不是回退。出于向后兼容性的原因，默认情况下这是错误的</span></span><br><span class="line">AllowEmptyEnv(allowEmptyEnv <span class="type">bool</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// AutomaticEnv 使 Viper 检查环境变量是否与任何现有键（配置、默认值或标志）匹配。如果找到匹配的环境变量，则将它们加载到 Viper 中</span></span><br><span class="line">AutomaticEnv()</span><br><span class="line"></span><br><span class="line"><span class="comment">// BindEnv 将 Viper 键绑定到 ENV 变量。ENV 变量区分大小写。如果只提供了一个键，它将使用与键匹配的 env 键，大写。如果提供了更多参数，它们将表示应绑定到此键的环境变量名称，并将按指定顺序使用。当未提供 env 名称时，将在设置时使用 EnvPrefix。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BindEnv</span><span class="params">(input ...<span class="type">string</span>)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SetEnvPrefix 定义了 ENVIRONMENT 变量将使用的前缀</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetEnvPrefix</span><span class="params">(in <span class="type">string</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SetEnvKeyReplacer允许你使用strings.Replacer对象在一定程度上重写 Env 键</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetEnvKeyReplacer</span><span class="params">(r *strings.Replacer)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><em><strong>使用ENV变量时，务必要意识到Viper将ENV变量视为区分大小写。</strong></em></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// case 1</span></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  viper.SetDefault(<span class="string">`Val`</span>, <span class="string">`Original`</span>)</span><br><span class="line">  viper.BindEnv(<span class="string">`Val`</span>)</span><br><span class="line">  fmt.Println(viper.Get(<span class="string">`Val`</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通常是在应用程序之外完成的</span></span><br><span class="line">  <span class="keyword">if</span> i == <span class="number">3</span> &#123;</span><br><span class="line">    os.Setenv(<span class="string">&quot;VAL&quot;</span>, <span class="string">&quot;changed&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(i)</span><br><span class="line">  i += <span class="number">1</span></span><br><span class="line">  time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// case 2</span></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  viper.SetDefault(<span class="string">`Val`</span>, <span class="string">`Original`</span>)</span><br><span class="line">  viper.SetEnvPrefix(<span class="string">`CUSTOM`</span>) <span class="comment">// 将自动转为大写</span></span><br><span class="line">  viper.BindEnv(<span class="string">`Val`</span>)</span><br><span class="line">  fmt.Println(viper.Get(<span class="string">`Val`</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通常是在应用程序之外完成的</span></span><br><span class="line">  <span class="keyword">if</span> i == <span class="number">3</span> &#123;</span><br><span class="line">    os.Setenv(<span class="string">&quot;CUSTOM_VAL&quot;</span>, <span class="string">&quot;changed&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(i)</span><br><span class="line">  i += <span class="number">1</span></span><br><span class="line">  time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当第四次输出时<code>VAL</code>,将输出<code>change</code></p>
<p>小技巧：在使用环境变量的时候推荐采用全大写，避免混淆</p>
</blockquote>
<h2 id="使用viper获取值"><a class="markdownIt-Anchor" href="#使用viper获取值"></a> 使用viper获取值</h2>
<blockquote>
<p>获取函数如下所示，具体作用见名思意</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Get(key <span class="type">string</span>) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">Sub(key <span class="type">string</span>) *Viper</span><br><span class="line">GetBool(key <span class="type">string</span>) <span class="type">bool</span></span><br><span class="line">GetDuration(key <span class="type">string</span>) time.Duration</span><br><span class="line">GetFloat64(key <span class="type">string</span>) <span class="type">float64</span></span><br><span class="line">GetInt(key <span class="type">string</span>) <span class="type">int</span></span><br><span class="line">GetInt32(key <span class="type">string</span>) <span class="type">int32</span></span><br><span class="line">GetInt64(key <span class="type">string</span>) <span class="type">int64</span></span><br><span class="line">GetIntSlice(key <span class="type">string</span>) []<span class="type">int</span></span><br><span class="line">GetSizeInBytes(key <span class="type">string</span>) <span class="type">uint</span></span><br><span class="line">GetString(key <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">GetStringMap(key <span class="type">string</span>) <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">GetStringMapString(key <span class="type">string</span>) <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">GetStringMapStringSlice(key <span class="type">string</span>) <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span></span><br><span class="line">GetStringSlice(key <span class="type">string</span>) []<span class="type">string</span></span><br><span class="line">GetTime(key <span class="type">string</span>) time.Time</span><br><span class="line">GetUint(key <span class="type">string</span>) <span class="type">uint</span></span><br><span class="line">GetUint32(key <span class="type">string</span>) <span class="type">uint32</span></span><br><span class="line">GetUint64(key <span class="type">string</span>) <span class="type">uint64</span></span><br><span class="line">InConfig(key <span class="type">string</span>) <span class="type">bool</span></span><br><span class="line">IsSet(key <span class="type">string</span>) <span class="type">bool</span></span><br><span class="line">AllSettings() <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问嵌套的键"><a class="markdownIt-Anchor" href="#访问嵌套的键"></a> 访问嵌套的键</h3>
<p>访问器方法也接受深度嵌套键的格式化路径。例如，如果加载下面的JSON文件：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">5799</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;datastore&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;metric&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">3099</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;warehouse&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;198.21.112.32&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">2112</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>Viper可以通过传入<code>.</code>分隔的路径来访问嵌套字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">GetString(<span class="string">&quot;datastore.datastore.warehouse.host&quot;</span>) </span><br><span class="line"><span class="comment">// 返回 &quot;198.21.112.32&quot;</span></span><br></pre></td></tr></table></figure>
<p>这遵守上面建立的优先规则；搜索路径将遍历其余配置注册表，直到找到为止。(<br />
译注：因为Viper支持从多种配置来源，例如磁盘上的配置文件&gt;命令行标志位&gt;环境变量&gt;远程Key/Value存储&gt;<br />
默认值，我们在查找一个配置的时候如果在当前配置源中没找到，就会继续从后续的配置源查找，直到找到为止。)</p>
<p>例如，在给定此配置文件的情况下，<code>datastore.metric.host</code>和<code>datastore.metric.port</code><br />
均已定义（并且可以被覆盖）。如果另外在默认值中定义了<code>datastore.metric.protocol</code><br />
，Viper也会找到它。然而，如果<code>datastore.metric</code>被直接赋值覆盖（被flag，环境变量，<code>set()</code><br />
方法等等…），那么<code>datastore.metric</code><br />
的所有子键都将变为未定义状态，它们被高优先级配置级别“遮蔽”（shadowed）了。最后，如果存在与分隔的键路径匹配的键，则返回其值。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;datastore.metric.host&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;host&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;address&quot;</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">        <span class="string">&quot;port&quot;</span>: <span class="number">5799</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;datastore&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;metric&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;host&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;port&quot;</span>: <span class="number">3099</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;warehouse&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;host&quot;</span>: <span class="string">&quot;198.0.0.1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;port&quot;</span>: <span class="number">2112</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GetString(<span class="string">&quot;datastore.metric.host&quot;</span>) </span><br><span class="line"><span class="comment">// 返回 &quot;0.0.0.0&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="提取子树"><a class="markdownIt-Anchor" href="#提取子树"></a> 提取子树</h3>
<p>从Viper中提取子树，<code>viper</code>实例现在代表了以下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">app:</span></span><br><span class="line">  <span class="attr">cache1:</span></span><br><span class="line">    <span class="attr">max-items:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">item-size:</span> <span class="number">64</span></span><br><span class="line">  <span class="attr">cache2:</span></span><br><span class="line">    <span class="attr">max-items:</span> <span class="number">200</span></span><br><span class="line">    <span class="attr">item-size:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>执行后：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">subv := viper.Sub(<span class="string">&quot;app.cache1&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><code>subv</code>现在就代表：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">max-items:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">item-size:</span> <span class="number">64</span></span><br></pre></td></tr></table></figure>
<p>假设我们现在有这么一个函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCache</span><span class="params">(cfg *Viper)</span></span> *Cache &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>它基于<code>subv</code>格式的配置信息创建缓存。现在，可以轻松地分别创建这两个缓存，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cfg1 := viper.Sub(<span class="string">&quot;app.cache1&quot;</span>)</span><br><span class="line">cache1 := NewCache(cfg1)</span><br><span class="line"></span><br><span class="line">cfg2 := viper.Sub(<span class="string">&quot;app.cache2&quot;</span>)</span><br><span class="line">cache2 := NewCache(cfg2)</span><br></pre></td></tr></table></figure>
<h3 id="反序列化"><a class="markdownIt-Anchor" href="#反序列化"></a> 反序列化</h3>
<p>你还可以选择将所有或特定的值解析到结构体、map等。</p>
<p>有两种方法可以做到这一点：</p>
<ul>
<li><code>Unmarshal(rawVal interface&#123;&#125;) : error</code></li>
<li><code>UnmarshalKey(key string, rawVal interface&#123;&#125;) : error</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line"> Port <span class="type">int</span></span><br><span class="line"> Name <span class="type">string</span></span><br><span class="line"> PathMap <span class="type">string</span> <span class="string">`mapstructure:&quot;path_map&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> C config</span><br><span class="line"></span><br><span class="line">err := viper.Unmarshal(&amp;C)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"> t.Fatalf(<span class="string">&quot;unable to decode into struct, %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你想要解析那些键本身就包含<code>.</code>(默认的键分隔符）的配置，你需要修改分隔符：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v := viper.NewWithOptions(viper.KeyDelimiter(<span class="string">&quot;::&quot;</span>))</span><br><span class="line"></span><br><span class="line">v.SetDefault(<span class="string">&quot;chart::values&quot;</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">    <span class="string">&quot;ingress&quot;</span>: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">        <span class="string">&quot;annotations&quot;</span>: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">            <span class="string">&quot;traefik.frontend.rule.type&quot;</span>:                 <span class="string">&quot;PathPrefix&quot;</span>,</span><br><span class="line">            <span class="string">&quot;traefik.ingress.kubernetes.io/ssl-redirect&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line"> Chart <span class="keyword">struct</span>&#123;</span><br><span class="line">        Values <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> C config</span><br><span class="line"></span><br><span class="line">v.Unmarshal(&amp;C)</span><br></pre></td></tr></table></figure>
<p>Viper还支持解析到嵌入的结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Example config:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">module:</span></span><br><span class="line"><span class="comment">    enabled: true</span></span><br><span class="line"><span class="comment">    token: 89h3f98hbwf987h3f98wenf89ehf</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> &#123;</span><br><span class="line"> Module <span class="keyword">struct</span> &#123;</span><br><span class="line">  Enabled <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">  moduleConfig <span class="string">`mapstructure:&quot;,squash&quot;`</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// moduleConfig could be in a module specific package</span></span><br><span class="line"><span class="keyword">type</span> moduleConfig <span class="keyword">struct</span> &#123;</span><br><span class="line"> Token <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> C config</span><br><span class="line"></span><br><span class="line">err := viper.Unmarshal(&amp;C)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"> t.Fatalf(<span class="string">&quot;unable to decode into struct, %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Viper在后台使用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pdGNoZWxsaC9tYXBzdHJ1Y3R1cmU=">github.com/mitchellh/mapstructure<i class="fa fa-external-link-alt"></i></span><br />
来解析值，其默认情况下使用<code>mapstructure</code>tag。</p>
<blockquote>
<p><strong>注意</strong> 当我们需要将viper读取的配置反序列到我们定义的结构体变量中时，一定要使用<code>mapstructure</code>tag！</p>
</blockquote>
<h3 id="序列化成字符串"><a class="markdownIt-Anchor" href="#序列化成字符串"></a> 序列化成字符串</h3>
<p>你可能需要将viper中保存的所有设置序列化到一个字符串中，而不是将它们写入到一个文件中。你可以将自己喜欢的格式的序列化器与<code>AllSettings()</code><br />
返回的配置一起使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    yaml <span class="string">&quot;gopkg.in/yaml.v2&quot;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">yamlStringSettings</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    c := viper.AllSettings()</span><br><span class="line">    bs, err := yaml.Marshal(c)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;unable to marshal config to YAML: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(bs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="远程keyvalue存储支持"><a class="markdownIt-Anchor" href="#远程keyvalue存储支持"></a> 远程Key/Value存储支持</h2>
<p>在Viper中启用远程支持，需要在代码中匿名导入<code>viper/remote</code>这个包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import _ &quot;github.com/spf13/viper/remote&quot;</span><br></pre></td></tr></table></figure>
<p>Viper将读取从Key/Value存储（例如etcd或Consul）中的路径检索到的配置字符串（如<code>JSON</code>、<code>TOML</code>、<code>YAML</code>、<code>HCL</code>、<code>envfile</code><br />
和<code>Java properties</code><br />
格式）。这些值的优先级高于默认值，但是会被从磁盘、flag或环境变量检索到的配置值覆盖。（译注：也就是说Viper加载配置值的优先级为：磁盘上的配置文件&gt;<br />
命令行标志位&gt;环境变量&gt;远程Key/Value存储&gt;默认值。）</p>
<p>Viper使用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JrZXRlbHNlbi9jcnlwdA==">crypt<i class="fa fa-external-link-alt"></i></span><br />
从K/V存储中检索配置，这意味着如果你有正确的gpg密匙，你可以将配置值加密存储并自动解密。加密是可选的。</p>
<p>你可以将远程配置与本地配置结合使用，也可以独立使用。</p>
<p><code>crypt</code>有一个命令行助手，你可以使用它将配置放入K/V存储中。<code>crypt</code><br />
默认使用在<span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMTo0MDAxLw==">http://127.0.0.1:4001<i class="fa fa-external-link-alt"></i></span>的etcd。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/bketelsen/crypt/bin/crypt</span><br><span class="line">crypt <span class="built_in">set</span> -plaintext /config/hugo.json /Users/hugo/settings/config.json</span><br></pre></td></tr></table></figure>
<p>确认值已经设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crypt get -plaintext /config/hugo.json</span><br></pre></td></tr></table></figure>
<p>有关如何设置加密值或如何使用Consul的示例，请参见<code>crypt</code>文档。</p>
<h3 id="远程keyvalue存储示例-未加密"><a class="markdownIt-Anchor" href="#远程keyvalue存储示例-未加密"></a> 远程Key/Value存储示例-未加密</h3>
<h4 id="etcd"><a class="markdownIt-Anchor" href="#etcd"></a> etcd</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">viper.AddRemoteProvider(<span class="string">&quot;etcd&quot;</span>, <span class="string">&quot;http://127.0.0.1:4001&quot;</span>,<span class="string">&quot;/config/hugo.json&quot;</span>)</span><br><span class="line">viper.SetConfigType(<span class="string">&quot;json&quot;</span>) <span class="comment">// 因为在字节流中没有文件扩展名，所以这里需要设置下类型。支持的扩展名有 &quot;json&quot;, &quot;toml&quot;, &quot;yaml&quot;, &quot;yml&quot;, &quot;properties&quot;, &quot;props&quot;, &quot;prop&quot;, &quot;env&quot;, &quot;dotenv&quot;</span></span><br><span class="line">err := viper.ReadRemoteConfig()</span><br></pre></td></tr></table></figure>
<h4 id="consul"><a class="markdownIt-Anchor" href="#consul"></a> Consul</h4>
<p>你需要 Consul Key/Value存储中设置一个Key保存包含所需配置的JSON值。例如，创建一个key<code>MY_CONSUL_KEY</code><br />
将下面的值存入Consul key/value 存储：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">viper.AddRemoteProvider(<span class="string">&quot;consul&quot;</span><span class="punctuation">,</span> <span class="string">&quot;localhost:8500&quot;</span><span class="punctuation">,</span> <span class="string">&quot;MY_CONSUL_KEY&quot;</span>)</span><br><span class="line">viper.SetConfigType(<span class="string">&quot;json&quot;</span>) <span class="comment">// 需要显示设置成json</span></span><br><span class="line">err<span class="punctuation">:</span> = viper.ReadRemoteConfig()</span><br></pre></td></tr></table></figure>
<h4 id="firestore"><a class="markdownIt-Anchor" href="#firestore"></a> Firestore</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">viper.AddRemoteProvider(<span class="string">&quot;firestore&quot;</span>, <span class="string">&quot;google-cloud-project-id&quot;</span>, <span class="string">&quot;collection/document&quot;</span>)</span><br><span class="line">viper.SetConfigType(<span class="string">&quot;json&quot;</span>) <span class="comment">// 配置的格式: &quot;json&quot;, &quot;toml&quot;, &quot;yaml&quot;, &quot;yml&quot;</span></span><br><span class="line">err := viper.ReadRemoteConfig()</span><br></pre></td></tr></table></figure>
<p>当然，你也可以使用<code>SecureRemoteProvider</code>。</p>
<h3 id="远程keyvalue存储示例-加密"><a class="markdownIt-Anchor" href="#远程keyvalue存储示例-加密"></a> 远程Key/Value存储示例-加密</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">viper.AddSecureRemoteProvider(<span class="string">&quot;etcd&quot;</span>,<span class="string">&quot;http://127.0.0.1:4001&quot;</span>,<span class="string">&quot;/config/hugo.json&quot;</span>,<span class="string">&quot;/etc/secrets/mykeyring.gpg&quot;</span>)</span><br><span class="line">viper.SetConfigType(<span class="string">&quot;json&quot;</span>) <span class="comment">// 因为在字节流中没有文件扩展名，所以这里需要设置下类型。支持的扩展名有 &quot;json&quot;, &quot;toml&quot;, &quot;yaml&quot;, &quot;yml&quot;, &quot;properties&quot;, &quot;props&quot;, &quot;prop&quot;, &quot;env&quot;, &quot;dotenv&quot;</span></span><br><span class="line">err := viper.ReadRemoteConfig()</span><br></pre></td></tr></table></figure>
<h3 id="监控etcd中的更改-未加密"><a class="markdownIt-Anchor" href="#监控etcd中的更改-未加密"></a> 监控etcd中的更改-未加密</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 或者你可以创建一个新的viper实例</span></span><br><span class="line"><span class="keyword">var</span> runtime_viper = viper.New()</span><br><span class="line"></span><br><span class="line">runtime_viper.AddRemoteProvider(<span class="string">&quot;etcd&quot;</span>, <span class="string">&quot;http://127.0.0.1:4001&quot;</span>, <span class="string">&quot;/config/hugo.yml&quot;</span>)</span><br><span class="line">runtime_viper.SetConfigType(<span class="string">&quot;yaml&quot;</span>) <span class="comment">// 因为在字节流中没有文件扩展名，所以这里需要设置下类型。支持的扩展名有 &quot;json&quot;, &quot;toml&quot;, &quot;yaml&quot;, &quot;yml&quot;, &quot;properties&quot;, &quot;props&quot;, &quot;prop&quot;, &quot;env&quot;, &quot;dotenv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次从远程读取配置</span></span><br><span class="line">err := runtime_viper.ReadRemoteConfig()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">runtime_viper.Unmarshal(&amp;runtime_conf)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启一个单独的goroutine一直监控远端的变更</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">     time.Sleep(time.Second * <span class="number">5</span>) <span class="comment">// 每次请求后延迟一下</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 目前只测试了etcd支持</span></span><br><span class="line">     err := runtime_viper.WatchRemoteConfig()</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Errorf(<span class="string">&quot;unable to read remote config: %v&quot;</span>, err)</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 将新配置反序列化到我们运行时的配置结构体中。你还可以借助channel实现一个通知系统更改的信号</span></span><br><span class="line">     runtime_viper.Unmarshal(&amp;runtime_conf)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<h2 id="基于viper实现的环境变量动态链接"><a class="markdownIt-Anchor" href="#基于viper实现的环境变量动态链接"></a> 基于Viper实现的环境变量动态链接</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// DynamicEnv is a dynamic adapter that interoperates with environment variables</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DynamicEnv</span><span class="params">(envName, Prefix <span class="type">string</span>, defaultVal <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">   viper.SetDefault(envName, defaultVal)</span><br><span class="line">   viper.SetEnvPrefix(Prefix)</span><br><span class="line">   viper.BindEnv(envName)</span><br><span class="line">   <span class="keyword">return</span> viper.Get(envName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go代码测试与调优</title>
    <url>/65092.html</url>
    <content><![CDATA[<p>在了解golang的测试之前，先了解一下go语言自带的测试工具-go test</p>
<h2 id="go-test工具"><a class="markdownIt-Anchor" href="#go-test工具"></a> go test工具</h2>
<p>Go语言中的测试依赖<code>go test</code>命令。编写测试代码和编写普通的Go代码过程是类似的，并不需要学习新的语法、规则或工具。</p>
<span id="more"></span>
<p>go test命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以<code>_test.go</code><br />
为后缀名的源代码文件都是<code>go test</code>测试的一部分，不会被<code>go build</code>编译到最终的可执行文件中。</p>
<p>在<code>*_test.go</code>文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">格式</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">测试函数</td>
<td style="text-align:center">函数名前缀为Test</td>
<td style="text-align:center">测试程序的一些逻辑行为是否正确</td>
</tr>
<tr>
<td style="text-align:center">基准函数</td>
<td style="text-align:center">函数名前缀为Benchmark</td>
<td style="text-align:center">测试函数的性能</td>
</tr>
<tr>
<td style="text-align:center">示例函数</td>
<td style="text-align:center">函数名前缀为Example</td>
<td style="text-align:center">为文档提供示例文档</td>
</tr>
</tbody>
</table>
<h4 id="运行流程"><a class="markdownIt-Anchor" href="#运行流程"></a> 运行流程</h4>
<p><code>go test</code>命令会遍历所有的<code>*_test.go</code><br />
文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。</p>
<h3 id="使用详解"><a class="markdownIt-Anchor" href="#使用详解"></a> 使用详解</h3>
<p>上次对于<code>go test</code> 并没有详细的阐述，这次补上。</p>
<p>go test 的使用语法如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span> [build/test flags] [packages] [build/test flags &amp; <span class="built_in">test</span> binary flags]</span><br><span class="line"><span class="comment"># 可以直接 go test 直接运行，那么它将运行本目录下的所有*_test.go的基准测试。</span></span><br><span class="line"><span class="comment"># 还可以进行编译后测试例如 go test build </span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>更多请查看 <code>go help testfunc</code>。</p>
<p><code>go test</code> 命令还会忽略 <code>testdata</code> 目录，该目录用来保存测试需要用到的辅助数据。</p>
<p>go test 有两种运行模式：</p>
<p>1、本地目录模式，在没有包参数（例如 <code>go test</code> 或 <code>go test -v</code>）调用时发生。在此模式下，<code>go test</code><br />
编译当前目录中找到的包和测试，然后运行测试二进制文件。在这种模式下，caching<br />
是禁用的。在包测试完成后，<code>go test</code> 打印一个概要行，显示测试状态、包名和运行时间。</p>
<p>2、包列表模式，在使用显示包参数调用 <code>go test</code> 时发生（例如 <code>go test math</code>，<code>go test ./...</code><br />
甚至是 <code>go test .</code>）。在此模式下，go 测试编译并测试在命令上列出的每个包。如果一个包测试通过，<code>go test</code><br />
只打印最终的 <code>ok</code> 总结行。如果一个包测试失败，<code>go test</code> 将输出完整的测试输出。如果使用 <code>-bench</code><br />
或 <code>-v</code><br />
标志，则 <code>go test</code> 会输出完整的输出，甚至是通过包测试，以显示所请求的基准测试结果或详细日志记录。</p>
<p>下面详细说明下 <code>go test</code> 的具体用法，flag 的作用及一些相关例子。需要说明的是：一些 flag<br />
支持 <code>go test</code> 命令和编译后的二进制测试文件。它们都能识别加 <code>-test.</code> 前缀的<br />
flag，如 <code>go test -test.v</code><br />
，但编译后的二进制文件必须加前缀 <code>./sum.test -test.bench=.</code>。</p>
</blockquote>
<p>参数详解</p>
<h3 id="test-flag"><a class="markdownIt-Anchor" href="#test-flag"></a> test flag</h3>
<p>以下 flag 可以跟被 <code>go test</code> 命令使用：</p>
<ul>
<li><code>-args</code>：传递命令行参数，该标志会将 -args 之后的参数作为命令行参数传递，最好作为最后一个标志。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go test -args -p=true</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-c</code>：编译测试二进制文件为 [pkg].test，不运行测试。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go test -c &amp;&amp; ./sum.test -p=true</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-exec xprog</code>：使用 xprog 运行测试，行为同 <code>go run</code> 一样，查看 <code>go help run</code>。</li>
<li><code>-i</code>：安装与测试相关的包，不运行测试。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go test -i</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-o file</code>：编译测试二进制文件并指定文件，同时运行测试。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go test -o filename</span><br></pre></td></tr></table></figure>
<h3 id="testbinary-flag"><a class="markdownIt-Anchor" href="#testbinary-flag"></a> test/binary flag</h3>
<p>以下标志同时支持测试二进制文件和 <code>go test</code> 命令。</p>
<ul>
<li><code>-bench regexp</code>：通过正则表达式执行基准测试，默认不执行基准测试。可以使用 <code>-bench .</code>或<code>-bench=.</code><br />
执行所有基准测试。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go test -bench=.</span><br><span class="line">go test -c</span><br><span class="line">./sum.test -test.bench=.</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-benchtime t</code>：每个基准测试运行足够迭代消耗的时间，time.Duration（如 -benchtime 1h30s），默认 1s。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go test -bench=. -benchtime 0.1s</span><br><span class="line">./sum.test -test.bench=. -test.benchtime=1s</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-count n</code>：运行每个测试和基准测试的次数（默认 1），如果 -cpu 指定了，则每个 GOMAXPROCS 值执行 n<br />
次，Examples 总是运行一次。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go test -bench=. -count=2</span><br><span class="line">./sum.test -test.bench=. -test.count=2</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-cover</code>：开启覆盖分析，开启覆盖分析可能会在编译或测试失败时，代码行数不对。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go test -bench=. -cover</span><br></pre></td></tr></table></figure>
<ul>
<li>
<pre class="highlight"><code class="">-covermode set,count,atomic
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ：覆盖分析的模式，默认是 set，如果设置 -race，将会变为 atomic。</span><br><span class="line"></span><br><span class="line">  - set，bool，这个语句运行吗？</span><br><span class="line">  - count，int，该语句运行多少次？</span><br><span class="line">  - atomic，int，数量，在多线程正确使用，但是耗资源的。</span><br><span class="line"></span><br><span class="line">- `-coverpkg pkg1,pkg2,pkg3`：指定分析哪个包，默认值只分析被测试的包，包为导入的路径。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
# sum -&gt; $GOPATH/src/test/sum
$ go test -coverpkg test/sum
</code></pre>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `-cpu 1,2,4`：指定测试或基准测试的 GOMAXPROCS 值。默认为 GOMAXPROCS 的当前值。</span><br><span class="line">- `-list regexp`：列出与正则表达式匹配的测试、基准测试或 Examples。只列出顶级测试（不列出子测试），不运行测试。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>go test -list Sum</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `-parallel n`：允许并行执行通过调用 t.Parallel 的测试函数的最大次数。默认值为 GOMAXPROCS</span><br><span class="line">  的值。-parallel 仅适用于单个二进制测试文件，但`go test`命令可以通过指定 -p</span><br><span class="line">  并行测试不同的包。查看 `go help build`。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>go test -run=TestSumParallel -parallel=2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `-run regexp`：只运行与正则表达式匹配的测试和Examples。可以通过 / 来指定测试子函数。`go test Foo/A=`</span><br><span class="line">  ，会先去匹配并执行 Foo 函数，再查找子函数。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>go test -v -run TestSumSubTest/1+</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `-short`：缩短长时间运行的测试的测试时间。默认关闭。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>go test -short</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `-timeout d`：如果二进制测试文件执行时间过长，panic。默认10分钟（10m）。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>go test -run TestSumLongTime -timeout 1s</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `-v`：详细输出，运行期间所有测试的日志。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>go test -v</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### analyze flag</span><br><span class="line"></span><br><span class="line">以下测试适用于 `go test` 和测试二进制文件：</span><br><span class="line"></span><br><span class="line">- `-benchmem`：打印用于基准的内存分配统计数据。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>go test -bench=. -benchmem<br />
./sum.test -test.bench -test.benchmem</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `-blockprofile block.out`：当所有的测试都完成时，在指定的文件中写入一个 goroutine 阻塞概要文件。指定</span><br><span class="line">  -c，将写入测试二进制文件。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>go test -v -cpuprofile=prof.out<br />
go tool pprof prof.out</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `-blockprofilerate n`：goroutine 阻塞时候打点的纳秒数。默认不设置就相当于</span><br><span class="line">  -test.blockprofilerate=1，每一纳秒都打点记录一下。</span><br><span class="line">- `-coverprofile cover.out`：在所有测试通过后，将覆盖概要文件写到文件中。设置过 -cover。</span><br><span class="line">- `-cpuprofile cpu.out`：在退出之前，将一个 CPU 概要文件写入指定的文件。</span><br><span class="line">- `-memprofile mem.out`：在所有测试通过后，将内存概要文件写到文件中。</span><br><span class="line">- `-memprofilerate n`：开启更精确的内存配置。如果为 1，将会记录所有内存分配到 profile。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>go test -memprofile mem.out -memprofilerate 1<br />
go tool pprof mem.out</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `-mutexprofile mutex.out`：当所有的测试都完成时，在指定的文件中写入一个互斥锁争用概要文件。指定</span><br><span class="line">  -c，将写入测试二进制文件。</span><br><span class="line">- `-mutexprofilefraction n`：样本 1 在 n 个堆栈中，goroutines 持有 a，争用互斥锁。</span><br><span class="line">- `-outputdir directory`：在指定的目录中放置输出文件，默认情况下，`go test` 正在运行的目录。</span><br><span class="line">- `-trace trace.out`：在退出之前，将执行跟踪写入指定文件。</span><br><span class="line"></span><br><span class="line">## 单元测试</span><br><span class="line"></span><br><span class="line">&gt; 以下是来自wiki对于单元测试的定义</span><br><span class="line"></span><br><span class="line">在[计算机编程](https://zh.wikipedia.org/wiki/计算机编程)中，**单元测试**（英语：Unit Testing）又称为*</span><br><span class="line">*模块测试**</span><br><span class="line">，是针对[程序模块](https://zh.wikipedia.org/wiki/模組_(程式設計))（[软件设计](https://zh.wikipedia.org/wiki/软件设计)</span><br><span class="line">的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在[过程化编程](https://zh.wikipedia.org/wiki/過程化編程)</span><br><span class="line">中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</span><br><span class="line"></span><br><span class="line">通常来说，程序员每修改一次程序就会进行最少一次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到[软件规格书](https://zh.wikipedia.org/wiki/規格_(技術標準))</span><br><span class="line">要求的工作目标，没有[程序错误](https://zh.wikipedia.org/wiki/Bug)</span><br><span class="line">；虽然单元测试不是必须的，但也不坏，这牵涉到[项目管理](https://zh.wikipedia.org/wiki/專案管理)的政策决定。</span><br><span class="line"></span><br><span class="line">每个理想的[测试案例](https://zh.wikipedia.org/wiki/测试案例)</span><br><span class="line">独立于其它案例；为测试时隔离模块，经常使用stubs、mock[[1\]](https://zh.wikipedia.org/wiki/单元测试#cite_note-mocksarentstubs-1)</span><br><span class="line">或fake等测试[马甲程序](https://zh.wikipedia.org/w/index.php?title=马甲程序&amp;action=edit&amp;redlink=1)</span><br><span class="line">。单元测试通常由[软件开发人员](https://zh.wikipedia.org/w/index.php?title=软件开发人员&amp;action=edit&amp;redlink=1)</span><br><span class="line">编写，用于确保他们所写的代码符合软件需求和遵循[开发目标](https://zh.wikipedia.org/w/index.php?title=开发目标&amp;action=edit&amp;redlink=1)</span><br><span class="line">。它的实施方式可以是非常手动的（透过纸笔），或者是做成[构建自动化](https://zh.wikipedia.org/wiki/構建自動化)</span><br><span class="line">的一部分。</span><br><span class="line"></span><br><span class="line">简单来说，单元测试就是程序员自己对于自己的代码进行测试，而一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</span><br><span class="line"></span><br><span class="line">更有一种开发手法，那就是TDD（Test Driven Development）,测试驱动开发。期望局部最优到全局最优，这个是一种非常不错的好习惯</span><br><span class="line"></span><br><span class="line">&gt; 请注意这里的局部最优的，局部，并不是函数内的详细。而是整个函数。甚至是一个类，等等。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 因为有些函数内部的最优，并非这个函数的最优。这点需要格外的注意。若有兴趣，可了解一下有点关系的贪心算法</span><br><span class="line"></span><br><span class="line">### 测试函数格式</span><br><span class="line"></span><br><span class="line">其中参数`t`用于报告测试失败和附加的日志信息。 `testing.T`的拥有的方法如下：</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">func (c *T) Error(args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) Errorf(format string, args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) Fail()</span><br><span class="line">func (c *T) FailNow()</span><br><span class="line">func (c *T) Failed() bool</span><br><span class="line">func (c *T) Fatal(args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) Fatalf(format string, args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) Log(args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) Logf(format string, args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) Name() string</span><br><span class="line">func (t *T) Parallel()</span><br><span class="line">func (t *T) Run(name string, f func(t *T)) bool</span><br><span class="line">func (c *T) Skip(args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) SkipNow()</span><br><span class="line">func (c *T) Skipf(format string, args ...interface&#123;&#125;)</span><br><span class="line">func (c *T) Skipped() bool</span><br></pre></td></tr></table></figure>
<p>说了这么多，来实现一个<code>简单的</code>string中的Split函数，并对他进行单元测试，然后在剖析代码。了解单元测试的相关规范</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// splits.go</span></span><br><span class="line"><span class="keyword">package</span> splitStr</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// split package with a single split function.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Split slices s into all substrings separated by sep and</span></span><br><span class="line"><span class="comment">// returns a slice of the substrings between those separators.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="type">string</span>)</span></span> (result []<span class="type">string</span>) &#123;</span><br><span class="line"> i := strings.Index(s, sep)</span><br><span class="line"> <span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">  result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">  s = s[i+<span class="number">1</span>:]</span><br><span class="line">  i = strings.Index(s, sep)</span><br><span class="line"> &#125;</span><br><span class="line"> result = <span class="built_in">append</span>(result, s)</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// split_test.go</span></span><br><span class="line"><span class="keyword">package</span> splitStr</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;reflect&quot;</span></span><br><span class="line"> <span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestSplit 单元测试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123; <span class="comment">// 测试函数名必须以Test开头，必须接收一个*testing.T类型参数</span></span><br><span class="line"> got := Split(<span class="string">&quot;a:b:c&quot;</span>, <span class="string">&quot;:&quot;</span>)         <span class="comment">// 程序输出的结果</span></span><br><span class="line"> want := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;    <span class="comment">// 期望的结果</span></span><br><span class="line"> <span class="keyword">if</span> !reflect.DeepEqual(want, got) &#123; <span class="comment">// 因为slice不能直接比较，借助反射包中的方法比较</span></span><br><span class="line">  t.Errorf(<span class="string">&quot;excepted:%v, got:%#v&quot;</span>, want, got) <span class="comment">// 测试失败输出错误提示</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestSplit2 单元测试组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"> <span class="comment">// 定义一个测试用例类型</span></span><br><span class="line"> <span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">  input <span class="type">string</span></span><br><span class="line">  sep   <span class="type">string</span></span><br><span class="line">  want  []<span class="type">string</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 定义一个存储测试用例的切片</span></span><br><span class="line"> tests := []test&#123;</span><br><span class="line">  &#123;input: <span class="string">&quot;a:b:c&quot;</span>, sep: <span class="string">&quot;:&quot;</span>, want: []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;&#125;,</span><br><span class="line">  &#123;input: <span class="string">&quot;a:b:c&quot;</span>, sep: <span class="string">&quot;,&quot;</span>, want: []<span class="type">string</span>&#123;<span class="string">&quot;a:b:c&quot;</span>&#125;&#125;,</span><br><span class="line">  &#123;input: <span class="string">&quot;abcd&quot;</span>, sep: <span class="string">&quot;bc&quot;</span>, want: []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 遍历切片，逐一执行测试用例</span></span><br><span class="line"> <span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">  got := Split(tc.input, tc.sep)</span><br><span class="line">  <span class="keyword">if</span> !reflect.DeepEqual(got, tc.want) &#123;</span><br><span class="line">   t.Errorf(<span class="string">&quot;excepted:%v, got:%#v&quot;</span>, tc.want, got)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnrolzdwnuj318y0dq3z2.jpg" alt="" /></p>
<p>说明测试成功，本次通过。当然你也可以在<code>Terminal</code>里面直接运行<code>go test</code>，命令，如下所示</p>
<img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnropdatxhj30oa0bg0t4.jpg" style="zoom:70%;" />
<blockquote>
<p>温馨提示：关于可能造成运行test不成功原因</p>
<p>直接在<code>split_test.go</code>,运行。</p>
<ul>
<li>或许知道，go是以文件夹的方法来区分项目。所以当前文件，并不能跑到旁边文件中去找到<code>Split</code><br />
,以至于测试失败。或未达到预期效果</li>
</ul>
<p>那么正确的打开方式应该是？</p>
<p>在goland中，鼠标右键点击run测试文件所在的文件夹，选择后面第二个 <code>go test projectFileName</code></p>
<p>在<code>Terminal</code>中，应在<code>测试文件所在的文件夹</code>的路径中，进行<code>go test [arge...]</code></p>
</blockquote>
<p>示例看完了，那么进行简单的剖析。先从函数文件说起，(也就是这里的<code>splits.go</code>)</p>
<ol>
<li>不在是<code>package main</code>,而是<code>packge projectFileName</code></li>
<li>函数名大写，大写意味着公有函数，可支持外部调用</li>
</ol>
<p>测试文件</p>
<ol>
<li>文件名为’*_test.go’</li>
<li>不在是<code>package main</code>,而是<code>packge projectFileName</code></li>
<li>函数名为TestFuncName</li>
</ol>
<h2 id="基准测试"><a class="markdownIt-Anchor" href="#基准测试"></a> 基准测试</h2>
<h3 id="基准测试函数格式"><a class="markdownIt-Anchor" href="#基准测试函数格式"></a> 基准测试函数格式</h3>
<p>基准测试就是在一定的工作负载之下检测程序性能的一种方法。基准测试的基本格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkName</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基准测试以<code>Benchmark</code>为前缀，需要一个<code>*testing.B</code>类型的参数b，基准测试必须要执行<code>b.N</code><br />
次，这样的测试才有对照性，<code>b.N</code>的值是系统根据实际情况去调整的，从而保证测试的稳定性。 <code>testing.B</code><br />
拥有的方法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Error(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Errorf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Fail()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> FailNow()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Failed() <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Fatal(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Fatalf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Log(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Logf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Name() <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> ReportAllocs()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> ResetTimer()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> Run(name <span class="type">string</span>, f <span class="function"><span class="keyword">func</span><span class="params">(b *B)</span></span>) <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> RunParallel(body <span class="function"><span class="keyword">func</span><span class="params">(*PB)</span></span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> SetBytes(n <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> SetParallelism(p <span class="type">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Skip(args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> SkipNow()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Skipf(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span></span> Skipped() <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> StartTimer()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span></span> StopTimer()</span><br></pre></td></tr></table></figure>
<h3 id="基准测试示例"><a class="markdownIt-Anchor" href="#基准测试示例"></a> 基准测试示例</h3>
<p>为自己写的<code>Split</code>函数编写基准测试如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BenchmarkSplit 基准测试(性能测试)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplit</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;b.N ; i++ &#123;</span><br><span class="line">  Split(<span class="string">&quot;abcdebdae&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果如下</span></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: Gp/part5/splitStr</span><br><span class="line">BenchmarkSplit</span><br><span class="line">BenchmarkSplit<span class="number">-8</span>     <span class="number">5740642</span>        <span class="number">209</span> ns/op</span><br><span class="line">PASS</span><br><span class="line">ok   Gp/part5/splitStr <span class="number">1.963</span>s</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中</p>
<p>BenchmarkSplit：表示对Split函数进行基准测试</p>
<p>BenchmarkSplit-8：数字<code>8</code>表示<code>GOMAXPROCS</code>的值，这个对于并发基准测试很重要</p>
<p>5188407和206 ns/op：表示每次调用<code>Split</code>函数耗时<code>203ns</code></p>
</blockquote>
<p>还可以为基准测试添加<code>-benchmem</code>参数，来获得内存分配的统计数据。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnrw3i5yuej312k07adg0.jpg" alt="" /></p>
<blockquote>
<p>112 B/op：表示每次操作内存分配了112字节</p>
<p><code>3 allocs/op</code>：则表示每次操作进行了3次内存分配！！！</p>
</blockquote>
<p>优化后代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// split.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="type">string</span>)</span></span> (result []<span class="type">string</span>) &#123;</span><br><span class="line"> i := strings.Index(s, sep)</span><br><span class="line">  <span class="comment">// 手动分配固定内存，避免多次创建</span></span><br><span class="line"> result = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, strings.Count(s, sep)+<span class="number">1</span>)</span><br><span class="line"> <span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">  result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">  s = s[i+<span class="built_in">len</span>(sep):] <span class="comment">// 这里使用len(sep)获取sep的长度</span></span><br><span class="line">  i = strings.Index(s, sep)</span><br><span class="line"> &#125;</span><br><span class="line"> result = <span class="built_in">append</span>(result, s)</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化后代码如下</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnrx800j18j314g07gjrk.jpg" alt="" /></p>
<blockquote>
<p>这个使用make函数提前分配内存的改动，减少了2/3的内存分配次数，并且减少了一半的内存分配。</p>
<p>仅仅小小的一处改动，就引起如此大的性能改变。so good</p>
<p>量变产生质变</p>
</blockquote>
<h3 id="性能比较函数"><a class="markdownIt-Anchor" href="#性能比较函数"></a> 性能比较函数</h3>
<p>上面的基准测试只能得到给定操作的绝对耗时，但是在很多性能问题是发生在两个不同操作之间的相对耗时，比如同一个函数处理1000个元素的耗时与处理1万甚至100万个元素的耗时的差别是多少？再或者对于同一个任务究竟使用哪种算法性能最佳？通常需要对两个不同算法的实现使用相同的输入来进行基准比较测试。</p>
<p>性能比较函数通常是一个带有参数的函数，被多个不同的Benchmark函数传入不同的值来调用。举个例子如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmark</span><span class="params">(b *testing.B, size <span class="type">int</span>)</span></span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark10</span><span class="params">(b *testing.B)</span></span>&#123; benchmark(b, <span class="number">10</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark100</span><span class="params">(b *testing.B)</span></span>&#123; benchmark(b, <span class="number">100</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark1000</span><span class="params">(b *testing.B)</span></span>&#123; benchmark(b, <span class="number">1000</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>例如编写了一个计算斐波那契数列的函数如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fib.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fib 是一个计算第n个斐波那契数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> n</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> Fib(n<span class="number">-1</span>) + Fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写的性能比较函数如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fib_test.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmarkFib</span><span class="params">(b *testing.B, n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  Fib(n)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib1</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(b, <span class="number">1</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib2</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(b, <span class="number">2</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib3</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(b, <span class="number">3</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib10</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(b, <span class="number">10</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib20</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(b, <span class="number">20</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib40</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(b, <span class="number">40</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>运行基准测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">split</span> $ go <span class="built_in">test</span> -bench=.</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/payne/Gp/code_demo/test_demo/fib</span><br><span class="line">BenchmarkFib1-8         1000000000               2.03 ns/op</span><br><span class="line">BenchmarkFib2-8         300000000                5.39 ns/op</span><br><span class="line">BenchmarkFib3-8         200000000                9.71 ns/op</span><br><span class="line">BenchmarkFib10-8         5000000               325 ns/op</span><br><span class="line">BenchmarkFib20-8           30000             42460 ns/op</span><br><span class="line">BenchmarkFib40-8               2         638524980 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/payne/Gp/code_demo/test_demo/fib 12.944s</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，默认情况下，每个基准测试至少运行1秒。如果在Benchmark函数返回时没有到1秒，则b.N的值会按1,2,5,10,20,50，…增加，并且函数再次运行。</p>
<p>最终的BenchmarkFib40只运行了两次，每次运行的平均值只有不到一秒。像这种情况下应该可以使用<code>-benchtime</code><br />
标志增加最小基准时间，以产生更准确的结果。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">split</span> $ go <span class="built_in">test</span> -bench=Fib40 -benchtime=20s</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/payne/Gp/code_demo/test_demo/fib</span><br><span class="line">BenchmarkFib40-8              50         663205114 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/payne/Gp/code_demo/test_demo/fib 33.849s</span><br></pre></td></tr></table></figure>
<p>这一次<code>BenchmarkFib40</code>函数运行了50次，结果就会更准确一些了。</p>
<p>使用性能比较函数做测试的时候一个容易犯的错误就是把<code>b.N</code>作为输入的大小，例如以下两个例子都是错误的示范：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示范1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFibWrong</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">  Fib(n)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示范2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFibWrong2</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"> Fib(b.N)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重置时间"><a class="markdownIt-Anchor" href="#重置时间"></a> 重置时间</h2>
<p><code>b.ResetTimer</code>之前的处理不会放到执行时间里，也不会输出到报告中，所以可以在之前做一些不计划作为测试报告的操作。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplit</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"> time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">// 假设需要做一些耗时的无关操作</span></span><br><span class="line"> b.ResetTimer()              <span class="comment">// 重置计时器</span></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  strings.Split(<span class="string">&quot;山河和河山&quot;</span>, <span class="string">&quot;和&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并行测试"><a class="markdownIt-Anchor" href="#并行测试"></a> 并行测试</h2>
<p><code>func (b *B) RunParallel(body func(*PB))</code>会以并行的方式执行给定的基准测试。</p>
<p><code>RunParallel</code>会创建出多个<code>goroutine</code>，并将<code>b.N</code>分配给这些<code>goroutine</code>执行， 其中<code>goroutine</code><br />
数量的默认值为<code>GOMAXPROCS</code><br />
。用户如果想要增加非CPU受限（non-CPU-bound）基准测试的并行性， 那么可以在<code>RunParallel</code><br />
之前调用<code>SetParallelism</code> 。<code>RunParallel</code>通常会与<code>-cpu</code>标志一同使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplitParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"> <span class="comment">// b.SetParallelism(1) // 设置使用的CPU数</span></span><br><span class="line"> b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">   Split(<span class="string">&quot;山河和河山&quot;</span>, <span class="string">&quot;和&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行一下基准测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">split</span> $ go <span class="built_in">test</span> -bench=.</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/payne/Gp/code_demo/test_demo/split</span><br><span class="line">BenchmarkSplit-8                10000000               131 ns/op</span><br><span class="line">BenchmarkSplitParallel-8        50000000                36.1 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/payne/Gp/code_demo/test_demo/split       3.308s</span><br></pre></td></tr></table></figure>
<p>还可以通过在测试命令后添加<code>-cpu</code>参数如<code>go test -bench=. -cpu 1</code>来指定使用的CPU数量。</p>
<h2 id="setup与teardown"><a class="markdownIt-Anchor" href="#setup与teardown"></a> Setup与TearDown</h2>
<p>测试程序有时需要在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）。</p>
<h2 id="go性能优化"><a class="markdownIt-Anchor" href="#go性能优化"></a> Go性能优化</h2>
<p>做了这么多的测试最终的目的是测试代码有没有写对，性能是否可以优化。接下来进行性能优化与调优</p>
<p>在计算机性能调试领域里，profiling 是指对应用程序的画像，画像就是应用程序使用 CPU 和内存的情况。<br />
Go语言是一个对性能特别看重的语言，因此语言中自带了 profiling 的库。</p>
<p>Go语言项目中的性能优化主要有以下几个方面：</p>
<ul>
<li>CPU profile：报告程序的 CPU 使用情况，按照一定频率去采集应用程序在 CPU 和寄存器上面的数据</li>
<li>Memory Profile（Heap Profile）：报告程序的内存的使用情况</li>
<li>Block Profiling：报告 goroutine 不在运行状态的情况，可以用来分析与查找死锁等性能瓶颈</li>
<li>Goroutine Profiling：报告 goroutines 的使用情况，有哪些 goroutine，它们的调用关系是怎样的</li>
</ul>
<h3 id="采集性能数据"><a class="markdownIt-Anchor" href="#采集性能数据"></a> 采集性能数据</h3>
<p>Go语言内置了获取程序的运行数据的工具，包括以下两个标准库：</p>
<ul>
<li><code>runtime/pprof</code>：采集工具型应用运行数据进行分析</li>
<li><code>net/http/pprof</code>：采集服务型应用运行时数据进行分析</li>
</ul>
<p>pprof开启后，每隔一段时间（10ms）就会收集下当前的堆栈信息，获取各个函数占用的CPU以及内存资源；最后通过对这些采样数据进行分析，形成一个性能分析报告。</p>
<h3 id="pprof应用"><a class="markdownIt-Anchor" href="#pprof应用"></a> pprof应用</h3>
<p>如果你的应用程序是运行一段时间就结束退出类型。那么最好的办法是在应用退出的时候把 profiling<br />
的报告保存到文件中，进行分析。对于这种情况，可以使用<code>runtime/pprof</code>库。 首先在代码中导入<code>runtime/pprof</code><br />
工具：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;runtime/pprof&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="cpu性能分析"><a class="markdownIt-Anchor" href="#cpu性能分析"></a> CPU性能分析</h3>
<p>开启CPU性能分析：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pprof.StartCPUProfile(w io.Writer)</span><br></pre></td></tr></table></figure>
<p>停止CPU性能分析：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pprof.StopCPUProfile()</span><br></pre></td></tr></table></figure>
<p>应用执行结束后，就会生成一个文件，保存了 CPU profiling 数据。得到采样数据之后，使用<code>go tool pprof</code><br />
工具进行CPU性能分析。</p>
<h3 id="内存性能优化"><a class="markdownIt-Anchor" href="#内存性能优化"></a> 内存性能优化</h3>
<p>记录程序的堆栈信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pprof.WriteHeapProfile(w io.Writer)</span><br></pre></td></tr></table></figure>
<p>得到采样数据之后，使用<code>go tool pprof</code>工具进行内存性能分析。</p>
<p><code>go tool pprof</code>默认是使用<code>-inuse_space</code>进行统计，还可以使用<code>-inuse-objects</code>查看分配对象的数量。</p>
<h2 id="服务型应用"><a class="markdownIt-Anchor" href="#服务型应用"></a> 服务型应用</h2>
<p>如果你的应用程序是一直运行的，比如 web 应用，那么可以使用<code>net/http/pprof</code>库，它能够在提供 HTTP 服务进行分析。</p>
<p>如果使用了默认的<code>http.DefaultServeMux</code>（通常是代码直接使用 http.ListenAndServe(“0.0.0.0:8000”, nil)<br />
），只需要在你的web<br />
server端代码中按如下方式导入<code>net/http/pprof</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;net/http/pprof&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果你使用自定义的 Mux，则需要手动注册一些路由规则：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.HandleFunc(<span class="string">&quot;/debug/pprof/&quot;</span>, pprof.Index)</span><br><span class="line">r.HandleFunc(<span class="string">&quot;/debug/pprof/cmdline&quot;</span>, pprof.Cmdline)</span><br><span class="line">r.HandleFunc(<span class="string">&quot;/debug/pprof/profile&quot;</span>, pprof.Profile)</span><br><span class="line">r.HandleFunc(<span class="string">&quot;/debug/pprof/symbol&quot;</span>, pprof.Symbol)</span><br><span class="line">r.HandleFunc(<span class="string">&quot;/debug/pprof/trace&quot;</span>, pprof.Trace)</span><br></pre></td></tr></table></figure>
<p>如果你使用的是gin框架，推荐使用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpbi1jb250cmliL3Bwcm9m">github.com/gin-contrib/pprof<i class="fa fa-external-link-alt"></i></span><br />
，在代码中通过以下命令注册pprof相关路由。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pprof.Register(router)</span><br></pre></td></tr></table></figure>
<p>不管哪种方式，你的 HTTP 服务都会多出<code>/debug/pprof</code> endpoint，访问它会得到类似下面的内容：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpih7cgmhxj30hu0jwmy0.jpg" alt="" /></p>
<p>这个路径下还有几个子页面：</p>
<ul>
<li>
<p>/debug/pprof/profile：访问这个链接会自动进行 CPU profiling，并生成一个文件供下载</p>
</li>
<li>
<p>/debug/pprof/heap： Memory Profiling 的路径，访问这个链接会得到一个内存 Profiling 结果的文件</p>
</li>
<li>
<p>/debug/pprof/block：block Profiling 的路径</p>
</li>
<li>
<p>/debug/pprof/goroutines：运行的 goroutines 列表，以及调用关系</p>
</li>
<li>
<p>。。。 。。。</p>
</li>
</ul>
<h3 id="go-tool-pprof命令"><a class="markdownIt-Anchor" href="#go-tool-pprof命令"></a> go tool pprof命令</h3>
<p>不管是工具型应用还是服务型应用，我们使用相应的pprof库获取数据之后，下一步的都要对这些数据进行分析，我们可以使用<code>go tool pprof</code><br />
命令行工具。</p>
<p><code>go tool pprof</code>最简单的使用方式为:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool pprof [binary] [<span class="built_in">source</span>]</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>binary 是应用的二进制文件，用来解析各种符号；</li>
<li>source 表示 profile 数据的来源，可以是本地的文件，也可以是 http 地址。</li>
</ul>
<p><strong>注意事项：</strong> 获取的 Profiling<br />
数据是动态的，要想获得有效的数据，请保证应用处于较大的负载（比如正在生成中运行的服务，或者通过其他工具模拟访问压力）。否则如果应用处于空闲状态，得到的结果可能没有任何意义。</p>
<h3 id="命令行交互界面"><a class="markdownIt-Anchor" href="#命令行交互界面"></a> 命令行交互界面</h3>
<p>我们使用go工具链里的<code>pprof</code>来分析一下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool pprof cpu.pprof</span><br></pre></td></tr></table></figure>
<p>执行上面的代码会进入交互界面如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runtime_pprof $ go tool pprof cpu.pprof</span><br><span class="line">Type: cpu</span><br><span class="line">Time: Jun 28, 2020 at 11:28am (CST)</span><br><span class="line">Duration: 20.13s, Total samples = 1.91mins (538.60%)</span><br><span class="line">Entering interactive mode (<span class="built_in">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)  </span><br></pre></td></tr></table></figure>
<p>我们可以在交互界面输入<code>top3</code>来查看程序中占用CPU前3位的函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(pprof) top3</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> 100.37s, 87.68% of 114.47s total</span><br><span class="line">Dropped 17 nodes (cum &lt;= 0.57s)</span><br><span class="line">Showing top 3 nodes out of 4</span><br><span class="line">      flat  flat%   <span class="built_in">sum</span>%        cum   cum%</span><br><span class="line">    42.52s 37.15% 37.15%     91.73s 80.13%  runtime.selectnbrecv</span><br><span class="line">    35.21s 30.76% 67.90%     39.49s 34.50%  runtime.chanrecv</span><br><span class="line">    22.64s 19.78% 87.68%    114.37s 99.91%  main.logicCode</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>flat：当前函数占用CPU的耗时</li>
<li>flat：:当前函数占用CPU的耗时百分比</li>
<li>sun%：函数占用CPU的耗时累计百分比</li>
<li>cum：当前函数加上调用当前函数的函数占用CPU的总耗时</li>
<li>cum%：当前函数加上调用当前函数的函数占用CPU的总耗时百分比</li>
<li>最后一列：函数名称</li>
</ul>
<p>在大多数的情况下，我们可以通过分析这五列得出一个应用程序的运行情况，并对程序进行优化。</p>
<p>还可以使用<code>list 函数名</code>命令查看具体的函数分析，例如执行<code>list logicCode</code>查看我们编写的函数的详细分析。</p>
<h3 id="图形化"><a class="markdownIt-Anchor" href="#图形化"></a> 图形化</h3>
<p>或者可以直接输入web，通过svg图的方式查看程序中详细的CPU占用情况。<br />
想要查看图形化的界面首先需要安装<span class="exturl" data-url="aHR0cHM6Ly9ncmFwaHZpei5naXRsYWIuaW8v">graphviz<i class="fa fa-external-link-alt"></i></span>图形化工具。</p>
<p>Mac：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install graphviz</span><br></pre></td></tr></table></figure>
<p>Windows: 下载<span class="exturl" data-url="aHR0cHM6Ly9ncmFwaHZpei5naXRsYWIuaW8vX3BhZ2VzL0Rvd25sb2FkL0Rvd25sb2FkX3dpbmRvd3MuaHRtbA==">graphviz<i class="fa fa-external-link-alt"></i></span><br />
将<code>graphviz</code><br />
安装目录下的bin文件夹添加到Path环境变量中。 在终端输入<code>dot -version</code>查看是否安装成功。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpihc6efdzj310a0q676g.jpg" alt="" /></p>
<p>关于图形的说明： 每个框代表一个函数，理论上框的越大表示占用的CPU资源越多。 方框之间的线条代表函数之间的调用关系。<br />
线条上的数字表示函数调用的次数。<br />
方框中的第一行数字表示当前函数占用CPU的百分比，第二行数字表示当前函数累计占用CPU的百分比。</p>
<p>除了分析CPU性能数据，pprof也支持分析内存性能数据。比如，使用下面的命令分析http服务的heap性能数据，查看当前程序的内存占用以及热点内存对象使用的情况。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看内存占用数据</span></span><br><span class="line">go tool pprof -inuse_space http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line">go tool pprof -inuse_objects http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line"><span class="comment"># 查看临时内存分配数据</span></span><br><span class="line">go tool pprof -alloc_space http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line">go tool pprof -alloc_objects http://127.0.0.1:8080/debug/pprof/heap</span><br></pre></td></tr></table></figure>
<h2 id="go-torch和火焰图"><a class="markdownIt-Anchor" href="#go-torch和火焰图"></a> go-torch和火焰图</h2>
<p>火焰图（Flame Graph）是 Bredan Gregg 创建的一种性能分析图表，因为它的样子近似 🔥而得名。上面的 profiling<br />
结果也转换成火焰图，如果对火焰图比较了解可以手动来操作，不过这里我们要介绍一个工具：<code>go-torch</code>。这是<br />
uber 开源的一个工具，可以直接读取 golang profiling 数据，并生成一个火焰图的 svg 文件。</p>
<h3 id="安装go-torch"><a class="markdownIt-Anchor" href="#安装go-torch"></a> 安装go-torch</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -v github.com/uber/go-torch</span><br></pre></td></tr></table></figure>
<p>火焰图 svg 文件可以通过浏览器打开，它对于调用图的最优点是它是动态的：可以通过点击每个方块来 zoom in<br />
分析它上面的内容。</p>
<p>火焰图的调用顺序从下到上，每个方块代表一个函数，它上面一层表示这个函数会调用哪些函数，方块的大小代表了占用<br />
CPU 使用的长短。火焰图的配色并没有特殊的意义，默认的红、黄配色是为了更像火焰而已。</p>
<p>go-torch 工具的使用非常简单，没有任何参数的话，它会尝试从<code>http://localhost:8080/debug/pprof/profile</code>获取<br />
profiling 数据。它有三个常用的参数可以调整：</p>
<ul>
<li>-u –url：要访问的 URL，这里只是主机和端口部分</li>
<li>-s –suffix：pprof profile 的路径，默认为 /debug/pprof/profile</li>
<li>–seconds：要执行 profiling 的时间长度，默认为 30s</li>
</ul>
<h3 id="安装-flamegraph"><a class="markdownIt-Anchor" href="#安装-flamegraph"></a> 安装 FlameGraph</h3>
<p>要生成火焰图，需要事先安装 FlameGraph工具，这个工具的安装很简单（需要perl环境支持），只要把对应的可执行文件加入到环境变量中即可。</p>
<ol>
<li>下载安装perl：<span class="exturl" data-url="aHR0cHM6Ly93d3cucGVybC5vcmcvZ2V0Lmh0bWw=">https://www.perl.org/get.html<i class="fa fa-external-link-alt"></i></span></li>
<li>下载FlameGraph：<code>git clone https://github.com/brendangregg/FlameGraph.git</code></li>
<li>将<code>FlameGraph</code>目录加入到操作系统的环境变量中。</li>
<li>Windows平台，需要把<code>go-torch/render/flamegraph.go</code>文件中的<code>GenerateFlameGraph</code><br />
按如下方式修改，然后在<code>go-torch</code>目录下执行<code>go install</code>即可。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GenerateFlameGraph runs the flamegraph script to generate a flame graph SVG. func GenerateFlameGraph(graphInput []byte, args ...string) ([]byte, error) &#123;</span></span><br><span class="line">flameGraph := findInPath(flameGraphScripts)</span><br><span class="line"><span class="keyword">if</span> flameGraph == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">nil</span>, errNoPerlScript</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> runtime.GOOS == <span class="string">&quot;windows&quot;</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> runScript(<span class="string">&quot;perl&quot;</span>, <span class="built_in">append</span>([]<span class="type">string</span>&#123;flameGraph&#125;, args...), graphInput)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> runScript(flameGraph, args, graphInput)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="压测工具wrk"><a class="markdownIt-Anchor" href="#压测工具wrk"></a> 压测工具wrk</h3>
<p>推荐使用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dnL3dyaw==">https://github.com/wg/wrk<i class="fa fa-external-link-alt"></i></span> 或 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FkanVzdC9nby13cms=">https://github.com/adjust/go-wrk<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="使用go-torch"><a class="markdownIt-Anchor" href="#使用go-torch"></a> 使用go-torch</h3>
<p>使用wrk进行压测:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go-wrk -n 50000 http://127.0.0.1:8080/book/list</span><br></pre></td></tr></table></figure>
<p>在上面压测进行的同时，打开另一个终端执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go-torch -u http://127.0.0.1:8080 -t 30</span><br></pre></td></tr></table></figure>
<p>30秒之后终端会出现如下提示：<code>Writing svg to torch.svg</code></p>
<p>然后我们使用浏览器打开<code>torch.svg</code>就能看到如下火焰图了。</p>
<p>火焰图的y轴表示cpu调用方法的先后，x轴表示在每个采样调用时间内，方法所占的时间百分比，越宽代表占据cpu时间越多。通过火焰图我们就可以更清楚的找出耗时长的函数调用，然后不断的修正代码，重新采样，不断优化。</p>
<p>此外还可以借助火焰图分析内存性能数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go-torch -inuse_space http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line">go-torch -inuse_objects http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line">go-torch -alloc_space http://127.0.0.1:8080/debug/pprof/heap</span><br><span class="line">go-torch -alloc_objects http://127.0.0.1:8080/debug/pprof/heap</span><br></pre></td></tr></table></figure>
<h2 id="pprof与性能测试结合"><a class="markdownIt-Anchor" href="#pprof与性能测试结合"></a> pprof与性能测试结合</h2>
<p><code>go test</code>命令有两个参数和 pprof 相关，它们分别指定生成的 CPU 和 Memory profiling 保存的文件：</p>
<ul>
<li>-cpuprofile：cpu profiling 数据要保存的文件地址</li>
<li>-memprofile：memory profiling 数据要报文的文件地址</li>
</ul>
<p>我们还可以选择将pprof与性能测试相结合，比如：</p>
<p>比如下面执行测试的同时，也会执行 CPU profiling，并把结果保存在 cpu.prof 文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench . -cpuprofile=cpu.prof</span><br></pre></td></tr></table></figure>
<p>比如下面执行测试的同时，也会执行 Mem profiling，并把结果保存在 cpu.prof 文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench . -memprofile=./mem.prof</span><br></pre></td></tr></table></figure>
<p>需要注意的是，Profiling 一般和性能测试一起使用，这个原因在前文也提到过，只有应用在负载高的情况下<br />
Profiling 才有意义。</p>
<h2 id="referce"><a class="markdownIt-Anchor" href="#referce"></a> referce</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubGl3ZW56aG91LmNvbS9wb3N0cy9Hby9wZXJmb3JtYW5jZV9vcHRpbWlzYXRpb24v">李文周-Go性能优化<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go异常处理</title>
    <url>/36452.html</url>
    <content><![CDATA[<p>在了解go异常处理的时候,有必要先了解为什么需要做异常处理,异常处理主要在哪几个方面,区分异常和错误的区别等等.</p>
<h2 id="qa"><a class="markdownIt-Anchor" href="#qa"></a> QA</h2>
<h3 id="为什么需要做异常处理"><a class="markdownIt-Anchor" href="#为什么需要做异常处理"></a> 为什么需要做异常处理?</h3>
<p>我个人认为有一下几点</p>
<ol>
<li>从程序设计的角度来看, 保证程序的鲁棒性,健壮性</li>
<li>从开发的角度来看, 快速定位问题,解决问题,预防问题</li>
</ol>
<h3 id="异常处理主要在哪几个方面"><a class="markdownIt-Anchor" href="#异常处理主要在哪几个方面"></a> 异常处理主要在哪几个方面</h3>
<p>异常处理主要在实践上可以区分为</p>
<ul>
<li>业务层面: 保证业务的稳定性, 逻辑性</li>
<li>基础库: 保证代码逻辑正常</li>
</ul>
<h3 id="异常与错误的区别"><a class="markdownIt-Anchor" href="#异常与错误的区别"></a> 异常与错误的区别</h3>
<p>编程语言中的异常和错误是两个相似但不相同的概念。异常和错误都可以引起程序执行错误而退出，他们属于程序没有考虑到的例外情况(<br />
exception)。</p>
<p>便于理解举个例子:</p>
<p>一个网络请求, 没有网络-错误</p>
<p>一个网络请求过程中,对方服务器处理超时(注意是对方服务器正常) - 异常</p>
<h2 id="error-和-exception"><a class="markdownIt-Anchor" href="#error-和-exception"></a> Error 和 Exception</h2>
<h3 id="go-error"><a class="markdownIt-Anchor" href="#go-error"></a> go error</h3>
<blockquote>
<p>go error 就是一个普通的接口, 普通的值.</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://golang.org/pkg/builtin/#error</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经常使用 <code>errors.New()</code> 来返回一个 <code>error</code> 对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://go.dev/src/errors/errors.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> errors</span><br><span class="line"></span><br><span class="line"><span class="comment">// New returns an error that formats as the given text.</span></span><br><span class="line"><span class="comment">// Each call to New returns a distinct error value even if the text is identical.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// errorString is a trivial implementation of error.</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line"> s <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>New() 返回的是 errorString对象的指针</p>
<p>为什么返回的是指针?</p>
<ul>
<li>避免创建的error的值一致</li>
</ul>
</blockquote>
<p>基础库中大量定义的error</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://go.dev/src/bufio/bufio.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"> ErrInvalidUnreadByte = errors.New(<span class="string">&quot;bufio: invalid use of UnreadByte&quot;</span>)</span><br><span class="line"> ErrInvalidUnreadRune = errors.New(<span class="string">&quot;bufio: invalid use of UnreadRune&quot;</span>)</span><br><span class="line"> ErrBufferFull        = errors.New(<span class="string">&quot;bufio: buffer full&quot;</span>)</span><br><span class="line"> ErrNegativeCount     = errors.New(<span class="string">&quot;bufio: negative count&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>tip: 在定义错误的时候带上包名,便于区分.<br />
如<code>ErrInvalidUnreadByte = errors.New(&quot;bufio: invalid use of UnreadByte&quot;)</code> 中的<code>bufio:</code></p>
<h3 id="error-vs-exception"><a class="markdownIt-Anchor" href="#error-vs-exception"></a> Error VS Exception</h3>
<p>各语言的演进历史</p>
<p>C: 但返回值, 入参通过传递指针作为入参, 返回int 表示成功还是失败, 以及如果失败的状态码是什么</p>
<p>C++: 引入了Exception,但无法知道被调用者抛出什么异常</p>
<p>Java: 引入了checked exception,方法的所有者必须申明, 调用者必须处理.</p>
<p>go: 支持多参数返回, 所以很容易在函数签名上实现了error interface的对象,交由调用者处理</p>
<blockquote>
<p>如果一个函数返回了 <code>(value,error)</code>, 不能对这个<code>value</code>做任何假设, 必须先判定<code>error</code></p>
</blockquote>
<p>补充: go中<code>panic</code>机制,意味着 fatal all, 不能假设调用者来解决<code>panic</code> 意味着代码down了</p>
<p><strong>记录单一清晰的错误, 并处理!!!</strong></p>
<p>注意二值性</p>
<h3 id="go特征"><a class="markdownIt-Anchor" href="#go特征"></a> go特征</h3>
<ul>
<li>简单</li>
<li>考虑失败而不是成功</li>
<li>没有隐藏的控制流</li>
<li>完全交给开发者来处理</li>
<li><strong>Error are values</strong></li>
</ul>
<p>对于真正的错误, 表示不可恢复的程序错误,例如索引越界, 不可恢复的环境问题, 堆栈溢出,才使用<code>panic</code><br />
,对于其他的错误情况,应该是情况我使用error来进行判定</p>
<h2 id="go-error-type"><a class="markdownIt-Anchor" href="#go-error-type"></a> go error type</h2>
<h3 id="sentinel-error"><a class="markdownIt-Anchor" href="#sentinel-error"></a> Sentinel Error</h3>
<p>预定义的特定错误,称之为 Sentinel Error. 这个名字起源于计算机编程中使用一个表示不可能进一步处理的做法.<br />
使用特定值来表示错误.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err == ErrorSomething &#123; ....&#125;</span><br><span class="line"><span class="comment">// 类似于 io.EOF 更底层的syscall.ENOENT</span></span><br></pre></td></tr></table></figure>
<p>使用 Sentinel Error 值是最不灵活的错误处理策略, 因为调用方法 必须使用<code>==</code></p>
<p>将结果与预先声明的值进行比较. 当需要提供更多的上下文时,就会出现一个因为反返回一个不同的错误将被破坏相等性检查.</p>
<p>例如一些有意义的<code>fmt.Errorf</code> 携带一些上下文,也会破坏调用者的<code>==</code> ,调用者将被迫查看<code>error.Error()</code><br />
方法的输出,以查看它是否与特定的字符串匹配</p>
<p><strong>tips:</strong></p>
<ul>
<li>不依赖检查<code>error.Error</code>的输出.</li>
</ul>
<blockquote>
<p>不应该以来检测<code>error.Error</code>的输出, Error方法存在于error接口主要用于方便开发者使用,而不是程序(<br />
编写测试会依赖这个返回). 这个输出的字符串用于记录日志,输出到stdout</p>
</blockquote>
<ul>
<li>Sentient errors 成为你API公共部分</li>
</ul>
<blockquote>
<p>如果公共函数或方法返回一个特定的值,那么该值必须是公共的,当然要有文档记录,这会增加API的表面积</p>
<p>如果API定义了以恶搞返回特定错误的<code>Interface</code> ,则该接口的所有实现都将被限制为仅返回该错误,<br />
即使他们可以提供更具有描述性错误</p>
<p>比如: io.Reader. 像io.Copy这类函数需要reader的实现者比如返回 io.EOF 来告诉调用者没有更多数据量,但这又不是错误</p>
</blockquote>
<ul>
<li>Sentient errors 在这个两个包之间创建依赖</li>
</ul>
<blockquote>
<p>Sentinel errors 最糟糕的问题是他们在两个包之间创建了源码依赖关系</p>
<p>例如检查错误是否等于io.EOF, 代码就必须要导入io包,<br />
虽然听起来似乎不那么糟糕,但想象一下,当项目中的许多包到处错误值时,存在耦合,项目中的其他包必须要导入这些错误值才能校验特定的错误条件</p>
</blockquote>
<p><strong>建议:尽可能的避免使用 sentinel errors</strong></p>
<h3 id="error-types"><a class="markdownIt-Anchor" href="#error-types"></a> Error Types</h3>
<p>Error type 实现了error接口自定义类型.例如<code>ExampleError</code> 类型记录了文件和行号以及展示发生了什么.<br />
如下代码所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ExampleError <span class="keyword">struct</span> &#123;</span><br><span class="line"> Msg      <span class="type">string</span></span><br><span class="line"> FileName <span class="type">string</span></span><br><span class="line"> Line     <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *ExampleError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> fmt.Sprintf(<span class="string">`%s:%d %s`</span>, e.FileName, e.Line, e.Msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> &amp;ExampleError&#123;<span class="string">`something happened`</span>, <span class="string">`example.go`</span>, <span class="number">33</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> err := test()</span><br><span class="line"> <span class="keyword">switch</span> err := err.(<span class="keyword">type</span>) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line"> <span class="comment">// call succeeded, nothing to do</span></span><br><span class="line"> <span class="keyword">case</span> *ExampleError:</span><br><span class="line">  fmt.Println(<span class="string">`Error occurred on call:`</span>, err)</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line">  <span class="comment">// unknown error</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与错误值相比, 错误类型的优点是他们能够包装底层错误以提供更多上下文.</p>
<p>官方实例 os.PathError:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line"> Op      <span class="type">string</span></span><br><span class="line"> Path    <span class="type">string</span></span><br><span class="line"> Err     <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用者要使用类型断言和switch,就要让自定义的error变为公共的, 这种模型会导致和调用者产生强耦合,从而导致API非常脆弱</p>
<p>结论: 尽量避免使用error types,或者说尽量避免其成为公共API的一部分</p>
<p>虽然错误类型比sentinel error更完善,提供更多的上下文信息, 但error types 共享error value许多相同的问题.</p>
<h3 id="opaque-errors"><a class="markdownIt-Anchor" href="#opaque-errors"></a> Opaque errors</h3>
<blockquote>
<p>不透明的错误处理</p>
</blockquote>
<p>直接返回错误而不假设其内容</p>
<ul>
<li>Assert errors for behaviour, not type</li>
</ul>
<blockquote>
<p>在某些情况下,这种二分错误处理方法是不够的, 例如与外界交互(网络), 需要调用方法查错误的性质,以确定重试是否合理.<br />
在这种情况下,可以使用断言错误实现了<strong>特定的行为</strong>.</p>
</blockquote>
<h2 id="handle-error"><a class="markdownIt-Anchor" href="#handle-error"></a> Handle Error</h2>
<h3 id="indented-flow-is-for-errors"><a class="markdownIt-Anchor" href="#indented-flow-is-for-errors"></a> Indented flow is for errors</h3>
<blockquote>
<p>缩进流用于错误</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无错误的正常流程代码应为一条直线</span></span><br><span class="line">f, err := os.Open(filePath)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do stuff</span></span><br></pre></td></tr></table></figure>
<h3 id="eliminate-error-handing-by-eliminating-errors"><a class="markdownIt-Anchor" href="#eliminate-error-handing-by-eliminating-errors"></a> Eliminate error handing by eliminating errors</h3>
<blockquote>
<p>通过消除错误来消除错误处理</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthenticateRequest</span><span class="params">(r *Requests)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    err := authenticate(r.user)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthenticateRequest</span><span class="params">(r *Requests)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> authenticate(r.user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="io-reader-example"><a class="markdownIt-Anchor" href="#io-reader-example"></a> io Reader Example</h4>
<p><strong>统计 <code>io.Reader</code> 读取内容的行数代码实例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountLines</span><span class="params">(r io.Reader)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> (</span><br><span class="line">  br    = bufio.NewReader(r)</span><br><span class="line">  lines <span class="type">int</span></span><br><span class="line">  err   <span class="type">error</span></span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">  _, err := br.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">  lines++</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> err != io.EOF &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> lines, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进-使用<code>bufio.scanner</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountLines1</span><span class="params">(r io.Reader)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> lines <span class="type">int</span></span><br><span class="line"> sc := bufio.NewScanner(r)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> sc.Scan() &#123;</span><br><span class="line">  lines++</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> lines, sc.Err()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="http-example"><a class="markdownIt-Anchor" href="#http-example"></a> Http Example</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line"> Key, Value <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">struct</span> &#123;</span><br><span class="line"> Code   <span class="type">int</span></span><br><span class="line"> Reason <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResponse</span><span class="params">(w io.Writer, s Status, headers []Header, body io.Reader)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"> _, err := fmt.Fprintf(w, <span class="string">&quot;HTTP/1.1 %d %s\r\n&quot;</span>, s.Code, s.Reason)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">  _, err := fmt.Fprintf(w, <span class="string">&quot;%s:%s\r\n&quot;</span>, h.Key, h.Value)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> _, err := fmt.Fprintf(w, <span class="string">&quot;\r\n&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> _, err = io.Copy(w, body)</span><br><span class="line"> <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;io&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line"> Key, Value <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">struct</span> &#123;</span><br><span class="line"> Code   <span class="type">int</span></span><br><span class="line"> Reason <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> errWrite <span class="keyword">struct</span> &#123;</span><br><span class="line"> io.Writer</span><br><span class="line"> err <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errWrite)</span></span> Write(buf []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line"> <span class="keyword">if</span> e.err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> n, e.err = e.Writer.Write(buf)</span><br><span class="line"> <span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResponse</span><span class="params">(w io.Writer, s Status, headers []Header, body io.Reader)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"> ew := &amp;errWrite&#123;Writer: w&#125;</span><br><span class="line"> fmt.Fprintf(ew, <span class="string">&quot;HTTP/1.1 %d %s\r\n&quot;</span>, s.Code, s.Reason)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">  fmt.Fprintf(ew, <span class="string">&quot;%s:%s\r\n&quot;</span>, h.Key, h.Value)</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Fprint(ew, <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line"> io.Copy(ew, body)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> ew.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="wrap-errors"><a class="markdownIt-Anchor" href="#wrap-errors"></a> Wrap errors</h3>
<p>you should only handle errors once. Handing an error means inspecting the error value, and make a<br />
single decision</p>
<p>日志与错误无关且对调试没有帮助的信息都应视为噪声, 应予以质疑. 记录的原因是应为某些东西失败了,而包含了答案</p>
<ul>
<li>错误要被日志记录</li>
<li>应用程序处理错误,保证百分百完整性</li>
<li>之后不在报当前错误</li>
</ul>
<p><span class="exturl" data-url="aHR0cDovL2dpdGh1Yi5jb20vcGtnL2Vycm9ycw==">pkg-errors<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9wa2cuZ28uZGV2L2Vycm9ycw==">dev-pkg-errors<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="pkg-errors"><a class="markdownIt-Anchor" href="#pkg-errors"></a> pkg-errors</h4>
<ul>
<li>在应用代码中,使用<code>pkg/errors</code>中的<code>errors.New</code> 或者 <code>error.Errorf</code>返回错误</li>
<li>如果调用其他包内的函数,通常简单的直接返回</li>
<li>如果与其他库协作, 考虑使用<code>pkg/errors</code>中的<code>errors.New</code> 或者 <code>error.Errorf</code>返回错误保持堆栈信息</li>
<li>直接放回错误, 而不是每个错误产生的地方打日志</li>
<li>在程序的顶部或者是工作的 goroutine顶部(请求入口), 使用<code>%+v</code>保存堆栈详情记录</li>
<li>使用<code>errors.Cause</code>获取<code>root error</code> 在进行sentinel error判定</li>
</ul>
<p><strong>小结</strong></p>
<p>Packages that are reusable across many projects only return root error values.</p>
<blockquote>
<p>选择 wrap error 是只有 applications 可以选择应用的策略。具有最高可重用性的包只能返回根错误值。此机制与<br />
Go 标准库中使用的相同**（<strong>kit</strong>库的<strong>sql.ErrNoRows</strong>）**。</p>
</blockquote>
<p>If the error is not going to be handled, wrap and return up the call stack.</p>
<blockquote>
<p>这是关于函数/方法调用返回的每个错误的基本问题。如果函数/方法不打算处理错误，那么用足够的上下文 wrap<br />
errors 并将其返回到调用堆栈中。例如，额外的上下文可以是使用的<strong>输入参数</strong>或失败的查询<strong>语句</strong><br />
。确定您记录的上下文是足够多还是太多的一个好方法是检查日志并验证它们在开发期间是否为您工作。</p>
</blockquote>
<p>Once an error is handled, it is not allowed to be passed up the call stack any longer.</p>
<blockquote></blockquote>
<p><em>一旦确定函数/方法将处理错误，错误就不再是错误。如果函数/方法仍然需要发出返回，则它不能返回错误值。它应该只返回零</em>*<br />
（比如降级处理中，你返回了降级数据，然后需要* <em>return nil</em>*）**。*</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go日志库之logrus</title>
    <url>/40727.html</url>
    <content><![CDATA[<p>无路是在开发、测试、亦或者调试有一好的日志，都会事半功倍。本节我来学习一下 go 语言明星日志库<br />
logrus。相关链接如下所示<br />
<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NpcnVwc2VuL2xvZ3J1cw==">github<i class="fa fa-external-link-alt"></i></span>: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NpcnVwc2VuL2xvZ3J1cw==">https://github.com/sirupsen/logrus<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly9wa2cuZ28uZGV2L2xvZ3VyLmRldi9hZGFwdGVyL2xvZ3J1cw==">pkg<i class="fa fa-external-link-alt"></i></span>： <span class="exturl" data-url="aHR0cHM6Ly9wa2cuZ28uZGV2L2xvZ3VyLmRldi9hZGFwdGVyL2xvZ3J1cw==">https://pkg.go.dev/logur.dev/adapter/logrus<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="logrus-简介"><a class="markdownIt-Anchor" href="#logrus-简介"></a> Logrus 简介</h2>
<p>Logrus 是 Go 语言结构化的 logger，与标准库 logger 完全 API 兼容。</p>
<p>它有以下特点：</p>
<ul>
<li>完全兼容标准日志库，拥有七种日志级别：<code>Trace</code>, <code>Debug</code>, <code>Info</code>, <code>Warning</code>, <code>Error</code>, <code>Fatal</code><br />
and <code>Panic</code>。</li>
<li>可选的日志输出格式，内置了两种日志格式 JSONFormater 和 TextFormatter，还可以自定义日志格式</li>
<li>Field 机制，通过 Filed 机制进行结构化的日志记录</li>
<li>可扩展的 Hook 机制，允许使用者通过 Hook 的方式将日志分发到任意地方，如本地文件系统，logstash，elasticsearch<br />
或者 mq 等，或者通过 Hook 定义日志内容和格式等</li>
<li>线程安全</li>
</ul>
<h2 id="logrus-的安装"><a class="markdownIt-Anchor" href="#logrus-的安装"></a> logrus 的安装</h2>
<p>logrus 安装也非常的简单，直接使用<code>go get</code>即可，安装命令如下所示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go get -v -u logur.dev/adapter/logrus</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中</p>
<p><code>-v</code> 为显示包安装信息</p>
<p><code>-u</code> 为安装最新版</p>
</blockquote>
<h2 id="logrus-的使用"><a class="markdownIt-Anchor" href="#logrus-的使用"></a> logrus 的使用</h2>
<p>介绍的包的使用，或许可以从几个维度，初始化、基本使用、骚操作及拓展。源于包使用，但不限于包使用</p>
<h3 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h3>
<p>logrus 相关于初始化的方面，一共有三种方式。基于<code>New()</code>、<code>Logger</code>、<code>不操作</code></p>
<h4 id="直接使用"><a class="markdownIt-Anchor" href="#直接使用"></a> 直接使用</h4>
<p>直接使用相对来说更便捷，更清亮。也是相对来说性能最高的，但不足也显而易言，那就是不能有更自由的操作了，如设置<br />
log Level、Hook、Format 等等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">logrus.Trace(<span class="string">&quot;trace msg&quot;</span>)</span><br><span class="line">logrus.Tracef(<span class="string">&quot;trace %v&quot;</span>, <span class="string">&quot;msg&quot;</span>)</span><br><span class="line"></span><br><span class="line">logrus.Debug(<span class="string">&quot;debug msg&quot;</span>)</span><br><span class="line">logrus.Debugf(<span class="string">&quot;debug %v&quot;</span>, <span class="string">&quot;msg&quot;</span>)</span><br><span class="line"></span><br><span class="line">logrus.Info(<span class="string">&quot;info msg&quot;</span>)</span><br><span class="line">logrus.Infof(<span class="string">&quot;info %v&quot;</span>, <span class="string">&quot;msg&quot;</span>)</span><br><span class="line"></span><br><span class="line">logrus.Warn(<span class="string">&quot;warn msg&quot;</span>)</span><br><span class="line">logrus.Warnf(<span class="string">&quot;warn %v&quot;</span>, <span class="string">&quot;msg&quot;</span>)</span><br><span class="line"></span><br><span class="line">logrus.Error(<span class="string">&quot;error msg&quot;</span>)</span><br><span class="line">logrus.Errorf(<span class="string">&quot;error %v&quot;</span>, <span class="string">&quot;msg&quot;</span>)</span><br><span class="line"></span><br><span class="line">logrus.Fatal(<span class="string">&quot;fatal msg&quot;</span>)</span><br><span class="line">logrus.Fatalf(<span class="string">&quot;fatal  %v&quot;</span>, <span class="string">&quot;msg&quot;</span>)</span><br><span class="line"></span><br><span class="line">logrus.Panic(<span class="string">&quot;panic msg&quot;</span>)</span><br><span class="line">logrus.Panicf(<span class="string">&quot;panic  %v&quot;</span>, <span class="string">&quot;msg&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当然根据默认的规则会忽略掉一些输出信息</p>
</blockquote>
<h4 id="使用-new-初始化于定制"><a class="markdownIt-Anchor" href="#使用-new-初始化于定制"></a> 使用 New 初始化于定制</h4>
<p>相对直接使用，使用 New 初始化，拥有更多的操作空间。</p>
<p>首先声明一个全局变量<code>log</code>，代码如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> log = logrus.New()</span><br></pre></td></tr></table></figure>
<p>常规情况下对于日志的定制主要在以下几个方面</p>
<ul>
<li>日志可见等级</li>
<li>日志格式配置</li>
<li>执行调用信息</li>
<li>日志另存为</li>
</ul>
<p><strong>日志可见等级</strong></p>
<blockquote>
<p>相关源码如下</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"> <span class="comment">// PanicLevel level, highest level of severity. Logs and then calls panic with the</span></span><br><span class="line"> <span class="comment">// message passed to Debug, Info, ...</span></span><br><span class="line"> PanicLevel Level = <span class="literal">iota</span></span><br><span class="line"> <span class="comment">// FatalLevel level. Logs and then calls `logger.Exit(1)`. It will exit even if the</span></span><br><span class="line"> <span class="comment">// logging level is set to Panic.</span></span><br><span class="line"> FatalLevel</span><br><span class="line"> <span class="comment">// ErrorLevel level. Logs. Used for errors that should definitely be noted.</span></span><br><span class="line"> <span class="comment">// Commonly used for hooks to send errors to an error tracking service.</span></span><br><span class="line"> ErrorLevel</span><br><span class="line"> <span class="comment">// WarnLevel level. Non-critical entries that deserve eyes.</span></span><br><span class="line"> WarnLevel</span><br><span class="line"> <span class="comment">// InfoLevel level. General operational entries about what&#x27;s going on inside the</span></span><br><span class="line"> <span class="comment">// application.</span></span><br><span class="line"> InfoLevel</span><br><span class="line"> <span class="comment">// DebugLevel level. Usually only enabled when debugging. Very verbose logging.</span></span><br><span class="line"> DebugLevel</span><br><span class="line"> <span class="comment">// TraceLevel level. Designates finer-grained informational events than the Debug.</span></span><br><span class="line"> TraceLevel</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>简而言之，登记越高（数字越大），显示的等级越全。如 6 显示所有的日志，0 只显示<code>Panic</code></p>
<p>设置可见等级之需要在<code>log.SetLevel()</code>*（log 为<code>var log = logrus.New()</code>而来）*设置整形(6-0)即可。</p>
<p><strong>日志格式化配置</strong></p>
<p>日志格式化主要分为文本格式化、JSON 格式化、自定义格式化或第三方插件格式化</p>
<p>如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// log.SetFormatter(&amp;logrus.TextFormatter&#123;</span></span><br><span class="line"><span class="comment">//  DisableColors: false,</span></span><br><span class="line"><span class="comment">//  FullTimestamp: true,</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="keyword">type</span> TextFormatter <span class="keyword">struct</span> &#123;</span><br><span class="line"> <span class="comment">// Set to true to bypass checking for a TTY before outputting colors.</span></span><br><span class="line"> ForceColors <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Force disabling colors.</span></span><br><span class="line"> DisableColors <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Force quoting of all values</span></span><br><span class="line"> ForceQuote <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// DisableQuote disables quoting for all values.</span></span><br><span class="line"> <span class="comment">// DisableQuote will have a lower priority than ForceQuote.</span></span><br><span class="line"> <span class="comment">// If both of them are set to true, quote will be forced on all values.</span></span><br><span class="line"> DisableQuote <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Override coloring based on CLICOLOR and CLICOLOR_FORCE. - https://bixense.com/clicolors/</span></span><br><span class="line"> EnvironmentOverrideColors <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Disable timestamp logging. useful when output is redirected to logging</span></span><br><span class="line"> <span class="comment">// system that already adds timestamps.</span></span><br><span class="line"> DisableTimestamp <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Enable logging the full timestamp when a TTY is attached instead of just</span></span><br><span class="line"> <span class="comment">// the time passed since beginning of execution.</span></span><br><span class="line"> FullTimestamp <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// TimestampFormat to use for display when a full timestamp is printed.</span></span><br><span class="line"> <span class="comment">// The format to use is the same than for time.Format or time.Parse from the standard</span></span><br><span class="line"> <span class="comment">// library.</span></span><br><span class="line"> <span class="comment">// The standard Library already provides a set of predefined format.</span></span><br><span class="line"> TimestampFormat <span class="type">string</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// The fields are sorted by default for a consistent output. For applications</span></span><br><span class="line"> <span class="comment">// that log extremely frequently and don&#x27;t use the JSON formatter this may not</span></span><br><span class="line"> <span class="comment">// be desired.</span></span><br><span class="line"> DisableSorting <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// The keys sorting function, when uninitialized it uses sort.Strings.</span></span><br><span class="line"> SortingFunc <span class="function"><span class="keyword">func</span><span class="params">([]<span class="type">string</span>)</span></span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Disables the truncation of the level text to 4 characters.</span></span><br><span class="line"> DisableLevelTruncation <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// PadLevelText Adds padding the level text so that all the levels output at the same length</span></span><br><span class="line"> <span class="comment">// PadLevelText is a superset of the DisableLevelTruncation option</span></span><br><span class="line"> PadLevelText <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// QuoteEmptyFields will wrap empty fields in quotes if true</span></span><br><span class="line"> QuoteEmptyFields <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Whether the logger&#x27;s out is to a terminal</span></span><br><span class="line"> isTerminal <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// FieldMap allows users to customize the names of keys for default fields.</span></span><br><span class="line"> <span class="comment">// As an example:</span></span><br><span class="line"> <span class="comment">// formatter := &amp;TextFormatter&#123;</span></span><br><span class="line"> <span class="comment">//     FieldMap: FieldMap&#123;</span></span><br><span class="line"> <span class="comment">//         FieldKeyTime:  &quot;@timestamp&quot;,</span></span><br><span class="line"> <span class="comment">//         FieldKeyLevel: &quot;@level&quot;,</span></span><br><span class="line"> <span class="comment">//         FieldKeyMsg:   &quot;@message&quot;&#125;&#125;</span></span><br><span class="line"> FieldMap FieldMap</span><br><span class="line"></span><br><span class="line"> <span class="comment">// CallerPrettyfier can be set by the user to modify the content</span></span><br><span class="line"> <span class="comment">// of the function and file keys in the data when ReportCaller is</span></span><br><span class="line"> <span class="comment">// activated. If any of the returned value is the empty string the</span></span><br><span class="line"> <span class="comment">// corresponding key will be removed from fields.</span></span><br><span class="line"> CallerPrettyfier <span class="function"><span class="keyword">func</span><span class="params">(*runtime.Frame)</span></span> (function <span class="type">string</span>, file <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"> terminalInitOnce sync.Once</span><br><span class="line"></span><br><span class="line"> <span class="comment">// The max length of the level text, generated dynamically on init</span></span><br><span class="line"> levelTextMaxLength <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>格式 JSON 化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// log.SetFormatter(&amp;logrus.JSONFormatter&#123;&#125;)</span></span><br><span class="line"><span class="keyword">type</span> JSONFormatter <span class="keyword">struct</span> &#123;</span><br><span class="line"> <span class="comment">// TimestampFormat sets the format used for marshaling timestamps.</span></span><br><span class="line"> <span class="comment">// The format to use is the same than for time.Format or time.Parse from the standard</span></span><br><span class="line"> <span class="comment">// library.</span></span><br><span class="line"> <span class="comment">// The standard Library already provides a set of predefined format.</span></span><br><span class="line"> TimestampFormat <span class="type">string</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// DisableTimestamp allows disabling automatic timestamps in output</span></span><br><span class="line"> DisableTimestamp <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// DisableHTMLEscape allows disabling html escaping in output</span></span><br><span class="line"> DisableHTMLEscape <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// DataKey allows users to put all the log entry parameters into a nested dictionary at a given key.</span></span><br><span class="line"> DataKey <span class="type">string</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// FieldMap allows users to customize the names of keys for default fields.</span></span><br><span class="line"> <span class="comment">// As an example:</span></span><br><span class="line"> <span class="comment">// formatter := &amp;JSONFormatter&#123;</span></span><br><span class="line"> <span class="comment">//    FieldMap: FieldMap&#123;</span></span><br><span class="line"> <span class="comment">//    FieldKeyTime:  &quot;@timestamp&quot;,</span></span><br><span class="line"> <span class="comment">//    FieldKeyLevel: &quot;@level&quot;,</span></span><br><span class="line"> <span class="comment">//    FieldKeyMsg:   &quot;@message&quot;,</span></span><br><span class="line"> <span class="comment">//    FieldKeyFunc:  &quot;@caller&quot;,</span></span><br><span class="line"> <span class="comment">//    &#125;,</span></span><br><span class="line"> <span class="comment">// &#125;</span></span><br><span class="line"> FieldMap FieldMap</span><br><span class="line"></span><br><span class="line"> <span class="comment">// CallerPrettyfier can be set by the user to modify the content</span></span><br><span class="line"> <span class="comment">// of the function and file keys in the json data when ReportCaller is</span></span><br><span class="line"> <span class="comment">// activated. If any of the returned value is the empty string the</span></span><br><span class="line"> <span class="comment">// corresponding key will be removed from json fields.</span></span><br><span class="line"> CallerPrettyfier <span class="function"><span class="keyword">func</span><span class="params">(*runtime.Frame)</span></span> (function <span class="type">string</span>, file <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// PrettyPrint will indent all json logs</span></span><br><span class="line"> PrettyPrint <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NpcnVwc2VuL2xvZ3J1cyNmb3JtYXR0ZXJz">https://github.com/sirupsen/logrus#formatters<i class="fa fa-external-link-alt"></i></span></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1guu60plma8j60l00740to02.jpg" alt="image-20210926173746478" /></p>
<p><strong>写入文件夹 SetOutput</strong></p>
<p>O_RDONLY：只读模式(read-only)</p>
<p>O_WRONLY：只写模式(write-only)</p>
<p>O_RDWR：读写模式(read-write)</p>
<p>O_APPEND：追加模式(append)</p>
<p>O_CREATE：文件不存在就创建(create a new file if none exists.)</p>
<p>O_EXCL：与 O_CREATE 一起用，构成一个新建文件的功能，它要求文件必须不存在(used with O_CREATE, file must<br />
not exist)</p>
<p>O_SYNC：同步方式打开，即不使用缓存，直接写入硬盘 O_TRUNC：打开并清空文件</p>
<p>示例代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"> logDirPath := <span class="string">`log/`</span> + time.Now().Format(<span class="string">&quot;2006-01-02&quot;</span>)</span><br><span class="line"> logFilePath := filepath.Join(logDirPath, time.Now().Format(<span class="string">`15`</span>))</span><br><span class="line"> os.MkdirAll(logFilePath, <span class="number">0775</span>)</span><br><span class="line"> file, err := os.OpenFile(logFilePath + <span class="string">`/`</span> + time.Now().Format(<span class="string">`04`</span>) + <span class="string">`.log`</span>, os.O_RDWR|os.O_CREATE|os.O_APPEND, <span class="number">0644</span>)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Error(<span class="string">`open file error`</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> log.SetOutput(file)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>log.SetReportCaller()</code>: 显示调用关系，开启这个模式会增加性能开销(成本在 20% 到 40% 之间)。</p>
<p><strong>Hook</strong></p>
<p>logrus 通过实现 <code>Hook</code>接口扩展 hook 机制,可以根据需求将日志分发到任意的存储介质, 比如 es, mq<br />
或者监控报警系统,及时获取异常日志。可以说极大的提高了日志系统的可扩展性。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Hook <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// 定义哪些等级的日志触发 hook 机制</span></span><br><span class="line"> Levels() []Level</span><br><span class="line">  <span class="comment">// hook 触发器的具体执行操作</span></span><br><span class="line">  <span class="comment">// 如果 Fire 执行失败,错误日志会重定向到标准错误流</span></span><br><span class="line"> Fire(*Entry) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体 Hook 示列可参考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NpcnVwc2VuL2xvZ3J1cy9ibG9iL21hc3Rlci9ob29rcy9zeXNsb2cvUkVBRE1FLm1k">https://github.com/sirupsen/logrus/blob/master/hooks/syslog/README.md<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="referer"><a class="markdownIt-Anchor" href="#referer"></a> referer</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmd6aGV6aGlsdTAwMS9hcnRpY2xlL2RldGFpbHMvOTUzNjM3ODk=">https://blog.csdn.net/wangzhezhilu001/article/details/95363789<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NzZXJmL2FydGljbGUvZGV0YWlscy8xMDMzODgxMzM=">https://blog.csdn.net/sserf/article/details/103388133<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言中的方法</title>
    <url>/42522.html</url>
    <content><![CDATA[<h2 id="什么是方法"><a class="markdownIt-Anchor" href="#什么是方法"></a> 什么是方法</h2>
<p>​ 方法一般是面向对象编程(OOP)的一个特性，在cpp中方法对应一个类对象的成员函数，是关联到具体对象上的虚表中的。但是Go语言的方法却是<br />
<strong>关联到类型</strong>的，这样可以在编译阶段完成方法的静态绑定。</p>
<p>​<br />
一个面向对象的程序会用方法来表达其属性对应的操作，这样使用这个对象的用户就不需要直接去操作对象，而是借助方法来做这些事情。面向对象编程(<br />
OOP)<br />
进入主流开发领域一般认为是从cpp开始的，cpp就是在兼容C语言的基础之上支持了class等面向对象的特性。然后Java编程则号称是纯粹的面向对象语言，因为Java中函数是不能独立存在的，每个函数都必然是属于某个类的。</p>
<p>面向对象编程更多的只是一种思想，很多号称支持面向对象编程的语言只是将经常用到的特性内置到语言中了而已。</p>
<h2 id="方法的声明"><a class="markdownIt-Anchor" href="#方法的声明"></a> 方法的声明</h2>
<p>Go语言中的<code>方法（Method）</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者（Receiver）</code><br />
，其中方法接收器（receiver）参数、函数 / 方法参数，以及返回值变量对应的作用域范围，都是函数 /<br />
方法体对应的显式代码块。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型(值类型或指针类型)</span></span>) 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而非<code>self</code>、<code>this</code><br />
之类的命名。例如，<code>Person</code>类型的接收者变量应该命名为 <code>p</code>，<code>Connector</code>类型的接收者变量应该命名为<code>c</code><br />
等。</li>
<li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li>
<li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li>
</ul>
<p>一个简单的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> people <span class="keyword">struct</span> &#123;</span><br><span class="line"> name             <span class="type">string</span></span><br><span class="line"> age              <span class="type">uint16</span></span><br><span class="line"> height           <span class="type">float32</span></span><br><span class="line"> weight           <span class="type">float32</span></span><br><span class="line"> hometown         <span class="type">string</span></span><br><span class="line"> currentResidence <span class="type">string</span></span><br><span class="line"> lifeMotto        <span class="type">string</span></span><br><span class="line"> Hobby            <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line"> Job              <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPeople</span><span class="params">(name <span class="type">string</span>, age <span class="type">uint16</span>, height <span class="type">float32</span>, weight <span class="type">float32</span>, hometown <span class="type">string</span>, currentResidence <span class="type">string</span>, lifeMotto <span class="type">string</span>, hobby <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, job <span class="type">string</span>)</span></span> *people &#123;</span><br><span class="line"> <span class="keyword">return</span> &amp;people&#123;</span><br><span class="line">  name:             name,</span><br><span class="line">  age:              age,</span><br><span class="line">  height:           height,</span><br><span class="line">  weight:           weight,</span><br><span class="line">  hometown:         hometown,</span><br><span class="line">  currentResidence: currentResidence,</span><br><span class="line">  lifeMotto:        lifeMotto,</span><br><span class="line">  Hobby:            hobby,</span><br><span class="line">  Job:              job,</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> people := newPeople(</span><br><span class="line">  <span class="string">`Payne`</span>,</span><br><span class="line">  <span class="number">23</span>,</span><br><span class="line">  <span class="number">1.767</span>,</span><br><span class="line">  <span class="number">75</span>,</span><br><span class="line">  <span class="string">`HuNan`</span>,</span><br><span class="line">  <span class="string">`ShangHai`</span>,</span><br><span class="line">  <span class="string">`stay hungry,stay foolish`</span>,</span><br><span class="line">  <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">   <span class="string">`first`</span>: <span class="string">`reading`</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">`data engineer`</span>,</span><br><span class="line"> )</span><br><span class="line"> fmt.Println(people)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接收者"><a class="markdownIt-Anchor" href="#接收者"></a> 接收者</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法(值类型接受者)</span></span><br><span class="line"><span class="comment">// 当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。</span></span><br><span class="line"><span class="comment">//  在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p people)</span></span> introduce()  &#123;</span><br><span class="line"> fmt.Println(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法(指针类型接受者)</span></span><br><span class="line"><span class="comment">//  指针类型的接收者由一个结构体的指针组成，由于指针的特性，</span></span><br><span class="line"><span class="comment">//  调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。</span></span><br><span class="line"><span class="comment">//  这种方式就十分接近于其他语言中面向对象中的this或者self。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *people)</span></span> introduceMe()  &#123;</span><br><span class="line"> fmt.Println(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="什么时候应该使用指针类型接收者"><a class="markdownIt-Anchor" href="#什么时候应该使用指针类型接收者"></a> 什么时候应该使用指针类型接收者</h3>
<ol>
<li>需要修改接收者中的值</li>
<li>接收者是拷贝代价比较大的大对象</li>
<li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li>
</ol>
<h2 id="tips"><a class="markdownIt-Anchor" href="#tips"></a> Tips</h2>
<h3 id="构造函数优化"><a class="markdownIt-Anchor" href="#构造函数优化"></a> 构造函数优化</h3>
<p>在上面的例子中发现过多的参数，这个写法乍看之下是没啥问题的，但是一旦 people<br />
结构内部的字段发生了变化，增加或者减少了，那么这个初始化函数 newPeople 就怎么看都觉的别扭了。</p>
<p>​ 如果参数继续增加呢？那么所有调用了这个 newPeople 方法的地方也都需要进行修改，且按照代码整洁的逻辑，参数多于<br />
5 个，这个函数就很难使用了。而且，如果这 5 个参数都是可有可无的参数，就是有的参数可以不填写，</p>
<p>有默认值，比如 age 这个字段，即使我们不填写，在后续的业务逻辑中可能也没有很多影响，那么我在实际调用<br />
newPeople 的时候，age 这个字段还需要传递 0 值, 以及hometown为空值，那么构造方法newPeople如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">people := newPeople(</span><br><span class="line">  <span class="string">`Payne`</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">1.767</span>,</span><br><span class="line">  <span class="number">75</span>,</span><br><span class="line">  <span class="string">``</span>,</span><br><span class="line">  <span class="string">`ShangHai`</span>,</span><br><span class="line">  <span class="string">`stay hungry,stay foolish`</span>,</span><br><span class="line">  <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">   <span class="string">`first`</span>: <span class="string">`reading`</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">`data engineer`</span>,</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>
<p>乍看这行代码，你可能会以为我创建了一个 people，它的年龄为<br />
0以及hometown为空值，但是实际上我们是希望表达这里使用了一个“缺省值”，这种代码的语义逻辑就不对了。那改怎么如何呢？</p>
<h3 id="请使用options写法"><a class="markdownIt-Anchor" href="#请使用options写法"></a> 请使用options写法</h3>
<p>options 为可选参数，以上面的代码为例，我们只需<code>name</code>, <code>age</code>,<code>job</code> 为必选，其他为可选参数的，那此时可以这么写，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type people struct &#123;</span><br><span class="line"> name             string</span><br><span class="line"> age              uint16</span><br><span class="line"> height           float32</span><br><span class="line"> weight           float32</span><br><span class="line"> hometown         string</span><br><span class="line"> currentResidence string</span><br><span class="line"> lifeMotto        string</span><br><span class="line"> Hobby            map[string]string</span><br><span class="line"> Job              string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// peopleOptions 可选参数</span><br><span class="line">type peopleOptions func(p *people)</span><br><span class="line"></span><br><span class="line">func withHeight(height float32) peopleOptions &#123;</span><br><span class="line"> return func(p *people) &#123;</span><br><span class="line">  p.height = height</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func withWeight(weight float32) peopleOptions &#123;</span><br><span class="line"> return func(p *people) &#123;</span><br><span class="line">  p.weight = weight</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func withHometown(hometown string) peopleOptions &#123;</span><br><span class="line"> return func(p *people) &#123;</span><br><span class="line">  p.hometown = hometown</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func withCurrentResidence(currentResidence string) peopleOptions &#123;</span><br><span class="line"> return func(p *people) &#123;</span><br><span class="line">  p.currentResidence = currentResidence</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func withLifeMotto(lifeMotto string) peopleOptions &#123;</span><br><span class="line"> return func(p *people) &#123;</span><br><span class="line">  p.lifeMotto = lifeMotto</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func withHobby(Hobby map[string]string) peopleOptions &#123;</span><br><span class="line"> return func(p *people) &#123;</span><br><span class="line">  p.Hobby = Hobby</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 构造函数</span><br><span class="line">// 必选: name, age, job</span><br><span class="line">func newPeopleOptions(name string, age uint16, job string, options ...peopleOptions) *people &#123;</span><br><span class="line"> p := &amp;people&#123;</span><br><span class="line">  name: name,</span><br><span class="line">  age:  age,</span><br><span class="line">  Job:  job,</span><br><span class="line"> &#125;</span><br><span class="line"> for _, option := range options &#123;</span><br><span class="line">  option(p)</span><br><span class="line"> &#125;</span><br><span class="line"> return p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//方法(值类型接受者)</span><br><span class="line">func (p people) introduce() &#123;</span><br><span class="line"> fmt.Println(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//方法(指针类型接受者)</span><br><span class="line">func (p *people) introduceMe() &#123;</span><br><span class="line"> fmt.Println(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"> people := newPeopleOptions(</span><br><span class="line">  `Payne`,</span><br><span class="line">  21,</span><br><span class="line">  `data engineer`,</span><br><span class="line">  withHeight(1.767),</span><br><span class="line"> )</span><br><span class="line"> people.introduce()</span><br><span class="line"> //people.introduceMe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中with代表可选的， 如果我们后续 Foo 多了一个可变属性，那么我们只需要多一个 WithXXX 的方法就可以了，而<br />
NewFoo 函数不需要任何变化，调用方只要在指定这个可变属性的地方增加 WithXXX 就可以了，扩展性非常好。</p>
<h2 id="源码赏析"><a class="markdownIt-Anchor" href="#源码赏析"></a> 源码赏析</h2>
<p>以下是go爬虫框架<code>colly</code>的初始化部分，大致结构如下</p>
<ul>
<li>
<p>可选函数类型：<code>CollectorOption func(*Collector)</code></p>
</li>
<li>
<p>采集器结构体：<code>Collector</code></p>
</li>
<li>
<p>初始化方法：<code>Init</code></p>
</li>
<li>
<p>虚拟环境处理方法：<code>parseSettingsFromEnv</code></p>
</li>
<li>
<p>构造函数:<code>NewCollector</code></p>
</li>
</ul>
<blockquote>
<p>gocolly/colly.go</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A CollectorOption sets an option on a Collector.</span></span><br><span class="line"><span class="keyword">type</span> CollectorOption <span class="function"><span class="keyword">func</span><span class="params">(*Collector)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Collector provides the scraper instance for a scraping job</span></span><br><span class="line"><span class="keyword">type</span> Collector <span class="keyword">struct</span> &#123;</span><br><span class="line"> <span class="comment">// UserAgent is the User-Agent string used by HTTP requests</span></span><br><span class="line"> UserAgent <span class="type">string</span></span><br><span class="line"> <span class="comment">// MaxDepth limits the recursion depth of visited URLs.</span></span><br><span class="line"> <span class="comment">// Set it to 0 for infinite recursion (default).</span></span><br><span class="line"> MaxDepth <span class="type">int</span></span><br><span class="line"> <span class="comment">// AllowedDomains is a domain whitelist.</span></span><br><span class="line"> <span class="comment">// Leave it blank to allow any domains to be visited</span></span><br><span class="line"> AllowedDomains []<span class="type">string</span></span><br><span class="line"> <span class="comment">// DisallowedDomains is a domain blacklist.</span></span><br><span class="line"> DisallowedDomains []<span class="type">string</span></span><br><span class="line"> <span class="comment">// DisallowedURLFilters is a list of regular expressions which restricts</span></span><br><span class="line"> <span class="comment">// visiting URLs. If any of the rules matches to a URL the</span></span><br><span class="line"> <span class="comment">// request will be stopped. DisallowedURLFilters will</span></span><br><span class="line"> <span class="comment">// be evaluated before URLFilters</span></span><br><span class="line"> <span class="comment">// Leave it blank to allow any URLs to be visited</span></span><br><span class="line"> DisallowedURLFilters []*regexp.Regexp</span><br><span class="line"> <span class="comment">// URLFilters is a list of regular expressions which restricts</span></span><br><span class="line"> <span class="comment">// visiting URLs. If any of the rules matches to a URL the</span></span><br><span class="line"> <span class="comment">// request won&#x27;t be stopped. DisallowedURLFilters will</span></span><br><span class="line"> <span class="comment">// be evaluated before URLFilters</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Leave it blank to allow any URLs to be visited</span></span><br><span class="line"> URLFilters []*regexp.Regexp</span><br><span class="line"></span><br><span class="line"> <span class="comment">// AllowURLRevisit allows multiple downloads of the same URL</span></span><br><span class="line"> AllowURLRevisit <span class="type">bool</span></span><br><span class="line"> <span class="comment">// MaxBodySize is the limit of the retrieved response body in bytes.</span></span><br><span class="line"> <span class="comment">// 0 means unlimited.</span></span><br><span class="line"> <span class="comment">// The default value for MaxBodySize is 10MB (10 * 1024 * 1024 bytes).</span></span><br><span class="line"> MaxBodySize <span class="type">int</span></span><br><span class="line"> <span class="comment">// CacheDir specifies a location where GET requests are cached as files.</span></span><br><span class="line"> <span class="comment">// When it&#x27;s not defined, caching is disabled.</span></span><br><span class="line"> CacheDir <span class="type">string</span></span><br><span class="line"> <span class="comment">// IgnoreRobotsTxt allows the Collector to ignore any restrictions set by</span></span><br><span class="line"> <span class="comment">// the target host&#x27;s robots.txt file.  See http://www.robotstxt.org/ for more</span></span><br><span class="line"> <span class="comment">// information.</span></span><br><span class="line"> IgnoreRobotsTxt <span class="type">bool</span></span><br><span class="line"> <span class="comment">// Async turns on asynchronous network communication. Use Collector.Wait() to</span></span><br><span class="line"> <span class="comment">// be sure all requests have been finished.</span></span><br><span class="line"> Async <span class="type">bool</span></span><br><span class="line"> <span class="comment">// ParseHTTPErrorResponse allows parsing HTTP responses with non 2xx status codes.</span></span><br><span class="line"> <span class="comment">// By default, Colly parses only successful HTTP responses. Set ParseHTTPErrorResponse</span></span><br><span class="line"> <span class="comment">// to true to enable it.</span></span><br><span class="line"> ParseHTTPErrorResponse <span class="type">bool</span></span><br><span class="line"> <span class="comment">// ID is the unique identifier of a collector</span></span><br><span class="line"> ID <span class="type">uint32</span></span><br><span class="line"> <span class="comment">// DetectCharset can enable character encoding detection for non-utf8 response bodies</span></span><br><span class="line"> <span class="comment">// without explicit charset declaration. This feature uses https://github.com/saintfish/chardet</span></span><br><span class="line"> DetectCharset <span class="type">bool</span></span><br><span class="line"> <span class="comment">// RedirectHandler allows control on how a redirect will be managed</span></span><br><span class="line"> <span class="comment">// use c.SetRedirectHandler to set this value</span></span><br><span class="line"> redirectHandler <span class="function"><span class="keyword">func</span><span class="params">(req *http.Request, via []*http.Request)</span></span> <span class="type">error</span></span><br><span class="line"> <span class="comment">// CheckHead performs a HEAD request before every GET to pre-validate the response</span></span><br><span class="line"> CheckHead <span class="type">bool</span></span><br><span class="line"> <span class="comment">// TraceHTTP enables capturing and reporting request performance for crawler tuning.</span></span><br><span class="line"> <span class="comment">// When set to true, the Response.Trace will be filled in with an HTTPTrace object.</span></span><br><span class="line"> TraceHTTP <span class="type">bool</span></span><br><span class="line"> <span class="comment">// Context is the context that will be used for HTTP requests. You can set this</span></span><br><span class="line"> <span class="comment">// to support clean cancellation of scraping.</span></span><br><span class="line"> Context context.Context</span><br><span class="line"></span><br><span class="line"> store                    storage.Storage</span><br><span class="line"> debugger                 debug.Debugger</span><br><span class="line"> robotsMap                <span class="keyword">map</span>[<span class="type">string</span>]*robotstxt.RobotsData</span><br><span class="line"> htmlCallbacks            []*htmlCallbackContainer</span><br><span class="line"> xmlCallbacks             []*xmlCallbackContainer</span><br><span class="line"> requestCallbacks         []RequestCallback</span><br><span class="line"> responseCallbacks        []ResponseCallback</span><br><span class="line"> responseHeadersCallbacks []ResponseHeadersCallback</span><br><span class="line"> errorCallbacks           []ErrorCallback</span><br><span class="line"> scrapedCallbacks         []ScrapedCallback</span><br><span class="line"> requestCount             <span class="type">uint32</span></span><br><span class="line"> responseCount            <span class="type">uint32</span></span><br><span class="line"> backend                  *httpBackend</span><br><span class="line"> wg                       *sync.WaitGroup</span><br><span class="line"> lock                     *sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init initializes the Collector&#x27;s private variables and sets default</span></span><br><span class="line"><span class="comment">// configuration for the Collector</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Collector)</span></span> Init() &#123;</span><br><span class="line"> c.UserAgent = <span class="string">&quot;colly - https://github.com/gocolly/colly/v2&quot;</span></span><br><span class="line"> c.MaxDepth = <span class="number">0</span></span><br><span class="line"> c.store = &amp;storage.InMemoryStorage&#123;&#125;</span><br><span class="line"> c.store.Init()</span><br><span class="line"> c.MaxBodySize = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line"> c.backend = &amp;httpBackend&#123;&#125;</span><br><span class="line"> jar, _ := cookiejar.New(<span class="literal">nil</span>)</span><br><span class="line"> c.backend.Init(jar)</span><br><span class="line"> c.backend.Client.CheckRedirect = c.checkRedirectFunc()</span><br><span class="line"> c.wg = &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line"> c.lock = &amp;sync.RWMutex&#123;&#125;</span><br><span class="line"> c.robotsMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*robotstxt.RobotsData)</span><br><span class="line"> c.IgnoreRobotsTxt = <span class="literal">true</span></span><br><span class="line"> c.ID = atomic.AddUint32(&amp;collectorCounter, <span class="number">1</span>)</span><br><span class="line"> c.TraceHTTP = <span class="literal">false</span></span><br><span class="line"> c.Context = context.Background()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewCollector creates a new Collector instance with default configuration</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCollector</span><span class="params">(options ...CollectorOption)</span></span> *Collector &#123;</span><br><span class="line"> c := &amp;Collector&#123;&#125;</span><br><span class="line"> c.Init()</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> _, f := <span class="keyword">range</span> options &#123;</span><br><span class="line">  f(c)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> c.parseSettingsFromEnv()</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Collector)</span></span> parseSettingsFromEnv() &#123;</span><br><span class="line"> <span class="keyword">for</span> _, e := <span class="keyword">range</span> os.Environ() &#123;</span><br><span class="line">  <span class="keyword">if</span> !strings.HasPrefix(e, <span class="string">&quot;COLLY_&quot;</span>) &#123;</span><br><span class="line">   <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  pair := strings.SplitN(e[<span class="number">6</span>:], <span class="string">&quot;=&quot;</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">if</span> f, ok := envMap[pair[<span class="number">0</span>]]; ok &#123;</span><br><span class="line">   f(c, pair[<span class="number">1</span>])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   log.Println(<span class="string">&quot;Unknown environment variable:&quot;</span>, pair[<span class="number">0</span>])</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言相关资料</title>
    <url>/40038.html</url>
    <content><![CDATA[<h2 id="book"><a class="markdownIt-Anchor" href="#book"></a> Book</h2>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby93aWtpL0Jvb2tz">官方wiki<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h3 id="经典书籍"><a class="markdownIt-Anchor" href="#经典书籍"></a> 经典书籍</h3>
<p>《The Way To Go》- Go 语言百科全书</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9nbzEwMS5vcmcvYXJ0aWNsZS8xMDEuaHRtbA==">《Go 101》- Go 语言参考手册<i class="fa fa-external-link-alt"></i></span></p>
<p>《Go 语言学习笔记》- Go 源码剖析与实现原理探索</p>
<p>《Go 语言实战》- 实战系列经典之作，紧扣 Go 语言的精华</p>
<p>《Go 程序设计语言》- 人手一本的 Go 语言“圣经”</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoYWkyMDEwL2dvLWFzdC1ib29r">《Go语法树入门——开启自制编程语言和编译器之旅》<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9nb2NvbXBpbGVyLnNoaXpoei5tZS8=">《golang编译器代码解析》<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="值得一读"><a class="markdownIt-Anchor" href="#值得一读"></a> 值得一读</h3>
<p>《go语言精进之路》(全两册)—白明</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaGFpMjAxMC5jbi9hZHZhbmNlZC1nby1wcm9ncmFtbWluZy1ib29rLw==">《Go语言高级编程》<i class="fa fa-external-link-alt"></i></span></p>
<p>《go语言底层原理剖析》</p>
<p>《go语言并发之道》</p>
<h3 id="在线图书"><a class="markdownIt-Anchor" href="#在线图书"></a> 在线图书</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9kcmF2ZW5lc3MubWUvZ29sYW5nLw==">《go语言设计与实现》<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcuZGVzaWduL3VuZGVyLXRoZS1ob29kLw==">《go语言原本》<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9nb2NvbXBpbGVyLnNoaXpoei5tZS8=">《Golang 编译器》<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9nZWVrdHV0dS5jb20vcG9zdC9oaWdoLXBlcmZvcm1hbmNlLWdvLmh0bWw=">《Go 语言高性能编程》<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9xdWlpLmdpdGJvb2suaW8vbGVhcm4tZ28td2l0aC10ZXN0cw==">《learn-go-with-tests》<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jaGFpMjAxMC5jbi9nbzItYm9vay8=">《go2》<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ncmV5aXJlbGFuZC5naXRib29rLmlvL2FsZ29yaXRobS1wYXR0ZXJuLw==">《algorithm-pattern》<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudG9wZ29lci5jb20v">go语言地鼠文档<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudG9wZ29lci5jbi8=">地鼠文档<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>仅个人见解</p>
</blockquote>
<h2 id="文档"><a class="markdownIt-Anchor" href="#文档"></a> 文档</h2>
<p>官方文档：项目主线分支（master）上最新开发版本的文档：</p>
<ul>
<li>
<p><span class="exturl" data-url="aHR0cHM6Ly90aXAuZ29sYW5nLm9yZy8=">The Go Programming Language (golang.org)<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li>
<p><span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYv">The Go Programming Language<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYvcmVmL3NwZWM=">Go语言规范 The Go Programming Language Specification - The Go Programming Language<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYvcmVmL21vZA==">Go mod参考文档 Go Modules Reference - The Go Programming Language<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYvZG9jL2NtZA==">Go语言命令参考手册 Command Documentation - The Go Programming Language<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYvZG9jL2VmZmVjdGl2ZV9nbw==">Effective Go  Effective Go - The Go Programming Language<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9wa2cuZ28uZGV2">Go语言标准库参考手册<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYvZG9jL2ZhcQ==">go 常见问答 Frequently Asked Questions (FAQ) - The Go Programming Language<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="相关博客"><a class="markdownIt-Anchor" href="#相关博客"></a> 相关博客</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYvYmxvZy8=">Go语言官方博客 The Go Blog - The Go Programming Language<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jb21tYW5kY2VudGVyLmJsb2dzcG90LmNvbS8=">Go 语言之父 Rob Pike 的个人博客 command center<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9yZXNlYXJjaC5zd3RjaC5jb20v">Go 核心团队技术负责人 Russ Cox 的个人博客<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jb21tYW9rLnh5ei8=">Go 核心开发者 Josh Bleecher Snyder 的个人博客 Don’t Panic (commaok.xyz)<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9yYWt5bGwub3JnLw==">Go 核心团队前成员 Jaana Dogan 的个人博客<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kYXZlLmNoZW5leS5uZXQv">Go 鼓吹者 Dave Cheney 的个人博客<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYXJkYW5sYWJzLmNvbS9ibG9n">Go 语言培训机构 Ardan Labs 的博客<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9nb2NuLnZpcC8=">GoCN社区<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9nb2xhbmcuZGVzaWduLw==">Go 语言百科全书 The golang.design Initiative<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9nby1yZXZpZXcuZ29vZ2xlc291cmNlLmNvbS8=">Go 项目的代码 review 站点<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="技术演讲"><a class="markdownIt-Anchor" href="#技术演讲"></a> 技术演讲</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYvdGFsa3Mv">Go 官方的技术演讲归档 talks - The Go Programming Language<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vYy9Hb3BoZXJBY2FkZW15L3BsYXlsaXN0cw==">GopherCon 技术大会<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vYy9Hb3BoZXJDb25FdXJvcGUvcGxheWxpc3Rz">GopherCon Europe 技术大会 GopherCon Europe - YouTube<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vYy9Hb3BoZXJDb25VSy9wbGF5bGlzdHM=">GopherConUK 技术大会 GopherCon UK - YouTube<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vY2hhbm5lbC9VQ01FdnpvSFRJZFpJN0lNOExvUmJMc1EvcGxheWxpc3Rz">GoLab 技术大会 GoLab conference - YouTube<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vdXNlci9mb3NkZW10YWxrcy9wbGF5bGlzdHM=">Go Devroom@FOSDEM  FOSDEM - YouTube<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNDM2MzYxMjg3">GopherChina技术大会<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMzI2NzQ5NjYx">Go夜读<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RlbmNlbnQvc2VjZ3VpZGU=">代码安全指南<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zdHVkeWdvbGFuZy5jb20vcGtnZG9j">Go语言标准库文档中文版<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudG9wZ29lci5jb20vJUU1JUJDJTgwJUU2JUJBJTkwL2dvJUU1JUFEJUE2JUU0JUI5JUEwJUU3JUJBJUJGJUU4JUI3JUFGJUU1JTlCJUJFLmh0bWw=">go学习线路图 · Go语言中文文档 (topgoer.com)<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9nb2J5ZXhhbXBsZS5jb20v">gobyexample<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ViZXItZ28vZ3VpZGUvYmxvYi9tYXN0ZXIvc3R5bGUubWQ=">Uber代码规范<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3h4and4Yy91YmVyX2dvX2d1aWRlX2Nu">Uber Go 语言编码规范中文版<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2F2ZWxpbm8vYXdlc29tZS1nbw==">awesome-go<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21vYnkvbW9ieQ==">Moby Project - a collaborative project for the container ecosystem to assemble container-based systems<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="设计模式"><a class="markdownIt-Anchor" href="#设计模式"></a> 设计模式</h3>
<p>《Go设计模式》：</p>
<p>-<span class="exturl" data-url="aHR0cDovL3RtcnRzLmNvbS9nby1wYXR0ZXJucy8=">Go Patterns · GitBook (tmrts.com)<i class="fa fa-external-link-alt"></i></span></p>
<p>-<span class="exturl" data-url="aHR0cHM6Ly93d3cudG9wZ29lci5jbi9kb2NzL2dvbGFuZy1kZXNpZ24tcGF0dGVybg==">golang-design-pattern<i class="fa fa-external-link-alt"></i></span></p>
<p>设计模式Golang实现：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Nlbmdob28vZ29sYW5nLWRlc2lnbi1wYXR0ZXJu">设计模式 Golang实现－《研磨设计模式》<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9ib29rcy5oYWxmcm9zdC5jb20vbGVldGNvZGUv">leetcode cookbook<i class="fa fa-external-link-alt"></i></span></p>
<p>algorithms：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly90aGUtYWxnb3JpdGhtcy5jb20v">https://the-algorithms.com/<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RoZUFsZ29yaXRobXM=">https://github.com/TheAlgorithms<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9zZWFyY2gvcmVwb3NpdG9yaWVzP3E9bGFuZ3VhZ2U6Z28mYW1wO3Blcl9wYWdlPTEwMA==">Github Top 100<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ppdWp1YW4vZ28tY29sbGVjdGlvbg==">go-collection<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="referer"><a class="markdownIt-Anchor" href="#referer"></a> referer</h2>
<p>Go语言第一课 — 白明</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0j4gn2m15j21hc0t3die.jpg" alt="image-20220323002441627" /></p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes NFS实践</title>
    <url>/60916.html</url>
    <content><![CDATA[<h2 id="nfs实践"><a class="markdownIt-Anchor" href="#nfs实践"></a> NFS实践</h2>
<h3 id="安装nfs"><a class="markdownIt-Anchor" href="#安装nfs"></a> 安装NFS</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载nfs相关软件（全成员）</span></span><br><span class="line">yum install -y nfs-common nfs-utils rpcbind</span><br><span class="line"><span class="comment"># 创建NFS共享文件夹，以及授权（需要root）</span></span><br><span class="line"><span class="built_in">mkdir</span> /nfs &amp;&amp; <span class="built_in">chmod</span> 766 /nfs &amp;&amp; <span class="built_in">chown</span> nfsnobody /nfs/</span><br><span class="line"><span class="comment"># 声明共享文件权限（NFS主服务器）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/nfs *(rw,no_root_squash,no_all_squash,sync)&quot;</span> &gt;&gt; /etc/exports</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">exportfs -r</span><br><span class="line">systemctl restart rpcbind &amp;&amp; systemctl restart nfs &amp;&amp; systemctl status rpcbind &amp;&amp; systemctl status nfs</span><br></pre></td></tr></table></figure>
<h4 id="验证"><a class="markdownIt-Anchor" href="#验证"></a> 验证</h4>
<blockquote>
<p>IP: 主机地址</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看共享目录</span></span><br><span class="line">showmount -e IP</span><br><span class="line"><span class="built_in">mkdir</span> /test</span><br><span class="line"><span class="comment"># 将本机目录（test）挂载至目标目录（nfs）</span></span><br><span class="line">mount -t nfs IP:/nfs /test</span><br><span class="line"><span class="built_in">cd</span> /test</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;asdsadsa&quot;</span> &gt;&gt; a.txt</span><br><span class="line"><span class="built_in">cd</span> /</span><br><span class="line">umount /test &amp;&amp; <span class="built_in">rm</span> -rf /test</span><br></pre></td></tr></table></figure>
<h3 id="部署pv"><a class="markdownIt-Anchor" href="#部署pv"></a> 部署PV</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfspv-master</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">volumeMode:</span> <span class="string">Filesystem</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/nfs</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.27</span> <span class="comment"># 节点ip</span></span><br></pre></td></tr></table></figure>
<h3 id="pvc"><a class="markdownIt-Anchor" href="#pvc"></a> PVC</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">wangyanglinux/myapp:v2</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">www</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">  <span class="attr">volumeClaimTemplates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">metadata:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">www</span></span><br><span class="line">      <span class="attr">spec:</span></span><br><span class="line">        <span class="attr">accessModes:</span> [ <span class="string">&quot;ReadWriteOnce&quot;</span> ]</span><br><span class="line">        <span class="attr">storageClassName:</span> <span class="string">&quot;nfs&quot;</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure>
<h3 id="验证-2"><a class="markdownIt-Anchor" href="#验证-2"></a> 验证</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get pv</span><br><span class="line">kubectl desc</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gu3v3oji9fj62090u047b02.jpg" alt="image-20210903233505574" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 192.168.0.27 /nfs</span><br><span class="line">echo &quot;asds&quot;  &gt; index.html</span><br><span class="line">kubectl get pod -o wid</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gu3vd2jo46j61vk04uace02.jpg" alt="image-20210903234426686" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl 10.244.1.53</span><br><span class="line"><span class="comment"># asds</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kubernetes</category>
        <category>NFS</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>js调试小笔记</title>
    <url>/63578.html</url>
    <content><![CDATA[<h2 id="操作键"><a class="markdownIt-Anchor" href="#操作键"></a> 操作键</h2>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1guna6e3v4wj60bm01imwy02.jpg" alt="image-20210920184244435" /></p>
<p><strong>resume/pause script execution</strong>: 恢复/暂停脚本执行</p>
<p><strong>step over next function call</strong>: 跨过，实际表现是不遇到函数时，执行下一步。遇到函数时，不进入函数直接执行下一步。</p>
<p><strong>step into next function call</strong>: 跨入，实际表现是不遇到函数时，执行下一步。遇到到函数时，进入函数执行上下文。</p>
<p><strong>step out of current function</strong>:跳出当前函数</p>
<p><strong>deactivate breakpoints</strong>:停用断点</p>
<p><strong>don‘t pause on exceptions</strong>:不暂停异常捕获</p>
<h2 id="watch"><a class="markdownIt-Anchor" href="#watch"></a> Watch</h2>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1guna86ju6bj6042016gld02.jpg" alt="image-20210920184426027" /></p>
<p>变量监听</p>
<p>定位到关键值时加入Watch中实现实时监听，可根据监听内容变化预估此变化。</p>
<h2 id="breakpoints"><a class="markdownIt-Anchor" href="#breakpoints"></a> BreakPoints</h2>
<p>所有断点列表，且自动按照执行顺序排序</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1guna98mrchj60jm082mxp02.jpg" alt="image-20210920184528622" /></p>
<h2 id="scope"><a class="markdownIt-Anchor" href="#scope"></a> Scope</h2>
<p>该范围内所有变量的值</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gunafyd9hhj60kc0mc40502.jpg" alt="image-20210920185155365" /></p>
<h2 id="调用栈"><a class="markdownIt-Anchor" href="#调用栈"></a> 调用栈</h2>
<p><strong>一个 procedure（通常译作“过程”）吃进来一些参数，干一些事情，再吐出去一个返回值（或者什么也不吐）</strong></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gunaocua19j60co02m3ye02.jpg" alt="image-20210920185959949" /></p>
<h2 id="xhrfetch-breakpints"><a class="markdownIt-Anchor" href="#xhrfetch-breakpints"></a> XHR/fetch Breakpints</h2>
<p>XHR/fetch Breakpints：请求断点（拦截），当发生符合要求的将触发定位到请求发送前一步</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gunaonikx8j60kw03kaa902.jpg" alt="image-20210920190017589" /></p>
<h2 id="dom-break-points"><a class="markdownIt-Anchor" href="#dom-break-points"></a> DOM Break points</h2>
<p>当符合条件时触发定位到BOM</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gunau1dh9bj60ay038q2y02.jpg" alt="image-20210920190528135" /></p>
<h2 id="global-listeners"><a class="markdownIt-Anchor" href="#global-listeners"></a> Global Listeners</h2>
<p>全局时间监听，包含所有时间，如点击、滑动等</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gunavas820j60g80ect9a02.jpg" alt="image-20210920190640937" /></p>
<h2 id="event-listener-break-points"><a class="markdownIt-Anchor" href="#event-listener-break-points"></a> Event Listener Break points</h2>
<p>事件侦听器断点，监听所有事件与断点实现。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gunawqe43pj60gw0nyjsk02.jpg" alt="image-20210920190803044" /></p>
<h3 id="预览几种不同的breakpoint类型"><a class="markdownIt-Anchor" href="#预览几种不同的breakpoint类型"></a> 预览几种不同的breakpoint类型</h3>
<p>众人皆知的breakpoint类型是line-of-code。但是line-of-code型breakpoint有的时候没法设置（*<br />
<em>其实就是没法在代码左边点出一个绿点来</em>*<br />
），或者如果你正在使用一个大型的代码库。通过学习如何和何时使用这些不同类型的breakpoint debug，会大大节约你的时间。</p>
<table>
<thead>
<tr>
<th>断点类型</th>
<th>当你想Pause的时候使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Line-of-code</td>
<td>代码具体某一行（<strong>其实就是没法在代码左边点出一个绿点来</strong>）</td>
</tr>
<tr>
<td>Conditional line-of-code</td>
<td>代码具体某一行，但是只有在一些条件为true时</td>
</tr>
<tr>
<td>DOM</td>
<td>在改变或者移除一个DOM节点或者它的DOM子节点时</td>
</tr>
<tr>
<td>XHR</td>
<td>当一个XHR URL包含一个string pattern</td>
</tr>
<tr>
<td>Event Listener</td>
<td>在运行了某个特定事件后的代码上，例如click事件触发</td>
</tr>
<tr>
<td>Exception</td>
<td>在抛出了一个caught或者uncaught的exception时</td>
</tr>
<tr>
<td>Function</td>
<td>当一个函数被调用时</td>
</tr>
</tbody>
</table>
<h2 id="this指向"><a class="markdownIt-Anchor" href="#this指向"></a> this指向</h2>
<p>全局作用域 this = window</p>
<p>局部作用域 this = 调用者</p>
<p>类的方法里面 this = 类自己</p>
<h2 id="referer"><a class="markdownIt-Anchor" href="#referer"></a> referer</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hjX3pob3UvYXJ0aWNsZS9kZXRhaWxzLzEwNjI2OTIzOQ==">https://blog.csdn.net/xc_zhou/article/details/106269239<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3MzI0OTgzL2FydGljbGUvZGV0YWlscy8xMDI0NjcxOTk=">https://blog.csdn.net/qq_27324983/article/details/102467199<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>JS</category>
        <category>逆向</category>
        <category>sec</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes搭建dashboard</title>
    <url>/59122.html</url>
    <content><![CDATA[<p>当部署完Kubernetes集群之后，为了便于管理Web UI或许是一种新型且快捷的部署方式。本节将以部署工具helm搭建Kubernetes<br />
Dashboard。以及拍坑</p>
<p>helm相关文档：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9oZWxtLnNoL3poL2RvY3Mv">helm<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25jZi5pby9yZXBvcnRzL2NuY2YtaGVsbS1wcm9qZWN0LWpvdXJuZXktcmVwb3J0Lw==">CNCF Helm 项目过程报告<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="helm初始化"><a class="markdownIt-Anchor" href="#helm初始化"></a> helm初始化</h2>
<p>在这里推荐使用Kubernetes dashboard官方的仓库。在helm初始化完成后可使用如下命令进行helm repo初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add repo</span></span><br><span class="line">helm repo add kubernetes-dashboard https://kubernetes.github.io/dashboard/</span><br></pre></td></tr></table></figure>
<p>为避免加入的repo非最新，可使用如下命令进行更新</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm repo update</span><br></pre></td></tr></table></figure>
<p>效果如下所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gtz2xowgsrj61di0880wn02.jpg" alt="image-20210830201834557" /></p>
<h3 id="helm安装kubernetes-dashboard"><a class="markdownIt-Anchor" href="#helm安装kubernetes-dashboard"></a> helm安装Kubernetes dashboard</h3>
<p>笔者建议使用新的namespace</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create namespace</span></span><br><span class="line">Kubernetes create ns monitor</span><br><span class="line"><span class="comment"># helm install kubernetes dashboard</span></span><br><span class="line">helm install kubernetes-dashboard kubernetes-dashboard/kubernetes-dashboard -n monitor</span><br></pre></td></tr></table></figure>
<p>输出如下所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gtz47x30vvj627u0k2aj602.jpg" alt="image-20210830210303410" /></p>
<p>等待部署完成，查看如下图所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gtz67m63w5j60yc08sdi602.jpg" alt="image-20210830221157231" /></p>
<h4 id="修改端口暴露类型"><a class="markdownIt-Anchor" href="#修改端口暴露类型"></a> 修改端口暴露类型</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl edit -n monitor service kubernetes-dashboard</span><br></pre></td></tr></table></figure>
<p>将type：ClusterIP修改为NodePort类型暴露端口，如下所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gtz6dpjcmjj60v20r844s02.jpg" alt="image-20210830221749368" /></p>
<p>修改完成后，就可以获得暴露的端口啦，如下</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gtz6cvz8lmj610809iacr02.jpg" alt="image-20210830221701538" /></p>
<blockquote>
<p>若在云服务器上请开启对应端口，笔者这里为32623</p>
</blockquote>
<p>此时访问服务器ip+端口，即可进入登陆页面。如下图所示</p>
<blockquote>
<ol>
<li>
<p>必须为<span class="exturl" data-url="aHR0cHM6Ly9pcDpwb3J0">https://ip:port<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li>
<p>建议使用火狐浏览器</p>
</li>
</ol>
</blockquote>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gtz6inwfgxj624m0mqq6802.jpg" alt="image-20210830222235151" /></p>
<p>至此部署部分已经完成</p>
<h2 id="获取token与授权访问"><a class="markdownIt-Anchor" href="#获取token与授权访问"></a> 获取token与授权访问</h2>
<h3 id="获取token"><a class="markdownIt-Anchor" href="#获取token"></a> 获取token</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看token名称</span><br><span class="line">kubectl get secrets -n monitor | grep kubernetes-dashboard-token</span><br><span class="line"># 查看token详情</span><br><span class="line">kubectl describe secrets -n monitor | grep kubernetes-dashboard-token-你自己的后缀名</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gtz6lrrzogj611001o74u02.jpg" alt="image-20210830222534534" /></p>
<h3 id="授权"><a class="markdownIt-Anchor" href="#授权"></a> 授权</h3>
<p>此时我们刚进去界面，发现什么资源都显示不了，是因为dashboard默认的<code>serviceaccount</code>并没有权限，所以我们需要给予它授权。</p>
<blockquote>
<p><strong>注意</strong>：这里直接赋予的是超级管理员权限，如果需要更加细颗粒度的授权，请参照官方的说明</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2t1YmVybmV0ZXMvZGFzaGJvYXJkL2Jsb2IvbWFzdGVyL2RvY3MvdXNlci9hY2Nlc3MtY29udHJvbC9SRUFETUUubWQ=">https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/README.md<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gtz6nfrdq3j62060oktgn02.jpg" alt="image-20210830222709899" /></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">monitor</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">monitor</span></span><br></pre></td></tr></table></figure>
<p>将以上的yaml文件copy到master服务器上创建即可,当然若您也是使用的monitor 的namespace可直接使用如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/KubernetersDeployExample/script/main/dashboard/authorization.yaml</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes部署sekiro集群</title>
    <url>/16741.html</url>
    <content><![CDATA[<h2 id="sekiro简介"><a class="markdownIt-Anchor" href="#sekiro简介"></a> Sekiro简介</h2>
<blockquote>
<p>开抄！以下来自sekiro官方文档 <span class="exturl" data-url="aHR0cHM6Ly9zZWtpcm8udmlyamFyLmNvbS9zZWtpcm8tZG9jL2luZGV4Lmh0bWw=">https://sekiro.virjar.com/sekiro-doc/index.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>SEKIRO 是一个android下的API服务暴露框架，可以用在app逆向、app数据抓取、android群控等场景。同时Sekiro也是目前公开方案唯一稳定的JSRPC框架。</p>
<ol>
<li>对网络环境要求低，sekiro 使用长链接管理服务（可以理解为每个APP内置内网穿透功能），使得 Android<br />
手机可以分布于全国各地，甚至全球各地。手机掺合在普通用户群体，方便实现反抓突破，更加适合获取下沉数据。</li>
<li>不依赖 hook 框架，就曾经的 Hermes 系统来说，和 xposed 框架深度集成，在当今 hook<br />
框架遍地开花的环境下，框架无法方便迁移。所以在 Sekiro 的设计中，只提供了 RPC 功能了。</li>
<li>纯异步调用，在 Hermes 和其他曾经出现过的框架中，基本都是同步调用。虽然说签名计算可以达到上百<br />
QPS，但是如果用来做业务方法调用的话，由于调用过程穿透到目标 app<br />
的服务器，会有大量请求占用线程。系统吞吐存在上线(<br />
hermes 系统达到 2000QPS 的时候，基本无法横向扩容和性能优化了)。但是 Sekiro 全程使用<br />
NIO，理论上其吞吐可以把资源占满。</li>
<li>client 实时状态，在 Hermes 系统我使用 http 进行调用转发，通过手机上报心跳感知手机存活状态。心跳时间至少<br />
20s，这导致服务器调度层面对手机在线状态感知不及时，请求过大的时候大量转发调用由于 client 掉线<br />
timeout。在 Sekiro 长链接管理下，手机掉线可以实时感知。不再出现由于框架层面机制导致 timeout</li>
<li></li>
</ol>
<p>群控能力，一台Sekiro服务器可以轻松管理上万个手机节点或者浏览器节点，且保证他们的RPC调用没有资源干扰。你不需要关心这些节点的物理网络拓扑结构。不需要管理这些手机什么时候上线和下线。如果你是用naohttpd方案，你可能需要为手机提供一个内网环境，然后配置一套内网穿透。一个内网一个机房，你需要管理哪些机房有哪些手机。当你的手机达到一百台之后，对应的物理网络环境就将会比较复杂，且需要开发一个独立系统管理了。如果你使用的时FridaRPC方案，你可能还需要为每几个手机配置一台电脑。然后电脑再配置内网穿透，这让大批量机器管理的拓扑结构更加复杂。这也会导致手机天然集中在一个机房，存在IP、基站、Wi-Fi、定位等环境本身对抗。</p>
<ol start="6">
<li>多语言扩展能力。Sekiro的客户端lib库，目前已知存在Android(java)、IOS(objective-c)、js(浏览器)<br />
、易语言等多种客户端（不是所有的都是Sekiro官方实现）。Sekiro本身提供一个二进制协议（非常简单的二进制协议规则），只要你的语言支持socket(<br />
应该所有语言都支持)<br />
，那么你就可以轻松为Sekiro实现对应客户端。接入Sekiro，享受Sekiro本身统一机群管理的好处。在Sekiro的roadmap中，我们会基于frida<br />
Socket实现frida的客户端，完成Frida分析阶段的代码平滑迁移到Sekiro的生产环境。尽请期待</li>
<li></li>
</ol>
<p>客户端接入异步友好。Sekiro全程异步IO设计，这一方面保证整个框架的性能，另一方面更加贴近一般的app或者浏览器本身的异步环境。如果rpc调用用在签名计算上面，大部分签名仅仅是一个算法或者一个so的函数调用。那么同步调用就可以达到非常高的并发。但是如果你想通过rpc调用业务的API（如直接根据参数调用最网络框架的上层API，把参数编解码、加解密都，逻辑拼装都看作黑盒）。此时普通同步调用将会非常麻烦和非常消耗客户端性能。异步转同步的lock信号量机制、同步线程等待导致的线程资源占用和处理任务挤压等风险。FridaRPC支持异步，但是由于他的跨语言问题，并不好去构造异步的callback。目前nanohttpd或者FridaPRC，均大部分情况用在简单的签名函数计算上面。而Sekiro大部分用在上游业务逻辑的直接RPC场景上。</p>
<ol start="8">
<li>API友好（仅对AndroidAPI），我们为了编程方面和代码优雅，封装了一套开箱即用的API，基于SekiroAPI开发需求将会是非常快乐的。</li>
</ol>
<p>简而言之呢，Sekiro是一个virjar开发的一款强大稳定的rpc服务暴露框架</p>
<h2 id="kubernetes上部署"><a class="markdownIt-Anchor" href="#kubernetes上部署"></a> Kubernetes上部署</h2>
<p>首先，我们需要有一个 Kubernetes 集群，可以自己搭建，也可以使用 Minikube 或者用阿里云、腾讯云、Azure<br />
等服务商直接提供的 Kubernetes 服务。 另外我们需要能使用 <code>kubectl</code> 连接和控制当前的集群，</p>
<ul>
<li>
<p>搭建 Kubernetes<br />
集群：<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3Mvc2V0dXAvcHJvZHVjdGlvbi1lbnZpcm9ubWVudC90b29scy9rdWJlYWRtL2NyZWF0ZS1jbHVzdGVyLWt1YmVhZG0v">https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li>
<p>Minikube：<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvdHV0b3JpYWxzL2hlbGxvLW1pbmlrdWJlLw==">https://kubernetes.io/docs/tutorials/hello-minikube/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li>
<p>基于Kubeadmin实现Kubernetes 集群搭建： <span class="exturl" data-url="aHR0cHM6Ly9wYXluZXd1LmNvbS8xODg2NC5odG1s">https://paynewu.com/18864.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<p>上面的内容准备就绪之后，就可以开始 Kubernetes 搭建。搭建完成之后就开始部署Sekiro吧</p>
<p>在Kubernetes中容器环境部署那就离不开image，Sekiro的image为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">registry.cn-beijing.aliyuncs.com/virjar/sekiro-server:latest</span><br></pre></td></tr></table></figure>
<blockquote>
<p>无论是Docker、还是podman、亦或者是其他的容器。现成的景象就用这个</p>
</blockquote>
<p>Kubernetes部署服务的常用的有三种形式</p>
<ul>
<li>kubectl cli部署</li>
<li>基于YAML文件格式部署</li>
<li>基于JSON文件格式部署</li>
</ul>
<h3 id="部署服务"><a class="markdownIt-Anchor" href="#部署服务"></a> 部署服务</h3>
<p>首先为此创建一个名为<code>crawleruntil</code> 的 namespace</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create namespace crawleruntil</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1434e1lltj20ws02mjro.jpg" alt="image-20220410033511352" /></p>
<blockquote>
<p>因为我已经有<code>crawleruntil</code>这个namespace以及其他的服务，为了方便就不删了在演示了，将图中的sekiro即可</p>
</blockquote>
<p>至此已经完成四分之一了，接下来进行Sekiro的部署，yaml文件如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sekiro</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">crawleruntil</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">sekiro</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">sekiro</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">sekiro</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sekiro</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">registry.cn-beijing.aliyuncs.com/virjar/sekiro-server:latest</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">5601</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">5602</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">5603</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">&quot;1Gi&quot;</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;0.5&quot;</span></span><br><span class="line">            <span class="attr">limits:</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">&quot;2Gi&quot;</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sekiro</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">crawleruntil</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">sekiro</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">5601</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">nio</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">5601</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">5602</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">server</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">5602</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">5603</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">ws</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">5603</span></span><br></pre></td></tr></table></figure>
<p>将其复制到服务器上，然后使用命令<code>kubectl apply -f 此文件名</code>，当然<code>kubectl create -f 此文件名</code>也可以大差不差。</p>
<p>稍等几秒甚至是一两分钟，看看</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h143bhpa1bj21h80h8tc1.jpg" alt="image-20220410034203246" /></p>
<p>确认使用<code>kubectl get all -n crawleruntil</code> 中显示的内容中有STATUS均为<code>Running</code>, 代表就部署成功了</p>
<p>当然这还并不足以使服务可用，因为sekiro它运行在容器内的网络，暂时还无法在本地、或者远程反问服务。此时就需要将服务暴露出去。以便于使用</p>
<h3 id="服务暴露"><a class="markdownIt-Anchor" href="#服务暴露"></a> 服务暴露</h3>
<p>暴露服务有NotePort, LoadBalance，<br />
此外externalIPs也可以使各类service对外提供服务。当然最推荐的还是<code>Ingress</code>, 关于Ingress是什么感兴趣的请自行搜索。</p>
<p>首先先需要部署ingress collector，请搜索。部署完成后可采用如下YAML进行ingress服务暴露</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sekiro-ingress</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">crawleruntil</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">sekiro</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">server</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/asyncInvoke</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">sekiro</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">nio</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/websocket</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">sekiro</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">ws</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此时访问你外网地址, 就会发现。（80需要有权限打开访问哦）</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h143oadhvcj20u809wt90.jpg" alt="image-20220410035421312" /></p>
<p>ok，部署完成了！ sekiro就可以食用啦。</p>
<p>以上明显还不够，主要是两个问题</p>
<p>没有身份验证： 那么就意味着任何人都可以调用你的这个接口，岂不是…</p>
<p>某些网页端的JS有证书，这样部署的sekiro无法使用此场景，需要为之加上tls证书。</p>
<h3 id="ingress-网页添加认证"><a class="markdownIt-Anchor" href="#ingress-网页添加认证"></a> Ingress 网页添加认证</h3>
<p>想偷懒的可以直接使用这三条命令。认证令牌创建一步到位</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install httpd</span><br><span class="line"><span class="built_in">echo</span> `<span class="built_in">echo</span> $(hostname) | <span class="built_in">base64</span>` | htpasswd -ic ./auth  `<span class="built_in">echo</span> $(<span class="built_in">echo</span> $(hostname) | <span class="built_in">base64</span>)`</span><br><span class="line">kubectl create secret generic basic-auth-secret --from-file auth --namespace=crawleruntil </span><br></pre></td></tr></table></figure>
<p>我这里默认采用机器的hostname base64后的字符为用户名与密码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">echo</span> $(hostname) | <span class="built_in">base64</span>` ：密码改这里面的内容</span><br><span class="line">./auth  `<span class="built_in">echo</span> $(<span class="built_in">echo</span> $(hostname) | <span class="built_in">base64</span>)`： 用户名这里面的内容</span><br></pre></td></tr></table></figure>
<p>然后直接使用<code>kubectl create secret generic basic-auth-secret --from-file auth --namespace=crawleruntil</code></p>
<p>创建一个名为<code>basic-auth-secret</code> <code>generic</code>类型的secret。</p>
<blockquote>
<p>注意需要将namespace 指定为crawleruntil，实现同意命名空间</p>
</blockquote>
<p>将它挂到Ingress上去，</p>
<p>Ingress YAML如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sekiro-ingress</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">crawleruntil</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line">    <span class="attr">traefik.ingress.kubernetes.io/auth-type:</span> <span class="string">&quot;basic&quot;</span></span><br><span class="line">    <span class="attr">traefik.ingress.kubernetes.io/auth-secret:</span> <span class="string">&quot;basic-auth-secret&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">sekiro</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">server</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/asyncInvoke</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">sekiro</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">nio</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/websocket</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">sekiro</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">ws</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打开一个<strong>无痕浏览器</strong>，此时你就可以发现</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h14440ycgvj21l80mkgmj.jpg" alt="image-20220410040928885" /></p>
<p>这玩意需要认证了，cool～</p>
<h3 id="域名解析与tls网络证书"><a class="markdownIt-Anchor" href="#域名解析与tls网络证书"></a> 域名解析与TLS网络证书</h3>
<p>域名：首先你得需要有域名，这个去阿里云、腾讯云、华为云还是等等买就是咯。</p>
<p>证书：将你申请点TLS证书下载到本地，具体请搜索</p>
<p>创建证书的secret, 如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret tls tls-sekiro-paynewu-com --key sekiro.paynewu.com.key --cert=sekiro.paynewu.com_bundle.crt --namespace crawleruntil</span><br></pre></td></tr></table></figure>
<p>最终的Ingress YAML如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sekiro-ingress</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">crawleruntil</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line">    <span class="attr">traefik.ingress.kubernetes.io/auth-type:</span> <span class="string">&quot;basic&quot;</span></span><br><span class="line">    <span class="attr">traefik.ingress.kubernetes.io/auth-secret:</span> <span class="string">&quot;basic-auth-secret&quot;</span></span><br><span class="line">    <span class="attr">traefik.frontend.rule.type:</span> <span class="string">PathPrefixStrip</span></span><br><span class="line">    <span class="attr">traefik.ingress.kubernetes.io/redirect-entry-point:</span> <span class="string">https</span></span><br><span class="line">    <span class="attr">traefik.backend.circuitbreaker:</span> <span class="string">&quot;NetworkErrorRatio() &gt; 0.5&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">sekiro.paynewu.com</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">tls-sekiro-paynewu-com</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">sekiro.paynewu.com</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">sekiro</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">server</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/asyncInvoke</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">sekiro</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">nio</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/websocket</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">sekiro</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">name:</span> <span class="string">ws</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根路径</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h144c38mn9j20p80ce3yz.jpg" alt="image-20220410041714078" /></p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h144qrtmxlj214009edgc.jpg" alt="image-20220410043120299" /></p>
<h3 id="注入验证"><a class="markdownIt-Anchor" href="#注入验证"></a> 注入验证</h3>
<p>将 <span class="exturl" data-url="aHR0cHM6Ly9zZWtpcm8udmlyamFyLmNvbS9zZWtpcm8tZG9jL2Fzc2V0cy9zZWtpcm9fd2ViX2NsaWVudC5qcw==">https://sekiro.virjar.com/sekiro-doc/assets/sekiro_web_client.js<i class="fa fa-external-link-alt"></i></span> 中的文件复制到控制台，执行</p>
<p>然后在控制台调用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var client = new SekiroClient(&quot;wss://域名/websocket?group=ws-group-test&amp;clientId=&quot; + guid());</span><br></pre></td></tr></table></figure>
<p>校验</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h144u1tj0yj217w07egm8.jpg" alt="image-20220410043429585" /></p>
<p>完成～</p>
<h2 id="referer"><a class="markdownIt-Anchor" href="#referer"></a> Referer</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Zpcmphci9zZWtpcm8=">Sekiro GitHub<i class="fa fa-external-link-alt"></i></span></p>
<p>其他部署都可以看看邱佬的</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvbTBNXy12bGFxRnVWdWZFWDZYT3dSUQ==">linunx/win10搭建sekiro服务+web/app注入实战<i class="fa fa-external-link-alt"></i></span>（上）</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvWTFLQXMzX1BITG1WMTZCakRQeUJaUQ==">linunx/win10搭建sekiro服务+web/app注入实战<i class="fa fa-external-link-alt"></i></span>（下）</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvWEtBM2RrX3M1RXFXT1RlcDFTdkk0Zw==">sekiro服务器配置nginx反向代理升级为https<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2MudHJhZWZpay5pby90cmFlZmlrL3YxLjcvdXNlci1ndWlkZS9rdWJlcm5ldGVzLyNiYXNpYy1hdXRoZW50aWNhdGlvbg==">basic-authentication<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2MudHJhZWZpay5pby90cmFlZmlrL3YxLjcvY29uZmlndXJhdGlvbi9iYWNrZW5kcy9rdWJlcm5ldGVzLyNzZWN1cml0eS1oZWFkZXJzLWFubm90YXRpb25z">security-headers-annotations<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>sekiro</category>
        <category>rpc</category>
        <category>spider</category>
        <category>kuberenets</category>
      </categories>
      <tags>
        <tag>sekiro</tag>
      </tags>
  </entry>
  <entry>
    <title>mac配置php环境</title>
    <url>/11461.html</url>
    <content><![CDATA[<h2 id="安装php"><a class="markdownIt-Anchor" href="#安装php"></a> 安装php</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># homebrew 安装composer、php</span></span><br><span class="line">brew install composer</span><br></pre></td></tr></table></figure>
<blockquote>
<p>安装composer会自动安装php</p>
</blockquote>
<h2 id="配置composer"><a class="markdownIt-Anchor" href="#配置composer"></a> 配置composer</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9jb21wb3Nlcg==">https://developer.aliyun.com/composer<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/</span><br><span class="line">composer self-update</span><br><span class="line">composer diagnose</span><br><span class="line">composer clear</span><br></pre></td></tr></table></figure>
<h3 id="checking-pubkeys-fail"><a class="markdownIt-Anchor" href="#checking-pubkeys-fail"></a> Checking pubkeys: FAIL</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Checking pubkeys: FAIL</span><br><span class="line">Missing pubkey for tags verification</span><br><span class="line">Missing pubkey for dev verification</span><br><span class="line">Run composer self-update --update-keys to set them up</span><br></pre></td></tr></table></figure>
<p>打开<span class="exturl" data-url="aHR0cHM6Ly9jb21wb3Nlci5naXRodWIuaW8vcHVia2V5cy5odG1s">pubkeys<i class="fa fa-external-link-alt"></i></span> 将图中内容放在第一次的input。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0x352w42mj215w0j60y8.jpg" alt="image-20220404021653505" /></p>
<p>将图中内容放在第二次的input。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0x35f6nmaj21820o2dmo.jpg" alt="image-20220404021716092" /></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbXBvc2VyL2NvbXBvc2VyL2lzc3Vlcy80ODM5">https://github.com/composer/composer/issues/4839<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="配置php"><a class="markdownIt-Anchor" href="#配置php"></a> 配置php</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew services restart php</span><br></pre></td></tr></table></figure>
<h2 id="配置xdebug"><a class="markdownIt-Anchor" href="#配置xdebug"></a> 配置Xdebug</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载xdebug</span></span><br><span class="line">pecl install xdebug</span><br><span class="line"><span class="comment"># 配置xdebug</span></span><br><span class="line"><span class="comment"># set xdebug ini</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF &gt; /opt/homebrew/etc/php/8.1/conf.d/ext-xdebug.ini</span></span><br><span class="line"><span class="string">[xdebug]</span></span><br><span class="line"><span class="string">zend_extension = &quot;/opt/homebrew/Cellar/php/8.1.4/pecl/20210902/xdebug.so&quot;</span></span><br><span class="line"><span class="string">xdebug.mode = &quot;debug&quot;</span></span><br><span class="line"><span class="string">xdebug.remote_mode = &quot;req&quot;</span></span><br><span class="line"><span class="string">;是否开启远程调试自动启动</span></span><br><span class="line"><span class="string">xdebug.remote_autostart = 1</span></span><br><span class="line"><span class="string">;是否开启远程调试</span></span><br><span class="line"><span class="string">xdebug.remote_enable = 1</span></span><br><span class="line"><span class="string">;允许调试的客户端IP</span></span><br><span class="line"><span class="string">xdebug.remote_host= &quot;localhost&quot;</span></span><br><span class="line"><span class="string">;远程调试的端口（默认9000）</span></span><br><span class="line"><span class="string">xdebug.remote_port = 9001</span></span><br><span class="line"><span class="string">;调试插件dbgp</span></span><br><span class="line"><span class="string">xdebug.remote_handler=&quot;dbgp&quot;</span></span><br><span class="line"><span class="string">;是否收集变量</span></span><br><span class="line"><span class="string">xdebug.collect_vars = 1</span></span><br><span class="line"><span class="string">;是否收集返回值</span></span><br><span class="line"><span class="string">xdebug.collect_return = 1</span></span><br><span class="line"><span class="string">;是否收集参数</span></span><br><span class="line"><span class="string">xdebug.collect_params = 1</span></span><br><span class="line"><span class="string">;是否开启调试内容</span></span><br><span class="line"><span class="string">xdebug.profiler_enable= 1</span></span><br><span class="line"><span class="string">;设置php显示的级别长度</span></span><br><span class="line"><span class="string">xdebug.var_display_max_depth=10</span></span><br><span class="line"><span class="string">xdebug.idekey = PHPSTROM</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<h2 id="禁止更新"><a class="markdownIt-Anchor" href="#禁止更新"></a> 禁止更新</h2>
<p>homebrew更新时会随之将路径打散，在非必要情况建议禁止自动更新php</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew pin php</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>php</category>
        <category>xdebug</category>
        <category>homebrew</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>miniconda安装与配置</title>
    <url>/29531.html</url>
    <content><![CDATA[<p>在科学计算、深度学习、机器学习等领域 Python 语言拥有举足轻重的地位,Python 开发环境,相关链接如下：</p>
<ul>
<li>
<p>PyPi(第三方库)地址： <span class="exturl" data-url="aHR0cHM6Ly9weXBpLm9yZy8=">https://pypi.org/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li>
<p>Anconda 官方地址： <span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5hY29uZGEuY29tLw==">https://www.anaconda.com/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li>
<p>Anconda 官方文档： <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvbmRhLmlvL3Byb2plY3RzL2NvbmRhL2VuL2xhdGVzdC91c2VyZ3VpZGUvaW5zdGFsbC9pbmRleC5odG1s">https://docs.conda.io/projects/conda/en/latest/userguide/install/index.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li>
<p>Anconda 下载地址： <span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5hY29uZGEuY29tL3Byb2R1Y3RzL2luZGl2aWR1YWwjRG93bmxvYWRz">https://www.anaconda.com/products/individual#Downloads<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li>
<p>Anconda Installer repo: <span class="exturl" data-url="aHR0cHM6Ly9yZXBvLmFuYWNvbmRhLmNvbS9hcmNoaXZlLw==">https://repo.anaconda.com/archive/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li>
<p>Miniconda 下载地址：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNvbmRhLmlvL2VuL2xhdGVzdC9taW5pY29uZGEuaHRtbA==">https://docs.conda.io/en/latest/miniconda.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li>
<p>Miniconda Installer repo: <span class="exturl" data-url="aHR0cHM6Ly9yZXBvLmFuYWNvbmRhLmNvbS9taW5pY29uZGEv">https://repo.anaconda.com/miniconda/<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<p>安装 Python 的方式有很多种，但根据所需，Anconda 无疑是最好的选择。在这里以 Miniconda 为例，在<br />
Windows、macOS 平台下的安装。</p>
<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Mac x86</span></span><br><span class="line">wget -c https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-x86_64.sh &amp;&amp; sh Miniconda3-latest-MacOSX-x86_64.sh </span><br><span class="line"><span class="comment"># Mac m1</span></span><br><span class="line">wget -c https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-arm64.sh &amp;&amp; sh Miniconda3-latest-MacOSX-arm64.sh </span><br><span class="line"><span class="comment"># Linux</span></span><br><span class="line">wget -c https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh &amp;&amp; sh Miniconda3-latest-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>点击此<span class="exturl" data-url="aHR0cHM6Ly9yZXBvLmFuYWNvbmRhLmNvbS9taW5pY29uZGEvTWluaWNvbmRhMy1sYXRlc3QtV2luZG93cy14ODZfNjQuZXhl">Windows<i class="fa fa-external-link-alt"></i></span> 下载安装程序</p>
</blockquote>
<h2 id="配置终端显示"><a class="markdownIt-Anchor" href="#配置终端显示"></a> 配置终端显示</h2>
<h3 id="linux-or-mac"><a class="markdownIt-Anchor" href="#linux-or-mac"></a> Linux or Mac</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda config --<span class="built_in">set</span> auto_activate_base <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows</h3>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> <span class="literal">-ExecutionPolicy</span> RemoteSigned</span><br><span class="line">conda init <span class="literal">--all</span></span><br><span class="line">conda config <span class="literal">--set</span> changeps1 false</span><br><span class="line">conda config <span class="literal">--set</span> auto_activate_base false</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意: 需要在管理员权限下</p>
</blockquote>
<h2 id="设置镜像源"><a class="markdownIt-Anchor" href="#设置镜像源"></a> 设置镜像源</h2>
<p>不得不说<code>Anconda</code>是个非常不错的科学计算包管理工具（当然不限与Python，而笔者主要用conda来管理虚拟环境等），使用conda来管理的时<br />
候难免会遇到国外网络的各种意外。对于此最简单的方法就是使用咱们国内的镜像源。使用方式如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加 镜像地址</span></span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br></pre></td></tr></table></figure>
<p><strong>查看配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda config --show-sources</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gx43066thhj30i503qwes.jpg" alt="image-20211206140953931" /></p>
<p>当然也可以通过配置文件<code>.condarc</code>来修改，但笔者并不建议。在此遍不再过多赘述。</p>
]]></content>
      <categories>
        <category>miniconda</category>
        <category>conda</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>conda</tag>
      </tags>
  </entry>
  <entry>
    <title>mitmproxy的使用</title>
    <url>/35284.html</url>
    <content><![CDATA[<p>MitmProxy是一组优秀的网络代理拦截工具，可为 HTTP/1、HTTP/2 和 WebSockets 提供交互式、支持 SSL/TLS<br />
的拦截代理。它提供 拦截 HTTP 和 HTTPS 请求和响应并动态修改它们、保存完整的 HTTP<br />
会话，以供重放攻击和分析、反向代理模式将流量转发到指定服务器、macOS 和 Linux 上的透明代理、对 HTTP<br />
流量进行脚本化更改等功能。</p>
<ul>
<li>官方地址：<span class="exturl" data-url="aHR0cHM6Ly9taXRtcHJveHkub3JnLw==">https://mitmproxy.org/<i class="fa fa-external-link-alt"></i></span></li>
<li>官方文档：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pdG1wcm94eS5vcmc=">https://docs.mitmproxy.org<i class="fa fa-external-link-alt"></i></span></li>
<li>官方博客：<span class="exturl" data-url="aHR0cHM6Ly9taXRtcHJveHkub3JnL3Bvc3RzLw==">https://mitmproxy.org/posts/<i class="fa fa-external-link-alt"></i></span></li>
<li>插件: <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pdG1wcm94eS5vcmcvc3RhYmxlL2FkZG9ucy1vdmVydmlldy8=">https://docs.mitmproxy.org/stable/addons-overview/<i class="fa fa-external-link-alt"></i></span></li>
<li>Github: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pdG1wcm94eS9taXRtcHJveHk=">https://github.com/mitmproxy/mitmproxy<i class="fa fa-external-link-alt"></i></span></li>
<li>Releases：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pdG1wcm94eS9taXRtcHJveHkvcmVsZWFzZXM=">https://github.com/mitmproxy/mitmproxy/releases<i class="fa fa-external-link-alt"></i></span></li>
<li></li>
</ul>
<p>DockerHub：<span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yL21pdG1wcm94eS9taXRtcHJveHkv">https://hub.docker.com/r/mitmproxy/mitmproxy<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li>证书安装: <span class="exturl" data-url="aHR0cDovL21pdG0uaXQv">http://mitm.it/<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2>
<h3 id="python3安装"><a class="markdownIt-Anchor" href="#python3安装"></a> Python3安装</h3>
<p>直接使用pip即可，使用如下命令进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 升级pip</span></span><br><span class="line">python3 -m pip install -U pip</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">python3 -m pip install -U mitmproxy</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于windows话默认是没有python3的（如果你没做兼容也就是将python复制一份副本并重命名为python3），使用python即可</p>
</blockquote>
<h3 id="mac"><a class="markdownIt-Anchor" href="#mac"></a> Mac</h3>
<p>Mac 下推荐使用 <code>homebrew</code>安装，尤其是<code>m1</code>的，注意啦！！！</p>
<p>别问我怎么知道的，说多了都是泪</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install mitmproxy</span><br></pre></td></tr></table></figure>
<h2 id="mitmproxy组成"><a class="markdownIt-Anchor" href="#mitmproxy组成"></a> mitmproxy组成</h2>
<p>mitmproxy 由mitmproxy、mitmdump、mitmweb组成</p>
<h3 id="mitmproxy"><a class="markdownIt-Anchor" href="#mitmproxy"></a> mitmproxy</h3>
<p>mitmproxy是用于调试、测试、隐私测量和渗透测试的瑞士军刀。它可用于拦截、检查、修改和重放 Web 流量，例如<br />
HTTP/1、HTTP/2、WebSockets 或任何其他受 SSL/TLS 保护的协议。您可以美化和解码从 HTML<br />
到 Protobuf 的各种消息类型，即时截取特定消息，在它们到达目的地之前对其进行修改，并稍后将它们重播到客户端或服务器。</p>
<h3 id="mitmdump"><a class="markdownIt-Anchor" href="#mitmdump"></a> mitmdump</h3>
<p>强大的插件功能与python<br />
api集成，提供了对mitmproxy的完全控制，可以自动修改消息、重定向流量、可视化消息或实现自定义命令。基于mitmdump可实现拓展，完全自由定制。实现基于此的流量转发代理中间件。</p>
<h3 id="mitmproxy-2"><a class="markdownIt-Anchor" href="#mitmproxy-2"></a> mitmproxy</h3>
<p>在图形界面中使用 mitmproxy 的主要功能 mitmweb。mitmweb 为您提供任何其他应用程序或设备的类似体验，以及请求拦截和重放等附加功能。</p>
<h2 id="证书安装与配置"><a class="markdownIt-Anchor" href="#证书安装与配置"></a> 证书安装与配置</h2>
<p>对于任何中间人抓包工具来说，若需要完整的捕获HTTPS请求，必须需要配置HTTPS证书。由于mitmproxy的证书在安装时便已经自带了，所以不必多次安装。只需配置证书即可。</p>
<p>手机上需要下载直接进入  <span class="exturl" data-url="aHR0cDovL21pdG0uaXQv">http://mitm.it/<i class="fa fa-external-link-alt"></i></span> 即可（需要先连接上mitmproxy的代理）</p>
<h2 id="mitmproxy界面"><a class="markdownIt-Anchor" href="#mitmproxy界面"></a> mitmproxy界面</h2>
<p>mitmproxy有许多的功能界面主要有以下几个</p>
<h3 id="index"><a class="markdownIt-Anchor" href="#index"></a> index</h3>
<p>打开代理时的index界面，此界面为中心界面，一进来就是这个，简要的介绍了包</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h00od9mq9lj21js0u0qls.jpg" alt="image-20220307012744921" /></p>
<h3 id="包详情界面"><a class="markdownIt-Anchor" href="#包详情界面"></a> 包详情界面</h3>
<p>使用<code>j</code>、<code>k</code> （或者上下方向键）实现包之间的移动，enter（回车）进入包的详情界面，可以使用tab进行切换。如下图所示</p>
<blockquote>
<p>当然是要大写的 <code>P</code> 也可以进入这里</p>
</blockquote>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h00oeqi65tj21hp0u0tf3.jpg" alt="image-20220307012909484" /></p>
<h3 id="帮助界面"><a class="markdownIt-Anchor" href="#帮助界面"></a> 帮助界面</h3>
<p>每个CLI基本上都有help，而mitmproxy自然也有， 如下</p>
<blockquote>
<p><code>?</code>: 进入</p>
</blockquote>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h00olhfb8lj21hn0u0goo.jpg" alt="image-20220307013538512" /></p>
<p>还有过滤帮助，可以使用<code>TAB</code> 实现切换。如下所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h00omjcg24j21c40u0ady.jpg" alt="image-20220307013639677" /></p>
<p>当使用<code>f</code> 快速进入过滤命令中 再加上过滤语法即可实现过滤，并在其中输入 <code>~u baidu</code>如下所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h00ooh970tj21go0u0gnd.jpg" alt="image-20220307013812180" /></p>
<p>实现对url为 <code>baidu</code> 的实现过滤展示</p>
<h3 id="key-bindings界面"><a class="markdownIt-Anchor" href="#key-bindings界面"></a> Key Bindings界面</h3>
<p><code>shift + k</code> 也就是大写的K进入此界面</p>
<p>按键绑定界面，这里展示了所有的按键在mitmproxy中的功能，当然也可以修改其绑定，其界面如下所示。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h00ojylhwpj215g0u0tc4.jpg" alt="image-20220307013411247" /></p>
<h3 id="events界面"><a class="markdownIt-Anchor" href="#events界面"></a> Events界面</h3>
<p>此界面可以查看捕获流量的所有事件，使用<code>E</code> 进入，如下所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h00oraucocj21bz0u0ai3.jpg" alt="image-20220307014113646" /></p>
<h3 id="command-reference界面"><a class="markdownIt-Anchor" href="#command-reference界面"></a> Command Reference界面</h3>
<p>所有的输入的命令都可以在这里找到，当然需要一些英文的识别能力， 如下所示</p>
<blockquote>
<p><code>shift + c</code> ：进入Command Reference界面</p>
<p><code>:</code> 进入命令输入状态</p>
</blockquote>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h00otmz81bj21kd0u0wke.jpg" alt="image-20220307014328724" /></p>
<h3 id="options界面"><a class="markdownIt-Anchor" href="#options界面"></a> Options界面</h3>
<p>参数选项界面，可以认为这是mitmproxy设置界面， 如下所示</p>
<blockquote>
<p>大写的<code>o</code> 进入</p>
</blockquote>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h00ovqurflj21em0u0792.jpg" alt="image-20220307014527641" /></p>
<h2 id="一些常用的按键"><a class="markdownIt-Anchor" href="#一些常用的按键"></a> 一些常用的按键</h2>
<h3 id="移动"><a class="markdownIt-Anchor" href="#移动"></a> 移动</h3>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>command</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>q</td>
<td>console.view.pop</td>
<td>返回：界面间的返回</td>
</tr>
<tr>
<td>g</td>
<td>console.nav.start</td>
<td>跳到第一行</td>
</tr>
<tr>
<td>G</td>
<td>console.nav.end</td>
<td>跳到最后一行</td>
</tr>
<tr>
<td>h</td>
<td>console.nav.left</td>
<td>跳到左面</td>
</tr>
<tr>
<td>j</td>
<td>console.nav.down</td>
<td>跳到下一行</td>
</tr>
<tr>
<td>k</td>
<td>console.nav.up</td>
<td>跳到上一行</td>
</tr>
<tr>
<td>l</td>
<td>console.nav.right</td>
<td>跳到右面</td>
</tr>
<tr>
<td>space</td>
<td>console.nav.pagedown</td>
<td>跳到本页最后一行</td>
</tr>
<tr>
<td>ctrl b</td>
<td>console.nav.pageup</td>
<td>跳到本页第一行</td>
</tr>
<tr>
<td>ctrl f</td>
<td>console.nav.pagedown</td>
<td>跳到本页最后一行</td>
</tr>
<tr>
<td>tab</td>
<td>console.nav.next</td>
<td></td>
</tr>
</tbody>
</table>
<p>可参考 help 界面</p>
<p>e: 快速生成请求</p>
<h2 id="mitmdump具体实现"><a class="markdownIt-Anchor" href="#mitmdump具体实现"></a> mitmdump具体实现</h2>
<p>一个基于mitmdump<br />
实现的流式流量转发处理平台: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1dlYlNwaWRlclN1cGVyU3Rhci9NaXRtRHVtcE1hbg==">mitmdumpMan<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="抓包tips"><a class="markdownIt-Anchor" href="#抓包tips"></a> 抓包tips</h2>
<ul>
<li>使用类似与SwitchyOmega实现端口塞选效果更佳</li>
</ul>
]]></content>
      <categories>
        <category>mitmproxy</category>
        <category>mitmweb</category>
        <category>mitmdump</category>
      </categories>
      <tags>
        <tag>mitmproxy</tag>
      </tags>
  </entry>
  <entry>
    <title>pipenv 让你的虚拟环境更加funny一点</title>
    <url>/22141.html</url>
    <content><![CDATA[<h2 id="什么是虚拟环境"><a class="markdownIt-Anchor" href="#什么是虚拟环境"></a> 什么是虚拟环境？</h2>
<ul>
<li></li>
</ul>
<p>由<span class="exturl" data-url="aHR0cHM6Ly9jdWlxaW5nY2FpLmNvbS8lNUJodHRwczovL2JhaWtlLmJhaWR1LmNvbS9pdGVtLyVFOCU5OSU5QSVFNiU4QiU5RiVFNyU4RSVBRiVFNSVBMiU4My82NTI5MTUzP2ZyPWFsYWRkaW4lNUQoaHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglOTklOUElRTYlOEIlOUYlRTclOEUlQUYlRTUlQTIlODMvNjUyOTE1Mz9mcj1hbGFkZGluKQ==">百度百科<i class="fa fa-external-link-alt"></i></span><br />
得知： 以专利的实时动态程序行为修饰与模拟算法，直接利用本机的 OS，模拟出自带与本机相容 OS 的虚拟机（Vista<br />
下可模拟 Vista、XP，Windows 7 下则可模拟 Windows 7、Vista、XP），也称为 “虚拟环境”</p>
<ul>
<li>功能： 每一个环境都相当于一个新的 Python 环境。你可以在这个新的环境里安装库，运行代码等</li>
</ul>
<span id="more"></span>
<h2 id="为什么需要使用虚拟环境"><a class="markdownIt-Anchor" href="#为什么需要使用虚拟环境"></a> 为什么需要使用虚拟环境？</h2>
<ul>
<li>众所周知 Python 的强大在于其兼容性，其强大的社区等。正因为第三方库多，层次不齐造成了许多的第三方库并不兼容</li>
<li>真实环境与虚拟环境二者相对关联，并非绝对关联，可以在虚拟环境里面随便造。</li>
<li>虚拟环境中进行了隔离，更方便我们部署上线</li>
</ul>
<h2 id="什么时候需要使用虚拟环境"><a class="markdownIt-Anchor" href="#什么时候需要使用虚拟环境"></a> 什么时候需要使用虚拟环境？</h2>
<p><strong>例如：</strong></p>
<ul>
<li>项目依赖版本不同时</li>
<li>所需包与其他包(非此项目所需，但却存在)产生冲突时</li>
<li>等等</li>
</ul>
<h2 id="为什么虚拟环境使用pipenv好一点"><a class="markdownIt-Anchor" href="#为什么虚拟环境使用pipenv好一点"></a> 为什么虚拟环境使用<code>pipenv</code>好一点？</h2>
<p><strong>Pipenv</strong>是一种工具，旨在将所有包装领域（捆扎机，作曲家，npm，货物，纱线等）中的最佳产品引入Python世界。<br />
<em>Windows是我们世界上的头等公民。</em></p>
<p>它会自动为您的项目创建和管理virtualenv，并<code>Pipfile</code><br />
在您安装/卸载软件包时从您的软件包中添加/删除软件包。它还会生成非常重要的<code>Pipfile.lock</code>，用于生成确定性构建。</p>
<p>Pipenv的主要目的是为应用程序的用户和开发人员提供一种简单的方法来设置工作环境。有关库和应用程序之间的区别以及使用<code>setup.py</code><br />
vs<code>Pipfile</code><br />
定义依赖<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnBpcGVudi5vcmcvYWR2YW5jZWQvI3BpcGZpbGUtdnMtc2V0dXBweQ==">项的区别<i class="fa fa-external-link-alt"></i></span>，请参见<a href="https://docs.pipenv.org/advanced/#pipfile-vs-setuppy">☤Pipfile vs<br />
setup.py</a>。</p>
<p>Pipenv试图解决的问题是多方面的：</p>
<ul>
<li>您不再需要使用<code>pip</code>和<code>virtualenv</code>分开。他们一起工作。</li>
<li>管理<code>requirements.txt</code>文件可能会出现问题，因此Pipenv使用<code>Pipfile</code>和<code>Pipfile.lock</code>将抽象依赖声明与上次测试的组合分开。</li>
<li>哈希值随处可见。安全。自动公开安全漏洞。</li>
<li>强烈建议使用最新版本的依赖项，以最大程度地减少由于过时的组件引起的安全风险。</li>
<li>让您深入了解依赖关系图（例如）。<code>$ pipenv graph</code></li>
<li>通过加载<code>.env</code>文件来简化开发工作流程。</li>
</ul>
<h2 id="pipenv安装"><a class="markdownIt-Anchor" href="#pipenv安装"></a> pipenv安装</h2>
<p>建议使用<code>pip3</code>, mac还是服务器上的Linux一般都会有<code>python2.x</code>版本。在这种场景大多情况下，<code>pip</code><br />
指向<code>python2.x</code>,并非<code>python3.x</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip3 install --upgrade pip</span><br><span class="line"><span class="comment"># 推荐使用pip来安装</span></span><br><span class="line">pip3 install pipenv</span><br></pre></td></tr></table></figure>
<p>其他几种安装方式</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># If you’re on MacOS, you can install Pipenv easily with Homebrew:</span></span><br><span class="line">brew install pipenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># Or, if you’re using Fedora 28:</span></span><br><span class="line"><span class="built_in">sudo</span> dnf install pipenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># if you&#x27;re using centos</span></span><br><span class="line"><span class="built_in">sudo</span> yum install -y pipenv</span><br></pre></td></tr></table></figure>
<p>反正安装都一样,无论是使用其他的包管理工具还是pip，都可以</p>
<h2 id="创建虚拟环境"><a class="markdownIt-Anchor" href="#创建虚拟环境"></a> 创建虚拟环境</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python3 环境创建</span></span><br><span class="line">pipenv --python 3.x</span><br><span class="line">pipenv --three</span><br><span class="line">pipenv install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建完成后，虚拟环境的pip。并不是你真实环境的pip版本，如果有需要，需要升级一下pip 的版本</span></span><br><span class="line">python3 -m pip install --upgrade pip</span><br></pre></td></tr></table></figure>
<blockquote>
<p>值得一提的是，首先必须得安装了相对应的Python<br />
版本才能创建虚拟环境。可能点萌萌哒。举个栗子，例如我的电脑环境中只有python3.7，而我想创建一个python2.7<br />
这样是不能创建的</p>
<p>Pip3安装的pipenv 只能python3 只能使用</p>
</blockquote>
<h2 id="安装删除第三方库"><a class="markdownIt-Anchor" href="#安装删除第三方库"></a> 安装删除第三方库</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pipenv install packageName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装多个包，中间以空格分隔即可</span></span><br><span class="line">pipenv install packageName-1 packageName-2 packageNama-3</span><br><span class="line"></span><br><span class="line">pipenv uninstall packageName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然还可以使用-r </span></span><br><span class="line">pipenv install -r requirements.txt </span><br></pre></td></tr></table></figure>
<h2 id="terminal激活虚拟环境"><a class="markdownIt-Anchor" href="#terminal激活虚拟环境"></a> Terminal激活虚拟环境</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pipenv shell</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>此时终端会在最前面显示<code>(xxx)</code>, xxx一般为项目文件名。证明退出成功</li>
<li>并不需要关心虚拟环境的具体位置，只需要在当前目录下。有<code>Pipfile</code>即可</li>
</ul>
</blockquote>
<h2 id="terminal中退出虚拟环境"><a class="markdownIt-Anchor" href="#terminal中退出虚拟环境"></a> Terminal中退出虚拟环境</h2>
<p>在其他包的虚拟环境中退出可能是使用<code>deactivate</code>,在conda 中使用<code>conda deactivate</code>,而在pipenv 中直接使用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 即可退出</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果使用deactivate，然后在使用<code>pipenv shell</code>,造成本终端页面进入虚拟环境失败。请参考勘误2</p>
</blockquote>
<h2 id="删除虚拟环境"><a class="markdownIt-Anchor" href="#删除虚拟环境"></a> 删除虚拟环境</h2>
<p>在此项目目录下只需一下命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pipenv --<span class="built_in">rm</span> </span><br></pre></td></tr></table></figure>
<h2 id="镜像源安装第三方包"><a class="markdownIt-Anchor" href="#镜像源安装第三方包"></a> 镜像源安装第三方包</h2>
<p>我相信你也和我一样遇见过或尽力过下载第三方包失效包很慢，或者干脆出现<code>timeout</code><br />
导致第三方包下载失败的情况，那么接下来让我们来使用国内的镜像源进行安装第三方包。速度嗖嗖嗖～</p>
<h3 id="单一的安装"><a class="markdownIt-Anchor" href="#单一的安装"></a> 单一的安装</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以requests 为栗子</span></span><br><span class="line"> pipenv install requests  --pypi-mirror https://pypi.tuna.tsinghua.edu.cn/simple/</span><br></pre></td></tr></table></figure>
<h3 id="修改配置文件"><a class="markdownIt-Anchor" href="#修改配置文件"></a> 修改配置文件</h3>
<p>使用pipenv创建虚拟环境之后会在项目目录下生成<code>Pipfile</code>,的文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Pipfile</span></span><br><span class="line">[[<span class="built_in">source</span>]]</span><br><span class="line">url = <span class="string">&quot;https://pypi.tuna.tsinghua.edu.cn/simple/&quot;</span></span><br><span class="line">verify_ssl = <span class="literal">true</span></span><br><span class="line">name = <span class="string">&quot;pypi&quot;</span></span><br><span class="line"></span><br><span class="line">[packages]</span><br><span class="line">requests = <span class="string">&quot;*&quot;</span></span><br><span class="line"></span><br><span class="line">[dev-packages]</span><br><span class="line"></span><br><span class="line">[requires]</span><br><span class="line">python_version = <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="获取包依赖"><a class="markdownIt-Anchor" href="#获取包依赖"></a> 获取包依赖</h3>
<p>我们可以使用命令来清晰地呈现出当前安装的 Python 包版本及之间的依赖关系，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipenv graph</span><br></pre></td></tr></table></figure>
<blockquote>
<p>~ ProjectNote % pipenv graph<br />
lxml<mark>4.6.2<br />
requests</mark>2.25.1</p>
<ul>
<li>certifi [required: &gt;=2017.4.17, installed: 2020.12.5]</li>
<li>chardet [required: &gt;=3.0.2,&lt;5, installed: 4.0.0]</li>
<li>idna [required: &gt;=2.5,❤️, installed: 2.10]</li>
<li>urllib3 [required: &gt;=1.21.1,&lt;1.27, installed: 1.26.2]</li>
</ul>
</blockquote>
<h3 id="产生-pipfilelock"><a class="markdownIt-Anchor" href="#产生-pipfilelock"></a> 产生 Pipfile.lock</h3>
<p>有时候可能 Pipfile.lock 文件不存在或被删除了，这时候我们可以使用如下命令生成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipenv lock</span><br></pre></td></tr></table></figure>
<p>以上就是pipenv基础使用了，但这还不够哦。接下来让我们深入探究一下</p>
<h2 id="不知道但常用"><a class="markdownIt-Anchor" href="#不知道但常用"></a> 不知道但常用</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Usage: pipenv [OPTIONS] COMMAND [ARGS]...</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --<span class="built_in">where</span>                         Output project home information.</span><br><span class="line">  --venv                          Output virtualenv information.</span><br><span class="line">  --py                            Output Python interpreter information.</span><br><span class="line">  --envs                          Output Environment Variable options.</span><br><span class="line">  --<span class="built_in">rm</span>                            Remove the virtualenv.</span><br><span class="line">  --bare                          Minimal output.</span><br><span class="line">  --completion                    Output completion (to be executed by the</span><br><span class="line">                                  shell).</span><br><span class="line"></span><br><span class="line">  --man                           Display manpage.</span><br><span class="line">  --support                       Output diagnostic information <span class="keyword">for</span> use <span class="keyword">in</span></span><br><span class="line">                                  GitHub issues.</span><br><span class="line"></span><br><span class="line">  --site-packages / --no-site-packages</span><br><span class="line">                                  Enable site-packages <span class="keyword">for</span> the virtualenv.</span><br><span class="line">                                  [<span class="built_in">env</span> var: PIPENV_SITE_PACKAGES]</span><br><span class="line"></span><br><span class="line">  --python TEXT                   Specify <span class="built_in">which</span> version of Python virtualenv</span><br><span class="line">                                  should use.</span><br><span class="line"></span><br><span class="line">  --three / --two                 Use Python 3/2 when creating virtualenv.</span><br><span class="line">  --clear                         Clears caches (pipenv, pip, and pip-tools).</span><br><span class="line">                                  [<span class="built_in">env</span> var: PIPENV_CLEAR]</span><br><span class="line"></span><br><span class="line">  -v, --verbose                   Verbose mode.</span><br><span class="line">  --pypi-mirror TEXT              Specify a PyPI mirror.</span><br><span class="line">  --version                       Show the version and <span class="built_in">exit</span>.</span><br><span class="line">  -h, --<span class="built_in">help</span>                      Show this message and <span class="built_in">exit</span>.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Usage Examples:</span><br><span class="line">   Create a new project using Python 3.7, specifically:</span><br><span class="line">   $ pipenv --python 3.7</span><br><span class="line"></span><br><span class="line">   Remove project virtualenv (inferred from current directory):</span><br><span class="line">   $ pipenv --<span class="built_in">rm</span></span><br><span class="line"></span><br><span class="line">   Install all dependencies <span class="keyword">for</span> a project (including dev):</span><br><span class="line">   $ pipenv install --dev</span><br><span class="line"></span><br><span class="line">   Create a lockfile containing pre-releases:</span><br><span class="line">   $ pipenv lock --pre</span><br><span class="line"></span><br><span class="line">   Show a graph of your installed dependencies:</span><br><span class="line">   $ pipenv graph</span><br><span class="line"></span><br><span class="line">   Check your installed dependencies <span class="keyword">for</span> security vulnerabilities:</span><br><span class="line">   $ pipenv check</span><br><span class="line"></span><br><span class="line">   Install a <span class="built_in">local</span> setup.py into your virtual environment/Pipfile:</span><br><span class="line">   $ pipenv install -e .</span><br><span class="line"></span><br><span class="line">   Use a lower-level pip <span class="built_in">command</span>:</span><br><span class="line">   $ pipenv run pip freeze</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  check      Checks <span class="keyword">for</span> PyUp Safety security vulnerabilities and against PEP</span><br><span class="line">             508 markers provided <span class="keyword">in</span> Pipfile.</span><br><span class="line"></span><br><span class="line">  clean      Uninstalls all packages not specified <span class="keyword">in</span> Pipfile.lock.</span><br><span class="line">  graph      Displays currently-installed dependency graph information.</span><br><span class="line">  install    Installs provided packages and adds them to Pipfile, or (<span class="keyword">if</span> no</span><br><span class="line">             packages are given), installs all packages from Pipfile.</span><br><span class="line"></span><br><span class="line">  lock       Generates Pipfile.lock.</span><br><span class="line">  open       View a given module <span class="keyword">in</span> your editor.</span><br><span class="line">  run        Spawns a <span class="built_in">command</span> installed into the virtualenv.</span><br><span class="line">  scripts    Lists scripts <span class="keyword">in</span> current environment config.</span><br><span class="line">  shell      Spawns a shell within the virtualenv.</span><br><span class="line">  <span class="built_in">sync</span>       Installs all packages specified <span class="keyword">in</span> Pipfile.lock.</span><br><span class="line">  uninstall  Uninstalls a provided package and removes it from Pipfile.</span><br><span class="line">  update     Runs lock, <span class="keyword">then</span> <span class="built_in">sync</span>.</span><br></pre></td></tr></table></figure>
<h3 id="在真实环境中使用虚拟环境中包并运行"><a class="markdownIt-Anchor" href="#在真实环境中使用虚拟环境中包并运行"></a> 在真实环境中使用虚拟环境中包并运行</h3>
<blockquote>
<p>场景如下：</p>
<p>假设正式环境中为一个干净的仓库,有且仅有初始的包</p>
<p>虚拟环境中有所需要的第三方包。</p>
<p>如何实现在真实环境中使用虚拟环境中的第三方包并运行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipenv run python xxx.py</span><br></pre></td></tr></table></figure>
<h3 id="产生-pipfilelock-2"><a class="markdownIt-Anchor" href="#产生-pipfilelock-2"></a> 产生 Pipfile.lock</h3>
<p>有时候可能 Pipfile.lock 文件不存在或被删除了，这时候我们可以使用以下命令生成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pipenv lock</span><br></pre></td></tr></table></figure>
<h2 id="批量安装第三方依赖包"><a class="markdownIt-Anchor" href="#批量安装第三方依赖包"></a> 批量安装第三方依赖包</h2>
<p>部署的时候只需要将此执行一下命令即可安装所有的依赖包，它是依靠Pipfile.lock的</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pipenv <span class="built_in">sync</span></span><br></pre></td></tr></table></figure>
<h3 id="示例使用pipenv-对接docker或其他的部署"><a class="markdownIt-Anchor" href="#示例使用pipenv-对接docker或其他的部署"></a> 示例:使用pipenv 对接docker或其他的部署</h3>
<p>只说不做假把式，只做不说傻把式。搞了这么多，来个case实现与项目接轨吧。这里为以docker部署为栗子</p>
<p>首先在项目中我们也使用虚拟环境去开发,当然也建议这样去做。没错，我是在教你做事。嘻嘻～</p>
<p>此时的项目应该差不多如下,此时两个为必须存在一个是<code>Pipfile</code>, 一个是项目文件(<br />
文件夹)。<code>deploy</code>，<code>Dockerfile</code>为后实现</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1glvroonkofj30ly07i0so.jpg" alt="" /></p>
<p>书写Dockerfile，拿docker部署没有Dockerfile是不阔能滴</p>
<p>Dockerfile实现如下,可以按需修改</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /code</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /code</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sh deploy.sh</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;pipenv&quot;</span>, <span class="string">&quot;run&quot;</span>, <span class="string">&quot;python3&quot;</span>, <span class="string">&quot;testfile.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>Deploy.sh如下</p>
<p>其实deploy 其中的内容可以直接放到dockerfile中，我自己喜欢这样。更加清晰一点。啊，如此清晰的逻辑与结构，无敌～。我又在教你做事，大哥别杀我</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保持pip版本为最新版，及安装pipenv</span></span><br><span class="line">python3 -m pip install --upgrade pip  &amp;&amp; pip3 install pipenv</span><br><span class="line"><span class="comment"># 创建虚拟环境</span></span><br><span class="line">pipenv --python 3.8</span><br><span class="line"><span class="comment"># 安装环境依赖(第三方包)</span></span><br><span class="line">pipenv update</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里需要注意的是，我建议你使用<code>pipenv update</code>,更加保险。</p>
<p>什么， 你问我为什么不用sync？</p>
<p>既然你诚心诚意的发问了，那我就大发慈悲的告诉你吧。哈哈～</p>
<p><code>pipenv update</code>相当于执行了<code>pipenv lock</code>和<code>pipenv sync</code>两个命令</p>
<p>如果用<code>pipenv sync</code>，而此时的你如果没有<code>Pipfile.lock</code>,那岂不是很尬</p>
</blockquote>
<p>Docker build 执行结果如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Sending build context to Docker daemon  99.33kB</span><br><span class="line">Step 1/5 : FROM python:3.8</span><br><span class="line"> ---&gt; d1bfb3dd9268</span><br><span class="line">Step 2/5 : WORKDIR /code</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 74cda17b1483</span><br><span class="line">Removing intermediate container 74cda17b1483</span><br><span class="line"> ---&gt; ecfd46d28538</span><br><span class="line">Step 3/5 : COPY . /code</span><br><span class="line"> ---&gt; 8a89f329a4f9</span><br><span class="line">Step 4/5 : RUN pip install pipenv &amp;&amp; sh deploy.bash.sh</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> cea95051d481</span><br><span class="line">Collecting pipenv</span><br><span class="line">  Downloading pipenv-2020.11.15-py2.py3-none-any.whl (3.9 MB)</span><br><span class="line">Requirement already satisfied: setuptools&gt;=36.2.1 <span class="keyword">in</span> /usr/local/lib/python3.8/site-packages (from pipenv) (51.0.0)</span><br><span class="line">Requirement already satisfied: pip&gt;=18.0 <span class="keyword">in</span> /usr/local/lib/python3.8/site-packages (from pipenv) (20.3.3)</span><br><span class="line">Collecting virtualenv-clone&gt;=0.2.5</span><br><span class="line">  Downloading virtualenv_clone-0.5.4-py2.py3-none-any.whl (6.6 kB)</span><br><span class="line">Collecting certifi</span><br><span class="line">  Downloading certifi-2020.12.5-py2.py3-none-any.whl (147 kB)</span><br><span class="line">Collecting virtualenv</span><br><span class="line">  Downloading virtualenv-20.2.2-py2.py3-none-any.whl (5.7 MB)</span><br><span class="line">Collecting appdirs&lt;2,&gt;=1.4.3</span><br><span class="line">  Downloading appdirs-1.4.4-py2.py3-none-any.whl (9.6 kB)</span><br><span class="line">Collecting distlib&lt;1,&gt;=0.3.1</span><br><span class="line">  Downloading distlib-0.3.1-py2.py3-none-any.whl (335 kB)</span><br><span class="line">Collecting filelock&lt;4,&gt;=3.0.0</span><br><span class="line">  Downloading filelock-3.0.12-py3-none-any.whl (7.6 kB)</span><br><span class="line">Collecting six&lt;2,&gt;=1.9.0</span><br><span class="line">  Downloading six-1.15.0-py2.py3-none-any.whl (10 kB)</span><br><span class="line">Installing collected packages: six, filelock, distlib, appdirs, virtualenv-clone, virtualenv, certifi, pipenv</span><br><span class="line">Successfully installed appdirs-1.4.4 certifi-2020.12.5 distlib-0.3.1 filelock-3.0.12 pipenv-2020.11.15 six-1.15.0 virtualenv-20.2.2 virtualenv-clone-0.5.4</span><br><span class="line">Creating a virtualenv <span class="keyword">for</span> this project...</span><br><span class="line">Pipfile: /code/Pipfile</span><br><span class="line">Using /usr/local/bin/python3.8 (3.8.6) to create virtualenv...</span><br><span class="line">⠦ Creating virtual environment...created virtual environment CPython3.8.6.final.0-64 <span class="keyword">in</span> 1079ms</span><br><span class="line">  creator CPython3Posix(dest=/root/.local/share/virtualenvs/code-_Py8Si6I, clear=False, no_vcs_ignore=False, global=False)</span><br><span class="line">  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, wheel=bundle, via=copy, app_data_dir=/root/.local/share/virtualenv)</span><br><span class="line">    added seed packages: pip==20.3.1, setuptools==51.0.0, wheel==0.36.1</span><br><span class="line">  activators BashActivator,CShellActivator,FishActivator,PowerShellActivator,PythonActivator,XonshActivator</span><br><span class="line">                                                                                                                                                                           ✔ Successfully created virtual environment! </span><br><span class="line">Virtualenv location: /root/.local/share/virtualenvs/code-_Py8Si6I</span><br><span class="line">Installing dependencies from Pipfile.lock (d2a522)...</span><br><span class="line">To activate this project<span class="string">&#x27;s virtualenv, run pipenv shell.</span></span><br><span class="line"><span class="string">Alternatively, run a command inside the virtualenv with pipenv run.</span></span><br><span class="line"><span class="string">All dependencies are now up-to-date!</span></span><br><span class="line"><span class="string">Removing intermediate container cea95051d481</span></span><br><span class="line"><span class="string"> ---&gt; 5bc79a1c17b6</span></span><br><span class="line"><span class="string">Step 5/5 : CMD [&quot;pipenv&quot;, &quot;run&quot;, &quot;python3&quot;, &quot;testfile.py&quot;]</span></span><br><span class="line"><span class="string"> ---&gt; Running in d86af926715c</span></span><br><span class="line"><span class="string">Removing intermediate container d86af926715c</span></span><br><span class="line"><span class="string"> ---&gt; a64b6bc63353</span></span><br><span class="line"><span class="string">Successfully built a64b6bc63353</span></span><br><span class="line"><span class="string">Successfully tagged test:1</span></span><br><span class="line"><span class="string">(ProjectNote) stringle-004@zhixiankeji-004s-MacBook-Pro ProjectNote % docker run  test:1</span></span><br><span class="line"><span class="string">&lt;Response [200]&gt;</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action=//www.baidu.com/s class=fm&gt; &lt;input type=hidden name=bdorz_come value=1&gt; &lt;input type=hidden name=ie value=utf-8&gt; &lt;input type=hidden name=f value=8&gt; &lt;input type=hidden name=rsv_bp value=1&gt; &lt;input type=hidden name=rsv_idx value=1&gt; &lt;input type=hidden name=tn value=baidu&gt;&lt;span class=&quot;bg s_ipt_wr&quot;&gt;&lt;input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus=autofocus&gt;&lt;/span&gt;&lt;span class=&quot;bg s_btn_wr&quot;&gt;&lt;input type=submit id=su value=百度一下 clabg s_btn&quot; autofocus&gt;&lt;/span&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=u1&gt; &lt;a href=http://news.baidu.com name=tj_trnews class=mnav&gt;新闻&lt;/a&gt; &lt;a href=https://www.hao123.com name=tj_trhao1 class=mnav&gt;hao123&lt;/a&gt; &lt;a href=http://map.baidu.com name=tj_trmap class=mnav&gt;地图&lt;/a&gt; &lt;a href=http://v.baidu.com name=tj_trvideo class=mnav&gt;视频&lt;/a&gt; &lt;a href=http://tieba.bacom name=tj_trtieba class=mnav&gt;贴吧&lt;/a&gt; &lt;noscript&gt; &lt;a href=http://www.baidu.com/bdorz/login.gif?login&amp;amp;tpl=mn&amp;amp;u=http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1 name=tlogin class=lb&gt;登录&lt;/a&gt; &lt;/noscript&gt; &lt;script&gt;document.write(&#x27;</span>&lt;a href=<span class="string">&quot;http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u=&#x27;+ encodeURIComponent(window.location.href+ (windowocation.search === &quot;</span><span class="string">&quot; ? &quot;</span>?<span class="string">&quot; : &quot;</span>&amp;<span class="string">&quot;)+ &quot;</span>bdorz_come=1<span class="string">&quot;)+ &#x27;&quot;</span> name=<span class="string">&quot;tj_login&quot;</span> class=<span class="string">&quot;lb&quot;</span>&gt;登录&lt;/a&gt;<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">                &lt;/script&gt; &lt;a href=//www.baidu.com/more/ name=tj_briicon class=bri style=&quot;display: block;&quot;&gt;更多产品&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=ftCon&gt; &lt;div id=ftConw&gt; &lt;p id=lh&gt; &lt;a href=http://home.baidu.com&gt;关于百度&lt;/a&gt; &lt;a href=http://ir.baidu.com&gt;About Baidu&lt;/a&gt; &lt;/p&gt; &lt;p id=cp&gt;&amp;copy;2017&amp;nbsp;Baidu&amp;nbsp;&lt;a href=http://www.baidu.com/duty/&gt;前必读&lt;/a&gt;&amp;nbsp; &lt;a href=http://jianyi.baidu.com/ class=cp-feedback&gt;意见反馈&lt;/a&gt;&amp;nbsp;京ICP证030173号&amp;nbsp; &lt;img src=//www.baidu.com/img/gs.gif&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;tml&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;Element html at 0x7fbfe776d100&gt;</span></span><br></pre></td></tr></table></figure>
<p>Docker 构建注意事项：</p>
<ol>
<li>
<pre class="highlight"><code class="sh"><span class="comment"># Pipfile文件</span>
[requires]
python_version = <span class="string">&quot;3.8&quot;</span>

<span class="comment"># dockerfile</span>
FROM python:3.8

这两个后面跟的版本号必须一致，否则将会构建失败
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 使用`pipenv update`而不是`pipenv sync`,为什么，我就不告诉你了。看上面就好</span><br><span class="line"></span><br><span class="line">## 勘误</span><br><span class="line"></span><br><span class="line">### 1.pip版本过低造成安装失败</span><br><span class="line"></span><br><span class="line">还记得我之前在服务器上，无论怎么安装就是安装不上，无论是其他包还是`pipenv`.后来硬是找不到什么原因。直到。。。</span><br><span class="line"></span><br><span class="line">```sh</span><br><span class="line"># 查看pip 版本</span><br><span class="line">pip3 -V</span><br><span class="line"># or</span><br><span class="line">pip3 --version</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ol>
<blockquote>
<p>输出结果类似如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~ % pip3 -V</span><br><span class="line">pip 20.3.3 from /usr/local/lib/python3.9/site-packages/pip (python 3.9)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果pip 的版本还不是20版本的，需要进行升级</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推荐</span></span><br><span class="line">python3 -m pip install --upgrade pip [--user]</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">python3 -m pip install -U pip [--user]</span><br><span class="line"><span class="comment"># 不推荐</span></span><br><span class="line">pip3 install --upgrade pip</span><br><span class="line">pip3 install -U pip</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>
<p>其中[–user] 为可选参数，最好加上。一般情况下不加也没事</p>
</li>
<li>
<p><code>-m</code>:run library module as a script (terminates option list) 将库模块作为脚本运行（终止选项列表）</p>
</li>
</ul>
</blockquote>
<h3 id="2虚拟环境重载错误"><a class="markdownIt-Anchor" href="#2虚拟环境重载错误"></a> 2.虚拟环境重载错误</h3>
<p>之前使用其他的python虚拟环境工具的时候，使用<code>deactivate</code>,退出虚拟环境。而<code>pipenv</code>, 并不是这样</p>
<p>使用<code>deactivate</code>,退出虚拟环境后又使用`pipenv shell, 进入虚拟环境，结果显示…</p>
<blockquote>
<p>Shell for UNKNOWN_VIRTUAL_ENVIRONMENT already activated.<br />
No action taken to avoid nested environments.</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先exit 一下即可，然后使用</span></span><br><span class="line">pipenv shell</span><br><span class="line"><span class="comment"># 即可重新进入虚拟环境</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>创建虚拟环境需注意 pipenv 并不支持嵌套的虚拟环境，默认使用此文件的父级目录中的pipfile</p>
<blockquote>
<p>比如：在projectfile中有文件src-1，pipfile, src-2,如果进入src-1 中执行<code>pipenv install</code><br />
or<code>pipenv --python 3.8</code>or <code>pipenv  tree</code>,中任何一个命令都会优先使用projectfile/pipfile</p>
</blockquote>
</li>
</ol>
<blockquote></blockquote>
<h2 id="referer"><a class="markdownIt-Anchor" href="#referer"></a> Referer</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnBpcGVudi5vcmcv">pipenv官方文档<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9weXBpLm9yZy9wcm9qZWN0L3BpcGVudi8=">pipenv pypi<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
  </entry>
  <entry>
    <title>redis持久化那些事儿</title>
    <url>/35558.html</url>
    <content><![CDATA[<h2 id="redis-持久化"><a class="markdownIt-Anchor" href="#redis-持久化"></a> Redis 持久化</h2>
<p>redis的持久化方式有两种，一种是RDB持久化，一种是AOF持久化。</p>
<h1 id="rdb快照snapshot"><a class="markdownIt-Anchor" href="#rdb快照snapshot"></a> RDB快照（snapshot）</h1>
<p>redis把数据以快照的方式保存在磁盘上。默认的情况下，redis将数据保存在文件名为dump.rdb的二进制文件中。</p>
<p>redis在运行时，会把内存中的数据快照保存到磁盘上，在redis重启时，会从rdb文件中读取数据还原redis数据库的状态。</p>
<p>rdb是自动默认开启的，但并没有开启触发规则。</p>
<h2 id="触发机制"><a class="markdownIt-Anchor" href="#触发机制"></a> 触发机制</h2>
<p>RDB的触发可分为两大类，一类是自动触发，一类是手动触发。</p>
<p>自动触发</p>
<h3 id="自动触发"><a class="markdownIt-Anchor" href="#自动触发"></a> 自动触发</h3>
<p>当数据操作满足一定的规则，自动触发。详细规则如下</p>
<blockquote>
<p>默认开启rdb，但没有配置规则，若需要使用或配置则需要在配置文件中将注释放开</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># RDB自动持久化规则</span><br><span class="line"># 当900 秒内有至少有 1 个键被改动时，自动进行数据集保存操作</span><br><span class="line">save 900 1</span><br><span class="line"># 当 300 秒内有至少有 10 个键被改动时，自动进行数据集保存操作</span><br><span class="line">save 300 10</span><br><span class="line"># 当 60 秒内有至少有 10000 个键被改动时，自动进行数据集保存操作</span><br><span class="line">save 60 10000</span><br><span class="line"># RDB持久化文件名</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"># 数据持久化文件存储目录</span><br><span class="line">dir /var/lib/redis</span><br><span class="line"># bgsave发生错误时是否停止写入，通常为yes</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"># rdb文件是否使用压缩格式</span><br><span class="line">rdbcompression yes</span><br><span class="line"># 是否对rdb文件进行校验和检验，通常为yes</span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure>
<h3 id="手动触发"><a class="markdownIt-Anchor" href="#手动触发"></a> 手动触发</h3>
<h4 id="save命令"><a class="markdownIt-Anchor" href="#save命令"></a> save命令</h4>
<p>在客户端执行save命令，会触发一次保存快照。save命令是同步命令，在save执行时，会占用主进程，导致redis其他命令无法使用。在数据量过大时，可能会导致redis反应变慢。</p>
<h4 id="bgsave命令"><a class="markdownIt-Anchor" href="#bgsave命令"></a> bgsave命令</h4>
<p>bgsave命令是异步操作，执行bgsave命令保存快照，可以在生成快照的同时，依然可以正常处理其他命令。bgsave子进程是由主线程fock生成的，它不影响主进程的执行，同时还可以共享主进程的数据</p>
<h4 id="save和bgsave对比"><a class="markdownIt-Anchor" href="#save和bgsave对比"></a> save和bgsave对比</h4>
<table>
<thead>
<tr>
<th>命令</th>
<th>save</th>
<th>bgsave</th>
</tr>
</thead>
<tbody>
<tr>
<td>IO类型</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>是否阻塞redis</td>
<td>是</td>
<td>是(在生成子进程时有短暂阻塞，速度很快，基本没有影响)</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>不消耗额外内存</td>
<td>不阻塞客户端</td>
</tr>
<tr>
<td>缺点</td>
<td>阻塞客户端命令</td>
<td>需要fork子进程，消耗内存</td>
</tr>
</tbody>
</table>
<h3 id="关闭rdb"><a class="markdownIt-Anchor" href="#关闭rdb"></a> 关闭RDB</h3>
<p>虽然这种方式可能不需要，但若需要关闭rdb的时候，在redis-shell中只需要执行即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config set save &quot;&quot;</span><br></pre></td></tr></table></figure>
<p>当然也可以在配置文件中将 <code>save &quot;&quot;</code> 注释打开，也可以。</p>
<h1 id="aofappend-only-file"><a class="markdownIt-Anchor" href="#aofappend-only-file"></a> AOF（Append Only File）</h1>
<blockquote>
<p>默认情况下，Redis 异步转储磁盘上的数据集。RDB模式在很多应用场景中已经足够好了，但是 Redis<br />
进程的问题或断电可能会导致几分钟的写入丢失（取决于配置的保存点）。 Append Only File<br />
是另一种持久性模式，可提供更好的持久性。<br />
例如，使用默认的数据 fsync 策略（见后面的配置文件）Redis 可能会在服务器断电等戏剧性事件中丢失一秒钟的写入，或者如果<br />
Redis 进程本身发生问题，则会丢失一次写入，但是操作系统仍然正常运行。可以同时启用 AOF 和 RDB<br />
持久化。如果在启动时启用了 AOF，Redis 将加载 AOF，即具有更好持久性保证的文件。</p>
</blockquote>
<p>AOF是通过将修改的每一条指令写入一个记录文件件appendonly.aof中(先写入os cache，每隔一段时间<br />
fsync到磁盘)。这样子的话，在redis重启时，可以通过读取指令来重新写入数据达到重建数据库的目的。</p>
<h2 id="开启aof"><a class="markdownIt-Anchor" href="#开启aof"></a> 开启AOF</h2>
<p>可以通过修改配置文件来打开AOF功能与命令，配置文件中如下：</p>
<blockquote>
<p>在配置文件中将 <code>appendonly yes</code>注释打开即可</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
<p>命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config set appendonly yes</span><br></pre></td></tr></table></figure>
<h2 id="aof保存策略"><a class="markdownIt-Anchor" href="#aof保存策略"></a> AOF保存策略</h2>
<ul>
<li>appendfsync always：每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全。</li>
<li>appendfsync everysec：每秒 fsync 一次，足够快，并且在故障时只会丢失 1 秒钟的数据。</li>
<li>appendfsync no：从不 fsync ，将数据交给操作系统来处理。更快，也更不安全的选择。</li>
</ul>
<blockquote>
<p>推荐（也就是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性。</p>
</blockquote>
<h2 id="aof重写"><a class="markdownIt-Anchor" href="#aof重写"></a> AOF重写</h2>
<p>由于AOF不断的将命令追加到文件的末尾，因此随着命令的不断增加，AOF文件的体积会变的越来越大。</p>
<p>例如执行INCR命令执行了1000次，在AOF内会生成1000个操作命令。但实际上来说，只需要SET到当前值的命令就可以存储了，前面的999次INCR都是无意义的。</p>
<blockquote>
<p>实际上可能不止这一种多余的废操作，因此Redis可以对AOF文件进行重写，会把命令进行精简整合成一个新的AOF文件，新的文件里包含生成当前数据的最少命令。</p>
</blockquote>
<p>执行AOF重写的方式也有两种，一种是命令，一种是配置文件</p>
<h3 id="配置文件配置aof重写"><a class="markdownIt-Anchor" href="#配置文件配置aof重写"></a> 配置文件配置aof重写</h3>
<blockquote>
<p>默认开启重写，但需要先开始aof</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当前大小大于指定的百分比触发重写</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF 文件指定最小大小</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将此基本大小与当前大小进行比较。如果当前大小大于指定的百分比，则触发重写。此外，您还需要为要重写的 AOF<br />
文件指定最小大小，这对于避免重写 AOF 文件（即使达到百分比增加但仍然很小）很有用。指定百分比为零以禁用自动<br />
AOF 重写功能。</p>
</blockquote>
<h3 id="命令"><a class="markdownIt-Anchor" href="#命令"></a> 命令</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bgrewriteaof</span><br></pre></td></tr></table></figure>
<h1 id="rdb-与-aof对比"><a class="markdownIt-Anchor" href="#rdb-与-aof对比"></a> RDB 与 AOF对比</h1>
<h2 id="rdb"><a class="markdownIt-Anchor" href="#rdb"></a> RDB</h2>
<p><strong>优点</strong></p>
<ul>
<li>文件紧凑，很适合进行数据备份和容灾恢复</li>
<li>恢复大量数据时RDB速度快</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>数据量越大，二进制保存到磁盘会耗时越久</li>
<li>遇见意外的情况下，如宕机等，可能导致未持久化的数据完全丢失</li>
</ul>
<h2 id="aof"><a class="markdownIt-Anchor" href="#aof"></a> AOF</h2>
<p><strong>优点</strong></p>
<ul>
<li>可以使用不同的fsync策略，在默认的每秒fsync下，最多丢失1s的数据</li>
<li>AOF的持久化记录是文件追加，保存速度快</li>
<li>存储的是操作命令，AOF文件易读，可以轻易的进行文件分析</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>文件体积较RDB大</li>
<li>重启时恢复数据速度较慢</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>宕机恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>可能丢失数据</td>
<td>每秒fsync最多丢失1s数据</td>
</tr>
</tbody>
</table>
<h2 id="是rdb还是aof"><a class="markdownIt-Anchor" href="#是rdb还是aof"></a> 是rdb还是aof？</h2>
<p>使用可以根据需要来自行选择，如果对数据丢失不敏感的，使用rdb即可。当然在生产环境使用时，可以两种方式都启用。rdb文件可以用来做备份，aof文件来保证数据的安全性</p>
<h2 id="rdb与aof混用"><a class="markdownIt-Anchor" href="#rdb与aof混用"></a> RDB与AOF混用</h2>
<blockquote>
<p>必须先开启aof</p>
</blockquote>
<p>在redis4.0之后，出现了一个新的持久化选项——混合持久化。 可以通过以下配置开启混合持久化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在配置文件中设置</span></span><br><span class="line">aof‐use‐rdb‐preamble yes</span><br></pre></td></tr></table></figure>
<p>开启混合持久化后，AOF在重写时，不是单纯的把命令写入AOF文件，而是把重写这一刻之前的内存数据做RDB快照处理，在重写之后的还是继续使用AOF命令的形式保存。这样aof文件里就有历史的RDB快照和增量的AOF命令。<br />
我们知道，RDB文件的恢复速度比AOF快的多，因此这种混合的模式，在redis重启的时候能大大提升效率。</p>
<h1 id="redis淘汰机制"><a class="markdownIt-Anchor" href="#redis淘汰机制"></a> Redis淘汰机制</h1>
<p>将内存使用限制设置为指定的字节数。当达到内存限制时，Redis 将尝试根据选择的驱逐策略删除键。</p>
<p>MAXMEMORY 策略：</p>
<blockquote>
<p>当达到 maxmemory 时，Redis 将如何选择要删除的内容。可以从以下行为中选择一项</p>
</blockquote>
<p>noeviction：默认禁止驱逐数据。内存不够使用时，对申请内存的命令报错。</p>
<p>volatile-lru：从设置了过期时间的数据集中淘汰最近没使用的数据。</p>
<p>volatile-ttl：从设置了过期时间的数据集中淘汰即将要过期的数据。</p>
<p>volatile-random：从设置了过期时间的数据中随机淘汰数据。</p>
<p>allkeys-lru：淘汰最近没使用的数据。</p>
<p>allkeys-random：随机淘汰数据。</p>
<blockquote>
<p>注意：使用上述任何一种策略，当没有合适的键用于驱逐时，Redis<br />
将在需要更多内存的写操作时返回错误。这些通常是创建新密钥、添加数据或修改现有密钥的命令。一些示例是：SET、INCR、HSET、LPUSH、SUNIONSTORE、SORT（由于<br />
STORE 参数）和 EXEC（如果事务包括任何需要内存的命令）。</p>
</blockquote>
<p>如果 Redis 无法根据策略删除键，或者如果策略设置为“noeviction”，Redis 将开始对会使用更多内存的命令（如<br />
SET、LPUSH 等）回复错误信息，并将继续回复像 GET<br />
这样的只读命令。简而言之…如果附加了副本，建议为 maxmemory 设置一个下限，以便系统上有一些空闲 RAM<br />
用于副本输出缓冲区（但如果策略是“noeviction”，则不需要这样做）</p>
<p>警告：如果您将副本附加到启用了 maxmemory<br />
的实例，则从使用的内存计数中减去提供副本所需的输出缓冲区的大小，以便网络问题重新同步不会触发密钥被逐出的循环，并且在将副本的输出缓冲区填满，删除键的<br />
DEL<br />
触发删除更多键，依此类推，直到数据库完全清空</p>
]]></content>
      <categories>
        <category>redis</category>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy-splash对接代理</title>
    <url>/3018.html</url>
    <content><![CDATA[<h2 id="scrapy-splash使用及代理失败处理"><a class="markdownIt-Anchor" href="#scrapy-splash使用及代理失败处理"></a> Scrapy-Splash使用及代理失败处理</h2>
<p>在日常做爬虫的时候肯定遇到这么一些问题，网页js渲染，接口加密等，以至于无法有效的获取数据，那么此时若想获取数据大致有两种方向，<code>硬刚加密参数</code><br />
或<code>使用渲染工具</code></p>
<p>二者的各有所不同？</p>
<p>刚加密参数：</p>
<ul>
<li>
<p>优势：爬取速度快，实效性。损耗资源更少</p>
</li>
<li>
<p>劣势：耗费时间长，不懂的完全不会，会的也不一定能完全处理。难以在有效的时间内获取到数据</p>
</li>
</ul>
<span id="more"></span>
<p>渲染工具：webdervi，puppeteer，pyppeteer，splash</p>
<ul>
<li>优势：见效快、新手友好</li>
<li>劣势：爬取速度较慢、数据实效性难以保证、损耗资源多</li>
</ul>
<p>那么相信做爬虫的小伙伴一定会有相对应的权衡</p>
<blockquote>
<p>个人建议：如果可以刚参数，尽量刚参数。一方面是为了自己的在爬虫这条路上逐步前进，另一方面是更加符合</p>
<p>当然如果实在搞不掉了，也可以使用渲染工具来进行模拟爬取</p>
</blockquote>
<h3 id="splash是什么"><a class="markdownIt-Anchor" href="#splash是什么"></a> splash是什么？</h3>
<p><strong>Splash-一种JavaScript渲染服务</strong></p>
<p>Splash是一种javascript渲染服务。这是一个带有HTTP API的轻量级Web浏览器，使用Twisted和QT5在Python<br />
3中实现。（扭曲的）QT反应器用于使服务完全异步，从而允许通过QT主循环利用Webkit并发性。Splash的一些功能：</p>
<ul>
<li>并行处理多个网页；</li>
<li>获取HTML结果和/或获取屏幕截图；</li>
<li>关闭图片或使用Adblock Plus规则来加快渲染速度；</li>
<li>在页面上下文中执行自定义JavaScript；</li>
<li></li>
</ul>
<p>编写Lua浏览<span class="exturl" data-url="aHR0cHM6Ly9zcGxhc2gucmVhZHRoZWRvY3MuaW8vZW4vc3RhYmxlL3NjcmlwdGluZy10dXRvcmlhbC5odG1sI3NjcmlwdGluZy10dXRvcmlhbA==">脚本<i class="fa fa-external-link-alt"></i></span>;</p>
<ul>
<li>在<span class="exturl" data-url="aHR0cHM6Ly9zcGxhc2gucmVhZHRoZWRvY3MuaW8vZW4vc3RhYmxlL2tlcm5lbC5odG1sI3NwbGFzaC1qdXB5dGVy">Splash-Jupyter<i class="fa fa-external-link-alt"></i></span><br />
Notebook中开发Splash Lua脚本。</li>
<li>以HAR格式获取详细的渲染信息。</li>
</ul>
<p>话不多说，直接上splash。谁让我菜呢？</p>
<h3 id="splash的安装"><a class="markdownIt-Anchor" href="#splash的安装"></a> splash的安装</h3>
<p>官方建议直接使用docker进行运行，<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZ2V0LWRvY2tlci8=">docker安装<i class="fa fa-external-link-alt"></i></span></p>
<p>安装完成之后直接运行一下命令，使用docker运行splash</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取splash</span></span><br><span class="line">docker pull scrapinghub/splash</span><br><span class="line"><span class="comment"># 运行splash </span></span><br><span class="line">docker run -p 8050:8050 --name splash scrapinghub/splash</span><br><span class="line">docker run -itd --name splash  -p 8050:8050 scrapinghub/splash --disable-lua-sandbox</span><br><span class="line"><span class="comment"># -p 向外暴露端口</span></span><br><span class="line"><span class="comment"># -d 守护进程方式运行(后台运行)</span></span><br><span class="line"><span class="comment"># --name 自定义昵称</span></span><br><span class="line"><span class="comment"># --disable-lua-sandbox 关闭沙盒模式。如果是在测试环境上可以直接去体验一下，功能更全。如果是在开发环境的话那就直接用正式的，虽然花里胡哨，但安全性并不好</span></span><br></pre></td></tr></table></figure>
<p>此时你若无意外你可以访问’<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDUwLw==">http://localhost:8050/<i class="fa fa-external-link-alt"></i></span>'，就可以看到这样的画面</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1glt2mblmo3j31kh0u0q51.jpg" alt="" /></p>
<p>ok，到这里你就可以正常的使用它了，此时对于新手朋友的关照就已经结束了。接下来让我们对接scrapy。请确保scrapy可以正常运行。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建项目</span></span><br><span class="line">scrapy startproject &lt;projectName&gt;</span><br><span class="line"><span class="comment"># 创建spider</span></span><br><span class="line"><span class="built_in">cd</span> &lt;projectName&gt;</span><br><span class="line">scrapy genspider httpbin httpbin.org/get</span><br></pre></td></tr></table></figure>
<p>此时的项目结构应该如下</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1glt3ab0oyij30kc0fc3yn.jpg" alt="" /></p>
<h3 id="scrapy-splash试用前配置"><a class="markdownIt-Anchor" href="#scrapy-splash试用前配置"></a> scrapy-splash试用前配置</h3>
<h4 id="安装依赖"><a class="markdownIt-Anchor" href="#安装依赖"></a> 安装依赖</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip3 install scrapy-splash</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cDovL3NldHRpbmdzLnB5">settings.py<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改</span></span><br><span class="line">SPIDER_MIDDLEWARES = &#123;</span><br><span class="line">    <span class="string">&#x27;scrapy_splash.SplashDeduplicateArgsMiddleware&#x27;</span>: <span class="number">100</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">    <span class="string">&#x27;scrapy_splash.SplashCookiesMiddleware&#x27;</span>: <span class="number">723</span>,</span><br><span class="line">    <span class="string">&#x27;scrapy_splash.SplashMiddleware&#x27;</span>: <span class="number">725</span>,</span><br><span class="line">    <span class="string">&#x27;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&#x27;</span>: <span class="number">810</span>,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure scrapy-splash(加入)</span></span><br><span class="line">SPLASH_URL = <span class="string">&#x27;http://localhost:8050&#x27;</span></span><br><span class="line">DUPEFILTER_CLASS = <span class="string">&#x27;scrapy_splash.SplashAwareDupeFilter&#x27;</span></span><br><span class="line">HTTPCACHE_STORAGE = <span class="string">&#x27;scrapy_splash.SplashAwareFSCacheStorage&#x27;</span></span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cDovL0h0dGJpbi5weQ==">Httbin.py<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy_splash <span class="keyword">import</span> SplashRequest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttbinSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&#x27;httpbin&#x27;</span></span><br><span class="line">    <span class="comment"># allowed_domains = [&#x27;httbin.org/get&#x27;]</span></span><br><span class="line">    start_urls = [<span class="string">&#x27;https://httpbin.org/get&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_requests</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.start_urls[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">yield</span> SplashRequest(</span><br><span class="line">            url=<span class="variable language_">self</span>.start_urls[<span class="number">0</span>],</span><br><span class="line">            callback=<span class="variable language_">self</span>.parse</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(response)</span><br><span class="line">        <span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行爬虫</span></span><br><span class="line">scrapy crawl httpbin</span><br></pre></td></tr></table></figure>
<p>返回打印结果如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">2020-12-19 13:21:51 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://httpbin.org/get via http://localhost:8050/render.html&gt; (referer: None)</span><br><span class="line">&lt;200 https://httpbin.org/get&gt;</span><br><span class="line">&lt;html&gt;&lt;<span class="built_in">head</span>&gt;&lt;/head&gt;&lt;body&gt;&lt;pre style=<span class="string">&quot;word-wrap: break-word; white-space: pre-wrap;&quot;</span>&gt;&#123;</span><br><span class="line">  <span class="string">&quot;args&quot;</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">&quot;headers&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;en&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;httpbin.org&quot;</span>, </span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Scrapy/2.4.0 (+https://scrapy.org)&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Amzn-Trace-Id&quot;</span>: <span class="string">&quot;Root=1-5fdd8dea-4ba769963b76178b56cd9724&quot;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">&quot;origin&quot;</span>: <span class="string">&quot;220.202.249.12&quot;</span>, </span><br><span class="line">  <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://httpbin.org/get&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">---略</span><br></pre></td></tr></table></figure>
<p>我们用浏览器访问一下&quot;<span class="exturl" data-url="aHR0cHM6Ly9odHRwYmluLm9yZy9nZXQ=">https://httpbin.org/get<i class="fa fa-external-link-alt"></i></span>&quot;</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;args&quot;</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">&quot;headers&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate, br&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;zh-CN,zh;q=0.9,en;q=0.8,ja;q=0.7&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Dnt&quot;</span>: <span class="string">&quot;1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;httpbin.org&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Sec-Fetch-Dest&quot;</span>: <span class="string">&quot;document&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Sec-Fetch-Mode&quot;</span>: <span class="string">&quot;navigate&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Sec-Fetch-Site&quot;</span>: <span class="string">&quot;none&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Sec-Fetch-User&quot;</span>: <span class="string">&quot;?1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Upgrade-Insecure-Requests&quot;</span>: <span class="string">&quot;1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 11_0_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Amzn-Trace-Id&quot;</span>: <span class="string">&quot;Root=1-5fdd8e50-48c6e9ec6dc7274967b9a493&quot;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">&quot;origin&quot;</span>: <span class="string">&quot;220.202.249.12&quot;</span>, </span><br><span class="line">  <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://httpbin.org/get&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ok，基本的使用也就到这里ok了。那么该如何配置代理呢？访问量一大大多情况下都会封ip</p>
<h4 id="设置代理"><a class="markdownIt-Anchor" href="#设置代理"></a> 设置代理</h4>
<p>如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">import scrapy</span><br><span class="line">from scrapy_splash import SplashRequest</span><br><span class="line"></span><br><span class="line">class HttbinSpider(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&#x27;httbin&#x27;</span></span><br><span class="line">    <span class="comment"># allowed_domains = [&#x27;httbin.org/get&#x27;]</span></span><br><span class="line">    start_urls = [<span class="string">&#x27;https://httpbin.org/get&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    def start_requests(self):</span><br><span class="line">        <span class="built_in">print</span>(self.start_urls[0])</span><br><span class="line">        header = &#123;</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Linux; U; Android 0.5; en-us) AppleWebKit/522  (KHTML, like Gecko) Safari/419.3&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># yield scrapy.Request(url=self.start_urls[0], callback=self.parse, headers=header)</span></span><br><span class="line">        yield SplashRequest(</span><br><span class="line">            url=self.start_urls[0],</span><br><span class="line">            callback=self.parse,</span><br><span class="line">            args=&#123;</span><br><span class="line">                <span class="string">&quot;wait&quot;</span>: 3,</span><br><span class="line">                <span class="string">&quot;proxy&quot;</span>: <span class="string">&#x27;http://119.114.100.159:22992&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    def parse(self, response, **kwargs):</span><br><span class="line">        <span class="built_in">print</span>(response)</span><br><span class="line">        <span class="built_in">print</span>(response.text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果如下</span></span><br><span class="line">2020-12-19 13:31:06 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://httpbin.org/get via http://localhost:8050/render.html&gt; (referer: None)</span><br><span class="line">&lt;200 https://httpbin.org/get&gt;</span><br><span class="line">&lt;html&gt;&lt;<span class="built_in">head</span>&gt;&lt;/head&gt;&lt;body&gt;&lt;pre style=<span class="string">&quot;word-wrap: break-word; white-space: pre-wrap;&quot;</span>&gt;&#123;</span><br><span class="line">  <span class="string">&quot;args&quot;</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">&quot;headers&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;en&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;httpbin.org&quot;</span>, </span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Scrapy/2.4.0 (+https://scrapy.org)&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Amzn-Trace-Id&quot;</span>: <span class="string">&quot;Root=1-5fdd9017-7ef5ac1d6c66d99b52b200c0&quot;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">&quot;origin&quot;</span>: <span class="string">&quot;119.114.100.159&quot;</span>,  <span class="comment"># 代理修改完成</span></span><br><span class="line">  <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://httpbin.org/get&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>使用中间件的方式设置代理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHttpProxyMiddleware</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_request</span>(<span class="params">self, request, spider</span>):</span><br><span class="line">        request.meta[<span class="string">&#x27;splash&#x27;</span>][<span class="string">&#x27;args&#x27;</span>][<span class="string">&#x27;proxy&#x27;</span>] = proxyServer  <span class="comment"># （eg：&#x27;http://119.114.100.159:22992&#x27;）</span></span><br><span class="line">    <span class="comment"># 认证消息，没有可以不写</span></span><br><span class="line">    <span class="comment"># request.headers[&quot;Proxy-Authorization&quot;] = proxyAuth</span></span><br></pre></td></tr></table></figure>
<p>此时的中间件设置为</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">    <span class="string">&#x27;learnSplash.middlewares.MyHttpProxyMiddleware&#x27;</span>: 724,</span><br><span class="line">    <span class="string">&#x27;learnSplash.middlewares.MyUserAgentMiddleware&#x27;</span>: 400,</span><br><span class="line">    <span class="string">&#x27;scrapy_splash.SplashCookiesMiddleware&#x27;</span>: 723,</span><br><span class="line">    <span class="string">&#x27;scrapy_splash.SplashMiddleware&#x27;</span>: 725,</span><br><span class="line">    <span class="string">&#x27;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&#x27;</span>: 810,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对接代理错误点总结"><a class="markdownIt-Anchor" href="#对接代理错误点总结"></a> 对接代理错误点总结</h3>
<ol>
<li>
<pre class="highlight"><code class="python"><span class="comment"># settings中</span>
SPLASH_URL = <span class="string">&#x27;http://localhost:8050&#x27;</span>
错写成SPLASH_URL = <span class="string">&#x27;localhost:8050&#x27;</span> (错误。验证方式command+鼠标左点击，若能正常显示splash页面即可)
&lt;!--code￼<span class="number">11</span>--&gt;

</code></pre>
</li>
<li>
<pre class="highlight"><code class="python"><span class="comment"># 中间键设置代理</span>
<span class="comment"># 错误点一：书写格式不对，缺少http等字段</span>
<span class="comment"># 权重设置错误</span>
DOWNLOADER_MIDDLEWARES = &#123;
    <span class="string">&#x27;learnSplash.middlewares.MyHttpProxyMiddleware&#x27;</span>: <span class="number">724</span>,
    <span class="string">&#x27;learnSplash.middlewares.MyUserAgentMiddleware&#x27;</span>: <span class="number">400</span>,
    <span class="string">&#x27;scrapy_splash.SplashCookiesMiddleware&#x27;</span>: <span class="number">723</span>,
    <span class="string">&#x27;scrapy_splash.SplashMiddleware&#x27;</span>: <span class="number">725</span>,
    <span class="string">&#x27;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&#x27;</span>: <span class="number">810</span>,

&#125;
<span class="comment"># MyHttpProxyMiddleware的权重必须小于等于725，否则设定不成功。将使用原始ip访问</span>
</code></pre>
</li>
</ol>
<h3 id="referer"><a class="markdownIt-Anchor" href="#referer"></a> Referer</h3>
<h3 id="官方文档"><a class="markdownIt-Anchor" href="#官方文档"></a> <span class="exturl" data-url="aHR0cHM6Ly9zcGxhc2gucmVhZHRoZWRvY3MuaW8vZW4vc3RhYmxlLw==">官方文档<i class="fa fa-external-link-alt"></i></span></h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Bvd2VyU3BpZGVyL1NjcmFweVNwbGFzaFRlc3Q=">完整代码<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>scrapy</category>
        <category>splash</category>
        <category>scrapy-splash</category>
      </categories>
      <tags>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>sql,何必在忆-基础篇</title>
    <url>/44075.html</url>
    <content><![CDATA[<p>还记得那是在2018年的十月的某个日子，虽早已入秋，但夏日的炎热却丝毫不减退散。那时的我正捧着一本<code>SQL Server程序设计</code><br />
的白蓝皮书与九栋315的狗子们，匆匆的走向<code>j1-402</code>进行了我们人生中第一次<code>SQL数据库的学习</code><br />
，时光总是戏人，现实总是玩笑。当初的几个伙伴都走向了各行各业，而唯有我编程课，问啥啥不会，写啥啥就废的我进入了IT行业。说来实在嘲讽，缅怀那些我错过的编程课，致那些年说过无数次“让我学<code>SQL</code><br />
,根本不可能”，我承认我打脸了。正如此章的title一般，“SQL语句， 何必在忆？”</p>
<p>很久之前就学了SQL，然而又忘记，今天正式系统的性的回顾一下，温故而知新。可以为师矣</p>
<span id="more"></span>
<h2 id="表属性"><a class="markdownIt-Anchor" href="#表属性"></a> 表属性</h2>
<h3 id="表的属性"><a class="markdownIt-Anchor" href="#表的属性"></a> 表的属性</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">存储引擎:</span><br><span class="line">InnoDB（默认的）</span><br><span class="line">字符集和排序规则:</span><br><span class="line">utf8</span><br><span class="line">utf8mb4</span><br></pre></td></tr></table></figure>
<h3 id="列的属性"><a class="markdownIt-Anchor" href="#列的属性"></a> 列的属性</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">约束(一般建表时添加):</span><br><span class="line">primary key ：主键约束</span><br><span class="line">设置为主键的列，此列的值必须非空且唯一，主键在一个表中只能有一个，但是可以有多个列一起构成。 作为聚簇索引</span><br><span class="line">not null      ：非空约束</span><br><span class="line">列值不能为空，也是表设计的规范，尽可能将所有的列设置为非空。可以设置默认值为0</span><br><span class="line">unique key ：唯一键</span><br><span class="line">列值不能重复</span><br><span class="line">unsigned ：无符号</span><br><span class="line">针对数字列，非负数。</span><br><span class="line"></span><br><span class="line">其他属性:</span><br><span class="line">key :索引</span><br><span class="line">可以在某列上建立索引，来优化查询,一般是根据需要后添加</span><br><span class="line">default           :默认值</span><br><span class="line">列中，没有录入值时，会自动使用default的值填充</span><br><span class="line">auto_increment:自增长</span><br><span class="line">针对数字列，顺序的自动填充数据（默认是从1开始，将来可以设定起始点和偏移量）</span><br><span class="line">comment : 注释</span><br></pre></td></tr></table></figure>
<h3 id="sql_mode"><a class="markdownIt-Anchor" href="#sql_mode"></a> sql_mode</h3>
<p>作用：影响sql执行行为，规范SQL语句的书写方式(例如除数不能为0)</p>
<p>可以使用select @sql_mode查看(各版本有所出入)</p>
<h3 id="字符集charset及校对规则collation"><a class="markdownIt-Anchor" href="#字符集charset及校对规则collation"></a> 字符集(charset)及校对规则(Collation)</h3>
<h4 id="字符集"><a class="markdownIt-Anchor" href="#字符集"></a> 字符集</h4>
<ul>
<li>utf8：最大存储长度，单个字符最多3字节</li>
<li>utf8mb4：最大存储长度，单个字符最多4字节</li>
</ul>
<p>常用于建库建表时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database dbname charset utf8mb4;</span><br><span class="line"># 查看数据库的字符集合</span><br><span class="line">show create database dbname;</span><br></pre></td></tr></table></figure>
<h4 id="校对规则"><a class="markdownIt-Anchor" href="#校对规则"></a> 校对规则</h4>
<p>每种字符集，有多种校对规则(排序)，例如常见的ASCII编码表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show collation;</span><br></pre></td></tr></table></figure>
<p>作用：影响排序的操作</p>
<h3 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h3>
<h4 id="text类型"><a class="markdownIt-Anchor" href="#text类型"></a> text类型</h4>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmd63x1tzoj311o0u0go0.jpg" alt="" /></p>
<h4 id="number类型"><a class="markdownIt-Anchor" href="#number类型"></a> Number类型</h4>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmd64lw40rj313c0kegn5.jpg" alt="" /></p>
<p><code>*</code>:这些整数类型拥有额外的选项 UNSIGNED。通常，整数可以是负数或正数。如果添加 UNSIGNED 属性，那么范围将从<br />
0 开始，而不是某个负数。</p>
<h4 id="date类型"><a class="markdownIt-Anchor" href="#date类型"></a> Date类型</h4>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmd66b11g5j313o0piabh.jpg" alt="" /></p>
<p><code>*</code>即便 DATETIME 和 TIMESTAMP 返回相同的格式，它们的工作方式很不同。在 INSERT 或 UPDATE 查询中，TIMESTAMP<br />
自动把自身设置为当前的日期和时间。TIMESTAMP 也接受不同的格式，比如<br />
YYYYMMDDHHMMSS、YYMMDDHHMMSS、YYYYMMDD 或 YYMMDD。</p>
<h2 id="什么是sql语句"><a class="markdownIt-Anchor" href="#什么是sql语句"></a> 什么是SQL语句</h2>
<p>SQL语句是结构化查询语言(Structured Query Language)<br />
的简称,是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。</p>
<h2 id="sql语句的类型"><a class="markdownIt-Anchor" href="#sql语句的类型"></a> SQL语句的类型</h2>
<p>数据查询语言（<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9EUUw=">DQL<i class="fa fa-external-link-alt"></i></span>:Data Query<br />
Language）：其语句，也称为“数据检索<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglQUYlQUQlRTUlOEYlQTU=">语句<i class="fa fa-external-link-alt"></i></span><br />
”，用以从表中获得数据，确定数据怎样在应用程序给出。保留字<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9TRUxFQ1QvMTA3MzUwNjg=">SELECT<i class="fa fa-external-link-alt"></i></span><br />
是DQL（也是所有SQL）用得最多的动词，其他DQL常用的保留字有WHERE，ORDER<br />
BY，GROUP BY和HAVING。这些DQL保留字常与其它类型的SQL语句一起使用。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTUlQjAlRTYlOEQlQUUlRTYlOTMlOEQlRTQlQkQlOUMlRTglQUYlQUQlRTglQTglODA=">数据操作语言<i class="fa fa-external-link-alt"></i></span>（DML：Data Manipulation<br />
Language）：其语句包括动词<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9JTlNFUlQ=">INSERT<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9VUERBVEU=">UPDATE<i class="fa fa-external-link-alt"></i></span><br />
和<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9ERUxFVEU=">DELETE<i class="fa fa-external-link-alt"></i></span>。它们分别用于添加、修改和删除。</p>
<p>事务控制语言（TCL）：它的语句能确保被DML语句影响的表的所有行及时得以更新。包括COMMIT（提交）命令、SAVEPOINT（保存点）命令、ROLLBACK（回滚）命令。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTUlQjAlRTYlOEQlQUUlRTYlOEUlQTclRTUlODglQjYlRTglQUYlQUQlRTglQTglODA=">数据控制语言<i class="fa fa-external-link-alt"></i></span><br />
（DCL）：它的语句通过GRANT或REVOKE实现权限控制，确定单个用户和用户组对<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTUlQjAlRTYlOEQlQUUlRTUlQkElOTMlRTUlQUYlQjklRTglQjElQTE=">数据库对象<i class="fa fa-external-link-alt"></i></span><br />
的访问。某些RDBMS可用GRANT或REVOKE控制对<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglQTElQTglRTUlOEQlOTU=">表单<i class="fa fa-external-link-alt"></i></span>个列的访问。</p>
<p>数据定义语言（<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9EREwvMjE5OTc=">DDL<i class="fa fa-external-link-alt"></i></span><br />
）：其语句包括动词CREATE,ALTER和DROP。在数据库中创建新表或修改、删除表（CREATE TABLE 或 DROP<br />
TABLE）；为表加入索引等。</p>
<p>指针控制语言（CCL）：它的语句，像DECLARE CURSOR，FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。</p>
<p>比较常用的有<code>DDL(数据定义语言)</code>`DCL(数据控制语言)<code>\</code>DML(数据操作语言)<code>\</code>DQL(数据查询语言)`</p>
<h2 id="sql"><a class="markdownIt-Anchor" href="#sql"></a> SQL</h2>
<h3 id="client"><a class="markdownIt-Anchor" href="#client"></a> Client</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?         (\?) Synonym for `help&#x27;.           # 帮助信息                                                                                </span><br><span class="line">clear     (\c) Clear the current input statement.  清空此行sql                                                                         </span><br><span class="line">connect   (\r) Reconnect to the server. Optional arguments are db and host.                                                  </span><br><span class="line">delimiter (\d) Set statement delimiter.                                                                                      </span><br><span class="line">edit      (\e) Edit command with $EDITOR.                                                                                    </span><br><span class="line">ego       (\G) Send command to mysql server, display result vertically. 格式化输出</span><br><span class="line">exit      (\q) Exit mysql. Same as quit. 退出登陆 ctrl(control) + d </span><br><span class="line">go        (\g) Send command to mysql server.</span><br><span class="line">help      (\h) Display this help.</span><br><span class="line">nopager   (\n) Disable pager, print to stdout.</span><br><span class="line">tee       (\T) Set outfile [to_outfile]. Append everything into given outfile. # 记录日志（语句+结果） eg:tee /tmp/mysql.log</span><br><span class="line">notee     (\t) Don&#x27;t write into outfile. 不记录日志</span><br><span class="line">pager     (\P) Set PAGER [to_pager]. Print the query results via PAGER.</span><br><span class="line">print     (\p) Print current command.</span><br><span class="line">prompt    (\R) Change your mysql prompt.</span><br><span class="line">quit      (\q) Quit mysql.</span><br><span class="line">rehash    (\#) Rebuild completion hash.</span><br><span class="line">source    (\.) Execute an SQL script file. Takes a file name as an argument. 导入脚步，相当于 &lt;</span><br><span class="line">status    (\s) Get status information from the server.</span><br><span class="line">system    (\!) Execute a system shell command.</span><br><span class="line">use       (\u) Use another database. Takes database name as argument.</span><br><span class="line">charset   (\C) Switch to another charset. Might be needed for processing binlog with multi-byte charsets.</span><br><span class="line">warnings  (\W) Show warnings after every statement.</span><br><span class="line">nowarning (\w) Don&#x27;t show warnings after every statement.</span><br><span class="line">resetconnection(\x) Clean session context.</span><br></pre></td></tr></table></figure>
<h3 id="server"><a class="markdownIt-Anchor" href="#server"></a> server</h3>
<h4 id="ddl-数据定义语言"><a class="markdownIt-Anchor" href="#ddl-数据定义语言"></a> DDL 数据定义语言</h4>
<p>在日常中DDL多用于库、表的管理.</p>
<p><strong>库名与库属性</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#增</span><br><span class="line"><span class="keyword">create</span></span><br><span class="line">database dbname</span><br><span class="line">eg: <span class="keyword">create</span></span><br><span class="line">database dbname charset utf8mb4</span><br><span class="line">## 删</span><br><span class="line"><span class="keyword">drop</span></span><br><span class="line">database dbname</span><br><span class="line">## 改 (从小到大改</span><br><span class="line">， utf8 <span class="operator">-</span><span class="operator">&gt;</span> utf8mb4, 严格超集)</span><br><span class="line"><span class="keyword">alter</span></span><br><span class="line">database dbname 将修改的属性名 将要修改的属性值</span><br><span class="line">## 查</span><br><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建库规范：</p>
<p>1.库名不能有大写字母,不能太长(&lt;30字符) 多平台兼容性问题</p>
<p>2.建库要加字符集</p>
<p>3.库名不能有数字开头</p>
<p>4.库名要和业务相关</p>
</blockquote>
<p><strong>表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">增加</span><br><span class="line"><span class="keyword">create table</span> tableName</span><br><span class="line">(</span><br><span class="line">    列<span class="number">1</span> 属性（数据类型、约束、其他属性） ， 列<span class="number">2</span> 属性， 列<span class="number">3</span> 属性</span><br><span class="line">) eg:</span><br><span class="line"><span class="keyword">CREATE TABLE</span> student</span><br><span class="line">(</span><br><span class="line">    id      <span class="type">INT</span>          <span class="keyword">NOT NULL</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line">    sname   <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    sage    TINYINT UNSIGNED <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    sgender ENUM(<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;n&#x27;</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;n&#x27;</span> COMMENT <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">    sfz     <span class="type">CHAR</span>(<span class="number">18</span>)     <span class="keyword">NOT NULL</span> <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;身份证&#x27;</span>,</span><br><span class="line">    intime  <span class="type">TIMESTAMP</span>    <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> NOW() COMMENT <span class="string">&#x27;入学时间&#x27;</span></span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB CHARSET<span class="operator">=</span>utf8 COMMENT <span class="string">&#x27;学生表&#x27;</span>;</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line"><span class="type">INT</span> <span class="keyword">NOT NULL</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;全局id&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> TableName2 <span class="keyword">LIKE</span> TableName1;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">删除表</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> tableName</span><br><span class="line"></span><br><span class="line">    # 修改</span><br><span class="line"><span class="keyword">ALTER TABLE</span> tableName <span class="keyword">ADD</span>(<span class="keyword">DROP</span>) 属性（数据类型、约束、其他属性）</span><br><span class="line">eg:</span><br><span class="line"># 在stuent表中添加qq列</span><br><span class="line"><span class="keyword">ALTER TABLE</span> student</span><br><span class="line">    <span class="keyword">ADD</span> qq <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;qq&#x27;</span>;</span><br><span class="line">#</span><br><span class="line">在sname后加微信列</span><br><span class="line"><span class="keyword">ALTER TABLE</span> student</span><br><span class="line">    <span class="keyword">ADD</span> wechat <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT NULL</span> <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;微信号&#x27;</span> AFTER sname;</span><br><span class="line">#</span><br><span class="line">在id列前加一个新列num</span><br><span class="line"><span class="keyword">ALTER TABLE</span> student</span><br><span class="line">    <span class="keyword">ADD</span> num <span class="type">INT</span> <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;数字&#x27;</span> <span class="keyword">FIRST</span>;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">删除列</span><br><span class="line"><span class="keyword">ALTER TABLE</span> stu <span class="keyword">DROP</span> num;</span><br><span class="line"><span class="keyword">ALTER TABLE</span> stu <span class="keyword">DROP</span> qq;</span><br><span class="line"><span class="keyword">ALTER TABLE</span> stu <span class="keyword">DROP</span> wechat;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">将sgender 改为 sg 数据类型改为 <span class="type">CHAR</span> 类型</span><br><span class="line"><span class="keyword">ALTER TABLE</span> student change sgender sg <span class="type">CHAR</span> (<span class="number">1</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">用的时候</span><br><span class="line">，</span><br><span class="line">一定要注意</span><br><span class="line">：</span><br><span class="line">修改数据类型</span><br><span class="line">，修改字段位置  <span class="comment">---用modify</span></span><br><span class="line">修改名字 <span class="comment">--就用change</span></span><br><span class="line"># 范围大用change</span><br><span class="line">，小用modify</span><br><span class="line">。</span><br><span class="line"># 均需要加入类型</span><br><span class="line">，限制</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>表名小写</li>
<li>不能是数字开头</li>
<li>注意字符集和存储引擎</li>
<li>表名和业务有关</li>
<li>选择合适的数据类型，简短的、长度合适的数据类型</li>
<li>每个列都要有注释</li>
<li>每个列设置为非空，无法保证非空，用0来填充。</li>
<li>必须有主键</li>
</ol>
</blockquote>
<h4 id="dcl-数据控制语言"><a class="markdownIt-Anchor" href="#dcl-数据控制语言"></a> DCL 数据控制语言</h4>
<p>控制就是操作权限，而在DCL之中，主要有两个语法：GRANT,REVOKE</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 用户管理</span><br><span class="line">create user xxx@&quot;白名单&quot; indentified by &quot;password&quot;</span><br><span class="line">drop user</span><br><span class="line">alter user</span><br><span class="line">select user,host from mysql.user;</span><br><span class="line"># 权限</span><br><span class="line">## 查看所有权限列表</span><br><span class="line">show privileges;</span><br><span class="line">all </span><br><span class="line">with grant option</span><br><span class="line"></span><br><span class="line"># 查看用户权限</span><br><span class="line">show grant UserName@&quot;白名单&quot;</span><br><span class="line">select * from mysql.user\G; </span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmfo1pre7wj31hy0u0afz.jpg" alt="" /></p>
<p><strong>DCL</strong></p>
<p>授权</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant 权限 on 对象 to 用户 identified by “密码”</span><br><span class="line"># mysql 8.0+:(中文表示，可自定制)</span><br><span class="line">create user 用户 identified by “密码”</span><br><span class="line">grant 权限1，权限2，权限3... on 对象 to 用户 identified by “密码”</span><br></pre></td></tr></table></figure>
<p>权限:<br />
ALL: 管理员(不包含“ Grant option”，给他人授权)<br />
权限1，权限2，权限3…： 普通人员(开发人员)<br />
Grant option</p>
<p>对象范围:  库，表</p>
<table>
<thead>
<tr>
<th style="text-align:center">“.”</th>
<th style="text-align:center">—&gt; chmod -R 755 /</th>
<th style="text-align:center">管理员</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">userName.*</td>
<td style="text-align:center">—&gt; chmod -R 755 userName/</td>
<td style="text-align:center">普通用户</td>
</tr>
<tr>
<td style="text-align:center">userName.t1</td>
<td style="text-align:center">—&gt; chmod -R 755 userName/t1</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 授权</span><br><span class="line">grant create update, select ... on 库名.表的范围[*(所有), 表名1] to userName@“白名单”</span><br></pre></td></tr></table></figure>
<p>Mysql授权表</p>
<table>
<thead>
<tr>
<th style="text-align:center">user</th>
<th style="text-align:center"><em>.</em></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">db</td>
<td style="text-align:center">db.*</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">Tables_priv</td>
<td style="text-align:center">db.table</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">Colums</td>
<td style="text-align:center">列</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">Procs_priv</td>
<td style="text-align:center">存储过程中的权限</td>
<td></td>
</tr>
</tbody>
</table>
<p>回收权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">revoke 权限 on 库 from 用户@“白名单”</span><br><span class="line"># 具体eg如上</span><br></pre></td></tr></table></figure>
<p>拓展，忘记root密码了该怎么办？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 需知</span><br><span class="line"># --skip-grant-tables 跳过授权表</span><br><span class="line"># --skip-network  关闭TCP/IP连接</span><br><span class="line"></span><br><span class="line"># 1.关闭数据库(任选其一)</span><br><span class="line">service mysqld stop</span><br><span class="line">/etc/init.d/mysqld stop</span><br><span class="line">pkill mysqld</span><br><span class="line"></span><br><span class="line"># 2.跳过验证(任选其一)</span><br><span class="line">service mysqld start --skip-grant-tables</span><br><span class="line">service mysqld restart --skip-grant-tables</span><br><span class="line">mysql_safe --skip-grant-tables &amp;</span><br><span class="line"></span><br><span class="line"># 3.禁止远程连接</span><br><span class="line">service mysqld start --skip-grant-tables --skip-network </span><br><span class="line">service mysqld restart --skip-grant-tables --skip-network</span><br><span class="line"></span><br><span class="line"># 4.修改密码</span><br><span class="line">## 4.1手动加载授权表</span><br><span class="line">flush privileges</span><br><span class="line">## 4.2修改密码</span><br><span class="line">alter user root@&quot;localhost&quot; indentified by &quot;new Passwd&quot;</span><br><span class="line"></span><br><span class="line"># 5.重启数据库</span><br><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>
<p><strong>原理探究</strong></p>
<p>说到这个，那就不得不从mysql的<code>server</code>层说起了，mysql的架构图如下(仅关键部分)</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmgl5sg1n2j30rq0ic3yp.jpg" alt="" /></p>
<p>当我们忘记密码的时候,改怎么办呢？</p>
<p>这就对于我们平时对于mysql的模型有所考察了，如果你知道mysql的他内部到底是如何运行的,那么只需要在合适的地方，按照我们所想的给他“绕道而行”，是否就可以绕过这个密码验证了呢？答案是当然可以的。</p>
<p>首先我们介绍一下上面这副图中执行流程，当我们启动mysql服务的时候，系统会自动帮我们做一下这些事儿</p>
<ol>
<li>首先提供可连接的协议，也就是提供服务</li>
<li>打开用户与密码校验，以处理将要连接的客户</li>
<li>验证成功，分配独立的连接线程</li>
</ol>
<p>如果我们需要跳过密码校验,那么只需要做以下几件事。</p>
<ol>
<li>让系统重启</li>
<li>在重启的过程中停掉用户与密码校验</li>
</ol>
<p>这样我们就可以连接了，但是还不够。尽然已经停掉了。此时的我们无法修改密码.(<br />
跳过验证，而不是把验证功能移除了)</p>
<p>那么我们此时还需要把验证功能加载进来，然后对验证的表进行修改。</p>
<h4 id="dml-数据操作语言"><a class="markdownIt-Anchor" href="#dml-数据操作语言"></a> DML 数据操作语言</h4>
<p>这个也是我们日常中用的最多的地方，应为建库表，改权限，改密码。修改等等什么的并不是每次都要嘛.这个也很好理解</p>
<blockquote>
<p>DML 数据操作语言 对表中的数据行进行增、删、改</p>
</blockquote>
<p><strong>insert</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line">单行数据</span><br><span class="line">INSERT INTO tableName(key1, key2, key3..) VALUES(value1, value2,value3...) [SELECT * FROM tableName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多行数据</span></span><br><span class="line">INSERT INTO tableName(key1, key2, key3..) VALUES \</span><br><span class="line">(value1, value2,value3...)</span><br><span class="line">(value1, value2,value3...)</span><br><span class="line">(value1, value2,value3...);</span><br><span class="line">...</span><br><span class="line">[SELECT * FROM tableName]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>插入时, key1,key2,key3 必须与value1，value2， value3 数量一致</p>
<p>插入对应字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tableName(key1, key3..) VALUES(value1, value3...) [SELECT * FROM tableName]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>update</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 更新前我们一般都会先查表内数据</span><br><span class="line"># 查询出对应表已存在所有行</span><br><span class="line">DESC tableName;</span><br><span class="line"># 查询对应表已存在数据</span><br><span class="line">SELECT * FROM tableName; # * 可替换成字段名，查对应字段</span><br><span class="line"></span><br><span class="line"># 更新数据</span><br><span class="line">UPDATE student SET 字段名=&#x27;新值&#x27; [WHERE 限定条件];</span><br></pre></td></tr></table></figure>
<p>Eg:</p>
<p>创建一张新的student表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 建表</span><br><span class="line">CREATE TABLE `student` (</span><br><span class="line"> `id` int NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;,</span><br><span class="line"> `sname` varchar(255) CHARACTER SET utf8 NOT NULL COMMENT &#x27;姓名&#x27;,</span><br><span class="line"> `sage` tinyint unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;年龄&#x27;,</span><br><span class="line"> `intime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;入学时间&#x27;,</span><br><span class="line"> PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT=&#x27;学生表&#x27;</span><br><span class="line"></span><br><span class="line"># 插入演示数据</span><br><span class="line">INSERT INTO student(sname,sage) VALUES(&quot;赵一&quot;, 1),</span><br><span class="line">(&quot;王二&quot;, 2),</span><br><span class="line">(&quot;张三&quot;, 3),</span><br><span class="line">(&quot;李四&quot;, 4);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>数据库</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmgmsbglbmj30ey09it8s.jpg" alt="" /></p>
<p>需求一:</p>
<p>李四改名为“里斯”;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE student SET sname=&quot;里斯&quot; WHERE sname = &quot;李四&quot;;</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line">UPDATE student SET sname=&quot;里斯&quot; WHERE id=4;</span><br><span class="line">UPDATE student SET sname=&quot;里斯&quot; WHERE sage=4;</span><br></pre></td></tr></table></figure>
<p>修改后，如下所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmgmx1cum6j30ey09eq30.jpg" alt="" /></p>
<p>需求二:</p>
<p>将所有表内成员的年龄+10;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE student SET sage=sage + 10</span><br><span class="line"># UPDATE student SET sage+=10(错误写法,开发时候用的什么sage ++， sage +=，在这里都不允许)</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmgn1b1f0bj30f009ct8s.jpg" alt="" /></p>
<p>需求三:将所有表内成员的年龄+10,除了里斯</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE student SET sage=sage + 10 WHERE sname != &quot;里斯&quot;;</span><br><span class="line"># 当然也可以这样写;</span><br><span class="line">UPDATE student SET sage=sage + 10 WHERE sname = &quot;赵一&quot; OR sname = &quot;王二&quot; OR sname=&quot;张三&quot; ;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>AND: 执行均满足</p>
<p>OR: 满足其一执行</p>
<p>where 见下文</p>
</blockquote>
<p><strong>delete</strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"># 删除指定数据</span><br><span class="line">DELETE FROM tableName  [WHERE <span class="type">id</span>=<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"># 清空标中所有数据</span><br><span class="line">DELETE FROM student;</span><br><span class="line">truncate table student;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>区别:</p>
<p>delete: DML操作, 是逻辑性质删除,逐行进行删除,速度慢.</p>
<p>truncate: DDL操作,对与表段中的数据页进行清空,速度快.</p>
</blockquote>
<p>伪删除：用update来替代delete，最终保证业务中查不到（select）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.添加状态列</span><br><span class="line">ALTER TABLE stuent ADD state TINYINT NOT NULL DEFAULT 1 ;</span><br><span class="line">SELECT * FROM stuent;</span><br><span class="line">2. UPDATE 替代 DELETE</span><br><span class="line">UPDATE stuent SET state=0 WHERE id=6;</span><br><span class="line">3. 业务语句查询</span><br><span class="line">SELECT * FROM stu WHERE state=1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>拓展</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM student;</span><br><span class="line">DROP TABLE student;</span><br><span class="line">truncate table student;</span><br></pre></td></tr></table></figure>
<p>以上三条删除语句有何区别？</p>
<p>同：三者都是删除语句，均可删除</p>
<p>异:</p>
<p>DELETE FROM student:</p>
<p>逻辑上<code>逐行</code>删除，数据过多，操作很慢</p>
<p>并没有真正的从磁盘上删除，知识在磁盘上打上标记，磁盘空间不立即释放。HWM高位线不会降低</p>
<p>DROP TABLE student;</p>
<p>将表结构(元数据)和数据行，物理层次删除</p>
<p>truncate truncate table student;</p>
<p>清空表段中的所有数据页，物理层次删除全表数据，磁盘空间立即释放。HWM高位线降低</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmhjljoy2gj30j20643zc.jpg" alt="" /></p>
</blockquote>
<h4 id="dql-数据查询语言"><a class="markdownIt-Anchor" href="#dql-数据查询语言"></a> DQL 数据查询语言</h4>
<p>show类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show databases;</span><br><span class="line">show CREATE DATABASE databaseName;</span><br><span class="line"></span><br><span class="line">show table;</span><br><span class="line">show CREATE TABLE table;</span><br><span class="line"></span><br><span class="line">desc tableName;</span><br></pre></td></tr></table></figure>
<p><strong>select类</strong></p>
<blockquote>
<p>获取表中的数据行</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"><span class="selector-tag">select</span> @</span><br><span class="line"></span><br><span class="line">@xxx 查看系统参数</span><br><span class="line">SELECT @ @port;</span><br><span class="line"><span class="selector-tag">SELECT</span> @</span><br><span class="line"></span><br><span class="line">@basedir;</span><br><span class="line"><span class="selector-tag">SELECT</span> @</span><br><span class="line"></span><br><span class="line">@datadir;</span><br><span class="line"><span class="selector-tag">SELECT</span> @</span><br><span class="line"></span><br><span class="line">@socket;</span><br><span class="line"><span class="selector-tag">SELECT</span> @</span><br><span class="line"></span><br><span class="line">@server_id;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"><span class="selector-tag">select</span> 函数</span><br><span class="line"><span class="selector-tag">SELECT</span></span><br><span class="line">NOW</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">)</span><br><span class="line">;</span><br><span class="line"><span class="selector-tag">SELECT</span></span><br><span class="line">DATABASE</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">)</span><br><span class="line">;</span><br><span class="line"><span class="selector-tag">SELECT</span></span><br><span class="line">USER</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">)</span><br><span class="line">;</span><br><span class="line"><span class="selector-tag">SELECT</span></span><br><span class="line">CONCAT</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line">)</span><br><span class="line">;</span><br><span class="line"><span class="selector-tag">SELECT</span></span><br><span class="line">CONCAT</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">USER,</span><br><span class="line"></span><br><span class="line">&quot;@&quot;</span><br><span class="line">,</span><br><span class="line">HOST</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">FROM mysql.user</span><br><span class="line"></span><br><span class="line">;</span><br><span class="line"><span class="selector-tag">SELECT</span></span><br><span class="line">GROUP_CONCAT</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">USER,</span><br><span class="line"></span><br><span class="line">&quot;@&quot;</span><br><span class="line">,</span><br><span class="line">HOST</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">FROM mysql.user</span><br><span class="line"></span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p>手册 <span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL3NxbC1mdW5jdGlvbi1yZWZlcmVuY2UuaHRtbA==">https://dev.mysql.com/doc/refman/8.0/en/sql-function-reference.html<i class="fa fa-external-link-alt"></i></span></p>
<p>select配合子句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">FROM 表1，表2...,</span><br><span class="line">WHERE 过滤条件1，过滤条件2，过滤条件3 ...</span><br><span class="line">GROUP BY 条件列1，条件列2，条件列3 ...</span><br><span class="line"> # selct_list 列名</span><br><span class="line">HAVING 过滤条件1，过滤条件2，过滤条件3 ...</span><br><span class="line">ORDER BY 条件列1，条件列2，条件列3 ...</span><br><span class="line">LIMIT 限制条件;</span><br></pre></td></tr></table></figure>
<p><strong>单表子句-from</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列1,列2 FROM 表</span><br><span class="line">SELECT  *  FROM 表</span><br><span class="line"></span><br><span class="line"># EG</span><br><span class="line"># 查询student中所有的数据(不要对大表进行操作)</span><br><span class="line">SELECT * FROM stu ;</span><br><span class="line"># 查询stu表中,学生姓名和入学时间</span><br><span class="line">SELECT sname , intime FROM stuent;</span><br></pre></td></tr></table></figure>
<p><strong>单表子句-where</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT col1,col2 FROM TABLE WHERE colN 条件;</span><br><span class="line"># where 操作符(&gt;、&lt;、&gt;=、 &lt;=、 &lt;&gt;、in、like、and、or)</span><br><span class="line">SELECT col1,col2 FROM TABLE WHERE = 条件;</span><br><span class="line"></span><br><span class="line"># where 模糊查询</span><br><span class="line">SELECT * FROM city WHERE district LIKE &#x27;guang%&#x27;;    </span><br><span class="line">%  : 表示任意0个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示。</span><br><span class="line">_  : 表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字符长度语句</span><br><span class="line">[] : 表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。</span><br><span class="line"></span><br><span class="line"># where配合between...and...</span><br><span class="line">SELECT * FROM city  WHERE population &gt;1000000 AND population &lt;2000000;</span><br><span class="line">SELECT * FROM city  WHERE population BETWEEN 1000000 AND 2000000;</span><br></pre></td></tr></table></figure>
<p><strong>group by</strong></p>
<p>根据 by后面的条件进行分组，方便统计，by后面跟一个列或多个列</p>
<p>未分组分组列，使用聚合函数</p>
<p>聚合函数</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">**</span><span class="built_in">max</span>()<span class="operator">**</span>      ：最大值</span><br><span class="line"><span class="operator">**</span><span class="built_in">min</span>()<span class="operator">**</span>      ：最小值</span><br><span class="line"><span class="operator">**</span>avg()<span class="operator">**</span>      ：平均值</span><br><span class="line"><span class="operator">**</span>sum()<span class="operator">**</span>      ：总和</span><br><span class="line"><span class="operator">**</span>count()<span class="operator">**</span>    ：个数</span><br><span class="line">group_concat() : 列转行</span><br></pre></td></tr></table></figure>
<p><strong>HAVING</strong></p>
<p>需要在group by 之后，在做判断过滤使用(类似于where)</p>
<p><strong>order by</strong></p>
<blockquote>
<p>实现先排序，by后添加条件列(默认从小到大)</p>
<p>逆序：后加DESC</p>
</blockquote>
<p><strong>distinct：去重复</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SELECT countrycode FROM city ;</span><br><span class="line"><span class="function">SELECT <span class="title">DISTINCT</span><span class="params">(countrycode)</span> FROM city  </span>;</span><br></pre></td></tr></table></figure>
<p>联合查询- union all</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">-- 中国或美国城市信息</span><br><span class="line"></span><br><span class="line">SELECT * <span class="function">FROM city </span></span><br><span class="line"><span class="function">WHERE countrycode <span class="title">IN</span> (<span class="params"><span class="string">&#x27;CHN&#x27;</span> ,<span class="string">&#x27;USA&#x27;</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">SELECT * FROM city WHERE countrycode=<span class="string">&#x27;CHN&#x27;</span></span><br><span class="line">UNION ALL</span><br><span class="line">SELECT * FROM city WHERE countrycode=<span class="string">&#x27;USA&#x27;</span></span><br><span class="line"></span><br><span class="line">说明:一般情况下,我们会将 IN 或者 OR 语句 改写成 UNION ALL,来提高性能</span><br><span class="line">UNION     去重复</span><br><span class="line">UNION ALL 不去重复</span><br></pre></td></tr></table></figure>
<p><strong>LIMIT 限制条件</strong></p>
<p>限制查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> 表名 LIMIT 限制条件</span><br><span class="line">eg:</span><br><span class="line"><span class="comment">--- 只输出前1000条</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> 表名 LIMIT <span class="number">1000</span></span><br><span class="line"><span class="comment">--- 只输出前1000-2000条</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> 表名 LIMIT <span class="number">1000</span>, <span class="number">2000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> 表名 LIMIT <span class="number">1000</span>, <span class="number">2000</span></span><br><span class="line">相当于</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> 表名 LIMIT <span class="number">2000</span></span><br><span class="line"><span class="keyword">OFFSET</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p><strong>join 多表连接查询</strong></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmhk5wso0sj31080ak76b.jpg" alt="" /></p>
<p><strong>内连接</strong></p>
<p>查询li4家的地址</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.name, B.address</span><br><span class="line"><span class="keyword">FROM</span> A</span><br><span class="line">         <span class="keyword">JOIN</span> B</span><br><span class="line">              <span class="keyword">ON</span> A.id <span class="operator">=</span> B.id <span class="comment">--- 关联列</span></span><br><span class="line"><span class="keyword">WHERE</span> A.name <span class="operator">=</span> <span class="string">&#x27;li4&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--- 相当于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> A.name, B.address</span><br><span class="line"><span class="keyword">FROM</span> A</span><br><span class="line">         <span class="keyword">JOIN</span> B</span><br><span class="line">              <span class="keyword">ON</span> A.id <span class="operator">=</span> B.id</span><br><span class="line"><span class="keyword">WHERE</span> A.name <span class="operator">=</span> <span class="string">&#x27;li4&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>外连接</strong></p>
<p>驱动表建议使用 数据少的表 为驱动表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.name, B.address</span><br><span class="line"><span class="keyword">FROM</span> A</span><br><span class="line">         <span class="keyword">JOIN</span> B</span><br><span class="line">              <span class="keyword">ON</span> A.id <span class="operator">=</span> B.id <span class="comment">--- 关联列</span></span><br><span class="line"><span class="keyword">WHERE</span> A.name <span class="operator">=</span> <span class="string">&#x27;li4&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--- 相当于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> A.name, B.address</span><br><span class="line"><span class="keyword">FROM</span> A</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">JOIN</span> B</span><br><span class="line">                   <span class="keyword">ON</span> A.id <span class="operator">=</span> B.id</span><br><span class="line"><span class="keyword">WHERE</span> A.name <span class="operator">=</span> <span class="string">&#x27;li4&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">---  A left JOIN  B 其中a位驱动表</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>DBMS</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh结合actions实现源码分离部署</title>
    <url>/29057.html</url>
    <content><![CDATA[<p>本博客采用github page实现部署，但由于github的性质无法有效的进行分离快速部署。</p>
<p>必须博客展示页，必须以username.github.io结尾，这样感觉不是很方便</p>
<p>部署前基本流程为，部署github page -&gt; 手动上传源码到对应仓库。</p>
<p>那么我们是否可以直接push到私有源码仓库，出发二段部署从实现自动的博客部署，此时我们只需要关心与维护自己的博客源码，再也不用刻意的关注部署了</p>
<p>说干就干</p>
<h2 id="前置条件"><a class="markdownIt-Anchor" href="#前置条件"></a> 前置条件</h2>
<h3 id="ssh部署"><a class="markdownIt-Anchor" href="#ssh部署"></a> ssh部署</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your email&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>若配置了全局的git email 可使用<code>ssh-keygen -t rsa -C &quot;$(git config user.email)&quot; -f gh-pages -N &quot;&quot;</code></p>
</blockquote>
<p>完成后将在本地<code>$HOME/.ssh</code>中生成私钥<code>id_rsa</code>,与公钥，<code>id_rsa.pub</code><br />
,将公钥上传到github上，进入<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NldHRpbmdzL2tleXM=">https://github.com/settings/keys<i class="fa fa-external-link-alt"></i></span> ，登陆自己的github账号。如下所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gu4h329orfj60tf0a775a02.jpg" alt="image-20210904121559885" /></p>
<p>New SSH Key</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gu4h3tn133j60lp0bomxg02.jpg" alt="image-20210904121643113" /></p>
<p>其中title为自定义，key为<code>id_rsa.pub</code>中内容。完成后点击Add SSH key即可</p>
<h2 id="建立私有博客源码仓库"><a class="markdownIt-Anchor" href="#建立私有博客源码仓库"></a> 建立私有博客源码仓库</h2>
<p>github上创建一个私有仓库即可，详细流程不在过多赘述</p>
<h2 id="创建actions"><a class="markdownIt-Anchor" href="#创建actions"></a> 创建Actions</h2>
<h3 id="配置actions-secrets"><a class="markdownIt-Anchor" href="#配置actions-secrets"></a> 配置Actions secrets</h3>
<p>Settings -&gt; Deploy keys -&gt; New repository secrets，如下所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gu4ezhkflmj61mk0u0aeq02.jpg" alt="image-20210904110320916" /></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gu4f2jcgr5j61sv0u00v602.jpg" alt="image-20210904110617453" /></p>
<p>将上面生成的id_rsa，复制到私钥中。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gu4hbf985wj6172072wf202.jpg" alt="image-20210904122401191" /></p>
<p>将workflow增加到源码文件中，拉取到本地。</p>
<p>deploy.yml如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This is a basic workflow to help you get started with Actions</span></span><br><span class="line"></span><br><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">Github</span> <span class="string">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Controls when the action will run. Triggers the workflow on push or pull request</span></span><br><span class="line"><span class="comment"># events but only for the master branch</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># A workflow run is made up of one or more jobs that can run sequentially or in parallel</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="comment"># This workflow contains a single job called &quot;build&quot;</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="comment"># The type of runner that the job will run on</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Steps represent a sequence of tasks that will be executed as part of the job</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="comment"># Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Env</span> <span class="string">setup</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">          echo &quot;$&#123;&#123; secrets.DEPLOY_KEY &#125;&#125;&quot; &gt; ~/.ssh/id_rsa # DEPLOY_KEY 为secret name</span></span><br><span class="line"><span class="string">          chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          ssh-keyscan -t rsa github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">          # setup deploy git account</span></span><br><span class="line"><span class="string">          git config --global user.name &quot;your user name&quot;</span></span><br><span class="line"><span class="string">          git config --global user.email &quot;your email&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          find . -type f -name *.log -delete</span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string">          npm run clean</span></span><br><span class="line"><span class="string">          npm run build</span></span><br><span class="line"><span class="string">          npm run deploy</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>以上便是github page 源码保护分析详细过程，其基本原理就是将ssh部署的工作交给自动构建的Actions。</p>
]]></content>
      <categories>
        <category>git</category>
        <category>github， ssh</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>svn rollback</title>
    <url>/24493.html</url>
    <content><![CDATA[<p><code>svn</code>使用 命令行实现rollback</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看前100条提交日志</span></span><br><span class="line">svn <span class="built_in">log</span> -v -l 100</span><br><span class="line">svn <span class="built_in">log</span> -v -l 100 &gt; svn_do.log</span><br><span class="line"><span class="comment"># 尝试回滚</span></span><br><span class="line">svn merge --dry-run -r 当前版本号:目标版本号 target_repo_addr</span><br><span class="line"><span class="comment"># 回滚</span></span><br><span class="line">svn merge -r 当前版本号:目标版本号 target_repo_addr</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>svn</category>
        <category>rollback</category>
      </categories>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title>vim文本基础操作</title>
    <url>/15521.html</url>
    <content><![CDATA[<h2 id="文本插入"><a class="markdownIt-Anchor" href="#文本插入"></a> 文本插入</h2>
<p>几种进入插入模式的方法，以便于更快捷的编辑</p>
<p><code>a</code>: 用于在光标之后进入插入模式</p>
<p><code>A</code>: 用于当前行行末进入插入模式（与$a等价）</p>
<p><code>i</code>: 在当前位置进入插入模式</p>
<p><code>I</code>: 在当前行缩进之后的行首进入插入模式</p>
<p><code>o</code>: 在光标下一行新增一行并进入插入模式</p>
<p><code>O</code>: 在光标上一行新增一行并进入插入模式</p>
<h2 id="窗口"><a class="markdownIt-Anchor" href="#窗口"></a> 窗口</h2>
<p>横向分割窗口： <code>split</code> 或者<code>sp</code></p>
<p>纵向分割窗口： <code>vsplit</code> 或者 <code>vsp</code></p>
<h3 id="窗口跳转"><a class="markdownIt-Anchor" href="#窗口跳转"></a> 窗口跳转</h3>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ctrl+w j 向下移动</span><br><span class="line">ctrl+w k 向上移动</span><br><span class="line">ctrl+w h 向左移动</span><br><span class="line">ctrl+w l  向右移动</span><br><span class="line">ctrl+w t 移动到顶端</span><br><span class="line">ctrl+w b 移动到底端</span><br></pre></td></tr></table></figure>
<h2 id="vim-模式"><a class="markdownIt-Anchor" href="#vim-模式"></a> vim 模式</h2>
<p>普通模式：vi file_name,主要用于文件操作如浏览、增删改查</p>
<p>输入模式：在普通模式下输入 <code>i</code> 即可进入输入模式</p>
<p>命令模式：在普通模式下输入 <code>:</code> 进入命令模式，使用命令进行操作</p>
<p>可视模式：在普通模式中输入 <code>v</code> 进入可视模式。类似于鼠标选中进行批量操作</p>
<h2 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h2>
<p><code>g</code>: 跳至行首，<code>G</code>: 跳至文末尾</p>
<p><code>cc</code>：删除这一行进入修改模式</p>
<p><code>dd</code>:  删除一整行</p>
<p><code>uu</code>：撤销上次操作</p>
<p><code>yy</code>:  复制</p>
<p><code>pp</code>：粘贴</p>
<blockquote>
<p>tips： 这里笔者使用了组合的形式来展示，其实不然，比如删除4行，可以是<code>d4d</code>, 删除5个单词为<code>d4w</code>,</p>
</blockquote>
<p>当然还可以结合 可视模式（多选）来辅助批量复制粘贴等。</p>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>uiautomator2使用笔记</title>
    <url>/27102.html</url>
    <content><![CDATA[<h2 id="uiautomator2-简介"><a class="markdownIt-Anchor" href="#uiautomator2-简介"></a> uiautomator2 简介</h2>
<p>UiAutomator是Google提供的用来做安卓自动化测试的一个Java库，基于Accessibility服务。功能很强，可以对第三方App进行测试，获取屏幕上任意一个APP的任意一个控件属性，并对其进行任意操作。而uiautomator2便是UiAutomator的Python实现</p>
<p>除了对原有的库的bug进行了修复，还增加了很多新的Feature。主要有以下部分：</p>
<ul>
<li>设备和开发机可以脱离数据线，通过WiFi互联（基于<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29wZW5hdHgvYXR4LWFnZW50">atx-agent<i class="fa fa-external-link-alt"></i></span>）</li>
<li>集成了<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29wZW5zdGYvbWluaWNhcA==">openstf/minicap<i class="fa fa-external-link-alt"></i></span>达到实时屏幕投频，以及实时截图</li>
<li>集成了<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29wZW5zdGYvbWluaXRvdWNo">openstf/minitouch<i class="fa fa-external-link-alt"></i></span>达到精确实时控制设备</li>
<li>修复了<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW9jb25nL3VpYXV0b21hdG9y">xiaocong/uiautomator<i class="fa fa-external-link-alt"></i></span>经常性退出的问题</li>
<li>代码进行了重构和精简，方便维护</li>
<li>实现了一个设备管理平台(也支持iOS) <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29wZW5hdHgvYXR4c2VydmVyMg==">atxserver2<i class="fa fa-external-link-alt"></i></span></li>
<li>扩充了toast获取和展示的功能</li>
</ul>
<p>相关链接如下：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdHJhaW5pbmcvdGVzdGluZy91aS1hdXRvbWF0b3IuaHRtbA==">UiAutomator<i class="fa fa-external-link-alt"></i></span>：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdHJhaW5pbmcvdGVzdGluZy91aS1hdXRvbWF0b3IuaHRtbA==">https://developer.android.com/training/testing/ui-automator.html<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29wZW5hdHgvdWlhdXRvbWF0b3Iy">uiautomator2<i class="fa fa-external-link-alt"></i></span>： <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29wZW5hdHgvdWlhdXRvbWF0b3Iy">https://github.com/openatx/uiautomator2<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29wZW5hdHgvdWlhdXRvbWF0b3IyL2Jsb2IvbWFzdGVyL1FVSUNLX1JFRkVSRU5DRS5tZA==">QUICK_REFERENCE<i class="fa fa-external-link-alt"></i></span>： <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29wZW5hdHgvdWlhdXRvbWF0b3IyL2Jsb2IvbWFzdGVyL1FVSUNLX1JFRkVSRU5DRS5tZA==">https://github.com/openatx/uiautomator2/blob/master/QUICK_REFERENCE.md<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2>
<p>由于python实现的，在此可以使用<code>pip</code> 直接安装即可，命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># # 如果是在Windows平台下，未做`python3` 与 `python` 的link，在这里使用`python` 而不是`python3`</span></span><br><span class="line">python3 -m pip install --upgrade uiautomator2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips： 建议使用虚拟环境</p>
</blockquote>
<p>开发版安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -m pip install --upgrade --pre uiautomator2</span><br></pre></td></tr></table></figure>
<p>源码安装</p>
<blockquote>
<p>需要git客户端，若未安装git，可移步<code>https://git-scm.com/downloads</code>进行下载，</p>
<p>当然，源码也可以使用zip的方式进行下载，请自行探索</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/openatx/uiautomator2</span><br><span class="line">python3 -m pip install -e uiautomator2</span><br></pre></td></tr></table></figure>
<h3 id="校验"><a class="markdownIt-Anchor" href="#校验"></a> 校验</h3>
<p>先准备一台（不要两台）开启了<code>开发者选项</code>的安卓手机，连接上电脑，确保执行<code>adb devices</code>可以看到连接上的设备。如下图所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gx45djlejbj30mr01e0sq.jpg" alt="image-20211206153159233" /></p>
<p>运行<code>python3 -m uiautomator2 init</code>安装包含httprpc服务的apk到手机+<code>atx-agent, minicap, minitouch</code></p>
<blockquote>
<p>在过去的版本中，这一步是必须执行的，但是从1.3.0之后的版本，当运行python代码<code>u2.connect()</code>时就会自动推送这些文件了</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> uiautomator2 <span class="keyword">as</span> u2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接设备(当只有只有一台设备的时候可以为空，当有多台设备可以是设备号或ip地址)</span></span><br><span class="line">device = u2.connect()</span><br><span class="line"><span class="comment"># get uiautomator2 device info</span></span><br><span class="line">pprint(device.info)</span><br><span class="line"><span class="comment"># get device info</span></span><br><span class="line">pprint(device.device_info)</span><br><span class="line"><span class="comment"># get device windows size</span></span><br><span class="line"><span class="built_in">print</span>(device.window_size())</span><br><span class="line"><span class="comment"># get device wlan ip</span></span><br><span class="line">pprint(device.wlan_ip)</span><br><span class="line"><span class="comment"># get serial id</span></span><br><span class="line">pprint(device.serial)</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gx45jkcixoj30d906qmxa.jpg" alt="image-20211206153746081" /></p>
<h2 id="app开启与关闭"><a class="markdownIt-Anchor" href="#app开启与关闭"></a> app开启与关闭</h2>
<p>当我们需要打开对应的app时，需要知道对应设备的包名。获取包名有两种方式</p>
<ul>
<li>在设备上打开对应的app，获取当前app包名(<code>app_current()</code>)</li>
<li>获取全部的应用包(<code>app_list_running()</code>)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启app</span></span><br><span class="line">app_start</span><br><span class="line"><span class="comment"># 关闭app</span></span><br><span class="line">app_stop</span><br></pre></td></tr></table></figure>
<h3 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h3>
<blockquote>
<p>此时笔者的测试手机在已经打开app</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Date         : 07-12-2021 </span></span><br><span class="line"><span class="comment"># @Author       : Payne</span></span><br><span class="line"><span class="comment"># @Email        : wuzhipeng1289690157@gmail.com</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">import</span> uiautomator2 <span class="keyword">as</span> u2</span><br><span class="line"></span><br><span class="line"><span class="comment"># content device</span></span><br><span class="line">device = u2.connect()</span><br><span class="line">logger.info(<span class="string">f&quot;DEVICE INFO:<span class="subst">&#123;device.info&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># check current app</span></span><br><span class="line">current_app = device.app_current()</span><br><span class="line"><span class="comment"># get the package</span></span><br><span class="line">device.app_start(current_app.get(<span class="string">&#x27;package&#x27;</span>), stop=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 正态分布休眠,模拟操作</span></span><br><span class="line">time.sleep(random.uniform(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line"><span class="comment"># stop all app</span></span><br><span class="line">device.app_stop_all()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips: 复习一下adb command</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># adb 命令 -- 获取报包名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># current （需要打开app）</span></span><br><span class="line">adb -s &#123;device_serial&#125; shell dumpsys activity | grep mFocusedActivity</span><br><span class="line"><span class="comment"># all</span></span><br><span class="line">adb -s &#123;device_serial&#125; shell pm list packages</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据关键字过滤包</span></span><br><span class="line">adb -s &#123;device_serial&#125; shell pm list packages | grep “keyword”</span><br><span class="line"><span class="comment"># 查看包安装位置 </span></span><br><span class="line">adb -s &#123;device_serial&#125; shell pm list packages -f</span><br></pre></td></tr></table></figure>
<h2 id="点击"><a class="markdownIt-Anchor" href="#点击"></a> 点击</h2>
<ul>
<li>
<p>Turn on/off screen</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d.screen_on() # turn on the screen</span><br><span class="line">d.screen_off() # turn off the screen</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Press hard/soft key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d.press(&quot;home&quot;) # press the home key, with key name</span><br><span class="line">d.press(&quot;back&quot;) # press the back key, with key name</span><br><span class="line">d.press(0x07, 0x02) # press keycode 0x07(&#x27;0&#x27;) with META ALT(0x02)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>These key names are currently supported:</p>
<ul>
<li>
<p>home、back、</p>
</li>
<li>
<p>left、right、up、down</p>
</li>
<li>
<p>center、menu、search</p>
</li>
<li>
<p>enter、delete ( or del)</p>
</li>
<li>
<p>recent (recent apps)</p>
</li>
<li>
<p>volume_up、volume_down、volume_mute</p>
</li>
<li>
<p>camera、power</p>
</li>
</ul>
</li>
<li>
<p>Click on the screen</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">d.click(x, y)</span><br></pre></td></tr></table></figure>
<ul>
<li>Double click</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">d.double_click(x, y)</span><br><span class="line">d.double_click(x, y, 0.1) <span class="comment"># default duration between two click is 0.1s</span></span><br></pre></td></tr></table></figure>
<ul>
<li>long_click</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">d.long_click(x, y)</span><br><span class="line">d.long_click(x, y, 0.5) <span class="comment"># long click 0.5s (default)</span></span><br></pre></td></tr></table></figure>
<h2 id="滑动"><a class="markdownIt-Anchor" href="#滑动"></a> 滑动</h2>
<p><strong>Swipe</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Swipe</span></span><br><span class="line">swipe(<span class="variable language_">self</span>, fx, fy, tx, ty, duration: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span>, steps: <span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span>)</span><br><span class="line">fx, fy：起始坐标</span><br><span class="line">tx, ty：目标坐标</span><br><span class="line">duration： 持续时间（力度）</span><br><span class="line">steps： 分开滑动次数</span><br></pre></td></tr></table></figure>
<p><strong>swipe_ext</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">d.swipe_ext(<span class="string">&quot;right&quot;</span>) <span class="comment"># 手指右滑，4选1 &quot;left&quot;, &quot;right&quot;, &quot;up&quot;, &quot;down&quot;</span></span><br><span class="line">d.swipe_ext(<span class="string">&quot;right&quot;</span>, scale=0.9) <span class="comment"># 默认0.9, 滑动距离为屏幕宽度的90%</span></span><br><span class="line">d.swipe_ext(<span class="string">&quot;right&quot;</span>, box=(0, 0, 100, 100)) <span class="comment"># 在 (0,0) -&gt; (100, 100) 这个区域做滑动</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实践发现上滑或下滑的时候，从中点开始滑动成功率会高一些</span></span><br><span class="line">d.swipe_ext(<span class="string">&quot;up&quot;</span>, scale=0.8) <span class="comment"># 代码会vkk</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以使用Direction作为参数</span></span><br><span class="line">from uiautomator2 import Direction</span><br><span class="line"></span><br><span class="line">d.swipe_ext(Direction.FORWARD) <span class="comment"># 页面下翻, 等价于 d.swipe_ext(&quot;up&quot;), 只是更好理解</span></span><br><span class="line">d.swipe_ext(Direction.BACKWARD) <span class="comment"># 页面上翻</span></span><br><span class="line">d.swipe_ext(Direction.HORIZ_FORWARD) <span class="comment"># 页面水平右翻</span></span><br><span class="line">d.swipe_ext(Direction.HORIZ_BACKWARD) <span class="comment"># 页面水平左翻</span></span><br></pre></td></tr></table></figure>
<p><strong>Drag</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d.drag(sx, sy, ex, ey)</span><br><span class="line">d.drag(sx, sy, ex, ey, 0.5) </span><br><span class="line"></span><br><span class="line">sx, sy：起始坐标</span><br><span class="line">ex, ey：目标坐标</span><br></pre></td></tr></table></figure>
<p><strong>Swipe points</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># swipe from point(x0, y0) to point(x1, y1) then to point(x2, y2)</span></span><br><span class="line"><span class="comment"># time will speed 0.2s bwtween two points</span></span><br><span class="line"><span class="comment"># swipe_points(self, points, duration: float = 0.5)</span></span><br><span class="line">d.swipe_points([(x0, y0), (x1, y1), (x2, y2)], <span class="number">0.2</span>))</span><br></pre></td></tr></table></figure>
<h2 id="选择器"><a class="markdownIt-Anchor" href="#选择器"></a> 选择器</h2>
<p>选择器是一种在当前窗口中识别特定 UI 对象的便捷机制, 很多时候仅按照坐标时点击并不精确，通用型不强。</p>
<p>选择器支持以下参数。有关详细信息，请参阅<span class="exturl" data-url="aHR0cDovL2RldmVsb3Blci5hbmRyb2lkLmNvbS90b29scy9oZWxwL3VpYXV0b21hdG9yL1VpU2VsZWN0b3IuaHRtbA==">UiSelector Java 文档<i class="fa fa-external-link-alt"></i></span>。</p>
<ul>
<li><code>text</code>, <code>textContains</code>, <code>textMatches</code>,<code>textStartsWith</code></li>
<li><code>className</code>, <code>classNameMatches</code></li>
<li><code>description</code>, <code>descriptionContains</code>, <code>descriptionMatches</code>,<code>descriptionStartsWith</code></li>
<li><code>checkable</code>, <code>checked</code>, <code>clickable</code>,<code>longClickable</code></li>
<li><code>scrollable</code>, <code>enabled</code>, <code>focusable</code>, <code>focused</code>,<code>selected</code></li>
<li><code>packageName</code>, <code>packageNameMatches</code></li>
<li><code>resourceId</code>, <code>resourceIdMatches</code></li>
<li><code>index</code>, <code>instance</code></li>
</ul>
]]></content>
      <categories>
        <category>uiautomator2</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>uiautomator2</tag>
      </tags>
  </entry>
  <entry>
    <title>yaml语法详解</title>
    <url>/56655.html</url>
    <content><![CDATA[<blockquote>
<p>YAML Ain’t Markup Language™<br />
YAML is a human-friendly data serialization language for all programming languages.</p>
</blockquote>
<p>YAML 语言（发音 /ˈjæməl/ ）的设计目标，就是方便人类读写。它实质上是一种通用的数据串行化格式。</p>
<h2 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h2>
<ul>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进时不允许使用Tab键，只允许使用空格。</li>
<li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li>
</ul>
<h2 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h2>
<ul>
<li>
<p>对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</p>
</li>
<li>
<p>数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）</p>
</li>
<li>
<p>纯量（scalars）：单个的、不可再分的值。</p>
<ul>
<li>string</li>
<li>number
<ul>
<li>int</li>
<li>float</li>
</ul>
</li>
<li>Null</li>
<li>time</li>
<li>data</li>
</ul>
</li>
<li>
<p>注释: <code>#</code>表示注释，从这个字符一直到行尾，都会被解析器忽略。</p>
</li>
<li>
<p>锚点<code>&amp;</code>和别名<code>*</code>，可以用来引用。</p>
</li>
<li>
<p><code>|</code>: 保留换行符</p>
<ul>
<li><code>+</code>:保留文字块末尾的换行</li>
<li><code>-</code>:删除字符串末尾的换行</li>
</ul>
</li>
<li>
<p><code>&lt;&lt;</code>: 合并内容</p>
</li>
</ul>
<h2 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h2>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://www.json2yaml.com/</span></span><br><span class="line"><span class="comment"># https://nodeca.github.io/js-yaml/</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="attr">json:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">rigid</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">better</span> <span class="string">for</span> <span class="string">data</span> <span class="string">interchange</span></span><br><span class="line"><span class="attr">yaml:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">slim</span> <span class="string">and</span> <span class="string">flexible</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">better</span> <span class="string">for</span> <span class="string">configuration</span></span><br><span class="line"><span class="attr">object:</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">value</span></span><br><span class="line">  <span class="attr">array:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">null_value:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">boolean:</span> <span class="literal">true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">integer:</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># 锚点&amp;和别名*，可以用来引用。</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">alias:</span> <span class="string">&amp;example</span> <span class="string">aliases</span> <span class="string">are</span> <span class="string">like</span> <span class="string">variables</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">alias:</span> <span class="meta">*example</span></span><br><span class="line"><span class="comment"># 多行字符串可以使用|保留换行符，也可以使用&gt;折叠换行。</span></span><br><span class="line"><span class="attr">paragraph:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">  Blank lines denote</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">  <span class="string">paragraph</span> <span class="string">breaks</span></span><br><span class="line"><span class="comment"># +表示保留文字块末尾的换行，-表示删除字符串末尾的换行。</span></span><br><span class="line"><span class="attr">content:</span> <span class="string">|-</span></span><br><span class="line"><span class="string">  Or we</span></span><br><span class="line"><span class="string">  can auto</span></span><br><span class="line"><span class="string">  convert line breaks</span></span><br><span class="line"><span class="string">  to save space</span></span><br><span class="line"><span class="string"></span><span class="attr">alias:</span> <span class="meta">&amp;foo</span></span><br><span class="line">  <span class="attr">bar:</span> <span class="string">baz</span></span><br><span class="line"><span class="attr">alias_reuse:</span> <span class="meta">*foo</span></span><br><span class="line"><span class="comment"># &lt;&lt; 表示合并到当前数据</span></span><br><span class="line"><span class="string">&lt;&lt;:</span> <span class="meta">*foo</span></span><br></pre></td></tr></table></figure>
<h2 id="refer"><a class="markdownIt-Anchor" href="#refer"></a> refer</h2>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly95YW1sLm9yZy8=">https://yaml.org/<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDE2LzA3L3lhbWwuaHRtbA==">https://www.ruanyifeng.com/blog/2016/07/yaml.html<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>yaml</category>
        <category>config</category>
      </categories>
      <tags>
        <tag>tags</tag>
      </tags>
  </entry>
  <entry>
    <title>一些工作上的思考</title>
    <url>/20884.html</url>
    <content><![CDATA[<h2 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h2>
<p><strong>规范的</strong> 、<strong>结构的</strong>构造端到端</p>
<h2 id="计算机"><a class="markdownIt-Anchor" href="#计算机"></a> 计算机</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYWlqaWFoYW8uYmFpZHUuY29tL3M/aWQ9MTY5ODM1NDgwOTY1MDc4MTM1OA==">《我对计算的理解· 吴瀚清》<i class="fa fa-external-link-alt"></i></span></p>
<p>技术的本质就是<strong>结构与组合</strong>。</p>
<p>今天我们在谈技术架构，有时候我们也会谈产品架构，再往前走，我们会谈商业架构，它中间都是一个结构的问题。</p>
<p><strong>技术最重要的目标是开始追求生产效率，带来产能上的巨大提升</strong><br />
，当产能得到一个巨大提升之后，就能够创造出越来越多的产品，进而实现规模化。技术要通过架构师或者工程师的工作才能完成这个过程。</p>
<p><strong>技术要走向的就是规模化</strong></p>
<blockquote>
<p><strong>计算机真正在做的事情是模拟</strong></p>
<p>创造</p>
</blockquote>
<h2 id="闭环"><a class="markdownIt-Anchor" href="#闭环"></a> 闭环</h2>
<p>在职场中,在领导口中.口口声声说 “闭环”,但 究竟什么是闭环?</p>
<p>闭环思维是一种<strong>有始有终</strong>的思维，它是一份生活的智慧。</p>
<p>比如拖延症导致的熬夜。由于有拖延症，导致无法及时完成任务，最后不得不熬夜，第二天精神萎靡，工作效率下降，于是不得不继续熬夜。这就是一个恶性闭环。</p>
<p>要想改变这个闭环，我们需要找到一个突破点，对上一个阶段的效果进行总结，把控改进方向。</p>
<p>工作效率就是一个突破点，我们可以提升工作效率，原本需要2个小时完成的任务，火力全开用1个小时做完，那么晚上就不需要再熬夜了。有了充足的睡眠，第二天精力充沛，就可以保证工作效率，于是形成了一个正向的闭环。</p>
<h3 id="什么是闭环思维"><a class="markdownIt-Anchor" href="#什么是闭环思维"></a> 什么是闭环思维</h3>
<p>闭环思维实际上被称为反馈控制系统，它将系统输出的测量值与预期和定值进行比较，由此造成一个偏差信号，然后运用偏差去做调整，便于输出值尽可能接近期望值。</p>
<p>PDCA循环将管理分为计划（Plan）、执行（Do）、检查（Check）、行动（Act）<br />
四个阶段，这四个阶段不是独立存在的，而是周而复始的循环。这也是我们在企业中经常听到的“商业闭环”“闭环管理”<br />
等概念。</p>
<p>我们这里提到的闭环思维是指在一定的基础上，对于他人发起的活动或者工作，无论我们完成的程度如何，都要在要求的时间之内认真地反馈给发起人，并且每个活动或者工作都要贯穿这个思维。</p>
<h2 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h2>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">你需要有体系结构化思维的能力 -- 5w3h<span class="keyword">\ </span>6why</span><br><span class="line">你做的事情它有什么独特的优势,价值点在哪里 </span><br><span class="line">你是否做出了壁垒,形成核心竞争力</span><br><span class="line">你做的事情差异化在哪里</span><br><span class="line">你的事情是否沉淀了一套可复用的物理资料与方法论</span><br><span class="line">为什么是你来做,其他人是否可以?</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">最终交付价值是什么</span><br><span class="line">顶层设计在哪里, 底层逻辑是什么</span><br><span class="line">过程中的抓手在哪里</span><br><span class="line">如何保证效果闭环</span><br><span class="line">优势在哪,亮点在哪</span><br></pre></td></tr></table></figure>
<p>理解业务</p>
<p>技术 + 产品 + 运营</p>
<h2 id="referer"><a class="markdownIt-Anchor" href="#referer"></a> Referer</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYWlqaWFoYW8uYmFpZHUuY29tL3M/aWQ9MTcxMjQ3MDA2MzE3Mjc5OTQ1Mw==">闭环<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>work</category>
        <category>工作</category>
        <category>思考</category>
      </categories>
      <tags>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title>中国节假日订阅</title>
    <url>/31486.html</url>
    <content><![CDATA[<p>在一般情况下iPhone的日历是无法显示中国节假日等信息，就非常容易的忘掉一些重要的节日（我对于节日就是后知后觉的），那么有什么办法可以在iPhone原有的基础上加上这属于咱们中国节假日呢。方法当然是有滴，毕竟只要思想不滑坡办法总比问题多嘛。</p>
<p>在全球最大的同性交友网站github闲逛时，一个偶然的机会发现它——china-holiday-calender</p>
<p>基于订阅的方式，实现组件化的方式嵌入到iPhone原生的日历，cool～</p>
<ol>
<li>节假日信息来自<span class="exturl" data-url="aHR0cDovL3d3dy5nb3YuY24v">中国政府网<i class="fa fa-external-link-alt"></i></span>，一手信息、权威准确</li>
<li>包含最近3年的节假日信息，机器人自动维护，更新及时</li>
<li>日历标题包含放假、补班的天数信息</li>
<li>日历标题包含放假、补班等关键字，方便脚本开发。例如使用<code>iPhone</code>的<code>快捷指令</code>应用编写工作日闹钟</li>
<li>每个补班日程自动设置上班提醒，默认时间为<code>09:00~18:00</code>、提前一个小时提醒</li>
<li>支持个性化定制补班日程的开始、结束时间和提醒时间(例如提前一天提醒)</li>
</ol>
<p>订阅地址如下：</p>
<ul>
<li>国内订阅地址(**支持定制补班日程<br />
**): <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2h1eXouY29tL2dpdGh1YmZpbGVzL2NoaW5hLWhvbGlkYXktY2FsZW5kZXIvbWFzdGVyL2hvbGlkYXlDYWwuaWNz">https://www.shuyz.com/githubfiles/china-holiday-calender/master/holidayCal.ics<i class="fa fa-external-link-alt"></i></span></li>
<li>jsDelivr订阅地址: <span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2xhbmNlbGlhby9jaGluYS1ob2xpZGF5LWNhbGVuZGVyL2hvbGlkYXlDYWwuaWNz">https://cdn.jsdelivr.net/gh/lanceliao/china-holiday-calender/holidayCal.ics<i class="fa fa-external-link-alt"></i></span></li>
<li>GitHub订阅地址(<br />
科学上网): <span class="exturl" data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2xhbmNlbGlhby9jaGluYS1ob2xpZGF5LWNhbGVuZGVyL21hc3Rlci9ob2xpZGF5Q2FsLmljcw==">https://raw.githubusercontent.com/lanceliao/china-holiday-calender/master/holidayCal.ics<i class="fa fa-external-link-alt"></i></span></li>
<li>Telegram讨论组: <span class="exturl" data-url="aHR0cHM6Ly90Lm1lL2pvaW5jaGF0L0V3aE1aUlZCN3hJNE9wdVhMWHVra3c=">https://t.me/joinchat/EwhMZRVB7xI4OpuXLXukkw<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<blockquote>
<p>任选其一，主要推荐<code>国内订阅地址(**支持定制补班日程**)</code> ，其次是<code>jsDelivr订阅地址</code></p>
</blockquote>
<h2 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h2>
<ol>
<li>打开日历app（返回首页，如下图所示），点击中间的 “日历”（如下图红色方框所示）</li>
</ol>
<img data-src="/Users/payne/Library/Application Support/typora-user-images/image-20220320072755412.png" alt="image-20220320072755412" style="zoom:50%;" />
<ol start="2">
<li>在日历设置页（如下图所示），点击左下角添加日历 -&gt; 添加订阅日历（如下图红色方框所示）</li>
</ol>
<img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0fzw21zjxj20ki0wctat.jpg" alt="image-20220320072952006" style="zoom:50%;" />
<ol start="3">
<li>将网址输入框中，如下图所示</li>
</ol>
<img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0fzz2wstcj20kw0yc75v.jpg" alt="image-20220320073246216" style="zoom:50%;" />
<ol start="4">
<li>输入 <code>https://www.shuyz.com/githubfiles/china-holiday-calender/master/holidayCal.ics</code> 点击订阅即可</li>
</ol>
<p>完成啦～</p>
<img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0g03s8iaaj20u01sztcp.jpg" alt="image-20220320073717862" style="zoom:33%;" />
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0g05fnmg3j21az0u00w8.jpg" alt="image-20220320073853232" /></p>
<p>macbook pro 日历</p>
<h2 id="referer"><a class="markdownIt-Anchor" href="#referer"></a> Referer</h2>
<p>china-holiday-calender: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xhbmNlbGlhby9jaGluYS1ob2xpZGF5LWNhbGVuZGVy">https://github.com/lanceliao/china-holiday-calender<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>calendar</category>
        <category>mac</category>
        <category>apple</category>
      </categories>
      <tags>
        <tag>calendar</tag>
      </tags>
  </entry>
  <entry>
    <title>云源生相关技术栈</title>
    <url>/16832.html</url>
    <content><![CDATA[<h2 id="虚拟化系统"><a class="markdownIt-Anchor" href="#虚拟化系统"></a> 虚拟化系统</h2>
<ul>
<li>进程虚拟化</li>
<li><strong>Namespaces</strong> 进行虚拟化隔离</li>
<li>Control Groups 进行对资源的限制，</li>
<li>联合文件 UFS（Union File Systems)来快速构建（可复用的镜像层）</li>
</ul>
<h2 id="docker"><a class="markdownIt-Anchor" href="#docker"></a> Docker</h2>
<p>Docker的前世今生</p>
<p>Docker的架构与容器生命周期：created、running、stopped、paused、deleted</p>
<p>Docker 环境搭建</p>
<p>Docker 基本操作</p>
<p>Dockerfile 编写与各指令使用</p>
<p>Docker 网络</p>
<p>Docker 存储</p>
<p>Docker 编排：Docker、Docker-compose、Docker-Swarm</p>
<p>Docker DevOpts</p>
<h2 id="kubernetes"><a class="markdownIt-Anchor" href="#kubernetes"></a> Kubernetes</h2>
<p>Kubernetes 的前世今生（Borg 系统）</p>
<p>Kubernetes 架构与生命周期</p>
<p>Kubernetes 基本术语</p>
<p>Kubernetes 环境搭建</p>
<p>Pod</p>
<ul>
<li>什么是Pod</li>
<li>Pod使用</li>
<li>Pod生命周期</li>
<li>Pod健康检查</li>
<li>Pod 调度
<ul>
<li>调度器：Deployment、ReplicationController、ReplicaSet、StatefulSets、DaemonSet、Jobs、CronJobs</li>
<li>Pod、Node 亲和性</li>
<li>Pod调度优先级</li>
<li>污点和容忍</li>
</ul>
</li>
<li>Pod扩缩容机制</li>
</ul>
<p>Kubernetes 网络</p>
<ul>
<li>
<p>Services</p>
</li>
<li>
<p>DNS</p>
</li>
<li>
<p>Ingress</p>
</li>
</ul>
<p>Kubernetes 存储</p>
<ul>
<li>存储机制</li>
<li>存储卷：PV、PVC、StorageClass</li>
<li>GlusterFS</li>
<li>CSI</li>
</ul>
<p>Kubernetes 安全</p>
<ul>
<li>API Server认证与授权</li>
<li>Admission Control</li>
<li>Service Account</li>
<li>Secret</li>
</ul>
<p>Kubernetes 运维管理与监控</p>
<ul>
<li>Helm</li>
<li>DevOps</li>
<li>Dashboard</li>
<li>Prometheus（thanos） + Granfana</li>
<li>Kafka、ElasticSearch、FileBaet、Kibana</li>
</ul>
<p>Kubernetes组件及运行机制</p>
<ul>
<li>API Server</li>
<li>Controller Manager</li>
<li>Scheduler</li>
<li>kubelet</li>
<li>Kube-proxy</li>
<li>etcd</li>
<li>Kubernetes调度器与控制器</li>
</ul>
<p>服务治理-Istio</p>
<p>Envoy</p>
<h2 id="学习资源"><a class="markdownIt-Anchor" href="#学习资源"></a> 学习资源</h2>
<p>官方网站：<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlv">https://kubernetes.io<i class="fa fa-external-link-alt"></i></span></p>
<p>GitHub: <span class="exturl" data-url="aHR0cDovL2dpdGh1Yi5jb20va3ViZXJuZXRlcw==">http://github.com/kubernetes<i class="fa fa-external-link-alt"></i></span></p>
<p>aliyun：<span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vcHJvZHVjdC84NTIyMi5odG1s">https://help.aliyun.com/product/85222.html<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="书"><a class="markdownIt-Anchor" href="#书"></a> 书</h3>
<h3 id="docker-2"><a class="markdownIt-Anchor" href="#docker-2"></a> Docker</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly95ZWFzeS5naXRib29rLmlvL2RvY2tlcl9wcmFjdGljZS8=">Docker从入门到实践<i class="fa fa-external-link-alt"></i></span></p>
<p>深入浅出Docker</p>
<p>Docker容器与容器云</p>
<p>第一本Docker书</p>
<h3 id="kubernetes-2"><a class="markdownIt-Anchor" href="#kubernetes-2"></a> Kubernetes</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9qaW1teXNvbmcuaW8va3ViZXJuZXRlcy1oYW5kYm9vay8=">Kubernetes Handbook<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9qaW1teXNvbmcuaW8vaXN0aW8taGFuZGJvb2sv">istio-handbook<i class="fa fa-external-link-alt"></i></span></p>
<p>Kubernetes权威指南</p>
<p>Kubernetes进阶实战</p>
<p>Kubernetes网络权威指南</p>
<p>Kubernetes生产化与实践之路</p>
<p>深入剖析Kubernetes</p>
<p>Kubernetes源码剖析</p>
<p>Kubernetes in Action</p>
<p>云原生服务网格istio</p>
<p>性能之巅：洞悉系统、企业与云计算洞悉系统、企业与云计算</p>
<p>BPF之巅洞悉Linux系统和应用性能</p>
<h2 id="社区"><a class="markdownIt-Anchor" href="#社区"></a> 社区</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cua3ViZXJuZXRlcy5vcmcuY24v">https://www.kubernetes.org.cn/<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9qaW1teXNvbmcuaW8v">https://jimmysong.io/<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="视频"><a class="markdownIt-Anchor" href="#视频"></a> 视频</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMTNRNHkxQzdoUw==">https://www.bilibili.com/video/BV13Q4y1C7hS<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>could-native</category>
        <category>Docker</category>
        <category>Kubernetes</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>could-native</tag>
      </tags>
  </entry>
  <entry>
    <title>优雅的从服务器上传下载文件</title>
    <url>/4.html</url>
    <content><![CDATA[<p><strong>如何优雅的从Linux服务器上进行文件“上传”与“下载”</strong></p>
<p>不知你是否也遇到以下几种情形：</p>
<ul>
<li>本地电脑上传文件至Linux服务器</li>
<li>Linux服务器之间文件传递</li>
</ul>
<p>那么如何有效、且优雅的的进行呢。特意为了此下载xshell、finalshell等软件？其实也大可不必，隐患太多也并不方便。只需要学会使用Linux中scp命令即可</p>
<h2 id="scp"><a class="markdownIt-Anchor" href="#scp"></a> scp</h2>
<p>scp在网络上的主机之间复制文件。它使用ssh进行数据传输，并使用与ssh相同的身份验证和提供相同的安全性。scp如果身份验证需要密码或密码短语，则会询问密码或密码。</p>
<p>scp 是加密的，rcp 是不加密的，scp 是 rcp 的加强版。</p>
<blockquote>
<p>文件名可能包含用户和主机规范，以指示将文件复制到该主机或从该主机复制文件。本地文件名可以使用绝对或相对路径名</p>
</blockquote>
<h3 id="基本使用"><a class="markdownIt-Anchor" href="#基本使用"></a> 基本使用</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载</span></span><br><span class="line">scp [options] remote_ip:remote_folder(remote_file) local_folder(local_file)</span><br><span class="line">scp [options] remote_user@remote_ip:remote_folder(remote_file) local_folder(local_file)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上传</span></span><br><span class="line">scp [options] local_folder(local_file) remote_ip:remote_folder(remote_file)</span><br><span class="line">scp [options] local_folder(local_file) remote_user@remote_ip:remote_folder(remote_file)</span><br></pre></td></tr></table></figure>
<p><strong>记忆</strong></p>
<blockquote>
<p>remote_ip 在前即下载，在后即上传</p>
</blockquote>
<h3 id="进阶使用"><a class="markdownIt-Anchor" href="#进阶使用"></a> 进阶使用</h3>
<ul>
<li>-1： 强制scp命令使用协议ssh1</li>
<li>-2： 强制scp命令使用协议ssh2</li>
<li>-4： 强制scp命令只使用IPv4寻址</li>
<li>-6： 强制scp命令只使用IPv6寻址</li>
<li>-B： 使用批处理模式（传输过程中不询问传输口令或短语）</li>
<li>-C： 允许压缩（将-C标志传递给ssh，从而打开压缩功能）</li>
<li>-q： 不显示传输进度条。</li>
<li>-r： 递归复制整个目录。</li>
<li>-v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li>
<li>-c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</li>
<li>-F ssh_config： 指定一个替代的ssh配置文件，此参数直接传递给ssh。</li>
<li>-i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</li>
<li>-l limit： 限定用户所能使用的带宽，以Kbit/s为单位。</li>
<li>-o ssh_option： 如果习惯于使用ssh_config中的参数传递方式，</li>
<li>-P port：注意是大写的P, port是指定数据传输用到的端口号</li>
<li>-S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</li>
</ul>
<h3 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h3>
<p>使用scp命令要确保使用的用户具有可读取远程服务器相应文件的权限，否则scp命令是无法起作用的。</p>
<p>如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">scp 命令使用端口号 4526</span></span><br><span class="line">scp -P 4526 remote@s2:/usr/local/checkNetwokr.sh ~/</span><br></pre></td></tr></table></figure>
<h2 id="实例脚本"><a class="markdownIt-Anchor" href="#实例脚本"></a> 实例脚本</h2>
<p>使用scp实现文件(夹)分发上传到服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 远程地址列表 remote hosts List</span></span></span><br><span class="line">rhs_list=(s1 s2)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 本地文件路径</span></span></span><br><span class="line">local_file=~/c.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 目的文件路径</span></span></span><br><span class="line">target_path=~/</span><br><span class="line"></span><br><span class="line">for host in $&#123;rhs_list[@]&#125;; do</span><br><span class="line">  scp -C $&#123;local_file&#125; root@$&#123;host&#125;:~/</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<blockquote>
<p>反之也可下载</p>
</blockquote>
<h2 id="小技巧"><a class="markdownIt-Anchor" href="#小技巧"></a> 小技巧</h2>
<p>配合ssh免密登陆与host解析scp更加丝滑哦</p>
<p>具体可参考基于ssh-key实现服务器免密登陆</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>scp</category>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/60366.html</url>
    <content><![CDATA[<h2 id="进制与位运算"><a class="markdownIt-Anchor" href="#进制与位运算"></a> 进制与位运算</h2>
<p>在我们编程的领域，进制的重要性不言而喻。为什么我的世界只有0与1，这之间到底有什么不可不知的秘密</p>
<p>为什么旁边的“高级工程师”，天天学框架、学架构，反而给他学废了。这一切的一切究竟是计算机的计算扭曲，还是计算机的道德沦丧。今天让我们进入哪个传说中只有0与1的世界。</p>
<span id="more"></span>
<h3 id="进制介绍"><a class="markdownIt-Anchor" href="#进制介绍"></a> 进制介绍</h3>
<p>进制是人为定义的带进位的计数方法（有不带进位的计数方法，比如原始的结绳计数法，唱票时常用的“正”字计数法，以及类似的tally<br />
mark计数）。 对于任何一种进制—X进制，就表示每一位置上的数运算时都是逢X进一位。<br />
是逢十进一，是逢十六进一，就是逢二进一，以此类推，x进制就是逢x进位。</p>
<h3 id="常见进制表示"><a class="markdownIt-Anchor" href="#常见进制表示"></a> 常见进制表示</h3>
<p>二进制: 0, 1 逢2进1，常以0b，0B开头</p>
<p>八进制：0-7 逢8进1，常以o开头</p>
<p>十进制：0-9 逢10进1</p>
<p>十六进制：逢16进1，0-9 A(10)-F(15 )常以0x开头</p>
<h3 id="进制运算"><a class="markdownIt-Anchor" href="#进制运算"></a> 进制运算</h3>
<p>二进制数的加法和乘法基本运算法则各有四条，如下：</p>
<p>0+0=0，0+1=1，1+0=1，1+1=10</p>
<p>0×0=0，0×1=0，1×0=0，1×1=1</p>
<h3 id="进制转换"><a class="markdownIt-Anchor" href="#进制转换"></a> 进制转换</h3>
<h4 id="十进制转二进制"><a class="markdownIt-Anchor" href="#十进制转二进制"></a> 十进制转二进制</h4>
<p>一个十进制整数转换为二进制整数通常采用除二取余法，即用2连续除十进制数，直到商为0，<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklODAlODYlRTUlQkElOEY=">逆序<i class="fa fa-external-link-alt"></i></span><br />
排列余数即可得到――简称除二取余法．</p>
<p>上面这段话是什么意思呢？逆序排列即二进制中的从高位到低位排序</p>
<p>如以下为例</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 十进制11的二进制</span></span><br><span class="line">11 ➗ 2 = 5  余 1</span><br><span class="line"> 5 ➗ 2 = 2  余 1</span><br><span class="line"> 2 ➗ 2 = 1  余 0 </span><br><span class="line"> 1 ➗ 2 = 0  余 1</span><br><span class="line"></span><br><span class="line">11 = (1011)2</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>十进制数除以 2 ，得到商和余数；</li>
<li>再用第一步的商除以 2,得到新的商和余数；</li>
<li>重复第 1 和第 2 步，直到商为 0;</li>
<li>将先得到的余数作为二进制数的高位，后得到的余数作为二进制数的低位，依次排序；</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decimal_to_binary</span>(<span class="params">value: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">if</span> value == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0b0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Accepted parameters must be int&quot;</span>)</span><br><span class="line">    flag = <span class="literal">False</span> <span class="keyword">if</span> value &lt;= <span class="number">0</span> <span class="keyword">else</span> <span class="literal">True</span></span><br><span class="line">    value = <span class="built_in">abs</span>(value)</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> value:</span><br><span class="line">        <span class="keyword">if</span> value % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            result.append(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        value &gt;&gt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0b&#x27;</span> + <span class="string">&#x27;&#x27;</span>.join(result[::-<span class="number">1</span>]) <span class="keyword">if</span> flag <span class="keyword">else</span> <span class="string">&#x27;-0b&#x27;</span> + <span class="string">&#x27;&#x27;</span>.join(result[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h4 id="二进制转十进制"><a class="markdownIt-Anchor" href="#二进制转十进制"></a> 二进制转十进制</h4>
<p>二进制转化为十进制的原理，(二进制数长度(不含0b) - 1) 次方 X 此位置的数值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0b1101 13</span><br><span class="line">2的3次方 乘 1 + 2的2次方 乘 1 + 2的1次方 乘 0 + 2的0次方 乘 1</span><br><span class="line">8 + 4 + 0 + 1</span><br></pre></td></tr></table></figure>
<p>代码实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary_to_decimal</span>(<span class="params">binary: <span class="built_in">str</span></span>):</span><br><span class="line">    binary_list = binary.split(<span class="string">&quot;0b&quot;</span>)[-<span class="number">1</span>] <span class="keyword">if</span> <span class="string">&#x27;0b&#x27;</span> <span class="keyword">in</span> binary <span class="keyword">else</span> binary</span><br><span class="line">    <span class="comment">#  判断是否为正数</span></span><br><span class="line">    flag = <span class="literal">True</span> <span class="keyword">if</span> <span class="string">&#x27;-&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> binary <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(binary_list):</span><br><span class="line">        a = <span class="number">2</span> ** <span class="built_in">int</span>(<span class="built_in">len</span>(binary_list) - index - <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">sum</span> += a * <span class="built_in">int</span>(value)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span> <span class="keyword">if</span> flag <span class="keyword">else</span> <span class="string">f&#x27;-<span class="subst">&#123;<span class="built_in">sum</span>&#125;</span>&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13: </span><br><span class="line">binary：0b1101 </span><br><span class="line">oct：(001) (101) 0o15</span><br><span class="line">hex：0000 (1101) 0xd</span><br></pre></td></tr></table></figure>
<p>同理得进制转换</p>
<h2 id="原码-反码-补码"><a class="markdownIt-Anchor" href="#原码-反码-补码"></a> 原码、反码、补码</h2>
<h2 id="位运算"><a class="markdownIt-Anchor" href="#位运算"></a> 位运算</h2>
<p>现代的计算器技术全部采用的是二进制，因为他只使用0、1两个数字符号，非常简单方便，易于计算机实现。计算机内部都是采用二进制数来表示</p>
]]></content>
      <categories>
        <category>computer</category>
        <category>bit</category>
      </categories>
      <tags>
        <tag>computer</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Golang操作文件的那些事儿</title>
    <url>/1627.html</url>
    <content><![CDATA[<h2 id="golang-文件操作"><a class="markdownIt-Anchor" href="#golang-文件操作"></a> Golang 文件操作</h2>
<p>Os模块的使用与源码研究</p>
<p>文件：计算机中的文件是存储在外部介质（通常是磁盘）上的数据集合，文件分为文本文件和二进制文件。例如咱们常见的文件后缀名<code>.exe</code>,<code>.txt</code><br />
,‘.word’…等等</p>
<p>文件的基本操作可简单分为<code>增</code>、<code>删</code>两类，也就是咱们所说的CURD(增删改查)<br />
，也是基于此两类操作。可简单理解为<code>打开文件夹</code>、<code>CURD</code>、关闭文件夹。结束～</p>
<p>golang对于文件基本上都是基于Golang的<code>os</code>模块，那让我们一起了解一下，那么Golang是如何对文件进行操作呢。Let’s<br />
Go~</p>
<span id="more"></span>
<h3 id="打开文件"><a class="markdownIt-Anchor" href="#打开文件"></a> 打开文件</h3>
<p>Golang中打开文件使用<code>os.Open</code>模块,官方os.open部分源码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os.Open</span></span><br><span class="line"><span class="comment">// Open opens the named file for reading. If successful, methods on</span></span><br><span class="line"><span class="comment">// the returned file can be used for reading; the associated file</span></span><br><span class="line"><span class="comment">// descriptor has mode O_RDONLY.</span></span><br><span class="line"><span class="comment">// If there is an error, it will be of type *PathError.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="type">string</span>)</span></span> (*File, <span class="type">error</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> OpenFile(name, O_RDONLY, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Open打开命名文件以供读取。如果成功，则可以使用返回文件上的方法进行读取；关联的文件。描述符的模式为O_RDONLY。<br />
如果有错误，它将是* PathError类型。</p>
<p>它接收一个string 类型的变量<code>name</code>,返回两个值，File的指针和错误error。那么我们使用它打开文件的的时候就需要这样做</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fileObj, err := os.Open(name <span class="type">string</span>)</span><br><span class="line"><span class="comment">// 其中os.Open中的name为路径Path</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>基础使用的介绍暂且为止，其实我们更应该关心的应该是<code>OpenFile(name, O_RDONLY, 0)</code><br />
，这个函数到底干了啥，我们追踪一下这个函数(在GoLang编辑器中， mac可以直接使用command +<br />
鼠标左键直接进入，Win可以使用ctrl + 鼠标左键)，如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (*File, <span class="type">error</span>) &#123;</span><br><span class="line"> testlog.Open(name)</span><br><span class="line"> f, err := openFileNolog(name, flag, perm)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line"> &#125;</span><br><span class="line"> f.appendMode = flag&amp;O_APPEND != <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// OpenFile是广义的open调用；大多数用户将使用Open 或Create代替。它打开带有指定标志的命名文件（O_RDONLY等）。如果该文件不存在，并且传递了O_CREATE标志，则会使用模式perm（在umask之前）创建该文件。如果成功，返回文件上的方法可以用于I / O。 如果有错误，它将是* PathError类型。</span></span><br></pre></td></tr></table></figure>
<p>这个文件全部内容还是有点分量的，有信息的伙伴，可以详细的阅读一下全部内容。暂且为止</p>
<p>那让我们实践一下，使用Golang打开文件，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// 打开此文件，./main.go为相对路径。在这里是此文件</span></span><br><span class="line"> fileObj, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line"> <span class="comment">// 异常处理</span></span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;Open File Error Message:%#v\n&quot;</span>, err)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 尝试打印(此处输出的为地址值)</span></span><br><span class="line"> fmt.Println(&amp;fileObj)</span><br><span class="line"> <span class="comment">// defer 关闭文件</span></span><br><span class="line"> <span class="keyword">defer</span> fileObj.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl44ct0b29j31fu0u07d6.jpg" alt="" /></p>
<p>以防忘记关闭文件，造成bug，我们在这里使用defer + 关闭。</p>
<blockquote></blockquote>
<p>注意：在编辑器中并不建议直接使用鼠标右键运行，这样可能会导致路径错误。大部分的编辑器都并不是只运行此文件!!!</p>
<blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Open File Error Message:&amp;os.PathError&#123;Op:<span class="string">&quot;open&quot;</span>, Path:<span class="string">&quot;./main.go&quot;</span>, Err:0x2&#125;</span><br></pre></td></tr></table></figure>
<p>如果你遇见了类似的错误，你可以直接在终端中，切换到当前路径。使用<code>go run main.go</code>，直接运行。这样就可以直接得到正确的结果啦</p>
</blockquote>
<h3 id="读取文件"><a class="markdownIt-Anchor" href="#读取文件"></a> 读取文件</h3>
<p>打开文件之后，那么我们可以就可以对他们进行操作了，我们在这里主要演示一下读取文件的操作。还是老样子，先看一下主要的相关源码，如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FileObj.Read()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Read(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> err := f.checkValid(<span class="string">&quot;read&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line"> &#125;</span><br><span class="line"> n, e := f.read(b)</span><br><span class="line"> <span class="keyword">return</span> n, f.wrapErr(<span class="string">&quot;read&quot;</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f.read(b)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> read(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"> n, err = f.pfd.Read(b)</span><br><span class="line"> runtime.KeepAlive(f)</span><br><span class="line"> <span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>FileObj.Read()</p>
<p>示例化接受文件的地址值(也就是咱们前面打开获取到的结果)，接受切片的字节，返回读取的内容，以及错误</p>
<p>在此函数中首先检查是否为有效的读取，然后在进行f.read(b)的操作,接受其返回结果。</p>
<p>f.read(b)</p>
<p>在这里，主要检测是否在读取，如果是那么返回本次的读取内容</p>
</blockquote>
<p>从以上我们不难看出，其实读取文件是读取文件内部的字节</p>
<p>那么更具FileObj.Read()，我们可以了解它基本的使用方法，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Read(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>读取部分的示例代码如下：</p>
<p>在这里我们需要考虑：是否能够正常读取？是否读完了？具体请看异常处理部分</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"> <span class="comment">// 定义每次读取的大小</span></span><br><span class="line"> <span class="comment">//var tmp = make([]byte, 128)</span></span><br><span class="line"> <span class="keyword">var</span> tmp  [<span class="number">128</span>]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// n:从开始到结尾的内容</span></span><br><span class="line"> n, err := fileObj.Read(tmp[:])</span><br><span class="line"> <span class="comment">// 异常处理</span></span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;Read of File Error, ErrorMessage:%#v\n&quot;</span>, err)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;文件读完了&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;读取了%d个字节\n&quot;</span>, n)</span><br><span class="line"> fmt.Printf(<span class="string">&quot;读取到的内容：\n%s&quot;</span>,tmp[:])</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl453fvstjj30su0fg75h.jpg" alt="" /></p>
<p>以上很明显是并没有读完的仅读取了部分，原始的全部代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;io&quot;</span></span><br><span class="line"> <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// 打开此文件，./main.go为相对路径。在这里是此文件</span></span><br><span class="line"> fileObj, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line"> <span class="comment">// 异常处理</span></span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;Open of File Error, ErrorMessage:%#v\n&quot;</span>, err)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 尝试打印(此处输出的为地址值)</span></span><br><span class="line"> fmt.Println(&amp;fileObj)</span><br><span class="line"> <span class="comment">// defer 关闭文件</span></span><br><span class="line"> <span class="keyword">defer</span> fileObj.Close()</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 读取文件</span></span><br><span class="line"> <span class="comment">// 定义每次读取的大小</span></span><br><span class="line"> <span class="comment">//var tmp = make([]byte, 128)</span></span><br><span class="line"> <span class="keyword">var</span> tmp  [<span class="number">128</span>]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// n:从开始到结尾的内容</span></span><br><span class="line"> n, err := fileObj.Read(tmp[:])</span><br><span class="line"> <span class="comment">// 异常处理</span></span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;Read of File Error, ErrorMessage:%#v\n&quot;</span>, err)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;文件读完了&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;读取了%d个字节\n&quot;</span>, n)</span><br><span class="line"> fmt.Printf(<span class="string">&quot;读取到的内容：\n%s&quot;</span>,tmp[:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="完整读取"><a class="markdownIt-Anchor" href="#完整读取"></a> 完整读取</h3>
<h4 id="for无线循环读取"><a class="markdownIt-Anchor" href="#for无线循环读取"></a> for无线循环读取</h4>
<p>由于以上我们并没有读取完整个文件，那么我需要读取全部的该怎么办呢？一个方法是不断的读取下去，然后和在一起就是完整的内容了，示例代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;io&quot;</span></span><br><span class="line"> <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// 打开此文件，./main.go为相对路径。在这里是此文件</span></span><br><span class="line"> fileObj, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line"> <span class="comment">// 异常处理</span></span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;Open of File Error, ErrorMessage:%#v\n&quot;</span>, err)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 尝试打印(此处输出的为地址值)</span></span><br><span class="line"> fmt.Println(&amp;fileObj)</span><br><span class="line"> <span class="comment">// defer 关闭文件</span></span><br><span class="line"> <span class="keyword">defer</span> fileObj.Close()</span><br><span class="line"> <span class="comment">// 循环读取文件</span></span><br><span class="line"> <span class="keyword">var</span> content []<span class="type">byte</span></span><br><span class="line"> <span class="keyword">var</span> tmp = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">128</span>)</span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">  n, err := fileObj.Read(tmp)</span><br><span class="line">  <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;文件读完了&quot;</span>)</span><br><span class="line">   <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;Read of File Error, ErrorMessage:%#v\n&quot;</span>, err)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  content = <span class="built_in">append</span>(content, tmp[:n]...)</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Println(<span class="type">string</span>(content))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主要的思路为：无限循环去读取，读完了之后break掉。然后把读取的内容合并起来</p>
<p>这种读取虽然可行，不过是否有点太麻烦了，那么有什么更简便的方式呢？答案当然是有的，bufio读取</p>
<h4 id="bufio读取"><a class="markdownIt-Anchor" href="#bufio读取"></a> bufio读取</h4>
<p>bufio是在file的基础上封装了一层API，支持更多的功能。</p>
<p>主要的部分源码如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bufio.NewReader</span></span><br><span class="line"><span class="comment">// NewReader returns a new Reader whose buffer has the default size.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span></span> *Reader &#123;</span><br><span class="line"> <span class="keyword">return</span> NewReaderSize(rd, defaultBufSize)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewReaderSize</span></span><br><span class="line"><span class="comment">// NewReaderSize returns a new Reader whose buffer has at least the specified</span></span><br><span class="line"><span class="comment">// size. If the argument io.Reader is already a Reader with large enough</span></span><br><span class="line"><span class="comment">// size, it returns the underlying Reader.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReaderSize</span><span class="params">(rd io.Reader, size <span class="type">int</span>)</span></span> *Reader &#123;</span><br><span class="line"> <span class="comment">// Is it already a Reader?</span></span><br><span class="line"> b, ok := rd.(*Reader)</span><br><span class="line"> <span class="keyword">if</span> ok &amp;&amp; <span class="built_in">len</span>(b.buf) &gt;= size &#123;</span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> size &lt; minReadBufferSize &#123;</span><br><span class="line">  size = minReadBufferSize</span><br><span class="line"> &#125;</span><br><span class="line"> r := <span class="built_in">new</span>(Reader)</span><br><span class="line"> r.reset(<span class="built_in">make</span>([]<span class="type">byte</span>, size), rd)</span><br><span class="line"> <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它简便的原因是因为已经帮我们定义了文件的指针，以及它还定义了缓冲区，这样我们使用它来读取更加的快与便捷。</p>
<p>bufio.NewReader语法格式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span></span> *Reader </span><br><span class="line"><span class="comment">// 其中rd为我们打开文件的对象</span></span><br></pre></td></tr></table></figure>
<p>使用如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;bufio&quot;</span></span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;io&quot;</span></span><br><span class="line"> <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// 打开此文件，./main.go为相对路径。在这里是此文件</span></span><br><span class="line"> fileObj, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line"> <span class="comment">// 异常处理</span></span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;Open of File Error, ErrorMessage:%#v\n&quot;</span>, err)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 尝试打印(此处输出的为地址值)</span></span><br><span class="line"> fmt.Println(&amp;fileObj)</span><br><span class="line"> <span class="comment">// defer 关闭文件</span></span><br><span class="line"> <span class="keyword">defer</span> fileObj.Close()</span><br><span class="line"> <span class="comment">// bufio读取</span></span><br><span class="line"> reader := bufio.NewReader(fileObj)</span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">  line, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">//注意是字符</span></span><br><span class="line">  <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(line) != <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(line)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;文件读完了&quot;</span>)</span><br><span class="line">   <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;read file failed, err:&quot;</span>, err)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Print(line)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入结果如上，略。。。</p>
<p>搞了这么多，就没有一键读取的么？当然也是有的，让我们来了体验一下<code>ioutil</code>读取整个文件的愉悦。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> &quot;fmt&quot;</span><br><span class="line"> &quot;io/ioutil&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// ioutil.ReadFile读取整个文件</span><br><span class="line">func main() &#123;</span><br><span class="line"> content, err := ioutil.ReadFile(&quot;./main.go&quot;)</span><br><span class="line"> if err != nil &#123;</span><br><span class="line">  fmt.Println(&quot;read file failed, err:&quot;, err)</span><br><span class="line">  return</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Println(string(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其内部的实现原理，先预测整个文件的大小。然后一次性全部读取。当然需要做好异常的准备哦</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReadFile reads the file named by filename and returns the contents.</span></span><br><span class="line"><span class="comment">// A successful call returns err == nil, not err == EOF. Because ReadFile</span></span><br><span class="line"><span class="comment">// reads the whole file, it does not treat an EOF from Read as an error</span></span><br><span class="line"><span class="comment">// to be reported.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line"> f, err := os.Open(filename)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">defer</span> f.Close()</span><br><span class="line"> <span class="comment">// It&#x27;s a good but not certain bet that FileInfo will tell us exactly how much to</span></span><br><span class="line"> <span class="comment">// read, so let&#x27;s try it but be prepared for the answer to be wrong.</span></span><br><span class="line"> <span class="keyword">var</span> n <span class="type">int64</span> = bytes.MinRead</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> fi, err := f.Stat(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="comment">// As initial capacity for readAll, use Size + a little extra in case Size</span></span><br><span class="line">  <span class="comment">// is zero, and to avoid another allocation after Read has filled the</span></span><br><span class="line">  <span class="comment">// buffer. The readAll call will read into its allocated internal buffer</span></span><br><span class="line">  <span class="comment">// cheaply. If the size was wrong, we&#x27;ll either waste some space off the end</span></span><br><span class="line">  <span class="comment">// or reallocate as needed, but in the overwhelmingly common case we&#x27;ll get</span></span><br><span class="line">  <span class="comment">// it just right.</span></span><br><span class="line">  <span class="keyword">if</span> size := fi.Size() + bytes.MinRead; size &gt; n &#123;</span><br><span class="line">   n = size</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> readAll(f, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件写入操作"><a class="markdownIt-Anchor" href="#文件写入操作"></a> 文件写入操作</h3>
<p><code>os.OpenFile()</code>函数能够以指定模式打开文件，从而实现文件写入相关功能。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (*File, <span class="type">error</span>) &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<p><code>name</code>：要打开的文件名 <code>flag</code>：打开文件的模式。 模式有以下几种：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>os.O_WRONLY</code></td>
<td style="text-align:center">只写</td>
</tr>
<tr>
<td style="text-align:center"><code>os.O_CREATE</code></td>
<td style="text-align:center">创建文件</td>
</tr>
<tr>
<td style="text-align:center"><code>os.O_RDONLY</code></td>
<td style="text-align:center">只读</td>
</tr>
<tr>
<td style="text-align:center"><code>os.O_RDWR</code></td>
<td style="text-align:center">读写</td>
</tr>
<tr>
<td style="text-align:center"><code>os.O_TRUNC</code></td>
<td style="text-align:center">清空</td>
</tr>
<tr>
<td style="text-align:center"><code>os.O_APPEND</code></td>
<td style="text-align:center">追加</td>
</tr>
</tbody>
</table>
<p><code>perm</code>：文件权限，一个八进制数。r（读）04，w（写）02，x（执行）01。</p>
<h4 id="write和writestring"><a class="markdownIt-Anchor" href="#write和writestring"></a> Write和WriteString</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> file, err := os.OpenFile(test.txt<span class="string">&quot;, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)</span></span><br><span class="line"><span class="string"> if err != nil &#123;</span></span><br><span class="line"><span class="string">  fmt.Println(&quot;</span>open file failed, err:<span class="string">&quot;, err)</span></span><br><span class="line"><span class="string">  return</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"> defer file.Close()</span></span><br><span class="line"><span class="string"> str := &quot;</span>hello<span class="string">&quot;</span></span><br><span class="line"><span class="string"> file.Write([]byte(str))       //写入字节切片数据</span></span><br><span class="line"><span class="string"> file.WriteString(&quot;</span>hello<span class="string">&quot;) //直接写入字符串数据</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="bufionewwriter"><a class="markdownIt-Anchor" href="#bufionewwriter"></a> bufio.NewWriter</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> file, err := os.OpenFile(<span class="string">&quot;xx.txt&quot;</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;open file failed, err:&quot;</span>, err)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">defer</span> file.Close()</span><br><span class="line"> writer := bufio.NewWriter(file)</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  writer.WriteString(<span class="string">&quot;hello&quot;</span>) <span class="comment">//将数据先写入缓存</span></span><br><span class="line"> &#125;</span><br><span class="line"> writer.Flush() <span class="comment">//将缓存中的内容写入文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ioutilwritefile"><a class="markdownIt-Anchor" href="#ioutilwritefile"></a> ioutil.WriteFile</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> str := <span class="string">&quot;hello&quot;</span></span><br><span class="line"> err := ioutil.WriteFile(<span class="string">&quot;./asd.txt&quot;</span>, []<span class="type">byte</span>(str), <span class="number">0666</span>)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;write file failed, err:&quot;</span>, err)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>so cool～</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Jetbrains Mono字体</title>
    <url>/14146.html</url>
    <content><![CDATA[<p>Jetbrains Mono 字体据说是Jetbrains 公司对于开发人员而开发的字体，当然个人觉得也不错，所以在此安装以及使用一波。分别在Jetbrains和VSCode中,Mono<br />
相关链接如下</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamV0YnJhaW5zLmNvbS9scC9tb25vLyNob3ctdG8taW5zdGFsbA==">Mono<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamV0YnJhaW5zLmNvbS96aC1jbi9scC9tb25vLyNob3ctdG8taW5zdGFsbA==">Mono zh-cn<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="在jetbrains编辑器中使用"><a class="markdownIt-Anchor" href="#在jetbrains编辑器中使用"></a> 在Jetbrains编辑器中使用</h2>
<h3 id="设置"><a class="markdownIt-Anchor" href="#设置"></a> 设置</h3>
<p><strong>step 1</strong></p>
<p>Preferences/Settings -&gt; Editor -&gt; Font，右边字体中选择 <code>Jetbrains Mono</code>,</p>
<blockquote>
<p>我的设置</p>
<p>Size：13 Line hight：1.2 Enable Ligature</p>
</blockquote>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gxsee1orkhj30ra0jojtc.jpg" alt="image-20211227145717002" /></p>
<blockquote>
<p>Tip: 从 v2019.3 开始，JetBrains IDE 随附了最新版本的 JetBrains Mono。</p>
</blockquote>
<p><strong>step 2</strong></p>
<blockquote>
<p>进行了以上的设置之后可能还无法使用，此时我们需要在进一步的设置，如下</p>
</blockquote>
<p>Preferences/Settings -&gt; Editor -&gt; Color Scheme -&gt; Color Scheme Font</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gxseoq1e4nj30ra0jo3zx.jpg" alt="image-20211227150734888" /></p>
<p>效果如下</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gxseu12227j30ol0llabw.jpg" alt="image-20211227151240648" /></p>
<h2 id="在vscode中使用"><a class="markdownIt-Anchor" href="#在vscode中使用"></a> 在Vscode中使用</h2>
<h3 id="下载"><a class="markdownIt-Anchor" href="#下载"></a> 下载</h3>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gxsf74l0goj318q0l7gnh.jpg" alt="image-20211227152516091" /></p>
<h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gxsf7sit6nj30io08474w.jpg" alt="image-20211227152554293" /></p>
<blockquote>
<p>为了兼容性考虑，我建议是全部安装。当然也可仅安装<code>Regular.tff</code>也可</p>
</blockquote>
<h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2>
<p>在配置文件中修改为如下</p>
<blockquote>
<p>存在即修改，不存在就新增。重启VS code即可</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;editor.fontFamily&quot;: &quot;JetBrains Mono, Menlo, Monaco, &#x27;Courier New&#x27;, monospace&quot;,</span><br><span class="line">&quot;editor.fontLigatures&quot;: true</span><br></pre></td></tr></table></figure>
<p>显示如下所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gxsfgpmnjhj30u50bl0tz.jpg" alt="image-20211227153428863" /></p>
]]></content>
      <categories>
        <category>font</category>
        <category>Jetbrains</category>
        <category>Jetbrains-mono</category>
      </categories>
      <tags>
        <tag>font</tag>
      </tags>
  </entry>
  <entry>
    <title>使用迭代器优化pymysql大量查询</title>
    <url>/47941.html</url>
    <content><![CDATA[<h2 id="缘由"><a class="markdownIt-Anchor" href="#缘由"></a> 缘由</h2>
<p>当我们需要使用<code>pymysql</code>进行大量数据的提取时，发现越来越慢。直到阻塞，down。</p>
<h2 id="解决"><a class="markdownIt-Anchor" href="#解决"></a> 解决</h2>
<p>使用<code>SSDictCursor</code>无缓冲游标来操作，使用<code>fetchall_unbuffered</code>，来进行。同时辅以分页查询即可。</p>
<p>首先是建立连接，<code>curror</code> 的选择</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymysql <span class="keyword">import</span> connect, cursors</span><br><span class="line"></span><br><span class="line">client = connect(**&#123;</span><br><span class="line">    <span class="string">&quot;host&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;port&quot;</span>: <span class="number">3306</span>,</span><br><span class="line">    <span class="string">&quot;user&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;123321&quot;</span>,</span><br><span class="line">    <span class="string">&quot;database&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;charset&#x27;</span>: <span class="string">&#x27;utf8&#x27;</span></span><br><span class="line">&#125;, cursorclass=cursors.SSCursor)</span><br><span class="line"></span><br><span class="line">cursor = client.cursor()</span><br></pre></td></tr></table></figure>
<p>注意在此可以选择<strong>无缓冲游标</strong>， 来操作。即<code>cursors.SSCursor</code>,<code>cursors.SSDictCursor</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">page_count = <span class="number">1000</span></span><br><span class="line"><span class="keyword">for</span> pg <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    query_sql = <span class="string">f&quot;&quot;&quot;select * from xiaohongshu_comment_note_2 limit <span class="subst">&#123;page_number * page_count&#125;</span>, <span class="subst">&#123;page_count&#125;</span>;&quot;&quot;&quot;</span></span><br><span class="line">    cursor.execute(query_sql)</span><br><span class="line"><span class="keyword">for</span> results <span class="keyword">in</span> cursor.fetchall_unbuffered():</span><br><span class="line">    <span class="built_in">print</span>(results)</span><br></pre></td></tr></table></figure>
<p>当然还可以在函数中这样写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">unbuffer_query</span>(<span class="params">page_count=<span class="number">1000</span>, max_page=<span class="number">1000</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param page_count:</span></span><br><span class="line"><span class="string">    :param max_page:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> page_number <span class="keyword">in</span> <span class="built_in">range</span>(max_page):</span><br><span class="line">        query_sql = <span class="string">f&quot;&quot;&quot;select * from xiaohongshu_comment_note_2 limit <span class="subst">&#123;page_number * page_count&#125;</span>, <span class="subst">&#123;page_count&#125;</span>;&quot;&quot;&quot;</span></span><br><span class="line">        cursor.execute(query_sql)</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> cursor.fetchall_unbuffered()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> unbuffer_query(page_count=<span class="number">999</span>, max_page=<span class="number">9999</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<p>瑞思拜～</p>
]]></content>
      <categories>
        <category>python</category>
        <category>pymysql</category>
        <category>iterators</category>
      </categories>
      <tags>
        <tag>pymysql</tag>
      </tags>
  </entry>
  <entry>
    <title>初探nginx</title>
    <url>/20679.html</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9uZ2lueC5vcmcv">开源官方网站<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9uZ2lueC5vcmcvZW4vZG93bmxvYWQuaHRtbA==">下载界面<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9uZ2lueC5vcmcvZW4vZG9jcy8=">官方文档<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL29wZW5yZXN0eS5vcmcvZW4v">openresty<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9uZ2lueC5jb20v">商业nginx<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL29wZW5yZXN0eS5jb20=">商业openresty<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="什么是nginx"><a class="markdownIt-Anchor" href="#什么是nginx"></a> 什么是Nginx</h2>
<p><strong>Nginx</strong> <strong>(engine x)</strong> 是一款轻量级的Web 服务器 、反向代理服务器及电子邮件（IMAP/POP3）代理服务器。</p>
<p><strong>反向代理：</strong></p>
<p>反向代理（Reverse<br />
Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<p><strong>正向代理:</strong></p>
<p>是一个位于客户端和原始服务器(origin server)<br />
之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)<br />
，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。</p>
<h3 id="正向代理和反向代理区别"><a class="markdownIt-Anchor" href="#正向代理和反向代理区别"></a> 正向代理和反向代理区别？</h3>
<p><strong>正向代理</strong>，**是在客户端的。<strong>比如需要访问某些国外网站，我们可能需要购买vpn。并且</strong>vpn是在我们的用户浏览器端设置的<br />
**(并不是在远端的服务器设置)。浏览器先访问vpn地址，vpn地址转发请求，并最后将请求结果原路返回来。</p>
<p><strong>反向代理是作用在服务器端的，是一个虚拟ip(VIP)</strong>。对于用户的一个请求，会转发到多个后端处理器中的一台来处理该具体请求。</p>
<h2 id="为什么是nginx"><a class="markdownIt-Anchor" href="#为什么是nginx"></a> 为什么是Nginx？</h2>
<p>互联网数据量快速增长，高并发</p>
<p>摩尔定律：性能提升</p>
<p>比Apache(一个连接对应一个进程)更快</p>
<h3 id="nginx优点"><a class="markdownIt-Anchor" href="#nginx优点"></a> Nginx优点</h3>
<ul>
<li>高并发、高性能</li>
<li>可拓展性好（插件）</li>
<li>高可靠</li>
<li>热部署</li>
<li>BSD认证</li>
</ul>
<h2 id="nginx-主要使用场景"><a class="markdownIt-Anchor" href="#nginx-主要使用场景"></a> Nginx 主要使用场景</h2>
<img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzuy18sw32j20j50hrdh4.jpg" alt="image-20220302040819009" style="zoom:50%;" />
<img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzuy0uhn4zj20lz0l3dgt.jpg" alt="image-20220302040819009" style="zoom:50%;" />
<h2 id="nginx组成"><a class="markdownIt-Anchor" href="#nginx组成"></a> Nginx组成</h2>
<ul>
<li>Nginx，二进制可执行文件</li>
<li>Nginx config 配置文件： 控制nginx行为</li>
<li>access log : 记录每一条请求</li>
<li>error log：错误日志</li>
</ul>
<h2 id="nginx-版本"><a class="markdownIt-Anchor" href="#nginx-版本"></a> Nginx 版本</h2>
<p>Mainline version：主线版本，最新功能等</p>
<p>Stable version：稳定版，</p>
<p>Legacy versions：历史版本</p>
<p><span class="exturl" data-url="aHR0cDovL3RlbmdpbmUudGFvYmFvLm9yZy8=">tenginx<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9uZ2lueC5vcmcvZW4vQ0hBTkdFUw==">nginx各版本更新日志<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li>Bugfix： 修复bug</li>
<li>Change： 修改</li>
<li>Feature： 新特性</li>
</ul>
<h2 id="编译安装nginx"><a class="markdownIt-Anchor" href="#编译安装nginx"></a> 编译安装Nginx</h2>
<p>安装Nginx 通常有两张方式，其一，那便是使用包管理工具如<code>yum</code>、<code>apt-get</code>、<code>homebrew</code>、<code>winget</code><br />
等直接安装，而另外一种便是编译安装。</p>
<p>个人推荐使用编译安装，其主要原因为可以将各组件一起编译生成，兼容其强大的生态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Download</span></span><br><span class="line">curl -OC - https://nginx.org/download/nginx-1.20.2.tar.gz</span><br><span class="line"><span class="comment"># unzip</span></span><br><span class="line">tar -xzf nginx-1.20.2.tar.gz &amp;&amp; <span class="built_in">cd</span> nginx-1.20.2</span><br><span class="line"><span class="comment"># 编译(默认参数)</span></span><br><span class="line"><span class="comment"># yum -y install gcc gcc-c++ make libtool zlib zlib-devel openssl openssl-devel pcre pcre-devel</span></span><br><span class="line">./configure --prefix=/opt</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make </span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx </span><br><span class="line">  --pid-path=/var/run/nginx/nginx.pid </span><br><span class="line">  --lock-path=/var/lock/nginx.lock </span><br><span class="line">  --error-log-path=/var/log/nginx/error.log </span><br><span class="line">  --http-log-path=/var/log/nginx/access.log </span><br><span class="line">  --with-http_gzip_static_module </span><br><span class="line">  --http-client-body-temp-path=/var/temp/nginx/client </span><br><span class="line">  --http-proxy-temp-path=/var/temp/nginx/proxy </span><br><span class="line">  --http-fastcgi-temp-path=/var/temp/nginx/fastcgi </span><br><span class="line">  --http-uwsgi-temp-path=/var/temp/nginx/uwsgi </span><br><span class="line">  --http-scgi-temp-path=/var/temp/nginx/scgi</span><br></pre></td></tr></table></figure>
<p>相关参数</p>
<img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzv31s7hj2j20qq0d0js5.jpg" alt="1051646169511_.pic"/>
<h2 id="nginx源码目录结构"><a class="markdownIt-Anchor" href="#nginx源码目录结构"></a> nginx源码目录结构</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">drwxr-xr-x 6 1001 1001   4096 Mar  2 03:09 auto: 编译时所用</span><br><span class="line">-rw-r--r-- 1 1001 1001 312251 Nov 16 22:44 CHANGES：版本变更</span><br><span class="line">-rw-r--r-- 1 1001 1001 476577 Nov 16 22:44 CHANGES.ru：版本变更（俄语）</span><br><span class="line">drwxr-xr-x 2 1001 1001   4096 Mar  2 03:09 conf nginx配置示例文件</span><br><span class="line">-rwxr-xr-x 1 1001 1001   2590 Nov 16 22:44 configure：用来生产中间文件，执行编译前的必备动作</span><br><span class="line">drwxr-xr-x 4 1001 1001   4096 Mar  2 03:09 contrib：vim工具，</span><br><span class="line">drwxr-xr-x 2 1001 1001   4096 Mar  2 03:09 html: 500错误，index.html</span><br><span class="line">-rw-r--r-- 1 1001 1001   1397 Nov 16 22:44 LICENSE</span><br><span class="line">drwxr-xr-x 2 1001 1001   4096 Mar  2 03:09 man: nginx 帮助文件</span><br><span class="line">-rw-r--r-- 1 1001 1001     49 Nov 16 22:44 README：</span><br><span class="line">drwxr-xr-x 9 1001 1001   4096 Nov 16 22:44 src： nginx源代码</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="comment"># tree . -d 1</span></span><br><span class="line"></span><br><span class="line">├── auto</span><br><span class="line">│   ├── cc：用于编译</span><br><span class="line">│   ├── lib：外部目录</span><br><span class="line">│   │   ├── geoip</span><br><span class="line">│   │   ├── google-perftools</span><br><span class="line">│   │   ├── libatomic</span><br><span class="line">│   │   ├── libgd</span><br><span class="line">│   │   ├── libxslt</span><br><span class="line">│   │   ├── openssl</span><br><span class="line">│   │   ├── pcre</span><br><span class="line">│   │   ├── perl</span><br><span class="line">│   │   └── zlib</span><br><span class="line">│   ├── os: 操作系统判断</span><br><span class="line">│   └── types</span><br><span class="line">├── conf: 配置文件示意</span><br><span class="line">├── contrib</span><br><span class="line">│   ├── unicode2nginx</span><br><span class="line">│   └── vim</span><br><span class="line">│       ├── ftdetect</span><br><span class="line">│       ├── ftplugin</span><br><span class="line">│       ├── indent</span><br><span class="line">│       └── syntax</span><br><span class="line">├── html</span><br><span class="line">├── man</span><br><span class="line">└── src</span><br><span class="line">    ├── core</span><br><span class="line">    ├── event</span><br><span class="line">    │   └── modules</span><br><span class="line">    ├── http</span><br><span class="line">    │   ├── modules</span><br><span class="line">    │   │   └── perl</span><br><span class="line">    │   └── v2</span><br><span class="line">    ├── mail</span><br><span class="line">    ├── misc</span><br><span class="line">    ├── os</span><br><span class="line">    │   └── unix</span><br><span class="line">    └── stream</span><br></pre></td></tr></table></figure>
<p>tips</p>
<p>将 contrib 中的文件夹copy 到vim目录下，以便于使用vim对配置文件等进行便捷的编辑，如下command</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DIR=<span class="string">&quot;ftdetect ftplugin indent syntax&quot;</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> <span class="variable">$DIR</span>; <span class="keyword">do</span></span><br><span class="line"> <span class="built_in">mkdir</span> -p ~/.vim/<span class="variable">$&#123;dir&#125;</span></span><br><span class="line">  <span class="built_in">cp</span> -r contrib/vim/<span class="variable">$&#123;dir&#125;</span>/nginx.vim ~/.vim/<span class="variable">$&#123;dir&#125;</span>/nginx.vim</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h2 id="nginx-配置"><a class="markdownIt-Anchor" href="#nginx-配置"></a> Nginx 配置</h2>
<h3 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h3>
<ul>
<li>配置文件由指令与指令块构成</li>
<li>每条指令以<code>;</code> 结尾，指令与参数之间以空格符号分割</li>
<li>指令块以<code>&#123;&#125;</code> 将多条指令组织在一起</li>
<li>include语句允许组合多个配置文件，提升可维护性</li>
<li><code>#</code>: 实现注释</li>
<li><code>$</code>:使用变量</li>
<li>部分指令支持regexp， 如路径匹配等</li>
</ul>
<h3 id="参数"><a class="markdownIt-Anchor" href="#参数"></a> 参数</h3>
<p><strong>时间</strong></p>
<ul>
<li>ms: MilliSeconds</li>
<li>s: Seconds</li>
<li>m: minutes</li>
<li>h: hours</li>
<li>d: days</li>
<li>w: weeks</li>
<li>m: months</li>
<li>years</li>
</ul>
<p><strong>存储空间</strong></p>
<p>bytes (default)</p>
<p>k/K: kilobytes</p>
<p>m/M: megabytes</p>
<p>g/G: gigabytes</p>
<h3 id="配置指令块"><a class="markdownIt-Anchor" href="#配置指令块"></a> 配置指令块</h3>
<img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzv0wsgmh8j20va0kzwfu.jpg" alt="image-20220302040819009" style="zoom:50%;" />
<p>http: 表示所有的指令都是http解析的</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line"> <span class="attribute">include</span> mine.types</span><br><span class="line">  <span class="comment"># 上游服务</span></span><br><span class="line"> upstream thwp &#123;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span></span><br><span class="line"> &#125;</span><br><span class="line">  <span class="comment"># (一组)域名</span></span><br><span class="line">  server &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span> </span><br><span class="line">    location ～*.(gif|jpg|jpeg)$ &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置实践"><a class="markdownIt-Anchor" href="#配置实践"></a> 配置实践</h3>
<p><strong>配置upstream</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  // proxycluster: 服务组名字</span><br><span class="line">  <span class="section">upstream</span> proxycluster &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">10.21.200.101:8081</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">10.21.200.121:8081</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">10.21.200.111:8081</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">10.21.200.191:8081</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://proxycluster;</span><br><span class="line">    <span class="attribute">auth_basic</span> <span class="string">&quot;Restricted&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>weight=number: 服务器的权重值，默认是1；</p>
<p>max_conns=number: 设置允许的最大活动连接数。默认是0，表示不限制。（设置<code>keepalive</code><br />
时，如果有多个worker共享内存，则连接数可能会超过设置的值）</p>
<p>max_fails=number: 设置在<code>fail_timeout</code>参数设置的时间段内允许的失败最大尝试次数，默认是1，设置0表示失败不会尝试。</p>
<p>fail_timeout=time: <code>fail_timeout</code>的值包含两层意思：</p>
<ol>
<li>
<p>在这个时间段内服务器通信失败次数决定服务状态是否为不可用；</p>
</li>
<li>
<p>服务器被视为不可用状态的时间段。默认是10秒。</p>
</li>
</ol>
<p>backup: 标记服务器是备用服务器，只有在其他服务器都不可用的情况下，才会请求该服务器。（在哈希、IP哈希、随机三种负载均衡模式下不可用）</p>
<p>down: 标记服务器永久不可用状态。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzc1MzM3OQ==">正则表达式匹配路由<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>nginx</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>反爬虫常见策略总结</title>
    <url>/49632.html</url>
    <content><![CDATA[<p>知己知彼，百战不殆 ——《孙子兵法》。</p>
<blockquote>
<p>本文仅总结鄙人所知的反爬虫方式，不涉猎任何具体的分析与绕过方案。</p>
</blockquote>
<h1 id="反爬虫"><a class="markdownIt-Anchor" href="#反爬虫"></a> 反爬虫</h1>
<p>反爬虫，即应对爬虫进行反制的统称，<strong>主要区分“正常用户”与“机器人”的一种策略统称</strong>。</p>
<h2 id="认识反爬虫"><a class="markdownIt-Anchor" href="#认识反爬虫"></a> 认识反爬虫</h2>
<p>​ 正所谓知其然，知其所以然。对于反爬虫的措施有所了解与认知，一方面便于快捷定位防护点实现分析或绕过，另一方面组成爬虫攻防体系。万变自不离其宗，应对反爬虫措施游刃有余。一般常在如下几大部分<br />
<strong>设伏</strong>。</p>
<blockquote>
<p>以下便不考虑第三方测试工具的校验</p>
</blockquote>
<h3 id="请求前校验"><a class="markdownIt-Anchor" href="#请求前校验"></a> 请求前校验</h3>
<h4 id="抓包拦截"><a class="markdownIt-Anchor" href="#抓包拦截"></a> <strong>抓包拦截</strong></h4>
<p>​ 做过爬虫的小伙伴，一定知道在分析加密、执行爬虫项目之前。首先第一步一定是先抓包，定位到对应数据包，然后继续才进行分析或规律。那么在此无疑是<br />
<strong>最为有效</strong><br />
的反抓，捕获不到流量包URL未知，除了使用自动化测试工具、RPC等通常可能都毫无办法。</p>
<p>抓包拦截又可细分为控制台检测、端口转移、证书校验，私有协议总而言之就是让你抓不到包，其方法无所不用其极。</p>
<p>控制台检测抓包绕过策略：</p>
<ul>
<li>
<p>替代法: 采用<strong>中间人抓包</strong>（Charles、mitmproxy、firdler等）</p>
</li>
<li>
<p>分析绕过法：定位到检测处，分析绕过</p>
</li>
</ul>
<p>端口转移绕过策略：</p>
<ul>
<li>强制端口</li>
<li>流量转发</li>
</ul>
<p><strong>证书锁定与公钥锁定</strong></p>
<p>​ 为了防止中间人攻击，采用SSL-Pinning的技术来反抓包。 中间人抓包要点是伪造了一个假的证书实现拦截与转发，从而在中间获取的过路数据包实现抓包。<br />
反抓思路就是，客户端也预置一份服务端的证书，比较一下就知道真假了。SSL-pinning有两种方式证书锁定（Certificate<br />
Pinning）与公钥锁定（Public Key Pinning）</p>
<p>证书锁定</p>
<blockquote>
<p>​ 证书锁定是SSL/TLS加密的额外保证手段。它会将服务器的证书公钥预先保存在客户端。在建立安全连接的过程中，客户端会将预置的公钥和接受的证书做比较。<br />
如果一致，就建立连接，否则就拒绝连接。在客户端设置证书只允许设置指定域名的证书，而不接受操作系统或浏览器内置的CA根证书对应的任何证书。</p>
</blockquote>
<p>公钥锁定</p>
<blockquote>
<p>HTTP公钥锁定是HTTPS网站防止攻击者CA机构错误签发的证书进行中间人攻击的一种安全机制，用于预防CA遭受入侵或其他会造成CA签发未授权证书的情况。<br />
采用公钥锁定时，网站会提供已授权公钥的哈希列表，指示客户端在后续通讯中只接受列表上的公钥。提取证书中的公钥并内置到客户端中，通过与服务器对比公钥值来验证连接的正确性。</p>
</blockquote>
<p>绕过：Hook到证书校验，无论如何返回正确的即可</p>
<p><strong>私有协议通讯</strong></p>
<p>一线大厂自定义通讯协议，自然考虑到了抓包。那么自然而然也设置了反抓包</p>
<p>绕过：Hook、沙箱</p>
<h4 id="运行环境检测"><a class="markdownIt-Anchor" href="#运行环境检测"></a> 运行环境检测</h4>
<p>CDN网络分发加验证:经典产品5秒盾</p>
<blockquote>
<p>其核心为 请求 -&gt; cdn -&gt; 返回关键参数 -&gt; 通过 -&gt; 数据(可能为假)</p>
</blockquote>
<h3 id="请求校验"><a class="markdownIt-Anchor" href="#请求校验"></a> 请求校验</h3>
<blockquote>
<p>当抓到包之后，便是模拟用户请求了。那么这里的常见的反抓措施有哪些呢</p>
</blockquote>
<p>请求校验，即在发送请求时即对网络请求时进行校验，实现区分。<strong>通过则返回数据，未通过不返回或返回假数据</strong><br />
常有如下几种方式</p>
<h4 id="协议校验"><a class="markdownIt-Anchor" href="#协议校验"></a> <strong>协议校验</strong></h4>
<p>常见通用的协议有HTTP1.0、 HTTP1.1、HTTP2.0 ，若强行只允许HTTP2.0协议来完成请求与响应。那么平常使用其他</p>
<h4 id="tsl指纹"><a class="markdownIt-Anchor" href="#tsl指纹"></a> <strong>TSL指纹</strong></h4>
<p>每个请求库其实是有自己的库指纹，若只允许某段或某规则指纹通过，那么自然而言实现了反抓的效果。</p>
<h4 id="header校验"><a class="markdownIt-Anchor" href="#header校验"></a> header校验</h4>
<p>header校验又可分为两种。其一是字段校验，其二是header字段顺序校验</p>
<p>header各字段校验，如ua、sign、cookie、token、safe等</p>
<blockquote>
<p>绕过方案或思想：<br />
通过JS解密或逆向获取关键参数缺啥补啥，完成模拟即可</p>
</blockquote>
<p>header字段顺序：当我们打开一个网页其实是一个新的会话那么在未断开或重新连接的时候那么这个顺序就是固定的。而字典格式中位置其实是随机分配的，自定义客户端刷新，对header取指纹或字段顺序检测即可实现鉴别</p>
<blockquote>
<p>绕过方案或思想：保持会话一致</p>
</blockquote>
<h4 id="参数校验"><a class="markdownIt-Anchor" href="#参数校验"></a> 参数校验</h4>
<p>通常字段不仅在header中校验还经常在请求参数中，如sgin、token、safe等。</p>
<blockquote>
<p>参数不可无缘无故来，主要来源JS 生成、服务器下发(不限于文件、JS、wasm等)。又可进行多次中间操作</p>
</blockquote>
<h4 id="前后端分离技术ajax"><a class="markdownIt-Anchor" href="#前后端分离技术ajax"></a> 前后端分离技术Ajax</h4>
<blockquote>
<p>严格来说并不算反扒而是前后端分离技术,但常常结合反抓共同出现</p>
</blockquote>
<p>Ajax（异步JavaScript和XML）也叫不刷新页面请求。</p>
<h4 id="rpc防护"><a class="markdownIt-Anchor" href="#rpc防护"></a> RPC防护</h4>
<p>采用RPC及加密或编码方式实现前后端分离、微服务架构等。</p>
<blockquote>
<p>rpc结合反抓基本步骤，客户端请求(中间极有可能涉猎加密)RPC服务端，RPC客户端(原服务端)再次(<br />
中间极有可能涉猎加密)请求(一次或多次)。实现“分端”请求，多端加密。</p>
</blockquote>
<blockquote>
<p>逆写rpc进行调用，模拟“第一次”客户端请求rpc无差别，绕过</p>
</blockquote>
<h4 id="请求校验小结"><a class="markdownIt-Anchor" href="#请求校验小结"></a> 请求校验小结</h4>
<p>通常设置参数有两种情况，</p>
<ol>
<li>二次或多次请求：
<ol>
<li>RPC：客户端请求，服务端使用RPC等再请求。</li>
<li>AJax</li>
</ol>
</li>
<li>JS设置关键参数（<strong>含二次刷新删除源文件跳转页面</strong>）</li>
</ol>
<h2 id="验证码"><a class="markdownIt-Anchor" href="#验证码"></a> 验证码</h2>
<ul>
<li>识别点选或输入型</li>
<li>滑轨、滑块型</li>
<li>计算型</li>
<li>空值补齐型</li>
<li>空间推理型</li>
<li>短信或语音验证型</li>
</ul>
<h2 id="风控"><a class="markdownIt-Anchor" href="#风控"></a> 风控</h2>
<p>范围极大极广，简而言之，用户行为、运行环境等是否<strong>合理</strong>。从而实现区分</p>
<p>IP封禁</p>
<p>代码运行环境检测</p>
<p>等</p>
<h3 id="数据保护"><a class="markdownIt-Anchor" href="#数据保护"></a> 数据保护</h3>
<p>在不改变原有展示的情况下实现**“隐藏”**</p>
<p>通常数据保护有以下种方式：</p>
<ol>
<li>动态字体</li>
<li>CSS偏移</li>
<li>内容加密映射</li>
<li>SVG映射等</li>
<li>内容图片化</li>
</ol>
<h2 id="代码防护"><a class="markdownIt-Anchor" href="#代码防护"></a> 代码防护</h2>
<h3 id="js代码混淆"><a class="markdownIt-Anchor" href="#js代码混淆"></a> JS代码混淆</h3>
<p>在遇见需要逆向的参数时候，往往不像表面一个参数那般平静。一查看各种混淆、防护又来了。怎么办怎么办，肝啊！当然也可以使用渲染工具模拟，此方案在此便不在过多赘述。</p>
<p>代码混淆是增加分析难度而牺牲部分性能的一种方案，此方案大部分是体现在通过逻辑转换换等方式将代码转化为难以分析的代码。难以分析是混淆的目的，等价转换是需要确保混淆前后的代码需不影响运行的功能。对于混淆可以又分为如下四种：布局混淆、数据混淆、控制混淆、预防混淆</p>
<p><strong>布局混淆</strong></p>
<p>布局混淆指在源代码中删除原有无用代码，处理常量名、变量名函数名等标识符，增加对于代码的阅读与分析。</p>
<p>无用代码：注释、调试信息、缩进、换行、无用函数与数据等</p>
<p>处理常量名、变量名函数名等标识符：</p>
<ul>
<li>标识重命名：将原有代码重命名为无具体意义的字符，例如 将name 重命名为a</li>
</ul>
<blockquote>
<p>注意点：作用域内标识符碰撞情况</p>
</blockquote>
<p><strong>小结</strong>：布局混淆并不会影响执行的过程、内存开销，甚至代码体积反而减少了。</p>
<p><strong>数据混淆</strong></p>
<p>JS拥有常见的7种数据类型，number、string、boolean、unfined、null、Object</p>
<p><strong>数字混淆</strong></p>
<p>数据混淆有常见：进制转换、数字分治、其他</p>
<ul>
<li>
<p>进制转换：将十进制转化为二进制、八进制、十六进制等，从而达到“混淆”的目的</p>
</li>
<li>
<p><strong>数学分治</strong>：简而言之就是将数拆开，例如 2 = 1 + 1，也等于2 - 1 - 1 + 2再辅以数学公式等</p>
</li>
<li>
<p>其他：重新赋值等</p>
</li>
</ul>
<p><strong>字符串混淆</strong></p>
<p>字符串混淆常见的有编码转换编译、加密。常见的有hash、base64、md5等</p>
<p><strong>boolean</strong></p>
<p>我们都知道Boolean值为True、False。根据对boolean的处理，变成难以显示阅读的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!0,!1</span><br><span class="line">![], !![]</span><br><span class="line">!&#123;&#125;,!!&#123;&#125;</span><br><span class="line">!NaN,!!NaN</span><br><span class="line">!&quot;&quot;, !!&quot;&quot;</span><br><span class="line">!undefined, !!undefined</span><br><span class="line">!null, !!null</span><br><span class="line">!Object, !!Object</span><br><span class="line">!void(0),!!void(1)</span><br><span class="line"></span><br><span class="line">|,||, &amp;, &amp;&amp;, Boolean()</span><br></pre></td></tr></table></figure>
<p><strong>控制混淆</strong></p>
<p>控制混淆是指对程序的控制流进行转换变化，常见的方式有插入僵尸代码、控制流平坦化</p>
<p>插入僵尸代码：插入僵尸代码即插入无用的代码，增强调试难度</p>
<p>控制流平坦化：控制流平坦化,将原本的的执行流程平坦化。具体可自行搜索</p>
<p><strong>预防混淆</strong></p>
<p>主要体现在 提高反混淆的难度或检测现有混淆器中的漏洞设计</p>
<h3 id="js虚拟机"><a class="markdownIt-Anchor" href="#js虚拟机"></a> JS虚拟机</h3>
<p>自定义或定制JavaScript虚拟机，基于给予二进制文件获取结果</p>
<h3 id="androidios-sdk-加固保护"><a class="markdownIt-Anchor" href="#androidios-sdk-加固保护"></a> Android/iOS SDK 加固保护</h3>
<p><strong>代码混淆</strong></p>
<blockquote>
<p>具体可参考JS混淆部分，殊归同途</p>
</blockquote>
<p><strong>Dex 加固与抽取</strong></p>
<p>​ Dex<br />
加固即将需要保护的代码单独生成Dex，在so加载时解密jar并通过DexClassLoader加载到内存里。该方案的主要问题在于解密后的Dex会以文件形式存储在手机内存中，而且通过内存dump<br />
的方式能够获取解密后的jar<br />
包，而没有生成文件加载的方式存在很多兼容性的问题</p>
<p>​ 在实际对抗环境下，Dex 无论如何保护，都有方法还原至原始的Dex，进而反编译得到Java 代码。而C<br />
代码相对而言较难逆向。Java2c 是指将原有的Java 代码抽取出来，通过jni 在native 层反射实现。</p>
<p>流程如下：Dex→smali→抽取+native 化→生成so</p>
<p>抽取后的原始Java 函数，反编译出来是native 函数，在运行过程中也不会还原。Java2c 配合C<br />
语言的代码混淆技术和字符串混淆技术，可以对Android 的Java 代码起到很好的保护效果。同时也不需要对原始Java<br />
代码进行重写</p>
<p><strong>LLVM</strong></p>
<p>LLVM 是Low Level Virtual Machine 的缩写，其定位是一个比较底层的虚拟机。然而LLVM 本身并不是一个完整的编译器，LLVM<br />
是一个编译器基础架构，把很多编译器需要的功能以可调用的模块形式实现出来并包装成库，其他编译器实现者可以根据自己的需要使用或扩展，主要聚焦于编译器后端功能，如代码生成、代码优化、JIT<br />
等。</p>
<p><strong>代码虚拟化</strong></p>
<p>​ 代码虚拟化保护技术是一种比Dex 文件保护、Java2c 技术更强的安全防护技术，可以更有效地对抗逆向工程或破解，避免造成核心技术和风控逻辑被泄密的问题。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(已有)==无数次的中间转换==&gt; B1(所需)</span><br></pre></td></tr></table></figure>
<p>以上便是本人对于所见所知所想的反爬虫，各种加密、编译、混淆等。中间围绕无数种可能。一起加油吧！！！</p>
<p>好像什么都说了，什么都没说。望君参考却不限于此。</p>
<p>总体来说就是抓包、请求前校验、请求校验、数据保护。以及风控、验证码、及对于代码进行保护。</p>
]]></content>
      <categories>
        <category>spider</category>
        <category>crawler</category>
      </categories>
      <tags>
        <tag>data-acquisition</tag>
      </tags>
  </entry>
  <entry>
    <title>基于ssh-key实现服务器免密登陆</title>
    <url>/34306.html</url>
    <content><![CDATA[<p>远程连接Linux服务器，通常有两种方式， 第一种就是ssh直接远程连接， 第二种就是采用第三方的工具进行连接。<br />
那么我本人是十分习惯以及喜欢终端（terminal）直接连接的。<br />
一是因为快捷键更熟悉，另一方面是相对更安全。但采用ssh直接连接难免是有很多不便， 例如每次输入密码，例如每次输入远程ip地址。<br />
密码我个人是喜欢设置成非常难以记忆的密码，保存在本地一个记事本或者文档里面，ip更不用说。记自然是不可能记的。那么如何实现ssh免密登陆以及ip的代号呢</p>
<h2 id="生成密钥"><a class="markdownIt-Anchor" href="#生成密钥"></a> 生成密钥</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@youremailhost.com&quot; -f ~/.ssh/id_ali_rsa</span><br></pre></td></tr></table></figure>
<h2 id="上传公钥到服务器"><a class="markdownIt-Anchor" href="#上传公钥到服务器"></a> 上传公钥到服务器</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_ali_rsa.pub root@host</span><br></pre></td></tr></table></figure>
<h3 id="初次密码验证"><a class="markdownIt-Anchor" href="#初次密码验证"></a> 初次密码验证</h3>
<p>输入密码</p>
<p>下次直接使用ssh登陆即可实现免密登陆</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh user@host</span><br></pre></td></tr></table></figure>
<h3 id="小技巧"><a class="markdownIt-Anchor" href="#小技巧"></a> 小技巧</h3>
<p>远程登录的ip一般来说都是没有规律的，也十分的难记。那么如何才能给他一个好记的名字来替代，但又好区分呢。方法也非常的简单。</p>
<p>只需要啊在<code>~/.ssh/config</code> 中进行如下设置即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host ali</span><br><span class="line">  Hostname ip</span><br><span class="line">  User root</span><br><span class="line">  Port 22</span><br><span class="line">  IdentityFile ~/.ssh/id_ali_rsa</span><br><span class="line">  AddKeysToAgent <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>
<p>下次ssh连接服务的ip时, 直接使用<code>ssh ali</code> 即可</p>
<p>config 规则请参考</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWJzZC5vcmcvY2dpL21hbi5jZ2k/cXVlcnk9c3NoX2NvbmZpZw==">https://www.freebsd.org/cgi/man.cgi?query=ssh_config<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>如何做好自我介绍</title>
    <url>/42723.html</url>
    <content><![CDATA[<h2 id="自我介绍"><a class="markdownIt-Anchor" href="#自我介绍"></a> 自我介绍</h2>
<p>介，古代传递宾主之言的人。绍，绍继、接续。介绍指相继传话；为人引进或带入新的事物。自我介绍是向别人展示你，认识你。</p>
<p>自我介绍好不好，重要性不言而喻其直接关系到你给别人的第一印象的好坏及以后交往的顺利与否。同时，也是认识自我的手段。</p>
<h3 id="如何做好自我介绍"><a class="markdownIt-Anchor" href="#如何做好自我介绍"></a> 如何做好自我介绍</h3>
<p>自我介绍一是为了更好的破冰，让别人记住你、了解你等，那么如何做自我介绍自然也从这几点切入。</p>
<h3 id="自嘲式"><a class="markdownIt-Anchor" href="#自嘲式"></a> 自嘲式</h3>
<blockquote>
<p>适用场景：演讲</p>
<p>关键词：破冰</p>
</blockquote>
<p>有趣的自嘲可以快速吸引注意力，让人对你记忆犹新。</p>
<p>例如：你（大家）好，我叫xxx。原本想做一名x x x,可能是xxx不太好。所以目前做了xxx</p>
<h3 id="八卦式"><a class="markdownIt-Anchor" href="#八卦式"></a> 八卦式</h3>
<blockquote>
<p>适用场景：非正式场合</p>
<p>关键词：好奇</p>
</blockquote>
<p>在远古社会，智人凭借八卦，使整个群体更趋于稳定和学会更多的协作，而协作就是智人强大起来的秘诀，但是为什么八卦可以使一个族群稳定和协作呢?因为信任，因为八卦这种社交行为可以让智人相互信任，而信任的基础就是相互了解，八卦就是智人相互了解的过程。<br />
——《人类简史》</p>
<p>例如：大家好，我叫xxx，来自xxx，（合理热点）结果xxx。我xxx</p>
<h3 id="自荐式"><a class="markdownIt-Anchor" href="#自荐式"></a> 自荐式</h3>
<blockquote>
<p>适用场景：商务场合、聚会，面试</p>
<p>关键词：自我推荐</p>
</blockquote>
<p>我是xxx，他人最需要自我价值面。</p>
<blockquote>
<p>切记避免<strong>多次</strong>,尽量全面</p>
</blockquote>
]]></content>
      <categories>
        <category>个人随笔</category>
        <category>所思所想</category>
      </categories>
      <tags>
        <tag>所思所想</tag>
      </tags>
  </entry>
  <entry>
    <title>少有人走的路</title>
    <url>/58816.html</url>
    <content><![CDATA[<h2 id="少有人走的路"><a class="markdownIt-Anchor" href="#少有人走的路"></a> 少有人走的路</h2>
<p>我们在生活中经常会评价一个人说这个人不成熟像个孩子，那到底什么成熟，一个人成熟与否最重要的是自律性然后是否懂得什么是真正的爱。就是当一个人学会自律，主动的要求自己用积极的心态去面对承受痛苦解决问题的时候那就是距离成熟的距离很近了。而且我们生活中大量的人就宁愿在不成熟当中徘徊宁愿在痛苦当中打转，就是不愿意走上这少有人走的路。走上这条用自律和爱，铸就通向心灵承受的道路。</p>
<p>自律是解决人生问题的最重要的主要工具</p>
<h2 id="全面的自律"><a class="markdownIt-Anchor" href="#全面的自律"></a> 全面的自律</h2>
<h3 id="不自律的表现"><a class="markdownIt-Anchor" href="#不自律的表现"></a> 不自律的表现</h3>
<p>遇到问题拖延着不去主动解决回避问题，假装看不见用药物、酒精等成瘾物麻痹自己，换得一时解脱</p>
<h3 id="实现自律的四个原则"><a class="markdownIt-Anchor" href="#实现自律的四个原则"></a> 实现自律的四个原则</h3>
<p>推迟满足感：父母没耐心教孩子，而企图靠吼或打骂的方式一下子解决问题。童年得不到父母爱的孩子容易缺乏安全感，而陷入“今朝有酒今朝醉”处事模式儿无法做到延迟满足。</p>
<p>承担责任：必须面对自己的问题，并承担解决问题的责任</p>
<ul>
<li>神经官能症：患者总是为自己增加责任</li>
<li>人格失调症：患者总是为自己推卸责任</li>
</ul>
<p>忠于事实</p>
<p>越是了解事实，处理问题就越得心应手</p>
<p>移情：固守自己已成型的“人生地图”用来解决一切事，不肯改变</p>
<p>保持平衡：确立富有弹性的束缚机制来平衡以上三个原则保持平衡的最高原则，是放弃</p>
<h2 id="爱是是自律的动力"><a class="markdownIt-Anchor" href="#爱是是自律的动力"></a> 爱是是自律的动力</h2>
<h3 id="爱的定义"><a class="markdownIt-Anchor" href="#爱的定义"></a> 爱的定义</h3>
<p>爱上人们自律的原动力，是一种未来促进自己和他人心智成熟，而不断拓展再叫我界限，实现自我完善的意愿</p>
<h3 id="爱的表现"><a class="markdownIt-Anchor" href="#爱的表现"></a> 爱的表现</h3>
<p>当事人意识和潜意识中目标一致。 是一个人长期、渐进的过程，应用心灵不断的成长和心智不断成熟</p>
<p>爱他人者必自爱， 爱需要付出努力</p>
<p>爱一个人必须付诸行动，想爱，爱的感觉和口头的爱都不等于去爱</p>
<h3 id="非爱的情况"><a class="markdownIt-Anchor" href="#非爱的情况"></a> 非爱的情况</h3>
<h4 id="堕入情网"><a class="markdownIt-Anchor" href="#堕入情网"></a> 堕入情网</h4>
<p>堕入情网不是出于主观臆断，不是有计划、有一事的选择</p>
<p>堕入情网不需要付出努力，并没有真正拓展自我界限</p>
<p>堕入情网不是出于可以消除寂寞，但无法有目的促进心灵</p>
<h4 id="过分依赖"><a class="markdownIt-Anchor" href="#过分依赖"></a> 过分依赖</h4>
<p>没有他/她我就活不下去，是一种寄生心理，而不是爱症状有忍受的寂寞，空虚感强烈</p>
<p>把失去伴侣当成极其恐怖的事情</p>
<h4 id="精神灌注"><a class="markdownIt-Anchor" href="#精神灌注"></a> 精神灌注</h4>
<p>不能给心灵带来滋养的精神关注都不是爱</p>
<p>爱金钱、爱权利、爱宠物、爱园艺都被称为“爱”</p>
<p>如果这些爱好中增长了知识，活的了自我界限的拓宽，是爱，否则就不是爱</p>
<h4 id="自我牺牲"><a class="markdownIt-Anchor" href="#自我牺牲"></a> 自我牺牲</h4>
<p>给予者以 “爱”作为幌子，满足自己的付出欲。不将对方的心智成熟当回事</p>
<h4 id="爱的体现"><a class="markdownIt-Anchor" href="#爱的体现"></a> 爱的体现</h4>
<p>关注：努力聆听，帮助对方成长</p>
<p>不惧风险：不要因为害怕失去就放弃爱</p>
<p>独立：人生唯一的安全感，来自于成分体验人生的不安全感保持自己独立，也许伴侣独立</p>
<p>充分透入：由承担来推动，持续或渐渐增多的投入是爱的基石，给对方以安全感</p>
<p>勤于自律，平等交流：当感觉矛盾与冲突时，用恰当的语言提出想法，而非使用自大的态度随意批评</p>
<p>懂得自律：真正的爱必然懂得约束自己，并促进双发心智的成熟，真正的爱对自己的约束力，容不下第三者，对伴侣和孩子和孩子负有责任感</p>
<h3 id="自我界限"><a class="markdownIt-Anchor" href="#自我界限"></a> 自我界限</h3>
<h4 id="自我界限的设立"><a class="markdownIt-Anchor" href="#自我界限的设立"></a> 自我界限的设立</h4>
<p>0-7个月，婴儿分辨与外部 世界</p>
<p>1岁：婴儿开始意识到自己和外界的区别，明白“我”是什么，什么不是“我”</p>
<p>2-3岁：从界限不明，以为自己无所不能，到开始明白自己能力有限，有了自我界限，开始感到孤独</p>
<h4 id="自我界限的暂时崩溃"><a class="markdownIt-Anchor" href="#自我界限的暂时崩溃"></a> 自我界限的暂时崩溃</h4>
<p>坠入情网意味着意味着自我界限的某一部分突然崩溃，人有体会到了小时候无所不能的感觉，所以兴奋不已。等到冷静下来，发现彼此的问题，各自的自我界限又再次合拢</p>
<h4 id="自我界限的拓宽"><a class="markdownIt-Anchor" href="#自我界限的拓宽"></a> 自我界限的拓宽</h4>
<p>走出舒适区，努力为一件事情付出，对自我边界形成永久性的扩张，实现自我正常</p>
<h3 id="信仰与恩典"><a class="markdownIt-Anchor" href="#信仰与恩典"></a> 信仰与恩典</h3>
<p>盲目地认为宗教信仰有助于或有害于个人心智的成熟与健康，都不是我们应有的态度，因人而异，因事而异。</p>
<p>生命中出现的恩典与奇迹，虽不能尽数解释，也应当理智对待。</p>
<h3 id="阻碍成熟的障碍懒惰"><a class="markdownIt-Anchor" href="#阻碍成熟的障碍懒惰"></a> 阻碍成熟的障碍—懒惰</h3>
<p>逃避痛苦的原动力</p>
<p>恐惧直面问题的麻烦和痛苦，是懒惰的深层原因</p>
]]></content>
      <categories>
        <category>read</category>
        <category>book</category>
      </categories>
      <tags>
        <tag>read</tag>
      </tags>
  </entry>
  <entry>
    <title>工程化衍生落地</title>
    <url>/41708.html</url>
    <content><![CDATA[<h2 id="agenda"><a class="markdownIt-Anchor" href="#agenda"></a> Agenda</h2>
<h3 id="提出需求"><a class="markdownIt-Anchor" href="#提出需求"></a> 提出需求</h3>
<h3 id="调研方案"><a class="markdownIt-Anchor" href="#调研方案"></a> 调研方案</h3>
<h3 id="研读资料"><a class="markdownIt-Anchor" href="#研读资料"></a> 研读资料</h3>
<h3 id="构建工程"><a class="markdownIt-Anchor" href="#构建工程"></a> 构建工程</h3>
<ul>
<li>工程设计
<ul>
<li>项目布局设计</li>
<li>功能设计</li>
</ul>
</li>
<li>代码设计
<ul>
<li>方法、接口设计</li>
</ul>
</li>
<li>实现代码</li>
</ul>
]]></content>
      <categories>
        <category>技术杂谈</category>
        <category>软件工程</category>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>技术杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>常见安全产品(pc)</title>
    <url>/63324.html</url>
    <content><![CDATA[<p>在做爬虫的时候，很多时候都会遇到较成熟成体系的安全产品。更好的&quot;认识&quot;<br />
它，对于解决有至关重要的帮助。以下一起来了解一下网站常见防护产品及特征</p>
<blockquote>
<p>声明：本节不涉猎任何实际的产品破解，仅介绍其特征与辨别方式或思路。以下仅根据个人现所了解暂划分为一线、二线等。</p>
</blockquote>
<h3 id="一线"><a class="markdownIt-Anchor" href="#一线"></a> 一线</h3>
<blockquote>
<p>学习的对象，自研产品。安全系数高，分析较困难</p>
</blockquote>
<p>ali、akamai、jd、pdd、google(含无感验证码)、各大银行支付接口</p>
<h4 id="ali滑块"><a class="markdownIt-Anchor" href="#ali滑块"></a> ali滑块</h4>
<p>阿里云验证码: <span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vcHJvZHVjdC8yODMwOC5odG1s">https://help.aliyun.com/product/28308.html<i class="fa fa-external-link-alt"></i></span></p>
<p>控制台中有g.alicdn.com字样，其中/后为版本号</p>
<h4 id="akamai"><a class="markdownIt-Anchor" href="#akamai"></a> akamai</h4>
<blockquote>
<p>主要在tls指纹进行相关加密</p>
</blockquote>
<h4 id="jd"><a class="markdownIt-Anchor" href="#jd"></a> jd</h4>
<blockquote>
<p>自写的虚拟机</p>
</blockquote>
<h4 id="pdd"><a class="markdownIt-Anchor" href="#pdd"></a> pdd</h4>
<blockquote>
<p>Web pack 打包 + 风控</p>
</blockquote>
<h4 id="google含无感验证码"><a class="markdownIt-Anchor" href="#google含无感验证码"></a> google(含无感验证码)</h4>
<p>5s 盾 + 谷歌验证码</p>
<p>绕过方案与线索</p>
<ul>
<li>5秒盾 <span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvendtYXRGM3lUZ1N5UzBnejhzaW5hQQ==">https://mp.weixin.qq.com/s/zwmatF3yTgSyS0gz8sinaA<i class="fa fa-external-link-alt"></i></span></li>
<li>谷歌验证码打码绕过方案<span class="exturl" data-url="aHR0cHM6Ly9jdWlxaW5nY2FpLmNvbS8zMDAyNi5odG1s">https://cuiqingcai.com/30026.html<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gtseloz24yj61d60naaca02.jpg" alt="image-20210825014317964" /></p>
<h3 id="二线"><a class="markdownIt-Anchor" href="#二线"></a> 二线</h3>
<blockquote>
<p>可敬的对象</p>
</blockquote>
<p>加密与代码保护：瑞数信息（瑞数）、创宇超防（加速乐）、</p>
<p>验证码：极验、数美、五秒盾、易盾、顶象</p>
<h4 id="加密与代码保护"><a class="markdownIt-Anchor" href="#加密与代码保护"></a> 加密与代码保护</h4>
<h5 id="瑞数信息瑞数"><a class="markdownIt-Anchor" href="#瑞数信息瑞数"></a> 瑞数信息（瑞数）</h5>
<ol>
<li>未带cookie访问首先是一段神奇的页面，如下图所示</li>
</ol>
<p>特征：</p>
<ol>
<li></li>
</ol>
<p>一长段的：content。有点类似于ob的大数组</p>
<p>script标签中带有 r=“m”的字样</p>
<p>执行加密函数1，函数名为 <code>_$xx(xxx)</code></p>
<p>执行加密函数2（实际加密处）</p>
<ol start="2">
<li>无比恶心的乱码</li>
</ol>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gsd76unofcj30sp02qt8m.jpg" alt="ddddd" /></p>
<ol start="3">
<li>
<p>动态js</p>
</li>
<li>
<p>版本号</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gsd8b8qfa3j305y00i0si.jpg" alt="" /></p>
</li>
</ol>
<p>首数字开头的编号，编号常见的有4、5、6代</p>
<h5 id="创宇超防加速乐"><a class="markdownIt-Anchor" href="#创宇超防加速乐"></a> 创宇超防（加速乐）</h5>
<ol>
<li>未带cookies访问，先是一段神奇的JS，设置cookie。如下图所示</li>
</ol>
<p>实际内容如下图所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gsd6qt4brnj311b02qjrj.jpg" alt="" /></p>
<ol start="2">
<li>
<p>魔改ob</p>
<p>用于cookies拼接</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gsd6wykikcj31lf0u0n36.jpg" alt="" /></p>
</li>
</ol>
<h4 id="验证码"><a class="markdownIt-Anchor" href="#验证码"></a> 验证码</h4>
<h5 id="极验"><a class="markdownIt-Anchor" href="#极验"></a> 极验</h5>
<p>geetest(极验)官网：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2VldGVzdC5jb20v">https://www.geetest.com/<i class="fa fa-external-link-alt"></i></span></p>
<p>demo：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2VldGVzdC5jb20vZGVtby8=">https://www.geetest.com/demo/<i class="fa fa-external-link-alt"></i></span></p>
<!---------->
<h5 id="数美"><a class="markdownIt-Anchor" href="#数美"></a> 数美</h5>
<p>官网：<span class="exturl" data-url="aHR0cHM6Ly93d3cuaXNodW1laS5jb20v">https://www.ishumei.com/<i class="fa fa-external-link-alt"></i></span></p>
<p>体验：<span class="exturl" data-url="aHR0cHM6Ly93d3cuaXNodW1laS5jb20vdHJpYWwvY2FwdGNoYS5odG1s">https://www.ishumei.com/trial/captcha.html<i class="fa fa-external-link-alt"></i></span></p>
<h5 id="网易易盾"><a class="markdownIt-Anchor" href="#网易易盾"></a> 网易易盾</h5>
<p>官网：<span class="exturl" data-url="aHR0cHM6Ly9kdW4uMTYzLmNvbS8=">https://dun.163.com/<i class="fa fa-external-link-alt"></i></span></p>
<p>Demo：<span class="exturl" data-url="aHR0cHM6Ly9kdW4uMTYzLmNvbS90cmlhbC9zcGFjZS1pbmZlcmVuY2U=">https://dun.163.com/trial/space-inference<i class="fa fa-external-link-alt"></i></span></p>
<h5 id="vaptcha"><a class="markdownIt-Anchor" href="#vaptcha"></a> Vaptcha</h5>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudmFwdGNoYS5jb20v">https://www.vaptcha.com/<i class="fa fa-external-link-alt"></i></span></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gsd8xpb30oj30vc0g1afq.jpg" alt="" /></p>
<h5 id="顶象"><a class="markdownIt-Anchor" href="#顶象"></a> 顶象</h5>
<h3 id="三线"><a class="markdownIt-Anchor" href="#三线"></a> 三线</h3>
<blockquote>
<p>主要来源于开源框架</p>
</blockquote>
<p>Ob混淆系（obfuscator、sojson、Jsaham）、Jsfuck、JJEncode、AAEncode、eval等、</p>
<p>obfuscator: <span class="exturl" data-url="aHR0cHM6Ly9vYmZ1c2NhdG9yLmlvLw==">https://obfuscator.io/<i class="fa fa-external-link-alt"></i></span></p>
<p>sojson：<span class="exturl" data-url="aHR0cHM6Ly93d3cuc29qc29uLmNvbS9qc2ppZW1pLmh0bWw=">https://www.sojson.com/jsjiemi.html<i class="fa fa-external-link-alt"></i></span></p>
<p>Jsaham：<span class="exturl" data-url="aHR0cDovL3d3dy5qc2hhbWFuLmNvbS8jc2VjdGlvbjI=">http://www.jshaman.com/#section2<i class="fa fa-external-link-alt"></i></span></p>
<p>jstuck:<span class="exturl" data-url="aHR0cDovL3d3dy5qc2Z1Y2suY29tLw==">http://www.jsfuck.com/<i class="fa fa-external-link-alt"></i></span>  GitHub:<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FlbWtlaS9qc2Z1Y2s=">https://github.com/aemkei/jsfuck<i class="fa fa-external-link-alt"></i></span></p>
<p>JJEncode:<span class="exturl" data-url="aHR0cDovL3d3dy5hdG9vbGJveC5uZXQvVG9vbC5waHA/SWQ9NzA0">http://www.atoolbox.net/Tool.php?Id=704<i class="fa fa-external-link-alt"></i></span></p>
<p>JJEncode:<span class="exturl" data-url="aHR0cDovL3d3dy5hdG9vbGJveC5uZXQvVG9vbC5waHA/SWQ9NzAz">http://www.atoolbox.net/Tool.php?Id=703<i class="fa fa-external-link-alt"></i></span></p>
<p>Eval:<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvZXZhbDs=">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval;<i class="fa fa-external-link-alt"></i></span></p>
<p>分析：eval换为console.log()(前提：console.log未改写)</p>
<h4 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h4>
<h5 id="ob系列"><a class="markdownIt-Anchor" href="#ob系列"></a> ob系列</h5>
<p>特点</p>
<ol>
<li>大数组</li>
<li>数据移位（常见regex内存检测，建议不format绕过或remove regex）</li>
<li>解密函数（常见regex内存检测，建议不format绕过或remove regex）</li>
<li>定时器setInterval() 、setTimeout() + 无限debugger （可能含有）</li>
<li><strong>业务代码 + 控制流平坦化：（ob强度90%取决于此代码强度、这里是加密前的逻辑）</strong></li>
<li>控制流平坦化 + 无限debugger + 僵尸代码注入（一般不含有业务逻辑）</li>
</ol>
<p>Example:</p>
<ol>
<li>找到实际处（ob）</li>
<li>找前三段（数组、数组移位、解密函数），剪切出去</li>
<li>格式化控制流平坦化、实际逻辑。放回前剪切出去的内容</li>
<li>定位加密函数</li>
</ol>
<h5 id="jsfuck-jjencode-aaencode"><a class="markdownIt-Anchor" href="#jsfuck-jjencode-aaencode"></a> Jsfuck、JJEncode、AAEncode</h5>
<p>配合eval类型防护：</p>
<blockquote>
<ol>
<li>直接放控制台console执行(报非unsafe错误)；点击错位堆栈直接完成脱壳</li>
</ol>
</blockquote>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gsdbgkbq35j30ix0bjwet.jpg" alt="" /></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gsdbfu2amkj31ae02maa0.jpg" alt="" /></p>
<blockquote>
<p>2.控制台不报错，构建强制报错。删除一些代码（为了不干扰原本代码，建议删除括号或加无意义代码）</p>
<p>3。控制台报unsafe错误，自写html文件运行。参考以上</p>
</blockquote>
<p>混淆部分数字：</p>
<h3 id="四线"><a class="markdownIt-Anchor" href="#四线"></a> 四线</h3>
<blockquote>
<p>工程化工具、各种加密函数魔改、辅助作用</p>
</blockquote>
<p>webpack、vue、react、angular</p>
<p>webpack：<span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmRvY3NjaGluYS5vcmcv">https://webpack.docschina.org/<i class="fa fa-external-link-alt"></i></span></p>
<p>关键点：加载器（也叫分发器）</p>
<p>经典绕过方案：点位插桩</p>
<p>扣取思路：找到加载器、扣出加载器构建自己的加载器（网站与关键参数（函数））、补环境</p>
<h3 id="验证码汇总"><a class="markdownIt-Anchor" href="#验证码汇总"></a> 验证码汇总</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmFsaXl1bi5jb20vcHJvZHVjdC8yODMwOC5odG1s">ali<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly8wMDcucXEuY29tLw==">tencent<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9yZWNhcHRjaGEvYWJvdXQv">reCAPTCHA (google.com)<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kdW4uMTYzLmNvbS90cmlhbC9zZW5zZQ==">163<i class="fa fa-external-link-alt"></i></span>:<span class="exturl" data-url="aHR0cHM6Ly9kdW4uMTYzLmNvbS8=">网易易盾-数字内容风控-内容安全|业务安全|移动安全 (163.com)<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Nkbi5kaW5neGlhbmctaW5jLmNvbS9jdHUtZ3JvdXAvY2FwdGNoYS11aS9kZW1vLw==">dingxiang<i class="fa fa-external-link-alt"></i></span>：<a href="https://www.dingxiang-inc.com/">顶象-业务安全引领者，让数字世界无风险 (<br />
dingxiang-inc.com)</a></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2VldGVzdC5jb20vZGVtby8=">geetest<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudmFwdGNoYS5jb20v">vaptcha<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaXNodW1laS5jb20vdHJpYWwvY2FwdGNoYS5odG1s">ishumei<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy55ZXNjYXB0Y2hhLmNvbS8=">yescaptch<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly8yY2FwdGNoYS5jb20v">2captcha<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>spider</category>
        <category>crawler</category>
      </categories>
      <tags>
        <tag>data-acquisition</tag>
      </tags>
  </entry>
  <entry>
    <title>思维与思维模式</title>
    <url>/49563.html</url>
    <content><![CDATA[<blockquote>
<p>在众多的思维方式中，首选结构化思维。其他的思维方式，如<strong>逻辑思维、批判性思维、创造性思维、战略思维、</strong><br />
等也很重要，更多影响你自己如何看待问题。</p>
</blockquote>
<p>逻辑思维和结构化思维核心影响你与他人的关系，影响信息传递效率，影响你的个人影响力，是非常显性化的两种思维方式，是其他思维方式的基础。<br />
显性化是你只要刻意练习，你便能习得这项能力，并且很快在工作中应用得到正反馈，提高你的工作效率、加强你的沟通表达能力。</p>
<p>思考和表达没有逻辑与结构，是种灾难。<strong>核心不是让自己怎样，而是非常浪费别人的时间</strong><br />
。大家的时间都很宝贵，你浪费了别人的时间，别人怎么还会有耐心信任你。尤其是对领导，你应该常常想几分钟内还没把事情讲清楚，他就没了耐心。<br />
同事之间沟通也如此，你讲了几分钟，对方还听不懂，那么他下次就不再想跟你沟通。</p>
<p><strong>同样一件事情，能有逻辑地结构化思考和表达，可以节省双方更多时间，提高效率</strong><br />
。逻辑与结构化思维可以让接受信息的人快速明白你要讲什么，也可以把你想表达的重点传递给到对方，它让我们在沟通交流中提高自身说服力。</p>
<h2 id="结构化思维"><a class="markdownIt-Anchor" href="#结构化思维"></a> 结构化思维</h2>
<p>同样沟通事情，有的人三句话就能说清楚，而你可能说了10分钟也说不到核心；同样是做汇报，有的人用5页PPT就能说服对方，而你可能写了20多页还要被反问想表达什么；</p>
<p>同样是阐述解决方案，有的人清晰讲出背景、问题、原因、影响和举措，而你挤牙膏式的回答一句紧接着再被问一句。</p>
<p>如果说一个人沟通表达能力差，情商是一个因素，但还有一个更关键点：结构化思维。如果对方听了半天都不知道你在表达什么，情商再高也失去色彩。</p>
<p>人类大脑在处理信息的时候，有两个规律：</p>
<ol>
<li><strong>不能一次太多，太多信息会让我们的大脑觉得负荷过大</strong></li>
<li><strong>喜欢有规律的信息</strong></li>
</ol>
<p>人的大脑最多仅记忆7个思想，当处理过多思想的时候需要建立逻辑关系，形成立体结构，完整、清晰地看到每一面和每个点。</p>
<p>表达能力强的人，不是比你更聪明，而是知道大脑这个特点，更懂得通过有效的结构化思维，快速对信息进行归纳和整理进行传递。</p>
<p>大脑容易记住有规律的东西，那么你在信息传递时尽量使用规律的东西来传递。把无序变得有规律的过程即结构化思维。</p>
<h3 id="结构化思维概述"><a class="markdownIt-Anchor" href="#结构化思维概述"></a> 结构化思维概述</h3>
<p>结构化思维是一种从整体到局部、从框架到细节的思维方式。它要求思考者不先入为主，不会过快地陷入细节，而要经常留意事物的整体框架，在框架的基础上去拓展细节。</p>
<p>先看能够解决问题的关键方面，然后再往下分析，从而实现从总体到局部的鸟瞰，最典型的就是金字塔结构图。</p>
<p><img data-src="https://p.ipic.vip/1vl919.jpg" alt="" /></p>
<p>结构化思维渗透在工作的方方面面，是建立在逻辑思维之上的另一种显性化思维方式，不可或缺。结构化思维可以带来显著的工作效率提升，尤其是在沟通中。</p>
<p>为什么在沟通中结构化思维可以发挥巨大作用？</p>
<p>因为人和人之间信息差。结构的越上层，彼此之间信息差越小；结构的越下层，彼此之间信息差越大。如果一上来陷入到最下层的细节之中，对方大概率听不懂时沟通出现低效。</p>
<h3 id="提升结构化思维"><a class="markdownIt-Anchor" href="#提升结构化思维"></a> 提升结构化思维</h3>
<p>如果说逻辑思维一定程度上跟人天生智力水平有关，即我们常说的一个人聪不聪明，那么结构化思维则可以通过刻意训练习得。</p>
<p>结构化思维完全由自己从0到1主动规划所得，就如同有些人可以做出好看的PPT，其实也是懂得了PPT背后的套路。</p>
<p><img data-src="https://p.ipic.vip/0hxnu6.jpg" alt="" /></p>
<ul>
<li>论：结论先行</li>
<li>证：以上统下</li>
<li>类：归类分组</li>
<li>比：逻辑递进</li>
</ul>
<p>结构化思维有2种方法：自下向上组结构和自上向下套框架。</p>
<ul>
<li>纵向逻辑关系
<ul>
<li>演绎逻辑，自上而下「使用演绎法」设计结构</li>
<li>归纳逻辑，自下而上「使用归纳法」提炼结构</li>
</ul>
</li>
<li>横向逻辑关系
<ul>
<li>时间顺序</li>
<li>空间顺序</li>
<li>程度顺序</li>
</ul>
</li>
</ul>
<h4 id="自下而上"><a class="markdownIt-Anchor" href="#自下而上"></a> 自下而上</h4>
<p>自下向上组结构核心在于这个结构是你自创的。根据你自己对接收到信息的理解，把信息重新组装的过程。比如我写这篇文章的框架结构，你日常整理会议纪要的结构。没有统一标准，你按照一定逻辑重新组合信息。</p>
<p>比如我给领导讲业务数据的PPT，首先会介绍我分析数据的整体框架，其次再给一个实际的数据分析的概览，再往下去细看每块的细分数据，针对每块的数据给出结论和TODO。</p>
<ul>
<li>整体数据指标体系（理论）——一页PPT</li>
<li>总体数据指标概览（实际数据）——一页PPT</li>
<li>分模块1数据指标——一页PPT</li>
<li>分模块2数据指标——一页PPT</li>
<li>分模块3数据指标——一页PPT</li>
<li>每页PPT里的结论和TODO</li>
<li>总结——一页PPT</li>
</ul>
<p>先框架后细节，先总结后具体，先结论后原因，先观点后建议，先重要后次要。这样，才能让对方第一时间抓住重点信息，知道我们要传递的核心内容。</p>
<p>站在自己视角时，先把所有零散的点穷举，再看点与点之间的关联性连接成面，面最终再成体。概括起来大致分为以下4步：</p>
<ul>
<li>尽可能列出所有思考的要点</li>
<li>找出关系，进行分类（找出要点间的逻辑关系，利用 MECE 原则归类分组）</li>
<li>总结概括要点，提炼观点</li>
<li>观点补充，完善思路</li>
</ul>
<h4 id="自上而下"><a class="markdownIt-Anchor" href="#自上而下"></a> 自上而下</h4>
<p>如果你是做已存领域的问题解决方案，那通过自上而下找结构：思考一个框架，然后将信息或解决方案放入框架。</p>
<p>比如，提到规划，可以使用五看三定框架；提到制定目标，可以使用SMART原则；提到制定任务计划，可以使用WBS任务拆解。</p>
<p>自上向下套框架依赖我们自身积累了多少种框架，在实际场景中可以随时被调用。</p>
<h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> reference</h2>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9rLnNpbmEuY29tLmNuL2FydGljbGVfMzE4MTc0NTk5N19iZGE1OTc0ZDAxOTAxNzFpZy5odG1s">最重要的两种思维：逻辑思维与结构化思维<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuMTYzLmNvbS9keS9hcnRpY2xlL0hEUjk2REhFMDU1MkdFWjUuaHRtbA==">7种鲜为人知的思维模式，帮助你更好地处理问题<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>思考</category>
        <category>结构化思维</category>
        <category>逻辑思维</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>我对思考的思考</title>
    <url>/43605.html</url>
    <content><![CDATA[<blockquote>
<p>思考， 简单却有困难的词。它离我们“近在咫尺”却又似乎“远在天涯”。那究竟什么叫思考？什么是思考？那么该如何思考？</p>
</blockquote>
<h2 id="思考的定义"><a class="markdownIt-Anchor" href="#思考的定义"></a> 思考的定义</h2>
<p>说到思考， 那咱们也不得不对其进行追本溯源， 去揪一下它的细节。什么是<strong>思、<strong>什么是</strong>考、<strong>什么是</strong>思考</strong><br />
思，汉语一级字，读作sāi或sī，在指“心情”等时旧读为sì，最早见于金文，其本义是深想、考虑，由此引申出怀念、悲伤、意念、创作的构想等。《说文解字》认为是“容也”。<br />
考（拼音：kǎo）是汉语通用规范一级字（常用字）。在甲骨文和金文中，考和老是同一个字，均像一老人举杖之形。考字用为年老之义，从商代经西周一直延用至于春秋战国时代。<br />
先秦时“考”常用作对父亲的称呼，可以指在世的，也可以指去世的。<br />
现代汉语的“考”多用于考察、考核，又表示研究、推求。这些都是后来出现的假借义，与考的本义无关。<br />
那什么是思考呢？由上可知思就是深想，考虑就是验证， 二者形成闭环故为思考。那么思考就是，就是<br />
<strong>思考就是考虑与验证的过程！</strong><br />
btw</p>
<ul>
<li>考虑在此的意思是检索，检索已有的知识。</li>
<li>验证在此的意思是过滤，过滤检索的知识。</li>
</ul>
<p>先split再merge，那就是答案啊</p>
<p>思考是思维的一种探索活动，思考力则是在思维过程中产生的一种具有<strong>积极性和创造性</strong>的作用力。<br />
思考源于主体对<strong>意向信息</strong>的加工。人之思考是<strong>自己心智对意向——信息内容的加工过程</strong>。任何思考的进行都是在<br />
<strong>联想—连锁反映中进行的推理与演算</strong>——信息内容的加工。如：相似联想、接近联想、对比联想、因果联想等理解来进行思考是必然的。</p>
<h2 id="思考流程"><a class="markdownIt-Anchor" href="#思考流程"></a> 思考流程</h2>
<p>由上可知， 思考流程是检索 -&gt; 验证 -&gt; 加工(排列组合) =&gt; 结果。需要注意的是检索与验证并不是仅是单次的，也可以是多次。</p>
<h3 id="论3-4的思考过程"><a class="markdownIt-Anchor" href="#论3-4的思考过程"></a> 论3 * 4的思考过程</h3>
<p><img data-src="https://cdn.nlark.com/yuque/__latex/3e90b256052522b05fd06968b19b78a3.svg#card=math&amp;code=3%20%2A%204%0A&amp;id=PQFP9" alt="3 * 4" /><br />
是如何计算出来的呢？ 当然，各位早就知晓了答案， 不就是12嘛。 浪费表情，so easy, 摊手🤷</p>
<p><img data-src="https://cdn.nlark.com/yuque/__latex/3e90b256052522b05fd06968b19b78a3.svg#card=math&amp;code=3%20%2A%204%0A&amp;id=SYVLR" alt="" /><br />
思考过程如下三种情况所示</p>
<ol>
<li>无法理解数字3、乘以✖️、数字4的含义。 思考失败</li>
<li>理解数字3、乘以✖️、数字4的含义，回归原始。点阵图数数来解决
<ol>
<li>建立横竖轴（x、y）</li>
<li>x轴放三个点点·,y轴放四个点点·(见代码片段-1)</li>
<li>一个一个数， 是12诶！</li>
</ol>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">· · ·</span><br><span class="line">· · ·</span><br><span class="line">· · ·</span><br><span class="line">· · ·</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>学会乘法， 知道乘法表（嘿嘿，回来。你已经会背乘法口诀表啦！）。直接三四一十二，perfect</li>
</ol>
<h4 id="复盘-3-4"><a class="markdownIt-Anchor" href="#复盘-3-4"></a> 复盘 3 * 4</h4>
<p>在上面对<img data-src="https://cdn.nlark.com/yuque/__latex/be1f45951ef7d08436b379402ebfa9ec.svg#card=math&amp;code=3%20%2A4&amp;id=GOAXB" alt="" /><br />
的各种假设的可能性进行了推延生与证明。相信在此时你也和笔者一样又有新的疑问了， 3* 4 不是我们数(算)<br />
出来的嘛？不是，在这之前存在一些“可选”项<br />
对， 是思考出来的。 流程如下<br />
<img data-src="https://cdn.nlark.com/yuque/0/2023/jpeg/22806252/1675183092904-cf89b109-6773-4bab-b538-5e0a9870f8c1.jpeg" alt="" /></p>
<h4 id="拓展计算机思考过程"><a class="markdownIt-Anchor" href="#拓展计算机思考过程"></a> 拓展：计算机“思考”过程</h4>
<ol>
<li>书写代码（在此省略代码编写的种种）</li>
<li>计算机进行“思考”
<ol>
<li>思：编译(将代码转化成计算机可理解的“知识”)。（编译过程，在此不过多赘述），</li>
<li>考：验证编译</li>
</ol>
</li>
<li>加工(位运算)</li>
<li>得到结果</li>
</ol>
<h4 id="题外话人与计算机的思维差异"><a class="markdownIt-Anchor" href="#题外话人与计算机的思维差异"></a> 题外话：人与计算机的思维差异</h4>
<p>人：“聪明”，但<strong>加工</strong>慢<br />
计算机：“愚昧”， 但加工快。快速的准确的yes or no， for loop</p>
<blockquote>
<p>所以，该如何写出“多快好省”的代码呢？尝试二者结合试试</p>
</blockquote>
<h3 id="谈谈想象力或创造力"><a class="markdownIt-Anchor" href="#谈谈想象力或创造力"></a> 谈谈想象力或创造力</h3>
<p>其本质还是思考</p>
<ol>
<li>检索</li>
<li>验证</li>
<li>加工(排列组合)</li>
</ol>
<h4 id="例子钢铁侠"><a class="markdownIt-Anchor" href="#例子钢铁侠"></a> 例子：钢铁侠</h4>
<p>这世界本没有钢铁侠，只是有人给他创造，想象了出来，并赋予其名。<br />
zoom out(宏观角度):  钢铁(科技与狠活) + 人(侠)<br />
zoom in(微观角度)：类似于计算机，譬如ACR核反应堆(类似于电脑的电)  、贾维斯(人工智能) 等等</p>
<h2 id="提高思考力"><a class="markdownIt-Anchor" href="#提高思考力"></a> 提高思考力？</h2>
<blockquote>
<p>思考力：即思考的能力</p>
</blockquote>
<p>由上可知，思考能力的强弱取决于两部分。</p>
<ol>
<li>已有背景知识的存量</li>
<li>梳理加工过滤的能力</li>
</ol>
<p>那么对此，我们可以得出。得出提高思考力的方法</p>
<ul>
<li>增加知识的存量质与量
<ul>
<li>量： 拥有更多的知识
<ul>
<li>输入-&gt; 学习、思考 -&gt; 化为己用</li>
</ul>
</li>
<li>质
<ul>
<li>建立连接：学习并非单纯的记忆，而是连接。旧知识 + 新知识 =&gt; 新认知</li>
<li>点-线-面-体-势，知识结构化，建立有关联的<strong>强链接</strong><br />
，让提取的知识不在是点而是线、是面、是体、甚至是势。不在有知识孤岛，也让思考更加开阔不在局限</li>
</ul>
</li>
</ul>
</li>
<li>增强梳理“过滤”能力
<ul>
<li>随意搭配-&gt; 创造力
<ul>
<li>加减乘除，排列组合</li>
</ul>
</li>
<li>套路搭配 -&gt; 方法论
<ul>
<li>怎么切、怎么分 流程与关键节点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="case-by-case-构建思考框架"><a class="markdownIt-Anchor" href="#case-by-case-构建思考框架"></a> case by case: 构建思考框架</h3>
<p>经过对于其的整合梳理，我们不难得到可复用的方法论。常见的方法如下</p>
<p>逻辑推理：三段论<br />
高效沟通：PREP法则<br />
工作总结：AEAP<br />
创业计划：商业模式画布<br />
工作规划：SMART原则<br />
质量管理：PDCA原则</p>
<h3 id="学习能力"><a class="markdownIt-Anchor" href="#学习能力"></a> 学习能力</h3>
<ul>
<li>学习金字塔</li>
<li>费曼学习法</li>
<li>刻意练习</li>
<li>RIA阅读法</li>
<li>二八定律</li>
</ul>
<h3 id="思考能力"><a class="markdownIt-Anchor" href="#思考能力"></a> 思考能力</h3>
<ul>
<li>黄金圈法则</li>
<li>八何分析法（5w3h、6w2h）</li>
<li>思维导图</li>
<li>策略选择：SWOT分析</li>
<li>梳理信息：MECE法则</li>
<li>10/10/10法则</li>
<li>冰山模型</li>
</ul>
<h3 id="创造能力"><a class="markdownIt-Anchor" href="#创造能力"></a> 创造能力</h3>
<ul>
<li>六顶思考帽</li>
<li>头脑风暴</li>
<li>逆向思维</li>
<li>类比思维</li>
<li>SCAMPER创新思维</li>
</ul>
<h3 id="设计能力"><a class="markdownIt-Anchor" href="#设计能力"></a> 设计能力</h3>
<ul>
<li>设计思维</li>
<li>最小可行性产品（MVP）</li>
<li>峰终定律</li>
<li>AARRR漏斗模型</li>
<li>上瘾（HOOK）模型</li>
</ul>
<h3 id="共情能力"><a class="markdownIt-Anchor" href="#共情能力"></a> 共情能力</h3>
<ul>
<li>五大圈层模型</li>
<li>高效倾听模型</li>
<li>情绪ABC模型</li>
<li>乔哈里视窗</li>
<li>冰山模型</li>
</ul>
<h3 id="演讲能力"><a class="markdownIt-Anchor" href="#演讲能力"></a> 演讲能力</h3>
<ul>
<li>故事五要素</li>
<li>结构表达: SCQA原则</li>
<li>结构阐述：STAR原则</li>
<li>SRAR模型</li>
<li>STORY模型</li>
<li>“英雄之旅”模型</li>
</ul>
<h3 id="领导能力"><a class="markdownIt-Anchor" href="#领导能力"></a> 领导能力</h3>
<ul>
<li>领导力梯队</li>
<li>情景领导力模型</li>
<li>GROW教练模型</li>
<li>管理4C模型</li>
<li>TOPIC模型</li>
</ul>
<h3 id="整合能力"><a class="markdownIt-Anchor" href="#整合能力"></a> 整合能力</h3>
<ul>
<li>杠杆思维</li>
<li>POA行动</li>
<li>系统思维</li>
<li>整合思维模型</li>
<li>多元思维模型</li>
</ul>
<h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2>
<p><strong>既要有“底层逻辑”也要有“顶层设计”。</strong></p>
<p>事物间的共同点，就是底层逻辑。只有不同之中的相同之处、变化背后不变的东西，才是底层逻辑。<br />
只有底层逻辑，才是有生命力的。只有底层逻辑，在我们面临环境变化时，才能被应用到新的变化中，从而产生适应新环境的方法论。所以我们说“底层逻辑+环境变量=方法论”</p>
<p><strong>以终为始，目标导向。</strong><br />
如论是如何思考，何种方法论。最终都是为“问题”所服务的， 切勿**拿着锤子看什么都是钉子！**这并非此文的本意。<br />
上述关于“如何思考” 阐述是微观，那么也希望你也能站在更顶层层次看待anythings</p>
<h2 id="referer"><a class="markdownIt-Anchor" href="#referer"></a> Referer</h2>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlODAlOUQvNTM2NDQ=">https://baike.baidu.com/item/思/53644<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglODAlODM=">https://baike.baidu.com/item/考<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlODAlOUQlRTglODAlODM=">https://baike.baidu.com/item/思考<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3p2aWRlby8xNDQxNDI1NTE2NTMyNzQ4Mjg4">如何才有高效的思考能力<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNzk4MzI4NTE=">人人都能变聪明的四个“核武器”<i class="fa fa-external-link-alt"></i></span></li>
<li>《底层逻辑》</li>
<li>《麻省理工深度思考法》</li>
</ul>
]]></content>
      <categories>
        <category>个人随笔</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>执行一条SQL，这之间到底发生了啥？</title>
    <url>/11430.html</url>
    <content><![CDATA[<h3 id="mysql模型初探"><a class="markdownIt-Anchor" href="#mysql模型初探"></a> MySQL模型初探</h3>
<p>MySQL基础结构是采用典型的C/S工作模型(即是server/client)</p>
<span id="more"></span>
<p>以sshd与xshell为例,如下图所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm9saa2hxxj30s60f0wfd.jpg" alt="" /></p>
<h2 id="mysql客户端实例"><a class="markdownIt-Anchor" href="#mysql客户端实例"></a> MySQL客户端实例</h2>
<p>MySQL客户端主要有以下功能</p>
<ul>
<li>连接数据库</li>
<li>发送指令</li>
</ul>
<h3 id="连接数据库"><a class="markdownIt-Anchor" href="#连接数据库"></a> 连接数据库</h3>
<p>socket连接方式与远程TCP/IP连接</p>
<p>在Linux中<code>/etc/my.cnf</code>文件中显示（已完成MySQL的安装）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">socket= /tmp/MySQL.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例如下</span></span><br><span class="line">root@ecs-dc8a-0003:~# <span class="built_in">cat</span> /etc/my.cnf                                                                                        </span><br><span class="line">[client]</span><br><span class="line"><span class="comment">#password       = your_password</span></span><br><span class="line">port            = 3306</span><br><span class="line">socket          = /tmp/MySQL.sock</span><br><span class="line"></span><br><span class="line">[MySQLd]</span><br><span class="line">port            = 3306</span><br><span class="line">socket          = /tmp/MySQL.sock</span><br><span class="line">datadir = /www/server/data</span><br><span class="line">default_storage_engine = InnoDB</span><br><span class="line">performance_schema_max_table_instances = 400</span><br><span class="line">table_definition_cache = 400</span><br><span class="line">skip-external-locking</span><br><span class="line">key_buffer_size = 1024M</span><br><span class="line"></span><br><span class="line">---略</span><br></pre></td></tr></table></figure>
<h3 id="连接mysql的两种方式实现"><a class="markdownIt-Anchor" href="#连接mysql的两种方式实现"></a> 连接MySQL的两种方式实现</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">way1: <span class="comment"># 只能在本地使用，不依靠ip地址与端口号</span></span><br><span class="line">在本地可直接使用如下命令进行scoket连接 </span><br><span class="line">MySQL -S /tmp/MySQL.sock</span><br><span class="line"></span><br><span class="line">way2: <span class="comment"># “远程”连接(基于TCP/IP)</span></span><br><span class="line">MySQL -h ip -P 3306 -u username -p passwd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>常用参数示例:</p>
<p><code>-S</code>:    指定socker文件</p>
<p><code>-h</code>:   指定连接ip地址</p>
<p><code>-P</code>：指定连接端口号，默认为3306</p>
<p><code>-u</code>:  指定连接用户名</p>
<p>`-p 指定连接密码</p>
</blockquote>
<h3 id="发送指令"><a class="markdownIt-Anchor" href="#发送指令"></a> 发送指令</h3>
<p>即发送操作数据库指令(SQL语句)</p>
<blockquote>
<p><strong>SQL种类</strong></p>
<p>DDL 数据定义语言</p>
<p>DCL 数据控制语言</p>
<p>DML 数据操作语言</p>
<p>DQL 数据查询语言</p>
</blockquote>
<h2 id="服务器端实例"><a class="markdownIt-Anchor" href="#服务器端实例"></a> 服务器端(实例)</h2>
<p>实例：My sqld + 工作线程 + 预分配内存</p>
<p>功能：管理数据(增删改查等)</p>
<h3 id="mysqld工作模型"><a class="markdownIt-Anchor" href="#mysqld工作模型"></a> MySQLd工作模型</h3>
<p>MySQLd的工作模型可分为两块，<code>server</code>层，<code>引擎层</code>，server层可细分为<code>连接层</code>、<code>SQL层</code></p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmace22omuj30em0jit8k.jpg" alt="MySQLd工作模型" /></p>
<h3 id="连接层提供连接"><a class="markdownIt-Anchor" href="#连接层提供连接"></a> 连接层：提供连接</h3>
<ol>
<li>提供可连接协议，例如（TCP/IP， socket）</li>
<li>验证用户名密码等连接</li>
<li>提供专用的连接线程</li>
</ol>
<p>在MySQL命令行中使用<code>show processlist;</code>查看连接线程,如下所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmacry3p4cj31p608wab1.jpg" alt="" /></p>
<h3 id="sql层执行sql"><a class="markdownIt-Anchor" href="#sql层执行sql"></a> SQL层：执行SQL</h3>
<ol>
<li>验证SQL语句(语法检查)</li>
<li>语意(SQL语句种类，DDL，DCL，DML，DQL)</li>
<li>权限验证</li>
<li>解析器：解析预处理，列举所有可行的方案</li>
<li>优化器：MySQL会采用自己的估价函数去预估选择&quot;最优执行&quot;方法</li>
<li>执行器：执行其按照优化器选择执行SQL语句</li>
<li>日志记录(bingo二进制日志\glog，默认不开启。需人工开启)</li>
</ol>
<p>MySQL中有查询缓存这么一说(query_cache,默认不开启)，当业务量有大量相同的查询等操作，我们一般采用Redis进行一个缓存.</p>
<h3 id="存储引擎层"><a class="markdownIt-Anchor" href="#存储引擎层"></a> 存储引擎层</h3>
<p>相当于Linux中文件系统，与磁盘交互的模块</p>
<h2 id="sql语句执行流程"><a class="markdownIt-Anchor" href="#sql语句执行流程"></a> SQL语句执行流程</h2>
<p>那么各层之间有什么作用呢？请听我细细说来，在这样我们使用一条SQL语句执行流程来理解一下此流程。</p>
<p>当需要执行SQL语句的时候，必然需要服务端（MySQLd）存在，那么我们无论如何是需要首先开启MySQLd的服务</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmahqqq935j31000sgwj9.jpg" alt="" /></p>
<h3 id="服务端开启"><a class="markdownIt-Anchor" href="#服务端开启"></a> 服务端开启</h3>
<p>首先开启MySQL服务即(MySQLd),成功开启此服务后，主要体现为<code>MySQLd实例</code>，开启工作线程，向系统申请内存(<br />
此内存为预分配内存，一旦分配无论使用与否，其他应用均不可使用)</p>
<p>MySQLd开启后，打开server层 存储引擎层，其中server层中连接层提供连接，sql层准备接受客户端指令，存储引擎层与系统磁盘交互。至此MySQLd服务开启成功</p>
<h3 id="客户端连接"><a class="markdownIt-Anchor" href="#客户端连接"></a> 客户端连接</h3>
<p>假设MySQL服务端启动完成之后，我们可以采用<code>TCP/IP</code>或者<code>socket</code>协议连接MySQL数据库。那么我们此时便发起连接请求。输入以下连接命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">MySQL -h ip -P 3306 -u username -p passwd</span><br></pre></td></tr></table></figure>
<p>服务端接受到连接请求，将会进行以下几步操作。(发生在服务端，肉眼无法直接看见)</p>
<p>首先会验证连接请求的账号与密码。去MySQL.user表中去寻找账号名，账号名不存在断开连接，账号存在下一步寻找对应加密了的密码。与之对应验证。验证成功后，分配此连接专用的连接线程。并提供服务。</p>
<p>连接成功之后如下所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmai4ejkq8j31920gs0us.jpg" alt="" /></p>
<p>接下来我们，在MySQL的终端上执行如下sql查询语句,它的意思是从MySQL库中的user表查询字段名(表头)<br />
为<code>host,name</code>的所有内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select host,name from MySQL.user;</span><br></pre></td></tr></table></figure>
<p>当MySQLd接收到此指令之后，会进行以下几步操作。</p>
<ol>
<li>
<p>语法检查，如果语法不属于sql语句系列，直接抛出错误，终止执行此语句。若通过之后执行下一步</p>
</li>
<li>
<p>语义，进一步释意sql语句。若表不存在，字段名不存在。直接抛出错误，终止执行此语句。若通过之后执行下一步</p>
</li>
<li>
<p>验证<code>用户权限</code>，顾名思义，这个没什么好说的</p>
</li>
<li>
<p>解析预处理，经过层层验证到了此步骤之后，说明此语句是可以被执行的。那么此时MySQLd会采用&quot;演练&quot;<br />
枚举列出所有的可执行方案。我们或多或少的知道，需要达到相同的效果，达成的方法有各种各样。此时MySQL会列举出所有的方案。例如，以&quot;<br />
select host,name from MySQL.user;&quot;这条SQL语句为例，它可达到目的的方式至少有两种，</p>
<ul>
<li>方案1.对MySQL下的user表进行全表查询，后截断塞选出user表查询字段名(表头)为<code>host,name</code>的所有内容。</li>
<li>方案2.对MySQL下user表字段<code>host,name</code>进行查询，后直接输出</li>
</ul>
<p>虽然二者执行的结果是一致的但资源消耗却并不是一致的</p>
</li>
<li>
<p>优化器，经过上一步的解析预处理之后，这一步MySQL会采用直接的估计函数，进行资源损耗的预估，从而选择“最优”</p>
</li>
<li>
<p>得到优化器的方案选举结果，执行</p>
</li>
<li>
<p>到存储引擎层申请数据，存储引擎层向磁盘获取数据</p>
</li>
<li>
<p>查询</p>
</li>
<li>
<p>查询成功，释放内存</p>
</li>
<li>
<p>输出</p>
</li>
</ol>
<p>执行成功后，如下所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gmaifmwzqfj30mu0ca74v.jpg" alt="" /></p>
<p>那么到这里你可能会有以下两个疑问</p>
<p>疑问一：</p>
<p>既然MySQL有‘优化器’来帮助我们进行最优的执行方案，那么是否我们的SQL语句只要能正常运行就好了呢？反正它都是“最优的”执行方案。</p>
<p>理论上确实如此，但是实际上却并不一定是这样的。MySQL的优化器仅仅帮我们达到了局部最优，而不是全局最优。类似于“贪心算法”思路，我们得到的最终结果就并不一定是全局最优的。</p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>DBMS</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索引擎使用技巧</title>
    <url>/27205.html</url>
    <content><![CDATA[<blockquote>
<p>大多数人以非常低效且通常无效的方式使用谷歌。如果您所做的只是输入几个关键字并单击搜索按钮，那么您就是那些无法从Google中获得尽可能多的资源的用户之一。——《谷歌百科》</p>
</blockquote>
<p>Hi,见字如面，我是裴恩。</p>
<p>在信息爆炸的如今，我们经常借助搜索引擎来获取信息，譬如baidu、google、bing等各搜索引擎。对，它真的非常的强大。只需将想知道的相关问题输入给它，他就会返回给我们“琳琅满目”的信息（当然这其中也包含答案）。<br />
但通常直接搜索已经无法满足我们的需求，尤其是开发中。例如我们需要查寻一个bug如何处理、如何写某某代码。这之间夹杂了许多无用的信息、广告、相似却无关的信息。这非常消耗我们的精力！</p>
<p>那么我们该如何高效精确的使用搜索引擎进行搜索？</p>
<h2 id="使用搜索"><a class="markdownIt-Anchor" href="#使用搜索"></a> 使用搜索</h2>
<p>由于搜索引擎，核心的显示就是一个搜索框。在此便不在对此进行过多赘述。<br />
无论我们是使用搜索引擎简单或是高级的搜索功能，在此之前我们都需要有效可靠的搜索方法和流程。遵循这些原则和使用这些方法就可以获取到对应更精准，更明确的结果。</p>
<ol>
<li>确定此次的目的与范围，（什么是一定不要的信息、什么又是可要可不要的信息、什么是一定要的信息。这些如果足够清晰，那么就可以更高效精准的找到答案）
<ol>
<li>此次的搜索是为了寻找什么（请始终保持该“初心”！）</li>
<li>精确、清晰简洁的描述需要寻找的信息（毕竟less is more！）</li>
<li>那些词可以帮助搜索进行排除，亦或者更好的定义问题</li>
</ol>
</li>
<li>构建搜索需求
<ol>
<li>使用尽可能清晰明确的关键词</li>
<li>尝试使用适当的搜索运算符来优化的搜索</li>
<li>使用搜索的筛选功能或“高级搜索”功能</li>
</ol>
</li>
<li>进行搜索</li>
<li>根据返回的结果，优化查询并再次搜索——或者通过切换到更合适的搜索站点来优化搜索</li>
</ol>
<blockquote>
<p>换言之，这需要你在搜索之前思考清楚，接着在获得最初结果后精炼你的搜索。这些多做的努力都是轻微的，但确实很值得。</p>
</blockquote>
<h2 id="高级搜索技巧"><a class="markdownIt-Anchor" href="#高级搜索技巧"></a> 高级搜索技巧</h2>
<p>高级搜索技巧主要包含两部分，其一就是操作符的使用， 搜索关键字按照什么<strong>逻辑关系</strong>如何<br />
排列组合。其二便是过滤搜索，搜索指定类型的内容。具体内容如下</p>
<h3 id="操作符"><a class="markdownIt-Anchor" href="#操作符"></a> 操作符</h3>
<h4 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符"></a> 逻辑运算符</h4>
<ul>
<li><code>AND</code>：与运算</li>
<li><code>OR</code>：或运算</li>
<li><code>NOT</code>: 非运算</li>
</ul>
<h4 id="逻辑符"><a class="markdownIt-Anchor" href="#逻辑符"></a> 逻辑符</h4>
<ul>
<li><code>+</code>: 包含</li>
<li><code>-</code>：排除</li>
<li><code>~</code>：近义词</li>
<li><code>()</code>:在需要需要查询的字词前后用()括起来。这个运算符的作用是提升运算顺序，跟数学中的()<br />
是一个用法。跟AND一样，单独比较少用，一般也是与其他的运算符组合使用。</li>
</ul>
<h4 id="正则表达式"><a class="markdownIt-Anchor" href="#正则表达式"></a> 正则表达式</h4>
<ul>
<li><code>.</code></li>
<li><code>*</code>：通配符，与在正则表达是含义一致</li>
</ul>
<h4 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h4>
<ul>
<li><code>&quot;&quot;</code>：以双引号内的句子作为搜索条件，而非split后的词。</li>
<li><code>@</code>：指定源</li>
</ul>
<blockquote>
<p>注意：搜索栏中的符号均为英文字符，英文字母必须为大写。否则可能会被搜素引擎忽略</p>
</blockquote>
<h3 id="指定搜索"><a class="markdownIt-Anchor" href="#指定搜索"></a> 指定搜索</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9zdXBwb3J0Lmdvb2dsZS5jb20vd2Vic2VhcmNoL2Fuc3dlci8yNDY2NDMz">https://support.google.com/websearch/answer/2466433<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>指定搜索的语法<code>指定范围：搜索内容</code>， 譬如baidu的咨询信息<code>info:baidu</code>。常见的搜素范围有如下</p>
<h4 id="指定词"><a class="markdownIt-Anchor" href="#指定词"></a> 指定词</h4>
<ul>
<li>filetype: 限制所搜索的文件一个特定的格式 filetype:extension</li>
<li>site: 限制所进行的搜索在指定的域名或网站内 site:domain</li>
<li>link:返回所有链接到某个URL地址的网页</li>
<li>info: 返回所有相关的咨询信息</li>
</ul>
<h4 id="指定词范围"><a class="markdownIt-Anchor" href="#指定词范围"></a> 指定词范围</h4>
<table>
<thead>
<tr>
<th>简介</th>
<th>单数</th>
<th>复数</th>
</tr>
</thead>
<tbody>
<tr>
<td>限制搜索的词语是网页中链接内包含的关键词</td>
<td>inanchor</td>
<td>allinanchor</td>
</tr>
<tr>
<td>限制搜索的词语是网页内文包含的关键词</td>
<td>intext</td>
<td>allintext</td>
</tr>
<tr>
<td>限制搜索的词语是网页网址中包含的关键词</td>
<td>inurl</td>
<td>allinurl</td>
</tr>
<tr>
<td>限制搜索的词语是网页标题中包含的关键词</td>
<td>intiitle</td>
<td>allintitle</td>
</tr>
</tbody>
</table>
<h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2>
<p>本文对于搜索引擎使用方式方法进行了探讨，同时还阐述了一些高级的搜索技巧的基础语法。希望这些技巧能够帮助你在工作中、生活中高效精确使用搜索引擎。</p>
<p>注意：虽然搜索引擎极大的降低了我们获取知识、答案的门槛，但是同时我们也要在使用搜索引擎中不断的完善我们自身。Google永远无法搜索到认知之外的事物！</p>
<h2 id="相关链接"><a class="markdownIt-Anchor" href="#相关链接"></a> 相关链接</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9hZHZhbmNlZF9zZWFyY2g=">Google 高级搜索<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly9zdXBwb3J0Lmdvb2dsZS5jb20vd2Vic2VhcmNoL2Fuc3dlci8xMzQ0Nzk/aGw9ZW4=">How to search on Google<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly9zaXRlcy5nb29nbGUuY29tL3NpdGUvaG9wZWFud2FuZy9nb29nbGUlRTYlQTMlODAlRTclQjQlQTIlRTYlOEElODAlRTUlQjclQTclRTUlQTQlQTclRTUlODUlQTg=">Google检索技巧大全<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3JtaXQuY29tL2FydGljbGVzL2FydGljbGUuYXNweD9wPTY3NTI3NA==">Ten Tips for Smarter Google Searches<i class="fa fa-external-link-alt"></i></span></p>
<p>非常感谢你的阅读，更多精彩内容，欢迎关注我的公众号「积跬Coder」一起成长。</p>
]]></content>
      <categories>
        <category>搜索引擎</category>
      </categories>
      <tags>
        <tag>搜索引擎</tag>
        <tag>Google</tag>
        <tag>Baidu</tag>
        <tag>Bing</tag>
        <tag>Yandex</tag>
      </tags>
  </entry>
  <entry>
    <title>新mac使用技巧入门指北</title>
    <url>/34489.html</url>
    <content><![CDATA[<h2 id="homebrew"><a class="markdownIt-Anchor" href="#homebrew"></a> HomeBrew</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9icmV3LnNoLw==">HomeBrew官方地址<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9icmV3LmlkYXllci5jb20v">brew.idayer<i class="fa fa-external-link-alt"></i></span></p>
<p>简单来说他是类似于<code>yum、apt</code>,mac的包管理工具，使用它我们可以非常简单、丝滑的下载大部分的包、或者软件</p>
<p>第一次可以尝试使用如下命令进行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</span><br></pre></td></tr></table></figure>
<p>由于种种原因，如果安装不上，可以使用华科大的源进行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install.sh)&quot;</span><br></pre></td></tr></table></figure>
<p>安装完成后，检查一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew update &amp;&amp; brew upgrade &amp;&amp; brew doctor</span><br></pre></td></tr></table></figure>
<p>设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git -C <span class="string">&quot;/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core&quot;</span> remote set-url origin https://github.com/Homebrew/homebrew-core</span><br></pre></td></tr></table></figure>
<h2 id="定制zsh编辑器"><a class="markdownIt-Anchor" href="#定制zsh编辑器"></a> 定制zsh编辑器</h2>
<p>原生的mac，zsh是没有命令提示的，以及显示也并没有那么好看。自定制一下,终端建议使用<code>iterm2</code></p>
<p>下载<code>iterm2</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install --cask iterm2</span><br></pre></td></tr></table></figure>
<h4 id="下载oh-my-zsh"><a class="markdownIt-Anchor" href="#下载oh-my-zsh"></a> 下载oh-my-zsh</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># curl 安装方式</span></span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span></span><br><span class="line"><span class="comment"># wget 安装方式</span></span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="复制-zshrc"><a class="markdownIt-Anchor" href="#复制-zshrc"></a> 复制 .zshrc</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure>
<h4 id="修改默认-shell可选"><a class="markdownIt-Anchor" href="#修改默认-shell可选"></a> 修改默认 shell(可选)</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>
<p>在终端中新建一个窗口(快捷键：command + n），你就发现不一样的shell，如下图所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNly1gpxd433qdsj317o0e0wes.jpg" alt="image-20210426191816929" /></p>
<h4 id="安装插件"><a class="markdownIt-Anchor" href="#安装插件"></a> 安装插件</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">zsh-autosuggestions 提供自动补全功能</span></span><br><span class="line">git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">zsh-syntax-highlighting 语法高亮</span></span><br><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git-open 插件 提供 快捷打开远程地址 git open</span></span><br><span class="line">git clone https://github.com/paulirish/git-open.git $ZSH_CUSTOM/plugins/git-open</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">zsh-z z -h</span></span><br><span class="line">git clone https://github.com/agkozak/zsh-z $ZSH_CUSTOM/plugins/zsh-z</span><br></pre></td></tr></table></figure>
<p><code>.zshrc</code> 文件如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># If you come from bash you might have to change your $PATH.</span></span><br><span class="line"><span class="comment"># export PATH=$HOME/bin:/usr/local/bin:$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Path to your oh-my-zsh installation.</span></span><br><span class="line"><span class="built_in">export</span> ZSH=<span class="string">&quot;<span class="variable">$HOME</span>/.oh-my-zsh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set name of the theme to load --- if set to &quot;random&quot;, it will</span></span><br><span class="line"><span class="comment"># load a random theme each time oh-my-zsh is loaded, in which case,</span></span><br><span class="line"><span class="comment"># to know which specific one was loaded, run: echo $RANDOM_THEME</span></span><br><span class="line"><span class="comment"># See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes</span></span><br><span class="line"><span class="comment"># ZSH_THEME=&quot;robbyrussell&quot;</span></span><br><span class="line">ZSH_THEME=<span class="string">&quot;random&quot;</span></span><br><span class="line"><span class="built_in">export</span> HISTSIZE=999999</span><br><span class="line"><span class="built_in">export</span> HISTFILESIZE=999999</span><br><span class="line">ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE=<span class="string">&quot;fg=#ff00ff,bg=cyan,bold,underline&quot;</span></span><br><span class="line"><span class="comment"># Set list of themes to pick from when loading at random</span></span><br><span class="line"><span class="comment"># Setting this variable when ZSH_THEME=random will cause zsh to load</span></span><br><span class="line"><span class="comment"># a theme from this variable instead of looking in $ZSH/themes/</span></span><br><span class="line"><span class="comment"># If set to an empty array, this variable will have no effect.</span></span><br><span class="line"><span class="comment"># ZSH_THEME_RANDOM_CANDIDATES=( &quot;robbyrussell&quot; &quot;agnoster&quot; )</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to use case-sensitive completion.</span></span><br><span class="line"><span class="comment"># CASE_SENSITIVE=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to use hyphen-insensitive completion.</span></span><br><span class="line"><span class="comment"># Case-sensitive completion must be off. _ and - will be interchangeable.</span></span><br><span class="line"><span class="comment"># HYPHEN_INSENSITIVE=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment one of the following lines to change the auto-update behavior</span></span><br><span class="line"><span class="comment"># zstyle &#x27;:omz:update&#x27; mode disabled  # disable automatic updates</span></span><br><span class="line"><span class="comment"># zstyle &#x27;:omz:update&#x27; mode auto      # update automatically without asking</span></span><br><span class="line"><span class="comment"># zstyle &#x27;:omz:update&#x27; mode reminder  # just remind me to update when it&#x27;s time</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to change how often to auto-update (in days).</span></span><br><span class="line"><span class="comment"># zstyle &#x27;:omz:update&#x27; frequency 13</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line if pasting URLs and other text is messed up.</span></span><br><span class="line"><span class="comment"># DISABLE_MAGIC_FUNCTIONS=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to disable colors in ls.</span></span><br><span class="line"><span class="comment"># DISABLE_LS_COLORS=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to disable auto-setting terminal title.</span></span><br><span class="line"><span class="comment"># DISABLE_AUTO_TITLE=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to enable command auto-correction.</span></span><br><span class="line"><span class="comment"># ENABLE_CORRECTION=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to display red dots whilst waiting for completion.</span></span><br><span class="line"><span class="comment"># You can also set it to another string to have that shown instead of the default red dots.</span></span><br><span class="line"><span class="comment"># e.g. COMPLETION_WAITING_DOTS=&quot;%F&#123;yellow&#125;waiting...%f&quot;</span></span><br><span class="line"><span class="comment"># Caution: this setting can cause issues with multiline prompts in zsh &lt; 5.7.1 (see #5765)</span></span><br><span class="line"><span class="comment"># COMPLETION_WAITING_DOTS=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line if you want to disable marking untracked files</span></span><br><span class="line"><span class="comment"># under VCS as dirty. This makes repository status check for large repositories</span></span><br><span class="line"><span class="comment"># much, much faster.</span></span><br><span class="line"><span class="comment"># DISABLE_UNTRACKED_FILES_DIRTY=&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line if you want to change the command execution time</span></span><br><span class="line"><span class="comment"># stamp shown in the history command output.</span></span><br><span class="line"><span class="comment"># You can set one of the optional three formats:</span></span><br><span class="line"><span class="comment"># &quot;mm/dd/yyyy&quot;|&quot;dd.mm.yyyy&quot;|&quot;yyyy-mm-dd&quot;</span></span><br><span class="line"><span class="comment"># or set a custom format using the strftime function format specifications,</span></span><br><span class="line"><span class="comment"># see &#x27;man strftime&#x27; for details.</span></span><br><span class="line"><span class="comment"># HIST_STAMPS=&quot;mm/dd/yyyy&quot;</span></span><br><span class="line">HIST_STAMPS=<span class="string">&quot;yyyy-mm-dd&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Would you like to use another custom folder than $ZSH/custom?</span></span><br><span class="line"><span class="comment"># ZSH_CUSTOM=/path/to/new-custom-folder</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Which plugins would you like to load?</span></span><br><span class="line"><span class="comment"># Standard plugins can be found in $ZSH/plugins/</span></span><br><span class="line"><span class="comment"># Custom plugins may be added to $ZSH_CUSTOM/plugins/</span></span><br><span class="line"><span class="comment"># Example format: plugins=(rails git textmate ruby lighthouse)</span></span><br><span class="line"><span class="comment"># Add wisely, as too many plugins slow down shell startup.</span></span><br><span class="line">plugins=(</span><br><span class="line">    rails</span><br><span class="line">    git</span><br><span class="line">    adb</span><br><span class="line">    textmate</span><br><span class="line">    lighthouse</span><br><span class="line">    bundler</span><br><span class="line">    dotenv</span><br><span class="line">    macos</span><br><span class="line">    rake</span><br><span class="line">    rbenv</span><br><span class="line">    git-open</span><br><span class="line">    zsh-z</span><br><span class="line">    zsh-autosuggestions</span><br><span class="line">    zsh-syntax-highlighting</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># User configuration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># export MANPATH=&quot;/usr/local/man:$MANPATH&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You may need to manually set your language environment</span></span><br><span class="line"><span class="built_in">export</span> LANG=en_US.UTF-8</span><br><span class="line"></span><br><span class="line"><span class="comment"># Preferred editor for local and remote sessions</span></span><br><span class="line"><span class="comment"># if [[ -n $SSH_CONNECTION ]]; then</span></span><br><span class="line"><span class="comment">#   export EDITOR=&#x27;vim&#x27;</span></span><br><span class="line"><span class="comment"># else</span></span><br><span class="line"><span class="comment">#   export EDITOR=&#x27;mvim&#x27;</span></span><br><span class="line"><span class="comment"># fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Compilation flags</span></span><br><span class="line"><span class="comment"># export ARCHFLAGS=&quot;-arch x86_64&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set personal aliases, overriding those provided by oh-my-zsh libs,</span></span><br><span class="line"><span class="comment"># plugins, and themes. Aliases can be placed here, though oh-my-zsh</span></span><br><span class="line"><span class="comment"># users are encouraged to define aliases within the ZSH_CUSTOM folder.</span></span><br><span class="line"><span class="comment"># For a full list of active aliases, run `alias`.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Example aliases</span></span><br><span class="line"><span class="built_in">alias</span> zshconfig=<span class="string">&quot;mate ~/.zshrc&quot;</span></span><br><span class="line"><span class="built_in">alias</span> ohmyzsh=<span class="string">&quot;mate ~/.oh-my-zsh&quot;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">cp</span>=<span class="string">&#x27;cp -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">mv</span>=<span class="string">&#x27;mv -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> brewski=<span class="string">&#x27;brew update; brew upgrade; brew cleanup; brew doctor&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> pyfmt=<span class="string">&#x27;fd . -e py | xargs black&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> gofmtl=<span class="string">&#x27;fd . -e go | xargs gofmt -w&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> cls=<span class="string">&#x27;clear&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ccnpm=<span class="string">&quot;npm --registry=https://registry.npmmirror.com \</span></span><br><span class="line"><span class="string">--cache=<span class="variable">$HOME</span>/.npm/.cache/cnpm \</span></span><br><span class="line"><span class="string">--disturl=https://npmmirror.com/mirrors/node \</span></span><br><span class="line"><span class="string">--userconfig=<span class="variable">$HOME</span>/.cnpmrc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GOPATH=<span class="string">&quot;/Users/payne/WorkSpace/Go&quot;</span></span><br><span class="line"><span class="built_in">export</span> GOBIN=<span class="string">&quot;<span class="variable">$&#123;GOPATH&#125;</span>/bin&quot;</span></span><br><span class="line"><span class="built_in">export</span> GOPROXY=<span class="string">&quot;https://goproxy.cn,direct&quot;</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$&#123;GOBIN&#125;</span>:<span class="variable">$&#123;GOPATH&#125;</span>:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; conda initialize &gt;&gt;&gt;</span></span><br><span class="line"><span class="comment"># !! Contents within this block are managed by &#x27;conda init&#x27; !!</span></span><br><span class="line">__conda_setup=<span class="string">&quot;<span class="subst">$(&#x27;/opt/homebrew/Caskroom/miniconda/base/bin/conda&#x27; &#x27;shell.zsh&#x27; &#x27;hook&#x27; 2&gt; /dev/null)</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="string">&quot;<span class="variable">$__conda_setup</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="string">&quot;/opt/homebrew/Caskroom/miniconda/base/etc/profile.d/conda.sh&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        . <span class="string">&quot;/opt/homebrew/Caskroom/miniconda/base/etc/profile.d/conda.sh&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">export</span> PATH=<span class="string">&quot;/opt/homebrew/Caskroom/miniconda/base/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">unset</span> __conda_setup</span><br><span class="line"><span class="comment"># &lt;&lt;&lt; conda initialize &lt;&lt;&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> &lt;(kubectl completion zsh)</span><br><span class="line"><span class="built_in">source</span> &lt;(helm completion zsh)</span><br><span class="line"></span><br><span class="line"><span class="comment">## HOMEBREW</span></span><br><span class="line"><span class="built_in">export</span> HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles</span><br></pre></td></tr></table></figure>
<h3 id="自动补全"><a class="markdownIt-Anchor" href="#自动补全"></a> 自动补全</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">zsh</span></span><br><span class="line">source &lt;(kubectl completion zsh)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bash (需要下载bash-completion)</span></span><br><span class="line">source /usr/share/bash-completion/bash_completion</span><br><span class="line">source &lt;(kubectl completion bash)</span><br></pre></td></tr></table></figure>
<h2 id="font"><a class="markdownIt-Anchor" href="#font"></a> font</h2>
<ul>
<li>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JvbWthdHYvcG93ZXJsZXZlbDEwaw==">https://github.com/romkatv/powerlevel10k<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Bvd2VybGluZS9mb250cw==">https://github.com/powerline/fonts<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>mac</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>新一代vim-neovim</title>
    <url>/610.html</url>
    <content><![CDATA[<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 普通安装</span></span><br><span class="line">brew install neovim</span><br><span class="line"><span class="comment"># 开发版本安装</span></span><br><span class="line">brew install --HEAD luajit</span><br><span class="line">brew install --HEAD neovim</span><br><span class="line"><span class="comment"># 包安装</span></span><br><span class="line">curl -LO https://github.com/neovim/neovim/releases/download/nightly/nvim-macos.tar.gz</span><br><span class="line">tar xzf nvim-macos.tar.gz</span><br><span class="line">./nvim-osx64/bin/nvim</span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">nvim --version</span><br></pre></td></tr></table></figure>
<p>熟悉的所有Vim命令都可以在Neovim中使用，Neovim的配置文件格式也与Vim相同。不过，.vimrc在Neovim中不会自动加载。Neovim的配置文件遵守XDG基本目录结构，即所有的配置文件都放在<code>~/.config</code><br />
目录中。Neovim的配置文件被保存在<code>~/.config/nvim</code>中</p>
<ul>
<li>
<p><code>~/.config/nvim/init.vim</code>对应于<code>~/.vimrc</code>。</p>
</li>
<li>
<p><code>~/.config/nvim/</code>对应于<code>~/.vim/</code>。</p>
</li>
</ul>
<h2 id="基本配置"><a class="markdownIt-Anchor" href="#基本配置"></a> 基本配置</h2>
<p>当然可以将Neovim的配置文件链接到Vim的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建配置文件夹</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.config</span><br><span class="line"><span class="comment"># 创建文件夹软连接</span></span><br><span class="line"><span class="built_in">ln</span> -s <span class="variable">$HOME</span>/.vim <span class="variable">$HOME</span>/.config/nvim</span><br><span class="line"><span class="comment"># 创建配置文件软连接</span></span><br><span class="line"><span class="built_in">ln</span> -s <span class="variable">$HOME</span>/.vimrc <span class="variable">$HOME</span>/.config/nvim/init.vim</span><br></pre></td></tr></table></figure>
<h2 id="初次使用neovim"><a class="markdownIt-Anchor" href="#初次使用neovim"></a> 初次使用neovim</h2>
<p>当在终端输入<code>nvim</code>时，将展示如下界面</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gyprbge7raj30m50930te.jpg" alt="image-20220125112813654" /></p>
<p>使用<code>shfit + :</code> 并输入<code>checkhealth</code>进行依赖检查</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -m pip install neovim</span><br><span class="line">npm install -g neovim</span><br><span class="line">cpan Neovim::ext</span><br></pre></td></tr></table></figure>
<p>Neovim的默认选项与Vim有很大的不同。在现代的计算机世界里，文本编辑器的默认值需要对用户比较友好。默认情况下Vim的.vimrc文件并不包含任何默认设置，而Neovim默认已经设置好语法高亮、合理的缩进设置、wildmenu、高亮显示搜索结果和增量搜索（incsearch）等。可通过查看<code>:help nvim-defaults</code><br />
了解Neovim的默认选项。</p>
<p>我的配置：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1BheW5lLVd1L0JyYWNrZXQvYmxvYi9tYXN0ZXIvU3lzdGVtSW5pdGlhbGl6YXRpb24vVmltL3ZpbXJj">https://github.com/Payne-Wu/Bracket/blob/master/SystemInitialization/Vim/vimrc<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>neovim</category>
        <category>vim</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>neovim</tag>
      </tags>
  </entry>
  <entry>
    <title>有人爱有人恨-GIL</title>
    <url>/53369.html</url>
    <content><![CDATA[<h2 id="什么是gil"><a class="markdownIt-Anchor" href="#什么是gil"></a> 什么是GIL</h2>
<p>GIL（Global Interpreter Lock，即全局解释器锁），是最流行的 Python 解释器 CPython<br />
中的一个技术术语。它的意思是全局解释器锁，本质上是<strong>类似操作系统的 Mutex</strong><br />
，它可以帮助CPython解决其在内存管理中存在的线程不安全问题。</p>
<p>每一个 Python 线程，在 CPython 解释器中执行时，都会先锁住自己的线程，阻止别的线程执行。</p>
<p>简而言之就是<strong>任意时刻，Python 只有一个线程在同时运行</strong>。</p>
<h2 id="为什么需要gil"><a class="markdownIt-Anchor" href="#为什么需要gil"></a> 为什么需要GIL</h2>
<p>在CPython中，<strong>全局解释器锁</strong>（GIL）是一个互斥体，用于保护对Python对象的访问，防止多个线程同时执行Python<br />
bytecodes。GIL的存在可<strong>防止竞争确保线程安全</strong>。</p>
<p>所以说，CPython 引进 GIL 主要原因:</p>
<ul>
<li>设计者为了规避类似于内存管理这样的复杂的竞争风险问题（race condition）；</li>
<li>因为 CPython 大量使用 C 语言库，但大部分 C 语言库都不是原生线程安全的（线程安全会降低性能和增加复杂度）。</li>
</ul>
<p>为什么 CPython 需要 GIL 呢？这其实和 CPython 的实现有关。Python 的内存管理机制， CPython 使用引用计数来管理内存，所有<br />
Python<br />
脚本中创建的实例，都会有一个引用计数，来记录有多少个指针指向它。当引用计数只有 0 时，则会自动释放内存。</p>
<h2 id="gil工作原理"><a class="markdownIt-Anchor" href="#gil工作原理"></a> GIL工作原理</h2>
<ol>
<li>某个线程拿到GIL</li>
<li>该线程执行代码，直到达到了check_interval*</li>
<li>解释器让当前线程释放GIL</li>
<li>所有的线程开始竞争GIL</li>
<li>竞争到GIL锁的线程又从第1步开始执行</li>
</ol>
<blockquote>
<p>Python2中，check_interavl是当前线程遇见IO操作或者ticks计数达到100*。*</p>
<p>在Python3中是执行时间达到阈值（默认为15毫秒）</p>
</blockquote>
<h2 id="gil存在的利弊"><a class="markdownIt-Anchor" href="#gil存在的利弊"></a> GIL存在的利弊</h2>
<h3 id="利"><a class="markdownIt-Anchor" href="#利"></a> 利</h3>
<p>GIL 的设计，主要是为了方便 CPython 解释器层面的编写者</p>
<ul>
<li>在单线程任务中更快；</li>
<li>在多线程任务中，对于I/O密集型程序运行更快；</li>
<li>在多线程任务中，对于用C语言包来实现CPU密集型任务的程序运行更快；</li>
<li>在写C扩展的时候更加容易，因为除非你在扩展中允许，否则Python解释器不会切换线程；</li>
<li>在打包C库时更加容易。我们不用担心线程安全性。，因为如果该库不是线程安全的，则只需在调用GIL时将其锁定即可。</li>
</ul>
<h3 id="弊"><a class="markdownIt-Anchor" href="#弊"></a> 弊</h3>
<p>这种 GIL 锁的设计对于只使用单线程运行的code来说其实没有什么影响。但是对于计算密集型的程序（CPU-bound）和基于多线程的程序来说，Python<br />
的 GIL 设计<strong>很有可能会</strong>造成性能瓶颈。</p>
<p>例子：</p>
<p>因为有GIL的存在，由CPython做解释器（虚拟机）的多线程Python程序只能利用多核处理器的一个核来运行。</p>
<p>例如，我们将一个8线程的JAVA程序运行在4核的处理器上，那么每个核会运行1个线程，然后利用时间片轮转，轮流运行每一个线程。</p>
<p>但是，我们将一个8线程的Python程序（由CPython作解释器）运行在一个4核处理器上，那么总共只会有1个核在工作，8个线程都要在这一个核上面时间片轮转。</p>
<h2 id="python-的线程安全"><a class="markdownIt-Anchor" href="#python-的线程安全"></a> Python 的线程安全</h2>
<p>有了 GIL，并不意味着我们 Python 编程者就不用去考虑线程安全了。即使我们知道，GIL 仅允许一个 Python<br />
线程执行，但前面我也讲到了，Python 还有 <strong>check interval</strong> 这样的抢占机制。</p>
<p>所以有了 GIL 并不意味着你的Python程序就可以高枕无忧了，我们仍然需要去注意线程安全。</p>
<p>GIL 的设计，主要是为了方便 CPython 解释器层面的编写者，而不是 Python 应用层面的程序员。作为 Python<br />
的使用者，我们还是需要 lock 等锁，来确保线程安全。</p>
<h2 id="python多线程"><a class="markdownIt-Anchor" href="#python多线程"></a> Python多线程</h2>
<p>CPython 会做一些小把戏，轮流执行 Python 线程。这样一来，用户看到的就是“伪并行”——Python<br />
线程在交错执行，来模拟真正并行的线程。</p>
<p><strong>所以说Python的多线程是伪多线程</strong></p>
<h3 id="gil-到底锁的是什么"><a class="markdownIt-Anchor" href="#gil-到底锁的是什么"></a> GIL 到底锁的是什么？</h3>
<p>GIL 的全称是 Global Interpreter Lock, 全局解释器锁。它锁的是解释器而不是你的 Python 代码。它防止多线程同时执行<br />
Python 的字节码(bytecodes)，防止多线程同时访问 Python 的对象。</p>
<p>在 Python 官方文档Releasing the GIL from extension code中，有这样一段话：</p>
<p>Here is how these functions work: <strong>the global interpreter lock is used to protect the pointer to<br />
the current thread<br />
state.</strong> When releasing the lock and saving the thread state, the current thread state pointer must<br />
be retrieved before<br />
the lock is released (since another thread could immediately acquire the lock and store its own<br />
thread state in the<br />
global variable). Conversely, when acquiring the lock and restoring the thread state, the lock must<br />
be acquired before<br />
storing the thread state pointer.</p>
<p>其中加黑的这一句话是说：GIL 锁用来保护指向当前进程<strong>状态的指针</strong>。</p>
<p>再看文档Thread State and the Global Interpreter Lock中提到的这样一句话：</p>
<p>Without the lock, even the simplest operations could cause problems in a multi-threaded program: for<br />
example, when two<br />
threads simultaneously increment the <strong>reference count</strong> of the same object, the reference count<br />
could end up being<br />
incremented only once instead of twice.</p>
<p>当两个线程同时提高同一个对象的引用计数时，（如果没有 GIL 锁）那么引用计数只会被提高了 1 次而不是 2 次。</p>
<p>大家注意这两段应用中的<code>指针</code>和<code>引用计数</code>。其中指针是 C 语言的概念，Python 没有指针；引用计数是 Python<br />
底层的概念。你平时写的 Python 代码，引用计数是在你调用变量的时候自动增加的，不需要你去手动加 1.</p>
<p>所以 GIL 锁住的东西，都是不需要你的代码直接交互的东西。</p>
<p>Python 的解释器通过切换线程来模拟多线程并发的情况，如上面举的例子，虽然同一个时间只有一个线程在活动，但仍然可以导致并发冲突。</p>
<h2 id="gil-对-python-多线程开发的影响"><a class="markdownIt-Anchor" href="#gil-对-python-多线程开发的影响"></a> GIL 对 Python 多线程开发的影响</h2>
<p>在提到开发性能瓶颈的时候，我们经常把对资源的限制分为两类，</p>
<ul>
<li>一类是计算密集型（CPU-bound）</li>
<li>一类是 I/O 密集型（I/O-bound）。</li>
</ul>
<p>计算密集型的程序是指的是把 CPU 资源耗尽的程序，也就是说想要提高性能速度，就需要提供更多更强的<br />
CPU，比如矩阵运算，图片处理这类程序。</p>
<p>I/O 密集型的程序只的是那些花费大量时间在等待 I/O 运行结束的程序，比如从用户指定的文件中读取数据，从数据库或者从网络中读取数据，I/O<br />
密集型的程序对 CPU 的资源需求不是很高。</p>
<h3 id="如何加速"><a class="markdownIt-Anchor" href="#如何加速"></a> 如何加速？</h3>
<p>一般来说 IO 密集型用多线程、协程来加速，CPU 密集型用多进程来加速。</p>
<p>结合来看IO密集型使用协程 + 多进程 不失为“最佳”方案：</p>
<p>aiomultiprocess：<span class="exturl" data-url="aHR0cHM6Ly9weXBpLm9yZy9wcm9qZWN0L2Fpb211bHRpcHJvY2Vzcy8=">https://pypi.org/project/aiomultiprocess/<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>如何绕过GIL？</strong></p>
<p>你并不需要过多考虑 GIL。因为如果多线程计算成为性能瓶颈，往往已经有 Python 库来解决这个问题了。</p>
<p>绕过 GIL 的大致思路有这么两种：</p>
<ul>
<li>绕过 CPython，使用 JPython（Java 实现的 Python 解释器）等别的实现；</li>
<li>把关键性能代码，放到别的语言（一般是 C++）中实现。</li>
</ul>
<h2 id="referer"><a class="markdownIt-Anchor" href="#referer"></a> referer</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvYTM3T3hVamdIZHBzMVpzUEI3cEtjUQ==">也许你对 Python GIL 锁的理解是 错的。—— kingname<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>python</category>
        <category>cython</category>
        <category>cpython</category>
        <category>GIL</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化的VimIDE-spacevim</title>
    <url>/28089.html</url>
    <content><![CDATA[<p>SpaceVim 是一个社区驱动的模块化的 Vim IDE，以模块的方式组织管理插件以及相关配置，<br />
为不同的语言开发量身定制了相关的开发模块，该模块提供代码自动补全， 语法检查、格式化、调试、REPL<br />
等特性。用户仅需载入相关语言的模块即可得到一个开箱即用的 Vim IDE。</p>
<p>相关链接如下：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zcGFjZXZpbS5vcmcv">官方网站<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zcGFjZXZpbS5vcmcvY24v">中文官方网站<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NwYWNlVmltL1NwYWNlVmlt">github<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vc3BhY2V2aW0vU3BhY2VWaW0=">gitee<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zcGFjZXZpbS5vcmcvY24vcXVpY2stc3RhcnQtZ3VpZGUv">入门指南<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2>
<blockquote>
<p><strong>前置条件</strong>: 需要安装完成<code>vim</code>或<code>neovim</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 前置安装</span><br><span class="line">## centos</span><br><span class="line">python3 -m pip install -U pip &amp;&amp; python3 -m pip install pynvim &amp;&amp; pip3 install neovim &amp;&amp; yum -y install neovim</span><br><span class="line">## Mac</span><br><span class="line">python3 -m pip install -U pip &amp;&amp; python3 -m pip install pynvim &amp;&amp; pip3 install neovim &amp;&amp; brew install neovim</span><br></pre></td></tr></table></figure>
<h3 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows</h3>
<p>Windows 下最快捷的安装方法是下载安装脚本 <span class="exturl" data-url="aHR0cHM6Ly9zcGFjZXZpbS5vcmcvY24vaW5zdGFsbC5jbWQ=">install.cmd<i class="fa fa-external-link-alt"></i></span> 并运行。</p>
<h3 id="linux-或-macos"><a class="markdownIt-Anchor" href="#linux-或-macos"></a> Linux 或 macOS</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置</span></span><br><span class="line"><span class="built_in">cat</span> &gt;&gt; /etc/profile &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">export EDITOR=nvim</span></span><br><span class="line"><span class="string">alias vim=&quot;nvim&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建配置文件夹</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.config</span><br><span class="line"><span class="comment"># 创建文件夹软连接</span></span><br><span class="line"><span class="built_in">ln</span> -s <span class="variable">$HOME</span>/.vim <span class="variable">$HOME</span>/.config/nvim</span><br><span class="line"><span class="comment"># 创建配置文件软连接</span></span><br><span class="line"><span class="built_in">ln</span> -s <span class="variable">$HOME</span>/.vimrc <span class="variable">$HOME</span>/.config/nvim/init.vim</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">curl -sLf https://spacevim.org/cn/install.sh | bash</span><br><span class="line"><span class="comment"># 如果需要获取安装脚本的帮助信息，可以执行如下命令，包括定制安装、更新和卸载等。</span></span><br><span class="line">curl -sLf https://spacevim.org/cn/install.sh | bash -s -- -h</span><br></pre></td></tr></table></figure>
<p>安装结束后，初次打开 vim 或者 neovim 时，SpaceVim 会自动下载并安装插件。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hcm1vdGVkdS9tYXJtb3RWaW0=">SpaceVim离线安装 (github.com)<i class="fa fa-external-link-alt"></i></span></p>
<p>环境搭建请参考：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zcGFjZXZpbS5vcmcvY24vcXVpY2stc3RhcnQtZ3VpZGUvIyVFNSU5QyVBOCVFNyVCQSVCRiVFNiU5NSU5OSVFNyVBOCU4Qg==">在线教程<i class="fa fa-external-link-alt"></i></span></p>
<p>更多sao操作情参考官方文档，瑞思拜～</p>
]]></content>
      <categories>
        <category>neovim</category>
        <category>vim</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>neovim</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器指纹在反爬虫领域的应用</title>
    <url>/38968.html</url>
    <content><![CDATA[<p>在上文中较为详细的介绍了指纹、设备指纹的常规获取与获取指纹环境监测，本节将详细的了解一下</p>
<p>浏览器指纹在反爬虫领域的应用，Android分析暂且搁置（其实是我也并不精通，pc端比较熟悉一点）</p>
<span id="more"></span>
<p>本节详细的聊聊Web指纹，在学习前必须先给自己的几个问题？</p>
<h2 id="什么是web指纹"><a class="markdownIt-Anchor" href="#什么是web指纹"></a> 什么是web指纹？</h2>
<p>见上文</p>
<h3 id="web指纹有何作用"><a class="markdownIt-Anchor" href="#web指纹有何作用"></a> Web指纹有何作用？</h3>
<p>Web指纹的作用有很多，例如区分环境、区分机器人与真实用户，保障正常运行，只要是web浏览器的特征均可以作为web指纹</p>
<h2 id="web指纹有哪些"><a class="markdownIt-Anchor" href="#web指纹有哪些"></a> Web指纹有哪些？</h2>
<p>浏览器常见指纹如下</p>
<p>全局：window、document</p>
<p>环境：navigator、screen、history</p>
<p>请求：XMLHttpRequest、fetch、worker、<code>.$ajax</code>(jquery)、SSL/TSL</p>
<p>Dom：canvas、dom、WebGL</p>
<p>存储：storage IndexedDB cookie</p>
<p>其他：Cache、WebGL、AndioContext、WebRTC</p>
<p>NodeJS</p>
<p>全局变量：global、__filename、__dirname</p>
<p>导包：require「危险⚠️」</p>
<p>可被重写的全局</p>
<p>绝大多数的Web API</p>
<p>全部的DOM节点</p>
<ul>
<li>Web API：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvYXBp">https://developer.mozilla.org/zh-CN/docs/Web/api<i class="fa fa-external-link-alt"></i></span></li>
<li>NodeJs API：中文：<span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkv">http://nodejs.cn/api/<i class="fa fa-external-link-alt"></i></span></li>
<li>官方： <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2FwaS8=">https://nodejs.org/api/<i class="fa fa-external-link-alt"></i></span></li>
<li>异同：<span class="exturl" data-url="aHR0cDovL25vZGVqcy5jbi9hcGkvcGF0aC5odG1s">http://nodejs.cn/api/path.html<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>无论做何操作均可视为区分正常用户与机器人，如果被检测出来，最简单的自然是拿不到数据，bt一点的蜜罐、甚至强制删除电脑内文件。</p>
]]></content>
      <categories>
        <category>spider</category>
        <category>crawler</category>
      </categories>
      <tags>
        <tag>data-acquisition</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读技巧</title>
    <url>/5922.html</url>
    <content><![CDATA[<blockquote>
<p>本文仅提供思路，还需自身有足够的基础。</p>
</blockquote>
<p>很多时候通常需要阅读很多源码，当然阅读源码也是有很多技巧的。</p>
<p>通常，根据他人总结的文档，先看整体（目录和类图）再看局部（类和函数）。</p>
<p>对于 Java 项目，就是先查看包的层级关系，然后分析包中类（接口）之间的关系，包括继承、实现、委托、方法调用等，最后再查看某个类具体的属性和方法的具体实现。</p>
<p>对于Python 项目，也是这样，先整体后局部，后核心。遵循先广度在深度，先核心在周围</p>
<h2 id="源码阅读基本步骤"><a class="markdownIt-Anchor" href="#源码阅读基本步骤"></a> 源码阅读基本步骤</h2>
<p>首先是通读官方文档，对框架或项目有个大致的了解</p>
<p>学习一些基础库及联系紧密的方法</p>
<p>找到一个趁手的IDEA，深层沉浸式阅读</p>
<p>尝试二次开发、修源码进行深入理解</p>
<h2 id="源码阅读小技巧"><a class="markdownIt-Anchor" href="#源码阅读小技巧"></a> 源码阅读小技巧</h2>
<h3 id="搜索"><a class="markdownIt-Anchor" href="#搜索"></a> 搜索</h3>
<h4 id="根据文件名搜索文件类等搜索"><a class="markdownIt-Anchor" href="#根据文件名搜索文件类等搜索"></a> 根据文件名搜索文件/类等搜索</h4>
<p>快捷键：shift + shift（连按两次）</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qk0490gjj20u00v8myv.jpg" alt="image-20220530172201840" /></p>
<h4 id="字段搜索"><a class="markdownIt-Anchor" href="#字段搜索"></a> <strong>字段搜索</strong></h4>
<p>局部搜索快捷键：Win: Ctrl + F Mac: Command + F</p>
<p>全局搜索快捷键：Win: Ctrl + shift + F Mac: Command + Shift + F</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qk2z3utsj20xm0t0djk.jpg" alt="image-20220530172449113" /></p>
<h3 id="代码跳转"><a class="markdownIt-Anchor" href="#代码跳转"></a> 代码跳转</h3>
<p><strong>对应文件跳转</strong></p>
<p>Mac快捷键：Command + e Win快捷键：Ctrl + e</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qkvg0g5kj20so0ig400.jpg" alt="image-20220530175210390" /></p>
<p><strong>跳转到上/下次光标的位置</strong></p>
<p>查看源码时，经常需要在两个类中来回跳转，这个功能就变得相当实用！</p>
<p>查看上次光标位置快捷键：Win: Alt + ← Mac: Option + Command + ←</p>
<p>查看下次光标位置快捷键：Win: Alt + → Mac: Option + Command + →</p>
<h4 id="调用"><a class="markdownIt-Anchor" href="#调用"></a> 调用</h4>
<p><strong>查看方法调用树</strong></p>
<p>可以查看指定方法的所有调用方和被调方。</p>
<p>快捷键：Win: Ctrl + Alt + H MAC： Control + Option + H</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qkyity7aj20qq0cydgo.jpg" alt="image-20220530175508252" /></p>
<p>调用与被调用</p>
<h4 id="方法函数结构"><a class="markdownIt-Anchor" href="#方法函数结构"></a> 方法函数结构</h4>
<p>快捷键：快捷键：Win: Alt + 7 Mac: Command + 7</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2qkzo9kl2j212q0gy0tl.jpg" alt="image-20220530175614503" /></p>
<h4 id="类关系"><a class="markdownIt-Anchor" href="#类关系"></a> 类关系</h4>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4ciu295kqj20e6030t8p.jpg" alt="image-20220719204419565" /></p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h4civ1gl90j21280h0dh9.jpg" alt="image-20220719204515904" /></p>
<h2 id="referer"><a class="markdownIt-Anchor" href="#referer"></a> referer</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDEyMTY4MTUwNDkzOTU0MDc5I2hlYWRpbmctMw==">https://juejin.cn/post/7012168150493954079#heading-3<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
  </entry>
  <entry>
    <title>漫游密码学</title>
    <url>/15928.html</url>
    <content><![CDATA[<p>作为一名优秀的新时代农民工，加密解密、编码算法自然逃不了。为了更安全、更隐蔽<br />
数字签名，信息加密在开发过程中一定少不了，例如用户密码、关键消息等等，所以密码学至关重要。</p>
<p>作为爬虫工程师，逆向工程师见到目标的加密后的结果，而又无法有效的获取与定位到关键函数。那岂不是抓瞎，那么如果对于常见的加密、编码算法算法有足够的了解，那么是可以便捷很多，例如</p>
<ul>
<li>根据特征结果，直接Hook对应函数。通常有奇效</li>
<li>根据特征结果，与所知的参数进行尝试碰撞。也可大幅度减少分析时间</li>
</ul>
<p>等等，书到用时方恨少，知识与见识自然也是。</p>
<span id="more"></span>
<h2 id="0x01-概述"><a class="markdownIt-Anchor" href="#0x01-概述"></a> 0x01 概述</h2>
<p>​ 结合爬虫来看，对于密码学，加密与解密掌握自然的越精通越好，同时这又是一陡峭的过程。相较于与密码学相关知识结合爬虫来看并不一定要成为“密码学专家”，但确实拥有足够的<br />
<strong>了解</strong><br />
将对于我们在逆向、防护方面有不错的帮助。就爬虫来说其中包含但不限于进制、摘要、非对称加密、对称加密等。</p>
<h2 id="0x02-加密与解密"><a class="markdownIt-Anchor" href="#0x02-加密与解密"></a> 0x02 加密与解密</h2>
<p>加密，是以某种特殊的算法改变原有的信息数据</p>
<p>解密，加密的逆过程，常为加密等逆处理。</p>
<p>具体实现有编码算法，摘要算法、对称加密、非对称加密等。当然这之间可以一次或多次、一个或多个过程使用</p>
<h2 id="0x03-编码算法"><a class="markdownIt-Anchor" href="#0x03-编码算法"></a> 0x03 编码算法</h2>
<p>编码是信息从一种形式或格式转换为另一种形式的过程。根据映射关系实现转换。</p>
<p>常见的算法有Base16、Base32、Base64</p>
<h2 id="0x04-摘要算法"><a class="markdownIt-Anchor" href="#0x04-摘要算法"></a> 0x04 摘要算法</h2>
<p>​ 消息摘要算法的主要特征是<strong>加密过程不需要密钥</strong>，并且经过加密的数据<strong>理论</strong><br />
上无法被解密，目前可以被解密逆向的只有<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9DUkMzMi83NDYwODU4">CRC32<i class="fa fa-external-link-alt"></i></span><br />
算法，只有输入相同的明文数据经过相同的消息摘要算法才能得到相同的密文。消息摘要算法不存在密钥的管理与分发问题，较为适合于分布式网络上使用。由于其加密计算的工作量相当可观，这种算法通常只用于数据量有限的情况下的加密，</p>
<p>​ 消息摘要算法主要应用在“数字签名”领域，作为对明文的摘要算法。著名的摘要算法有MD5算法和SHA-1算法及其大量的变体。</p>
<blockquote>
<p>MD5:</p>
<blockquote>
<p>默认key:01234567890abdcdef</p>
</blockquote>
<p>变体：md2、md4、md5、hmac(带密码的md5)</p>
<p>种类：16位 32位 40位</p>
<p>SHA-1:</p>
<p>sha1 40位</p>
<p>sha256 64位</p>
<p>sha512 128位</p>
</blockquote>
<h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3>
<p>消息摘要是把任意长度的输入揉和而产生长度固定的<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQkMlQUElRTklOUElOEYlRTYlOUMlQkE=">伪随机<i class="fa fa-external-link-alt"></i></span><br />
输入的算法。消息摘要的主要特点有：</p>
<ol>
<li></li>
</ol>
<p>无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。例如应用MD5算法摘要的消息有128个比特位，用SHA-1算法摘要的消息最终有160比特位的输出，SHA-1的变体可以产生192比特位和256比特位的消息摘要。一般认为，摘要的最终输出越长，该摘要算法就越安全。</p>
<ol start="2">
<li></li>
</ol>
<p>消息摘要看起来是“随机的”。这些比特看上去是胡乱的杂凑在一起的。可以用大量的输入来检验其输出是否相同，一般，不同的输入会有不同的输出，而且输出的摘要消息可以通过<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklOUElOEYlRTYlOUMlQkElRTYlODAlQTc=">随机性<i class="fa fa-external-link-alt"></i></span><br />
检验。但是，一个摘要并不是真正随机的，因为用相同的算法对相同的消息求两次摘要，其结果必然相同；而若是真正随机的，则无论如何都是无法重现的。因此消息摘要是“伪随机的”。</p>
<ol start="3">
<li></li>
</ol>
<p>一般地，只要输入的消息不同，对其进行摘要以后产生的摘要消息也必不相同；但相同的输入必会产生相同的输出。这正是好的消息摘要算法所具有的性质：输入改变了，输出也就改变了；两条相似的消息的摘要确不相近，甚至会大相径庭。</p>
<ol start="4">
<li></li>
</ol>
<p>消息摘要函数是无<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklOTklQjclRTklOTclQTg=">陷门<i class="fa fa-external-link-alt"></i></span><br />
的单向函数，即只能进行正向的信息摘要，而无法从摘要中恢复出任何的消息，甚至根本就找不到任何与原信息相关的信息。当然，可以采用强力攻击的方法，即尝试每一个可能的信息，计算其摘要，看看是否与已有的摘要相同，如果这样做，最终肯定会恢复出摘要的消息。但实际上，要得到的信息可能是无穷个消息之一，所以这种强力攻击几乎是无效的。</p>
<ol start="5">
<li>好的摘要算法，没有人能从中找到“碰撞”，虽然“碰撞”是肯定存在的。即对于给定的一个摘要，不可能找到一条信息使其摘要正好是给定的。或者说，无法找到两条消息，使它们的摘要相同。</li>
</ol>
<h2 id="0x05加密"><a class="markdownIt-Anchor" href="#0x05加密"></a> 0x05加密</h2>
<p>​ 加密一般分为对称式加密以及非对称式加密两类。采用的比较广泛的是对称式加密，主要特点是加密和解密使用同一个密钥。</p>
<p>​<br />
而非对称式加密在进行加密时则使用了两个密钥，加密和解密过程中分别使用不同的密钥，这两个密钥分别为“公钥”以及“私钥”，想要能正常完成加密解密过程，就必需配对使用，而在使用过程中，“公钥”是公开的，“私钥”则必须由发送人保密，同时只能由持有人所有。</p>
<h3 id="对称加密"><a class="markdownIt-Anchor" href="#对称加密"></a> 对称加密</h3>
<p>​ 需要对加密和解密使用相同密钥的加密算法。由于其速度快，对称性加密通常在消息发送方需要加密大量数据时使用。对称性加密也称为密钥加密。</p>
<p>​ 所谓对称，就是采用这种加密方法的双方使用方式用同样的密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密。</p>
<p>​ 因此加密的安全性不仅取决于<strong>加密算法本身，密钥管理的安全性更是重要</strong><br />
。因为加密和解密都使用同一个密钥，如何把密钥安全地传递到解密者手上就成了必须要解决的问题。对称加密算法中常用的算法有：<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9ERVM=">DES<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8zREVT">3DES<i class="fa fa-external-link-alt"></i></span><br />
、TDEA、<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9CbG93ZmlzaA==">Blowfish<i class="fa fa-external-link-alt"></i></span><br />
、RC2、RC4、<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9SQzU=">RC5<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9JREVB">IDEA<i class="fa fa-external-link-alt"></i></span><br />
、SKIPJACK等。</p>
<p>采用单钥密码的加密方法，同一个密钥可以同时用来加密和解密，这种加密方法称为对称加密，也称为单密钥加密。常用的单向加密算法：</p>
<p>1、DES（Data Encryption Standard）：<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTUlQjAlRTYlOEQlQUUlRTUlOEElQTAlRTUlQUYlODYlRTYlQTAlODclRTUlODclODYvMTU3NzE2OQ==">数据加密标准<i class="fa fa-external-link-alt"></i></span><br />
，速度较快，适用于加密大量数据的场合；</p>
<p>2、3DES（Triple DES）：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高；</p>
<p>3、AES（Advanced Encryption<br />
Standard）：<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklQUIlOTglRTclQkElQTclRTUlOEElQTAlRTUlQUYlODYlRTYlQTAlODclRTUlODclODYvNDY4Nzc0">高级加密标准<i class="fa fa-external-link-alt"></i></span><br />
，是下一代的加密算法标准，速度快，安全级别高，支持128、192、256、512位密钥的加密；</p>
<p>4、Blowfish</p>
<p><strong>算法特征</strong></p>
<p>1、加密方和解密方使用同一个密钥；</p>
<p>2、加密解密的速度比较快，适合数据比较长时的使用；</p>
<p>3、密钥传输的过程不安全，且容易被破解，密钥管理也比较麻烦；</p>
<h3 id="非对称加密"><a class="markdownIt-Anchor" href="#非对称加密"></a> 非对称加密</h3>
<p>非对称加密算法需要两个<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQUYlODYlRTklOTIlQTUvMTAxMTQ0">密钥<i class="fa fa-external-link-alt"></i></span><br />
来进行加密和解密，这两个密钥是<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlODUlQUMlRTUlQkMlODAlRTUlQUYlODYlRTklOTIlQTUvNzQ1MzU3MA==">公开密钥<i class="fa fa-external-link-alt"></i></span>（public<br />
key，简称公钥）和私有密钥（private key，简称私钥）。</p>
<ul>
<li>**RSA：**RSA 是一种目前应用非常广泛、历史也比较悠久的非对称秘钥加密技术，在1977年被麻省理工学院的罗纳德·李维斯特（Ron<br />
Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard<br />
Adleman）三位科学家提出，由于难于破解，RSA<br />
是目前应用最广泛的数字加密和签名技术，比如国内的支付宝就是通过RSA算法来进行签名验证。它的安全程度取决于秘钥的长度，目前主流可选秘钥长度为<br />
1024位、2048位、4096位等，理论上秘钥越长越难于破解，按照维基百科上的说法，小于等于256位的秘钥，在一台个人电脑上花几个小时就能被破解，512位的秘钥和768位的秘钥也分别在1999年和2009年被成功破解，虽然目前还没有公开资料证实有人能够成功破解1024位的秘钥，但显然距离这个节点也并不遥远，所以目前业界推荐使用<br />
2048 位或以上的秘钥，不过目前看 2048 位的秘钥已经足够安全了，支付宝的官方文档上推荐也是2048位，当然更长的秘钥更安全，但也意味着会产生更大的性能开销。</li>
<li>**DSA：**既 Digital Signature Algorithm，数字签名算法，他是由美国国家标准与技术研究所（NIST）与1991年提出。和<br />
RSA 不同的是 DSA<br />
仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。</li>
<li>**ECDSA：**Elliptic Curve Digital Signature Algorithm，椭圆曲线签名算法，是ECC（Elliptic curve<br />
cryptography，椭圆曲线密码学）和 DSA<br />
的结合，椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的，相比于RSA算法，ECC<br />
可以使用更小的秘钥，更高的效率，提供更高的安全保障，据称256位的ECC秘钥的安全性等同于3072位的RSA秘钥，和普通DSA相比，ECDSA在计算秘钥的过程中，部分因子使用了椭圆曲线算法。</li>
</ul>
<h3 id="加密小结"><a class="markdownIt-Anchor" href="#加密小结"></a> 加密小结</h3>
<p>对称加密只需要获取到公钥即可，进行解密</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklOUQlOUUlRTUlQUYlQjklRTclQTclQjAlRTUlOEElQTAlRTUlQUYlODYlRTclQUUlOTclRTYlQjMlOTU=">非对称加密算法<i class="fa fa-external-link-alt"></i></span><br />
需要两个<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQUYlODYlRTklOTIlQTU=">密钥<i class="fa fa-external-link-alt"></i></span>：<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlODUlQUMlRTUlQkMlODAlRTUlQUYlODYlRTklOTIlQTU=">公开密钥<i class="fa fa-external-link-alt"></i></span><br />
（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。</p>
<h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2>
<p>​ 简单来说加密与解密就阐述了密码学基本特征，非专业的了解。可大致了解编码、摘要、对称加密、非对称加密即可。后有兴趣可深入</p>
]]></content>
  </entry>
  <entry>
    <title>爬虫:有什么让人眼前一亮的调试习惯与技巧</title>
    <url>/10849.html</url>
    <content><![CDATA[<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqy39xz1a8j31hc0u077n.jpg" alt="" /></p>
<p>在爬虫调试的时候一个良好的调试习惯,正确的调试技巧。绝对能让您在抓包，定位及JS解密与JS逆向等各种方面事半功倍。</p>
<span id="more"></span>
<h2 id="优秀的调试习惯"><a class="markdownIt-Anchor" href="#优秀的调试习惯"></a> 优秀的调试习惯</h2>
<h3 id="无痕模式"><a class="markdownIt-Anchor" href="#无痕模式"></a> 无痕模式</h3>
<p>无痕浏览（<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklOUElOTAlRTclQTclODElRTYlQjUlOEYlRTglQTclODglRTYlQTglQTElRTUlQkMlOEY=">隐私浏览模式<i class="fa fa-external-link-alt"></i></span><br />
、隐身窗口、InPrevate），是指不留下上网浏览记录的互联网浏览方式。但是，用户下载的文件和建立的收藏夹或书签会保存下来。支持该模式的浏览器包括但不限于百度浏览器，Firefox火狐，搜狗浏览器，360安全浏览器，Avant<br />
browser ，世界之窗浏览器，Google Chrome，Internet Explorer 8及更新版本，Edge，Safari.</p>
<h4 id="主要特性"><a class="markdownIt-Anchor" href="#主要特性"></a> 主要特性</h4>
<p>不记录上网痕迹，保护您的个人隐私</p>
<p>不记录 Cookies</p>
<p>不记录 Internet <span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQjglQjQlRTYlOTclQjYlRTYlOTYlODclRTQlQkIlQjY=">临时文件<i class="fa fa-external-link-alt"></i></span></p>
<p>不记录网页表单数据（用户名、密码、搜索关键词等）</p>
<p>不记录撤销页面列表，即历史记录</p>
<p>等等</p>
<h4 id="特别提醒"><a class="markdownIt-Anchor" href="#特别提醒"></a> 特别提醒</h4>
<p><strong>通过无痕浏览不会影响其他用户、服务器或软件。但请谨防以下情况：</strong></p>
<ul>
<li>进行无痕浏览时，您下载的文件、新收藏的网址、新修改的浏览器配置将仍然被保留。</li>
<li>因特网服务提供商或雇主还是可以追溯用户访问过的页面。</li>
<li>如果想要清除电脑中的网页浏览痕迹，可以使用安全软件（如360安全卫士）的清理痕迹按钮或手动删除历史记录和缓存文件。</li>
<li>因为是无痕浏览，同样浏览器原先保存的密码和账号同样无法使用，这也会给网络浏览带来不便之处。</li>
<li>网站收集或分享您的相关信息</li>
<li>以提供免费表情图片为名跟踪按键记录的恶意软件</li>
<li>在您浏览过程中的监视者</li>
<li>浏览器插件信息的窃取</li>
</ul>
<h4 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h4>
<ul>
<li>IE 和 Chrome 都会在无痕浏览下默认关闭扩展功能，而 FireFox 不一样，在隐私模式下仍然可以使用插件，这无疑又给隐私泄露提供了另一个途径。</li>
<li>所以在关闭Firefox的隐私浏览模式后，您需要检查浏览器插件是否记录了浏览信息，或在隐私模式前暂时禁用不需要开启的插件，否则您的信息可能会被公开</li>
<li>部分插件（如Adobe Flash Player）拥有一套自己的Cookie系统，在隐私模式下 Cookies 仍然会正常工作，甚至在隐私模式下获取的<br />
Cookies<br />
一样是公开可读的。在退出无痕浏览后您需要手动清除Cookis才能做到完全无痕。</li>
</ul>
<h4 id="系统隔离技术"><a class="markdownIt-Anchor" href="#系统隔离技术"></a> 系统隔离技术</h4>
<p>通过一些轻量级的<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglOTklOUElRTYlOEIlOUYlRTclQjMlQkIlRTclQkIlOUY=">虚拟系统<i class="fa fa-external-link-alt"></i></span><br />
实现，具体原理：轻量级的虚拟系统可以实现与<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQjglQkIlRTYlOUMlQkElRTclQjMlQkIlRTclQkIlOUY=">主机系统<i class="fa fa-external-link-alt"></i></span><br />
相互隔离目标，隔离的实现是通过<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklOTUlOUMlRTUlODMlOEY=">镜像<i class="fa fa-external-link-alt"></i></span><br />
主机系统环境生成独立的操作系统<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlQTElOEMlRTklOUQlQTIlRTclOEUlQUYlRTUlQTIlODM=">桌面环境<i class="fa fa-external-link-alt"></i></span><br />
，用户可以在<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglOTklOUElRTYlOEIlOUYlRTclOEUlQUYlRTUlQTIlODM=">虚拟环境<i class="fa fa-external-link-alt"></i></span>下安装和使用Internet<br />
Explorer，遨游，<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9RUSVFNiVCNSU4RiVFOCVBNyU4OCVFNSU5OSVBOA==">QQ浏览器<i class="fa fa-external-link-alt"></i></span><br />
，Firefox等等<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclQUMlQUMlRTQlQjglODklRTYlOTYlQjklRTYlQjUlOEYlRTglQTclODglRTUlOTklQTg=">第三方浏览器<i class="fa fa-external-link-alt"></i></span><br />
，轻量级虚拟系统具有启动资源占用率低，可移动便携方便。这类产品有：VMware<br />
Workstation ，Prayaya v3虚拟系统，Ceedo，Macpac等等。</p>
<h4 id="沙盒技术"><a class="markdownIt-Anchor" href="#沙盒技术"></a> 沙盒技术</h4>
<p>所谓<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlQjIlOTklRTclOUIlOTIlRTYlOEElODAlRTYlOUMlQUY=">沙盒技术<i class="fa fa-external-link-alt"></i></span><br />
，具体见百科（<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9zYW5kYm94">sandbox<i class="fa fa-external-link-alt"></i></span>)<br />
，沙盒技术可以重定向<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQjglQkIlRTYlOUMlQkElRTclQjMlQkIlRTclQkIlOUY=">主机系统<i class="fa fa-external-link-alt"></i></span><br />
环境操作到其他的存储空间，以及重定向变量，同时沙盒退出后会自动消失原先的<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglOTklOUElRTYlOEIlOUYlRTclOEUlQUYlRTUlQTIlODM=">虚拟环境<i class="fa fa-external-link-alt"></i></span><br />
连接由此达到安装到沙盒中的应用程序不在主机系统中保留痕迹的目的。这类产品有：360安全浏览器，Google<br />
浏览器，火狐浏览器，遨游浏览器等</p>
<h4 id="为什么建议使用无痕模式进行调试"><a class="markdownIt-Anchor" href="#为什么建议使用无痕模式进行调试"></a> 为什么建议使用无痕模式进行调试</h4>
<p>当我们使用浏览器访问的时候，难免会由于cookies未及时手动清理，JS缓存等各种情况存在造成调试误差。让人难以快速正确的调试出问题。</p>
<h3 id="多浏览器"><a class="markdownIt-Anchor" href="#多浏览器"></a> 多浏览器</h3>
<p>多浏览器在这里指使用多个不同的浏览器进行调试，而非仅仅使用Chrome。其中的益处不言而喻，多浏览器能够快速的找到不同。</p>
<h3 id="优秀的调试方式与技巧"><a class="markdownIt-Anchor" href="#优秀的调试方式与技巧"></a> 优秀的调试方式与技巧</h3>
<blockquote>
<p>优秀的调试技巧，能够让你事半功倍，极大的降低调试难度。</p>
</blockquote>
<h4 id="巧用devtools搜索工具快速定位数据接口"><a class="markdownIt-Anchor" href="#巧用devtools搜索工具快速定位数据接口"></a> 巧用DevTools搜索工具快速定位数据接口</h4>
<p>当我们确定了需要抓取数据的目标网站，往往是这种情况。里面参杂了不少不包含数据的包，例如这样。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqvq9pigxwj312c0kqwfu.jpg" alt="" /></p>
<p>那么如果需要过去该页面数据，就必须找到对应的数据包，一个一个去找明显不现实。有什么方法可以快的定位到该数据包呢？我们可以这样操作。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxwjtd2efj30d60dv0t0.jpg" alt="" /></p>
<p>第一步：鼠标左键点击“放大镜”，呼出Search面板。</p>
<p>第二步：搜索对应的内容，支持大小写敏感，正则</p>
<p>第三步：根据结果，鼠标双击对应内容，即可直接跳至对应包位置</p>
<h4 id="巧用重放攻击快速定位加密位置"><a class="markdownIt-Anchor" href="#巧用重放攻击快速定位加密位置"></a> 巧用重放攻击快速定位加密位置</h4>
<p>当网站有相关的验证时，由于参数过多，无法快速的确定哪个参数才是真正决定是否为真实数据的时候，那么我们可以采用重放攻击的方式。进行测试从而快速定位加密位置。</p>
<h5 id="重放攻击"><a class="markdownIt-Anchor" href="#重放攻击"></a> 重放攻击</h5>
<p>重放攻击(Replay Attacks)<br />
又称重播攻击、回放攻击，是指攻击者发送一个目的<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQjglQkIlRTYlOUMlQkEvNDU1MTUx">主机<i class="fa fa-external-link-alt"></i></span><br />
已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。重放攻击可以由发起者，也可以由拦截并重发该数据的敌方进行。攻击者利用<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclQkQlOTElRTclQkIlOUMlRTclOUIlOTElRTUlOTAlQUMvMTA5MTQzMTg=">网络监听<i class="fa fa-external-link-alt"></i></span><br />
或者其他方式盗取认证凭据，之后再把它重新发给<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglQUUlQTQlRTglQUYlODElRTYlOUMlOEQlRTUlOEElQTElRTUlOTklQTg=">认证服务器<i class="fa fa-external-link-alt"></i></span><br />
。重放攻击在任何网络通过程中都可能发生，是计算机世界<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklQkIlOTElRTUlQUUlQTIvMTE4Mzk2">黑客<i class="fa fa-external-link-alt"></i></span><br />
常用的攻击方式之一。</p>
<h5 id="重放攻击的原理"><a class="markdownIt-Anchor" href="#重放攻击的原理"></a> 重放攻击的原理</h5>
<p>重放攻击的基本原理就是把以前<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclQUElODMlRTUlOTAlQUMvMTYyNDU5OQ==">窃听<i class="fa fa-external-link-alt"></i></span><br />
到的数据原封不动地重新发送给接收方。很多时候，网络上传输的数据是<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOEElQTAlRTUlQUYlODYvNzUyNzQ4">加密<i class="fa fa-external-link-alt"></i></span><br />
过的，此时窃听者无法得到数据的准确意义。但如果他知道这些数据的作用，就可以在不知道数据内容的情况下通过再次发送这些数据达到愚弄接收端的目的。例如，有的系统会将鉴别信息进行简单加密后进行传输，这时攻击者虽然无法窃听<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQUYlODYlRTclQTAlODEvNjU1NTM=">密码<i class="fa fa-external-link-alt"></i></span><br />
，但他们却可以首先截取加密后的口令然后将其重放，从而利用这种方式进行有效的攻击。再比如，假设网上存款系统中，一条消息表示用户支取了一笔存款，攻击者完全可以多次发送这条消息而偷窃存款</p>
<h5 id="重放攻击的类型"><a class="markdownIt-Anchor" href="#重放攻击的类型"></a> 重放攻击的类型</h5>
<p><strong>1.根据重放消息的接收方与消息的原定接收方的关系，重放攻击可分为3种：</strong></p>
<p>第一种是直接重放，即重放给原来的验证端，直接重放的发送方和接收方均不变。</p>
<p>第二种是反向重放，将原本发给接收方的消息反向重放给发送方。</p>
<p>第三种是第三方重放，将消息重放给域内的其他验证端。</p>
<p><strong>2.基于重放法发生在什么回合，可以将重放攻击分为两类：</strong></p>
<p>(1)在当前回合外攻击中，重放的消息来自协议当前回合之外，因此至少涉及协议的两个回合运行，可以并发也可以顺序地实现。</p>
<p>①交错攻击需要两回合或多回合同时执行<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOEQlOEYlRTglQUUlQUUvMTMwMjAyNjk=">协议<i class="fa fa-external-link-alt"></i></span><br />
，著名的例子是Lowe对NSPK协议的攻击。 [5]</p>
<p>②经典重放也涉及当前回合外执行协议，但不要求同时执行协议。攻击者存储在前面的回合中所传送的消息，并抓住机会重放它们，对协议的当前回合进行攻击。Denning和Sacco对NSSK协议的攻击，就是经典重放的一个著名例子。</p>
<p>(2)在当前回合内攻击中，重放的消息来自协议当前回合。</p>
<p><strong>3.考查攻击者对消息重定向，这种分类法称为目的地分类法。分类如下。</strong></p>
<p>(1)偏转重放攻击：重放消息重新定向，发送给不同于原接收者的第三方。这种情形可进一步分为如下子类：</p>
<p>①重放消息重定向，发送给原发送者，称为反射重放攻击。</p>
<p>②重放消息重定向，发送给第三方，即不同于原发送者和原接收方的第三方。</p>
<p>(2)攻击者通过延时的方法(可能涉及不同的协议回合)，将消息传送给目的地，称为直接重放攻击。</p>
<blockquote></blockquote>
<p>以上信息来自<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklODclOEQlRTYlOTQlQkUlRTYlOTQlQkIlRTUlODclQkIvMjIyOTI0MD9mcj1hbGFkZGlu">百度百科<i class="fa fa-external-link-alt"></i></span></p>
<h5 id="简单操作流程如下"><a class="markdownIt-Anchor" href="#简单操作流程如下"></a> 简单操作流程如下</h5>
<p>首先先确定数据包，获取该数据包中的URL。使用代码或脚本间隔一定时间发送网络请求。若根据时间到推移，手动对于请求参数的修改。进行多次验证。基本结构图如下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqvr9k38vtj30k90gmt8w.jpg" alt="" /></p>
<p><strong>多次</strong>请求验证，确定加密处。</p>
<h4 id="妙用中间人攻击进行抓包"><a class="markdownIt-Anchor" href="#妙用中间人攻击进行抓包"></a> 妙用中间人攻击进行抓包</h4>
<p>在很多情况下一个DevTools解决所有，但也有很少部分针对此进行了限制。</p>
<h4 id="中间人攻击"><a class="markdownIt-Anchor" href="#中间人攻击"></a> 中间人攻击</h4>
<p>中间人攻击（Man-in-the-MiddleAttack，简称“<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9NSVRNJUU2JTk0JUJCJUU1JTg3JUJCLzE1NjM3Mzg1">MITM攻击<i class="fa fa-external-link-alt"></i></span><br />
”）是一种“间接”的入侵攻击，这种攻击模式是通过各种技术手段将受入侵者控制的一台计算机虚拟放置在网络连接中的两台通信计算机之间，这台计算机就称为“中间人”。</p>
<p>中间人原理图，如下所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqw5udebogj30v80ggq2w.jpg" alt="" /></p>
<p>使用中间人进行”代理“拦截和转发。从而实现抓包的目的.</p>
<h5 id="进阶"><a class="markdownIt-Anchor" href="#进阶"></a> 进阶</h5>
<p>抓包抓不到？</p>
<blockquote>
<p>多体现在Android抓包</p>
</blockquote>
<p>强制代理</p>
<p>VPN转发</p>
<h4 id="各种断点助力调试"><a class="markdownIt-Anchor" href="#各种断点助力调试"></a> 各种断点助力调试</h4>
<blockquote>
<p>程序断点的相关概念便不在此过多赘述，若想了解请自行搜搜</p>
</blockquote>
<p><strong>DOM断点</strong></p>
<p>DOM断点一般有三种方式，subtree modification、attribute modification、node removal。如下图所示，</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqw795aqmuj30n00oign0.jpg" alt="" />在这里使用下了一个node<br />
removal断点。那么当我们删除此节点的时候将触发断点。如下图所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqw7bttdw2j31cx0u00vm.jpg" alt="" /></p>
<p>JS断点</p>
<p>Js断点有两种，一种是Js运行断点，一种是Js调试断点。</p>
<p>Js运行断点：当网页执行Js的时便会立即进入调试模式。操作方式如下</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxflr7ihpj31gt0u0q54.jpg" alt="" /></p>
<p>首先打开开发者工具，</p>
<p>然后进入source选项卡</p>
<p>然后进入右栏中 Event Listener Breakpoints中</p>
<p>最后勾选Script</p>
<p>即可开启，当网站运行时。便会进入debugger模式</p>
<p>Js调试断点: 此断点需要开发者的去下</p>
<p>首先打开开发者工具，</p>
<p>然后进入source选项卡</p>
<p>找到对应位置，鼠标左键点击。</p>
<p>即可完成</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxfvabvc5j31wc0p2q5u.jpg" alt="" /></p>
<p>若网页运行到此处，便会触发断点。</p>
<h4 id="xhr断点"><a class="markdownIt-Anchor" href="#xhr断点"></a> XHR断点</h4>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a><br />
（XHR）是一种创建<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9BSkFY">AJAX<i class="fa fa-external-link-alt"></i></span><br />
请求的<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9KYXZhU2NyaXB0">JavaScript<i class="fa fa-external-link-alt"></i></span><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9BUEk=">API<i class="fa fa-external-link-alt"></i></span><br />
。它的方法提供了在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9Ccm93c2Vy">浏览器<i class="fa fa-external-link-alt"></i></span><br />
和<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9TZXJ2ZXI=">服务器<i class="fa fa-external-link-alt"></i></span>之间发送请求的能力。</p>
<p>当网站是Ajax请求当时候，XHR断点将是一个非常不错的调试技巧。</p>
<p>XHR断点也有两种，一种是发生任何XHR请求的时候都出发断点，另一种是特定条件的XHR断点。</p>
<p>操作如下</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxg88pojcj31110hqt90.jpg" alt="" /></p>
<p>打开DevTools，进入source选项卡。点开XHR/fetch Breakpoints。</p>
<p>鼠标左键点击旁边的“+”号，直接Enter即可完成。如下图所示：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxg8o1vr1j305c01bdfm.jpg" alt="" /></p>
<p>特定XHR断点：</p>
<p>鼠标左键点击旁边的“+”号，在输入栏中输入限定条件，如Id，输入完成后Enter</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxgedm9qxj3060018dfm.jpg" alt="" /></p>
<h4 id="hook"><a class="markdownIt-Anchor" href="#hook"></a> Hook</h4>
<p>Hook<br />
又叫作钩子技术，它就是在程序运行的过程中，对其中的某个方法进行重写，在原有的方法前后自定义的代码。相当于在系统没有调用该函数之前，钩子程序就先捕获该消息，可以先得到控制权，这时钩子函数便可以加工处理（改变）该函数的执行行为。执行函数后释放控制权限，继续运行原有逻辑。</p>
<p>示意图如下，</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxgrt9q3sj30kv0j3wej.jpg" alt="" /></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// Hook 逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">)()</span><br></pre></td></tr></table></figure>
<p>常实现的有 Devtools Hook，本地文件映射Hook，插件Tempermonkey Hook</p>
<p><strong>Devtools 直接注入:</strong></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxh7igr7sj307f03wmx0.jpg" alt="" /></p>
<p>Devtools 直接注入的优点：可以直接把Hook函数copy至console中，直接运行。简单便捷。</p>
<p>缺点：比较难修改已经注入的Hook。难以复用。</p>
<p><strong>文件映射Hook</strong></p>
<p>在本地书写Hook函数，后使用DevTools中source选项卡中的Overrides进行文件映射。当网页运行满足Hook条件时候，便会触发Hook函数。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxhf2qvgnj30he03xglj.jpg" alt="" /></p>
<p><strong>Tempermonkey Hook</strong></p>
<p><em>Tampermonkey</em> 是第一个可以用来让 Chrome 支持更多 UserScript 的 Chrome 扩展，它可以加入更多的 Chrome<br />
本身不支持的用户脚本功能。Tempermonkey下载与使用请自行搜索</p>
<p>优点：可定制化，通用化。有针对的进行开发。</p>
<p>缺点：需要下载，需要学习Tempermonkey 的使用</p>
<h4 id="js注入"><a class="markdownIt-Anchor" href="#js注入"></a> JS注入</h4>
<p>当我们访问网站时候，一般情况下会将Js缓存到本地，进行相关运行。那么说如果我将本地的保存，修改其中逻辑，并覆盖其服务器下发的Js。这就是注入攻击</p>
<p>其原理是保存服务器下发的Js文件形成类似于“缓存”的功能，修改并覆盖下发Js文件即可完成。</p>
<p>常见的实现方法有三种</p>
<ol>
<li>
<p>DevTools中source选项卡中的Overrides进行文件映射</p>
</li>
<li>
<p>Tempermonkey</p>
<blockquote>
<p>以上操作，请参考上文</p>
</blockquote>
</li>
<li>
<p>Charles或其他第三方工具</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxhxiph0mj305a0j5jrl.jpg" alt="" /></p>
</li>
</ol>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxhxz28n1j30cx0budfw.jpg" alt="" /></p>
<h4 id="点位插桩调试"><a class="markdownIt-Anchor" href="#点位插桩调试"></a> 点位插桩调试</h4>
<p>其核心原理为：监听核心变量</p>
<p>首先在对应位置鼠标右键呼出，选择add conditional break…</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxia1wn4vj306s04ht8o.jpg" alt="" /></p>
<p>输入监听值</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxi9firu2j30gy02pq2t.jpg" alt="" /></p>
<p>放入 Logpoint中。完成后运行js即可在对应级别内看到日志输出</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxigqz9fpj306o06vdfp.jpg" alt="" /></p>
<center>
  <font color=red size=5px style="font-family: cursive">希望以上方法与技巧对你有所帮助</font>
  <font color=red size=3px style="font-family: cursive">知道的越多，不知道的越多。</font>
</center>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqy30zuc6nj31c20mgn13.jpg" alt="" /></p>
]]></content>
      <categories>
        <category>spider</category>
        <category>crawler</category>
      </categories>
      <tags>
        <tag>data-acquisition</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫优化之道</title>
    <url>/42803.html</url>
    <content><![CDATA[<h2 id="网络爬虫"><a class="markdownIt-Anchor" href="#网络爬虫"></a> 网络爬虫</h2>
<h3 id="网络爬虫的定义"><a class="markdownIt-Anchor" href="#网络爬虫的定义"></a> 网络爬虫的定义</h3>
<p>爬虫又称为网络蜘蛛、网页追逐者。是一种按照一定的规则，自动地抓取万维网信息的程序或脚本</p>
<p>同时还有很多种说法,但我个人认为最通俗的理解就是，模拟用户访问的程序或脚本。</p>
<span id="more"></span>
<h3 id="网络爬虫实现的核心步骤"><a class="markdownIt-Anchor" href="#网络爬虫实现的核心步骤"></a> 网络爬虫实现的核心步骤</h3>
<p>无论多么复杂的爬虫都离不开以下核心的四步，当然极少数特例除外。</p>
<ul>
<li>
<p>确定数据URL</p>
</li>
<li>
<p>发送请求,获取响应</p>
</li>
<li>
<p>解析响应，获取数据</p>
</li>
<li>
<p>数据持久化</p>
</li>
</ul>
<h2 id="网络爬虫优化"><a class="markdownIt-Anchor" href="#网络爬虫优化"></a> 网络爬虫优化</h2>
<p>无论是何种方向，我们都希望以更少的代价获取更大的收益，相信优化这一个话题一直是大家所探讨的。</p>
<p>决定网络爬虫性能的指标有很多，在不考虑特殊情况及阀值情况下</p>
<p>网络请求更快，解析效率更快，数据持久化更快等，那么爬虫会更快，这个是必然的</p>
<p>那么网络爬虫该如何优化，且听我从以下几个方面进行分析。</p>
<ol>
<li>分布式爬虫：更多的worker</li>
<li>减少重复或无效的网络请求、减少或分割繁琐的请求流程</li>
<li>网络优化</li>
<li>解析优化</li>
<li>数据持久化</li>
</ol>
<h3 id="爬虫优化第一式-分布式爬虫"><a class="markdownIt-Anchor" href="#爬虫优化第一式-分布式爬虫"></a> 爬虫优化第一式-分布式爬虫</h3>
<p>在网络爬虫的世界中，我们爬虫工程师开发的爬虫一般都是聚焦爬虫，而一个网站的数据量假设是个常量。那么爬虫的任务量也是个定值。那么更多的爬虫，一定是比单机单任务爬虫更快的。</p>
<blockquote>
<p>一般来说我们接触网站的数据增长量，还没有达到那种成几何倍数增长的情况。在这里只为论述大多情况下。特殊情况下例外</p>
</blockquote>
<p>分布式爬虫概念，在此便不再过多赘述，感兴趣的朋友可以自行搜索。</p>
<p>实现分布式爬虫的核心理念就是任务共有化统一调度。在这里爬虫领域，我们可以简单的理解为URL或URN的管理。只要管理好了URL或URN，分布式爬虫相信你实现起来也并不困难。分布式爬虫基础架构图如下所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gquzrwsspdj30r50do0sr.jpg" alt="" /></p>
<p><strong>分布式爬虫优化之一，氪金：</strong></p>
<p>只要机器够多，配置够高，集群够强大。那么日入过亿so easy。</p>
<p><strong>分布式爬虫优化之二：部署优化</strong></p>
<p>在以上的基础上，对于资源利用并不能够达到一个很完美的情况。如果有上百台机器，一个一个去启动爬虫没开完，爬虫工程师们就累死在了半路上。</p>
<p><strong>部署优化之一:单机批量运行</strong></p>
<blockquote>
<p>在一台机器机器中是允许开启多个爬虫！！！</p>
</blockquote>
<p>使用shell脚本，进行批量运行。</p>
<p>使用subprocess，进行批量运行。</p>
<p><strong>部署优化之二：虚拟容器</strong></p>
<p>在以上的基础上，我还建议你使用 docker，Kubernetes进行多机器分布式爬虫的部署。只需要短短几个命令即可部署到服务器。</p>
<p>这样就可以实现快捷部署</p>
<h3 id="爬虫优化第二式爬取策略"><a class="markdownIt-Anchor" href="#爬虫优化第二式爬取策略"></a> 爬虫优化第二式：爬取策略</h3>
<p>减少重复或无效的网络请求、减少或分割繁琐的请求流程。</p>
<p>首先我们来看个较经典的页面结构图，大部分页面都是一种B*树 或者图的数据结构。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqv1hqdepcj31400u04qr.jpg" alt="" /></p>
<div style="text-align: center;">首页简称Index，列表页简称List， 详情页简称detail</div>
<p>网页结构的不同采用不同遍历方式也不同，采用先深度后广度将是最快的“路径”。</p>
<p>如果detail可以一直获取到下一页</p>
<p>直接从起始页到最后一页。时间复杂度为O(N),N为总页数</p>
<p>如果只能列表页才能获取详情页</p>
<p>翻页获取下一页，可从先遍历List页后遍历获取详情页。时间复杂度为O(MN), M为列表页数，N为详情页数</p>
<p>如果是图，建议转化为树形结构进行考虑</p>
<blockquote>
<p>小技巧：</p>
<p>如何制定抓取策略？</p>
<p>建议自底向上的方式，先考虑详情页是否可以直达，后考虑列表页从而间接获取详情页</p>
</blockquote>
<h4 id="进阶"><a class="markdownIt-Anchor" href="#进阶"></a> 进阶</h4>
<p>如果是分布式爬虫，那么我们可以使用生产者-消费者模型的概念。ListCrwaler获取详情url，存入URL-Pool中</p>
<p>如下图所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqv21zh059j30f70asglk.jpg" alt="" /></p>
<blockquote>
<p>存入到URL-pool中建议使用Set进行URL去重。当URL过大的时候我们可以剔除公共部分，仅保存Id。</p>
<p>若数据量极大，可使用<strong>BloomFilter算法</strong></p>
</blockquote>
<h3 id="爬虫优化第三式-请求优化"><a class="markdownIt-Anchor" href="#爬虫优化第三式-请求优化"></a> 爬虫优化第三式: 请求优化</h3>
<h4 id="异常处理之超时"><a class="markdownIt-Anchor" href="#异常处理之超时"></a> 异常处理之超时</h4>
<p>当连接超过某个阀值，可判定此次请求失败。个人偏爱timeout 为60s</p>
<h4 id="提高并发量"><a class="markdownIt-Anchor" href="#提高并发量"></a> 提高并发量</h4>
<p>合适的并发量可以将资源使用到极致，合适的并发量可以从按照实际情况调。</p>
<h3 id="爬虫优化第四式网络优化"><a class="markdownIt-Anchor" href="#爬虫优化第四式网络优化"></a> 爬虫优化第四式：网络优化</h3>
<h4 id="网络io"><a class="markdownIt-Anchor" href="#网络io"></a> 网络IO</h4>
<p><strong>网络带宽</strong></p>
<h4 id="dns解析"><a class="markdownIt-Anchor" href="#dns解析"></a> DNS解析</h4>
<p><strong>域名系统</strong>（<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTglOEIlQjElRTYlOTYlODc=">英文<i class="fa fa-external-link-alt"></i></span>：<strong>D</strong>omain <strong>N</strong>ame <strong>S</strong><br />
ystem，<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclQkMlQTklRTUlODYlOTk=">缩写<i class="fa fa-external-link-alt"></i></span>：<strong>DNS</strong><br />
）是<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQkElOTIlRTglODElOTQlRTclQkQlOTE=">互联网<i class="fa fa-external-link-alt"></i></span><br />
的一项服务。它作为将<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOUYlOUYlRTUlOTAlOEQ=">域名<i class="fa fa-external-link-alt"></i></span><br />
和<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9JUCVFNSU5QyVCMCVFNSU5RCU4MA==">IP地址<i class="fa fa-external-link-alt"></i></span>相互<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTglQTAlRTUlQjAlODQ=">映射<i class="fa fa-external-link-alt"></i></span><br />
的一个<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlODglODYlRTUlQjglODMlRTUlQkMlOEYlRTYlOTUlQjAlRTYlOEQlQUUlRTUlQkElOTM=">分布式数据库<i class="fa fa-external-link-alt"></i></span>，能够使人更方便地访问网页。</p>
<p>简易的访问步骤到获取到呈现页面</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqv2nmieu3j30f90c1wec.jpg" alt="" /></p>
<p>当大规模抓取每次都要做DNS解析时，浪费的时间是非常大的。所以如果能在本地做DNS缓存，每次系统都读本地DNS的话，这个时间消耗大大降低。</p>
<p><strong>实现DNS缓存的常见几种方法</strong></p>
<p>最简单的方法就是直接修改/etc/hosts文件，在文件里直接添加IP和域名，例如这样</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqv30rtefqj30mt0bbjrk.jpg" alt="" /></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqv3074tn5j30s60apmx7.jpg" alt="" /></p>
<p>第二种方式：使用DNS缓存工具，例如DNSmasq</p>
<h3 id="爬虫优化第五式解析优化"><a class="markdownIt-Anchor" href="#爬虫优化第五式解析优化"></a> 爬虫优化第五式：解析优化</h3>
<p>智能解析算法</p>
<h3 id="爬虫优化第六式数据持久化优化"><a class="markdownIt-Anchor" href="#爬虫优化第六式数据持久化优化"></a> 爬虫优化第六式：数据持久化优化</h3>
<p>一次插入多条</p>
<p>异步插入多条</p>
<p>MQ</p>
<h3 id="爬虫优化第七式多数据源"><a class="markdownIt-Anchor" href="#爬虫优化第七式多数据源"></a> 爬虫优化第七式：多数据源</h3>
<p>单一的数据源难免由于并发量过大，给目标网站造成DDos攻击。</p>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<p>分别从分布式爬虫，抓取策略、请求优化、网络优化、解析优化、与多数据源方面进行考虑。希望对你能够有所启发</p>
<p>最后在开启超大规模的爬虫建议计算对方的带宽压力，不要抓取太过分了。抓取归抓取，但不要影响对方网站正常运营。</p>
<div style="text-align: center;">以上便是鄙人所知所用的爬虫方法论，希望能帮助到你。</div>
]]></content>
      <categories>
        <category>spider</category>
        <category>crawler</category>
      </categories>
      <tags>
        <tag>data-acquisition</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫对抗相关总结</title>
    <url>/13971.html</url>
    <content><![CDATA[<p>又双叒叕 一篇相关于爬虫对抗的总结. 一般来说对于爬虫的对抗主要体现在如下几个方面</p>
<ul>
<li>
<p>反调: 反抓包\反调试\代码混淆与防护</p>
</li>
<li>
<p>反(欺诈)模拟: 网络协议校验\TLS\请求头(字段\字段顺序\反盗链)校验</p>
</li>
<li>
<p>数据防护\验证码\风控对抗等</p>
</li>
</ul>
<p>反爬虫(风险策略)工程师预防以及防止爬虫工程师对数据的抓取, 一方要&quot;守&quot;一方要&quot;攻&quot;,各为其主各司其职你来我往谁也多呈不让.</p>
<h2 id="反抓包"><a class="markdownIt-Anchor" href="#反抓包"></a> 反抓包</h2>
<p>反抓包的目的多种多样,简而言之便是让爬虫工作者无法捕获网络数据包</p>
<p>如: 不走http\不走代理\请求分离\SSLping单(双)向校验\网络协议定制等</p>
<h2 id="反调试"><a class="markdownIt-Anchor" href="#反调试"></a> 反调试</h2>
<p>反调试的策略诸多, 主要体现方面有思路为 预防调试\ 阻断调试\ 破坏调试,让爬虫逆向者无法有效进行调试</p>
<h3 id="预防调试"><a class="markdownIt-Anchor" href="#预防调试"></a> 预防调试</h3>
<p>预防调试的手段也多种多样, 简而言之便是预防开发者调试从而阻断分析无法进入下一步,主要体现在环境检测\动态代码</p>
<p>譬如:</p>
<ul>
<li>
<p>web端: 控制台检测\动态js\wasm\代码防护与混淆\hook检测\堆栈顺序检测</p>
</li>
<li>
<p>Android:  运行环境检测(root\签名校验\hook检测\模拟器检测)\进程检测与调试工具检检测(<br />
jadx\apktool\jeb\xposed\frida\ida)\壳\so\</p>
</li>
<li>
<p>web:</p>
<ul>
<li>分辨率检测</li>
<li>控制台检测</li>
<li>动态js</li>
<li>wasm</li>
</ul>
</li>
<li>
<p>Android:</p>
<ul>
<li>运行环境检测
<ul>
<li>root检测</li>
<li>设备检测</li>
<li>签名校验</li>
</ul>
</li>
<li>调试器工具检查
<ul>
<li>工具特性检测
<ul>
<li>jadx</li>
<li>apktool</li>
<li>jeb</li>
<li>xposed</li>
<li>frida</li>
<li>ida</li>
</ul>
</li>
</ul>
</li>
<li>代码防护
<ul>
<li>壳</li>
<li>so</li>
<li>代码隐写</li>
</ul>
</li>
</ul>
</li>
<li>
<p>代码混淆</p>
<ul>
<li>布局混淆</li>
<li>数据混淆</li>
<li>数字混淆</li>
<li>字符串混淆</li>
<li>控制流平坦化</li>
</ul>
</li>
</ul>
<h3 id="阻断调试"><a class="markdownIt-Anchor" href="#阻断调试"></a> 阻断调试</h3>
<p>阻断调试, 顾名思义便是阻止调试.或着说将你引入错误的逻辑中,无法正常的调试</p>
<p>譬如代码中的环境检测\设备指纹</p>
<h3 id="破坏调试"><a class="markdownIt-Anchor" href="#破坏调试"></a> 破坏调试</h3>
<p>相对于阻断调试更加极端的手段，一方面对调试者信息进行采集、攻击调试者。例如删除文件、重置电脑、甚至释放病毒等</p>
<p><strong>小结</strong></p>
<p>做反调试主要有两个方面一方面是特征区分预防\阻断\破坏调试, 另一方面是对代码进行保护与混淆</p>
<h2 id="反欺诈模拟"><a class="markdownIt-Anchor" href="#反欺诈模拟"></a> 反(欺诈)模拟</h2>
<p>如果说反调试是为了防止逆向工作者,那么反模拟便是针对爬虫工程师.</p>
<p>简而言之,防止模拟请求. 那么对于此.我们只需要区分开这个请求,<br />
亦或者将结果数据进行处理这样就可以让开发者无法拿到正常有价值的数据,从而实现反爬虫的效果.</p>
<blockquote>
<p>因为我们知道爬虫简单来说就是模拟用户请求的代码实现</p>
</blockquote>
<p>反模拟主要在对于爬虫的请求进行甄别,常见的关键点有</p>
<p>请求库特征,譬如tls指纹</p>
<p>请求协议的区分: 譬如强制指定http2或quic等\使用自研的协议</p>
<p>参数校验: 校验的思路有 参数字段的校验如cookie等, 参数顺序的校验</p>
<p>加密与编码算法的定制修改,</p>
<ul>
<li>位运算\ 在特殊的头\尾部加入字符</li>
<li>魔改hash算法\base(16\32\64)等</li>
<li>对称加密与非对称加密算法</li>
</ul>
<blockquote>
<p>校验的字段通常使用到加密算法或编码算法</p>
</blockquote>
<h2 id="数据防护"><a class="markdownIt-Anchor" href="#数据防护"></a> 数据防护</h2>
<p>当我们完成了以上的种种, 便将&quot;战场&quot;迁移到最后的数据保护上,</p>
<p>常见的方式有数据加密(从服务端返回的数据进行加密或编码)</p>
<p>数据隐写</p>
<blockquote>
<p>无法轻松直接的从返回的数据包中获取到数据, 只需要保证界面展示上正常的即可</p>
</blockquote>
<h2 id="验证码"><a class="markdownIt-Anchor" href="#验证码"></a> 验证码</h2>
<p>验证码不必多说, 譬如常见的如下几种类型</p>
<ul>
<li>滑动型</li>
<li>计算型</li>
<li>点选型(图像: 一维\二维\三维)</li>
<li>短信或语音验证型</li>
</ul>
<p>通常验证码还会对对应的譬如图片进行安全处理, 如图片重排\模糊化等等干扰识别以及防止图像被还原</p>
<p>还有就是检测运行环境</p>
<h2 id="风控"><a class="markdownIt-Anchor" href="#风控"></a> 风控</h2>
<h3 id="ip风控"><a class="markdownIt-Anchor" href="#ip风控"></a> IP风控</h3>
<h3 id="设备风控"><a class="markdownIt-Anchor" href="#设备风控"></a> 设备风控</h3>
<h3 id="账号风控"><a class="markdownIt-Anchor" href="#账号风控"></a> 账号风控</h3>
<p>风控其核心的对抗 个人认为有两点</p>
<ol>
<li>特征</li>
<li>逻辑</li>
</ol>
<p>写的比较散,但实现起来却并不是唯一, 仅按个人认为的进行的区分, 大多情况都不可能单独出现.</p>
<h2 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h2>
<p>无论是爬虫工程师还是反爬虫亦或者风险策略工程师. 攻与守并非是一成不变的. ,掌握底层逻辑,不断的成长向上吧.<br />
瑞斯拜~</p>
]]></content>
      <categories>
        <category>spider</category>
        <category>crawler</category>
      </categories>
      <tags>
        <tag>data-acquisition</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫架构</title>
    <url>/33887.html</url>
    <content><![CDATA[<h2 id="爬虫架构"><a class="markdownIt-Anchor" href="#爬虫架构"></a> 爬虫架构</h2>
<blockquote>
<p>技术的本质就是<strong>结构与组合</strong>。今天在谈技术架构，有时候我们也会谈产品架构，再往前走，我们会谈商业架构，它中间都是一个结构的问题。</p>
</blockquote>
<h3 id="爬虫开发流程"><a class="markdownIt-Anchor" href="#爬虫开发流程"></a> 爬虫开发流程</h3>
<p>在聊爬虫架构的时候，非常有必要将爬虫的流程梳理清楚。毕竟万变不离其宗，对于爬虫流程的掌握可以更好的理解、设计、组合爬虫，<br />
爬虫基本步骤如下</p>
<ol>
<li>网络包捕获，确定URL</li>
<li>模拟发送网络请求，获取响应</li>
<li>解析响应， 获取数据</li>
<li>解析数据，数据持久化</li>
</ol>
<h2 id="分布式爬虫架构"><a class="markdownIt-Anchor" href="#分布式爬虫架构"></a> 分布式爬虫架构</h2>
<h3 id="均衡分布式"><a class="markdownIt-Anchor" href="#均衡分布式"></a> 均衡分布式</h3>
<h3 id="对等分布式"><a class="markdownIt-Anchor" href="#对等分布式"></a> 对等分布式</h3>
<h2 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h2>
<p>不要过度优化、不要过度预留扩展点、不要过度设计</p>
]]></content>
      <categories>
        <category>spider</category>
        <category>crawler</category>
      </categories>
      <tags>
        <tag>data-acquisition</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫需要学什么，怎么学？</title>
    <url>/11424.html</url>
    <content><![CDATA[<p>爬虫需要学什么，怎么学？小子不才，今日与诸位妄谈<code>爬虫需要学什么，怎么学？</code> 这一话题，个人拙见将自我的学习路程分为如下几个阶段</p>
<ul>
<li>第一层：编程语言</li>
<li>第二层：网络知识，各工具熟练使用</li>
<li>第三层：高性能的爬虫</li>
<li>第四层：JS逆向</li>
<li>第五层：小程序逆向</li>
<li>第六层：Android逆向</li>
<li>第七层：分布式爬虫</li>
<li>第八层：爬虫架构</li>
<li>第九层：工具链构建</li>
</ul>
<h2 id="第一层编程语言"><a class="markdownIt-Anchor" href="#第一层编程语言"></a> 第一层：编程语言</h2>
<p>编程语言自然不必多说，至少得会一门语言。推荐的语言有Java、Python、Go、JS</p>
<p>编程语言可简单细分为如下步骤</p>
<ul>
<li>语言背景与历史</li>
<li>环境搭建</li>
<li>常量变量</li>
<li>基础数据类型（bytes、String、int、bool）等</li>
<li>运算与运算符（<code>+、-、*、÷、｜、&amp;、^、</code>）、位运算</li>
<li>条件分支语句（if、switch等）</li>
<li>循环语句（forloop、while loop）</li>
<li>函数、匿名函数、嵌套函数、闭包</li>
<li>常见算法（递归、分治、回溯）、排序算法、动态规划、贪心算法、遍历算法</li>
<li>错误、异常处理</li>
<li>文件操作</li>
<li>并发编程</li>
<li>网络编程</li>
<li>面向对象</li>
<li>runtime</li>
<li>gc</li>
<li>数据库与中间件（MySQL、MongoDB、Redis、ES）</li>
</ul>
<blockquote>
<p>广度优先，重复学</p>
</blockquote>
<h2 id="第二层网络知识与各工具使用"><a class="markdownIt-Anchor" href="#第二层网络知识与各工具使用"></a> 第二层：网络知识与各工具使用</h2>
<ul>
<li>网络模型，ISO、TCP/IP</li>
<li>网络协议：HTTP、HTTPS</li>
<li>网络知识：URN、URI、URL</li>
<li>认证：cookie、session、Token、JWT</li>
</ul>
<h3 id="工具"><a class="markdownIt-Anchor" href="#工具"></a> 工具</h3>
<p>浏览器：Chrome</p>
<p>抓包工具：Fiddler、Charles、Mitmproxy（中间人抓包原理，网络原理）</p>
<p>Postman</p>
<p>学完这部分，恭喜你。你已经可以独立开发一个简单的爬虫了</p>
<p>爬虫基本开发步骤如下：</p>
<p>网络抓包，确定目标地址（URN）</p>
<p>发送请求，获取响应</p>
<p>解析响应、获取数据</p>
<p>数据存储（将提取的数据存储到txt或JSON、MySQL、MongoDB、Redis、ES）</p>
<h2 id="第三层高性能的爬虫"><a class="markdownIt-Anchor" href="#第三层高性能的爬虫"></a> 第三层：高性能的爬虫</h2>
<p>在完成了第二层之后，在其到基础上加速爬虫</p>
<ul>
<li>进程、线程、协程</li>
<li>并发并行</li>
<li>阻塞非阻塞、I/O模型</li>
</ul>
<h2 id="第四层js逆向"><a class="markdownIt-Anchor" href="#第四层js逆向"></a> 第四层：JS逆向</h2>
<p>——“想爬？偏不给你爬！”</p>
<ul>
<li>
<p>反抓包</p>
<ul>
<li>
<p>证书</p>
</li>
<li>
<p>双向验证</p>
</li>
<li>
<p>竟然不用HTTP(S)！RPC来搅局？</p>
</li>
</ul>
</li>
</ul>
<p>反请求</p>
<ul>
<li>
<p>请求头反抓</p>
<ul>
<li>UA</li>
<li>Sign、token、sale</li>
<li>Header</li>
</ul>
</li>
<li>
<p>代码防护</p>
<ul>
<li>布局混淆</li>
<li>数字混淆</li>
<li>字符串混淆</li>
<li>控制流混淆</li>
<li>预防混淆</li>
</ul>
</li>
<li>
<p>验证码</p>
<ul>
<li>
<p>识别点选或输入型</p>
</li>
<li>
<p>滑轨、滑块型</p>
</li>
<li>
<p>计算型</p>
</li>
<li>
<p>空值补齐型</p>
</li>
<li>
<p>空间推理型</p>
</li>
<li>
<p>短信或语音验证型</p>
</li>
</ul>
</li>
<li>
<p>数据防护</p>
<ul>
<li>动态字体</li>
<li>CSS偏移</li>
<li>内容加密映射</li>
<li>SVG映射等</li>
<li>内容图片化</li>
</ul>
</li>
<li>
<p>反调试</p>
<ul>
<li>控制台检测</li>
<li>无限debugger来了！</li>
<li>函数居然被重写？</li>
<li>不讲武德，参数生产后删除js！</li>
</ul>
</li>
<li>
<p>其他反抓</p>
<ul>
<li>风控（如IP、用户行为）</li>
<li>浏览器指纹</li>
<li>代码运行环境检测等</li>
<li>JS虚拟机、jsvm、jsvmp</li>
<li>wasm</li>
</ul>
</li>
</ul>
<p>金盆洗手？自动化工具来助威！ RPC半真半假远程调用</p>
<p>加密算法怎么定位？奇银技巧来助威！ Hook、各种搜索断点、debug（XHR、事件）中场休息助一臂之力</p>
<p>插桩妙调，算法自吐</p>
<p>代码怎么扣？环境怎么补？加密算法怎么还原？？</p>
<p>AST混淆代码对抗，逐一击破，稳扎稳扎。相信自己会逐渐强大</p>
<h2 id="第五层小程序逆向"><a class="markdownIt-Anchor" href="#第五层小程序逆向"></a> 第五层：小程序逆向</h2>
<p>在完成第四层JS逆向的基础上，来看看新宠儿小程序？</p>
<p>小程序包如何来，小程序又是如何验证的？</p>
<p>小程序项目结构又如何？</p>
<p>静态调试，全局游走gank</p>
<h2 id="第六层android逆向"><a class="markdownIt-Anchor" href="#第六层android逆向"></a> 第六层：Android逆向</h2>
<p>新的征程？！</p>
<p>Android正向开发也要学！apk、四大组件、项目布局、配置</p>
<p>反编译神器jadx初尝</p>
<p>又抓不到包了啊！</p>
<ul>
<li>不走代理端口了啊</li>
<li>证书校验</li>
<li>居然魔改网络协议？</li>
</ul>
<p>居然还有代码壳，保护代码</p>
<p>“强盗打劫！，移花接木”</p>
<ul>
<li>
<p>Frida</p>
</li>
<li>
<p>ratel</p>
</li>
<li>
<p>Xpose</p>
</li>
</ul>
<p>smail、汇编、C/C++、So</p>
<p>IDA动静调试一探究竟</p>
<p>AOSP</p>
<p>完了，芭比扣了</p>
<blockquote>
<p>补补Java、JNI、Android吧</p>
</blockquote>
<h2 id="第七层分布式爬虫"><a class="markdownIt-Anchor" href="#第七层分布式爬虫"></a> 第七层：分布式爬虫</h2>
<p>任务过多，工人不够？</p>
<p>消息队列抽离任务全局可用，一代多</p>
<p>任务supervisor一带多</p>
<p>配上docker虚拟化,K8s虚拟化，一起拥抱云源生</p>
<p>有始有终，奴奴++</p>
<h2 id="第八层爬虫架构"><a class="markdownIt-Anchor" href="#第八层爬虫架构"></a> 第八层：爬虫架构</h2>
<p>跑在云上等，网络角逐者</p>
<p>云监控：<span class="exturl" data-url="aHR0cHM6Ly90aGFub3MuaW8v">thanos<i class="fa fa-external-link-alt"></i></span> 、<span class="exturl" data-url="aHR0cHM6Ly9ncmFmYW5hLmNvbS8=">grafana<i class="fa fa-external-link-alt"></i></span></p>
<p>日志监控：<span class="exturl" data-url="aHR0cHM6Ly9rYWZrYS5hcGFjaGUub3JnLw==">Kafka<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9jbi9lbGFzdGljc2VhcmNoLw==">ElasticSearch<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9jbi9iZWF0cy9maWxlYmVhdA==">FileBaet<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9jbi9raWJhbmEv">kibana<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="第九层工具链构建"><a class="markdownIt-Anchor" href="#第九层工具链构建"></a> 第九层：工具链构建</h2>
<p>UA Pool</p>
<p>Proxy Pool</p>
<p>Account Pool</p>
<p>DL识别验证码</p>
<p>智能解析算法</p>
]]></content>
      <categories>
        <category>spider</category>
        <category>crawler</category>
      </categories>
      <tags>
        <tag>data-acquisition</tag>
      </tags>
  </entry>
  <entry>
    <title>监控系统</title>
    <url>/45041.html</url>
    <content><![CDATA[<p>俗话说“无监控,不运维”， 一套监控预警系统尤为重要</p>
<h2 id="日志监控系统"><a class="markdownIt-Anchor" href="#日志监控系统"></a> 日志监控系统</h2>
<p>目前市面上日志监控系统主要是以Elastic家族实现的日志系统，比较盛名的有</p>
<ul>
<li>ELK</li>
<li>EFK</li>
<li>KEFK</li>
</ul>
<p>其中</p>
<p>E为Elastic Search，也就是咱们常说的es</p>
<p>L为logstash，数据处理管道</p>
<p>F为Filebaet，轻量型日志采集器：用于转发和汇总日志与文件</p>
<p>K为Kibana，可拓展的用户展示界面</p>
<blockquote>
<p>主要思路基于ETL抽取（extract）、转换（transform）、加载（load）</p>
</blockquote>
<h3 id="ox1-elk架构"><a class="markdownIt-Anchor" href="#ox1-elk架构"></a> ox1: ELK架构</h3>
<h4 id="最简"><a class="markdownIt-Anchor" href="#最简"></a> 最简</h4>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h04qn1an8lj20nz0fmjry.jpg" alt="image-20220310134833384" /></p>
<p><strong>优点</strong></p>
<p>部署简单，轻量</p>
<p><strong>缺点</strong></p>
<p>Logstash同时兼顾了抽取（extract）、转换（transform）、加载（load）。较为损耗资源</p>
<h4 id="改进"><a class="markdownIt-Anchor" href="#改进"></a> 改进</h4>
<p>基于TCP推送至LogStash</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h04qrlcl18j20j90ad74q.jpg" alt="image-20220310135258151" /></p>
<p>优点：较于最简版，大大的减少了服务器负载</p>
<p>缺点：基于SDK开发，有代码侵入。耦合性强</p>
<h3 id="ox2-efk"><a class="markdownIt-Anchor" href="#ox2-efk"></a> Ox2: EFK</h3>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h04r199hvkj20u10nrgnj.jpg" alt="image-20220310140216214" /></p>
<p>优点：代码无侵入、占用资源少</p>
<p>缺点：日志数据共享困难；FileBaet只能配置一个output源</p>
<h3 id="0x3-kefk"><a class="markdownIt-Anchor" href="#0x3-kefk"></a> 0x3: KEFK</h3>
<p>Kafka、ElasticSearch、FileBaet、Kibana</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h04r6v0l5oj20va0gx755.jpg" alt="image-20220310140739079" /></p>
<p>优点：基于消息队列实现共享，稳定性能性高</p>
<p>缺点：组件多，运维成本大</p>
<h2 id="gpl"><a class="markdownIt-Anchor" href="#gpl"></a> GPL</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9ncmFmYW5hLmNvbS8=">Granfan<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9wcm9tZXRoZXVzLmlvLw==">Prometheus<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ncmFmYW5hLmNvbS9vc3MvbG9raS8=">loki<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="gtl"><a class="markdownIt-Anchor" href="#gtl"></a> GTL</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9ncmFmYW5hLmNvbS8=">Granfan<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly90aGFub3MuaW8v">thanos<i class="fa fa-external-link-alt"></i></span>：Thanos 是一组组件，可以组成一个具有无限存储容量的高度可用的指标系统，可以在现有的<br />
Prometheus 部署之上无缝添加。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ncmFmYW5hLmNvbS9vc3MvbG9raS8=">loki<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="gti与zabbix"><a class="markdownIt-Anchor" href="#gti与zabbix"></a> GTI与<strong>Zabbix</strong></h2>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mbHV4ZGF0YS5jb20v">influxdb<i class="fa fa-external-link-alt"></i></span>+<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmluZmx1eGRhdGEuY29tL3RlbGVncmFmLw==">telegraf<i class="fa fa-external-link-alt"></i></span>+Grafana</p>
<table>
<thead>
<tr>
<th>telegraf+influxdb+Grafana</th>
<th>Zabbix</th>
</tr>
</thead>
<tbody>
<tr>
<td>部署及使用简单</td>
<td>部署使用相对复杂</td>
</tr>
<tr>
<td>内置监控项丰富</td>
<td>内置监控项支持相对少一些，但是社区提供了丰富的监控采集方案</td>
</tr>
<tr>
<td>不支持跨机房部署</td>
<td>支持跨机房部署</td>
</tr>
<tr>
<td>审计功能相对较弱</td>
<td>审计功能成熟完善</td>
</tr>
<tr>
<td>出图能力灵活强大</td>
<td>出图功能相对弱一些，图形化定制方面操作复杂</td>
</tr>
<tr>
<td>告警功能简单</td>
<td>告警强大，支持告警依赖，告警升级</td>
</tr>
<tr>
<td>支持通过webhook方式触发命令</td>
<td>支持服务器端/客户端的命令自动触发，支持命令推送</td>
</tr>
<tr>
<td>权限管理相对简单</td>
<td>支持细粒度的权限定制，权限体系成熟完善</td>
</tr>
<tr>
<td>数据采集方式相对单一，仅支持自动上报，但支持较为丰富的数据源</td>
<td>支持多种数据采集方式/协议，数据源相对单一，v3.4.7版本开始支持ES存储历史数据</td>
</tr>
</tbody>
</table>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemFiYml4LmNvbS8=">Zabbix<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="相关地址"><a class="markdownIt-Anchor" href="#相关地址"></a> 相关地址</h2>
<p>elasticsearch: <span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9jbi9lbGFzdGljc2VhcmNoLw==">https://www.elastic.co/cn/elasticsearch/<i class="fa fa-external-link-alt"></i></span></p>
<p>kibana: <span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9jbi9raWJhbmEv">https://www.elastic.co/cn/kibana/<i class="fa fa-external-link-alt"></i></span></p>
<p>logstash: <span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9jbi9sb2dzdGFzaC8=">https://www.elastic.co/cn/logstash/<i class="fa fa-external-link-alt"></i></span></p>
<p>Kafka: <span class="exturl" data-url="aHR0cHM6Ly9rYWZrYS5hcGFjaGUub3JnLw==">https://kafka.apache.org/<i class="fa fa-external-link-alt"></i></span></p>
<p>Granfan:<span class="exturl" data-url="aHR0cHM6Ly9ncmFmYW5hLmNvbS8=">https://grafana.com/<i class="fa fa-external-link-alt"></i></span></p>
<p>Prometheus:<span class="exturl" data-url="aHR0cHM6Ly9wcm9tZXRoZXVzLmlvLw==">https://prometheus.io/<i class="fa fa-external-link-alt"></i></span></p>
<p>loki: <span class="exturl" data-url="aHR0cHM6Ly9ncmFmYW5hLmNvbS9vc3MvbG9raS8=">https://grafana.com/oss/loki/<i class="fa fa-external-link-alt"></i></span></p>
<p>thanos：<span class="exturl" data-url="aHR0cHM6Ly90aGFub3MuaW8v">https://thanos.io/<i class="fa fa-external-link-alt"></i></span></p>
<p>Zabbix:<span class="exturl" data-url="aHR0cHM6Ly93d3cuemFiYml4LmNvbS8=">https://www.zabbix.com/<i class="fa fa-external-link-alt"></i></span></p>
<p>telegraf：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmluZmx1eGRhdGEuY29tL3RlbGVncmFmLw==">https://docs.influxdata.com/telegraf/<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="other"><a class="markdownIt-Anchor" href="#other"></a> Other</h2>
<p><a href="https://baijiahao.baidu.com/s?id=1669965625932326951"><strong>ETL、ELT</strong>区别</a></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NDU3NDcxNTQ=">无监控，不运维<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNTAxOTAxNjY=">云原生<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly95YXNvbmd4dS5naXRib29rLmlvLw==">监控方案汇总<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
  </entry>
  <entry>
    <title>盘点go并发那些事儿</title>
    <url>/9672.html</url>
    <content><![CDATA[<h2 id="盘点golang并发那些事儿之一"><a class="markdownIt-Anchor" href="#盘点golang并发那些事儿之一"></a> 盘点Golang并发那些事儿之一</h2>
<blockquote>
<p>一生很短，Let’s Go</p>
<p>人生苦短，我用Python</p>
</blockquote>
<p>Golang、Golang、Golang 真的够浪，今天我们一起盘点一下<code>Golang</code>并发那些事儿，准确来说是<code>goroutine</code><br />
,关于多线程并发，咱们暂时先放一放(主要是俺现在还不太会，不敢出来瞎搞)。关于<code>golang</code><br />
优点如何，咱们也不扯那些虚的。反正都是大佬在说，俺只是个吃瓜群众，偶尔打打酱油，逃～。</p>
<span id="more"></span>
<p>说到并发，等等一系列的骚概念就出来了，为了做个照顾一下自己的菜，顺便复习一下</p>
<h2 id="基础概念"><a class="markdownIt-Anchor" href="#基础概念"></a> 基础概念</h2>
<h3 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h3>
<h4 id="进程的定义"><a class="markdownIt-Anchor" href="#进程的定义"></a> 进程的定义</h4>
<p><strong>进程</strong>（英语：process），是指计算机中已运行的<code>程序</code>。进程曾经是``<br />
分时系统<code>的基本运作单位。在面向进程设计的系统（如早期的</code>UNIX<code>，</code>Linux<br />
2.4<code>及更早的版本）中，进程是程序的基本执行实体；在面向线程设计的系统（如当代多数操作系统、</code>Linux`<br />
2.6及更新的版本）中，进程本身不是基本运行单位，而是<strong>线程</strong>的容器。</p>
<p>程序本身只是指令、数据及其组织形式的描述，相当于一个名词，进程才是程序（那些指令和数据）的真正运行实例，可以想像说是现在进行式。若干进程有可能与同一个程序相关系，且每个进程皆可以同步或<br />
<strong>异步</strong>的方式独立运行。现代<strong>计算机系统</strong><br />
可在同一段时间内以进程的形式将多个程序加载到存储器中，并借由时间共享（或称<strong>时分复用</strong>），以在一个<strong>处理器<br />
<strong>上表现出同时</strong>平行性</strong><br />
运行的感觉。同样的，使用多线程技术（多线程即每一个线程都代表一个进程内的一个独立执行上下文）的操作系统或计算机体系结构，同样程序的<br />
<strong>平行</strong>线程，可在多CPU主机或网络上真正<strong>同时</strong>运行（在不同的CPU上）。</p>
<h4 id="进程的创建"><a class="markdownIt-Anchor" href="#进程的创建"></a> 进程的创建</h4>
<p>操作系统需要有一种方式来创建进程。</p>
<p>以下4种主要事件会创建进程</p>
<ol>
<li>系统初始化 （简单可理解为关机后的开机）</li>
<li>正在运行的程序执行了创建进程的系统调用（例如：朋友发了一个网址，你点击后开启浏览器进入网页中）</li>
<li>用户请求创建一个新进程（例如：打开一个程序，打开QQ、微信）</li>
<li>一个批量作业的初始化</li>
</ol>
<h4 id="进程的终止"><a class="markdownIt-Anchor" href="#进程的终止"></a> 进程的终止</h4>
<p>进程在创建后，开始运行与处理相关任务。但并不会永恒存在，终究会完成或退出。那么以下四种情况会发生进程的终止</p>
<ol>
<li>正常退出（自愿）</li>
<li>错误退出（自愿）</li>
<li>崩溃退出（非自愿）</li>
<li>被其他杀死（非自愿）</li>
</ol>
<p>正常退出：你退出浏览器，你点了一下它<img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn9kz2montj301i01aa9t.jpg" alt="" /></p>
<p>错误退出：你此时正在津津有味的看着电视剧，突然程序内部发生bug，导致退出<img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn9l4ovbrdj31u70u0jsv.jpg" alt="" /></p>
<p>崩溃退出：你程序崩溃了<img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn9ldqess0j31ds0sogmr.jpg" alt="" /></p>
<p>被其他杀死：例如在windows上，使用任务管理器关闭进程</p>
<h4 id="进程的状态"><a class="markdownIt-Anchor" href="#进程的状态"></a> 进程的状态</h4>
<ol>
<li>运行态(实际占用CPU)</li>
<li>就绪态(可运行、但其他进程正在运行而暂停)</li>
<li>阻塞态(除非某种外部的时间发生，否则进程不能运行)</li>
</ol>
<p>前两种状态在逻辑上是类似的。处于这两种状态的进程都可以运行，只是对于第二种状态暂时没有分配CPU，一旦分配到了CPU即可运行</p>
<p>第三种状态与前两种不同，处于该状态的进程不能运行，即是CPU空闲也不行。</p>
<blockquote>
<p>如有兴趣，可进一步了解进程的实现、多进程设计模型</p>
</blockquote>
<h4 id="进程池"><a class="markdownIt-Anchor" href="#进程池"></a> 进程池</h4>
<p>进程池技术的应用至少由以下两部分组成：</p>
<p><strong>资源进程</strong></p>
<p>预先创建好的空闲进程，管理进程会把工作分发到空闲进程来处理。</p>
<p><strong>管理进程</strong></p>
<p>管理进程负责创建资源进程，把工作交给空闲资源进程处理，回收已经处理完工作的资源进程。</p>
<p>资源进程跟管理进程的概念很好理解，管理进程如何有效的管理资源进程，分配任务给资源进程，回收空闲资源进程，管理进程要有效的管理资源进程，那么管理进程跟资源进程间必然需要交互，通过IPC，信号，<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQkYlQTElRTUlOEYlQjclRTklODclOEY=">信号量<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlQjYlODglRTYlODElQUYlRTklOTglOUYlRTUlODglOTc=">消息队列<i class="fa fa-external-link-alt"></i></span><br />
，管道等进行交互。</p>
<blockquote></blockquote>
<p>进程池：准确来说它并不实际存在于我们的操作系统中，而是IPC，信号，<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQkYlQTElRTUlOEYlQjclRTklODclOEY=">信号量<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlQjYlODglRTYlODElQUYlRTklOTglOUYlRTUlODglOTc=">消息队列<i class="fa fa-external-link-alt"></i></span><br />
，管道等对多进程进行管理，从而减少不断的开启、关闭等操作。以求达到减少不必要的资源损耗</p>
<h3 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h3>
<h4 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h4>
<p><strong>线程</strong>（英语：thread）是<strong>操作系统</strong>能够进行运算<strong>调度</strong>的最小单位。大部分情况下，它被包含在<strong>进程</strong><br />
之中，是<strong>进程</strong>中的实际运作单位。一条线程指的是<strong>进程</strong><br />
中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在<strong>Unix System V</strong>及*<br />
*SunOS**中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel<br />
thread），而把用户线程（user thread）称为线程。</p>
<p>线程是独立调度和分派的基本单位。线程可以为操作系统内核调度的内核线程</p>
<p>同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，<strong>文件描述符</strong>和<strong>信号处理</strong><br />
等等。但同一进程中的多个线程有各自的<code>调用栈</code>（call stack），自己的<code>寄存器环境</code>（register<br />
context），自己的线程本地存储（thread-local storage）。</p>
<p>一个进程可以有很多线程来处理，每条线程并行执行不同的任务。如果进程要完成的任务很多，这样需很多线程，也要调用很多核心，在多核或多<br />
<strong>CPU</strong>，或支持<strong>Hyper-threading</strong><br />
的CPU上使用多线程程序设计的好处是显而易见的，即提高了程序的执行吞吐率。以人工作的样子想像，核心相当于人，人越多则能同时处理的事情越多，而线程相当于手，手越多则工作效率越高。在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责I/O处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，虽然多任务比不上多核，但因为具备多线程的能力，从而提高了程序的执行效率。</p>
<h4 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h4>
<p><strong>线程池</strong>（英语：thread<br />
pool）：一种<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUJBJUJGJUU3JUE4JThC">线程<i class="fa fa-external-link-alt"></i></span><br />
使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。<br />
例如，线程数一般取cpu数量+2比较合适，线程数过多会导致额外的线程切换开销。</p>
<p>任务调度以执行线程的常见方法是使用同步队列，称作任务队列。池中的线程等待队列中的任务，并把执行完的任务放入完成队列中。</p>
<p>线程池模式一般分为两种：HS/HA半同步/半异步模式、L/F领导者与跟随者模式。</p>
<ul>
<li></li>
</ul>
<h2 id="半同步半异步模式又称为生产者消费者模式是比较常见的实现方式比较简单-分为同步层-队列层-异步层三层-同步层的主线程处理工作任务并存入工作队列工作线程从工作队列取出任务进行处理如果工作队列为空则取不到任务的工作线程进入挂起状态-由于线程间有数据通信因此不适于大数据量交换的场合"><a class="markdownIt-Anchor" href="#半同步半异步模式又称为生产者消费者模式是比较常见的实现方式比较简单-分为同步层-队列层-异步层三层-同步层的主线程处理工作任务并存入工作队列工作线程从工作队列取出任务进行处理如果工作队列为空则取不到任务的工作线程进入挂起状态-由于线程间有数据通信因此不适于大数据量交换的场合"></a> 半同步/半异步模式又称为生产者消费者模式，是比较常见的实现方式，比较简单。分为同步层、队列层、异步层三层。同步层的主线程处理工作任务并存入工作队列，工作线程从工作队列取出任务进行处理，如果工作队列为空，则取不到任务的工作线程进入挂起状态。由于线程间有数据通信，因此不适于大数据量交换的场合</h2>
<p>领导者跟随者模式，在线程池中的线程可处在3种状态之一：领导者leader、追随者follower或工作者processor。任何时刻线程池只有一个领导者线程。事件到达时，领导者线程负责消息分离，并从处于追随者线程中选出一个来当继任领导者，然后将自身设置为工作者状态去处置该事件。处理完毕后工作者线程将自身的状态置为追随者。这一模式实现复杂，但避免了线程间交换任务数据，提高了CPU<br />
cache相似性。在<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvQUNFJUU4JTg3JUFBJUU5JTgwJTgyJUU5JTg1JThEJUU5JTgwJTlBJUU0JUJGJUExJUU3JThFJUFGJUU1JUEyJTgz">ACE<i class="fa fa-external-link-alt"></i></span>(Adaptive Communication<br />
Environment)中，提供了领导者跟随者模式实现。</p>
<p>线程池的<strong>伸缩性</strong>对性能有较大的影响。</p>
<ul>
<li>创建太多线程，将会浪费一定的资源，有些线程未被充分使用。</li>
<li>销毁太多线程，将导致之后浪费时间再次创建它们。</li>
<li>创建线程太慢，将会导致长时间的等待，性能变差。</li>
<li>销毁线程太慢，导致其它线程<strong>资源</strong>饥饿。</li>
</ul>
<h3 id="协程"><a class="markdownIt-Anchor" href="#协程"></a> 协程</h3>
<p>协程，英文叫作 Coroutine，又称微线程、纤程，协程是一种用户态的轻量级线程。</p>
<p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此协程能保留上一次调用时的状态，即所有局部状态的一个特定组合，每次过程重入时，就相当于进入上一次调用的状态。</p>
<p>协程本质上是个单进程，协程相对于多进程来说，无需线程上下文切换的开销，无需原子操作锁定及同步的开销，编程模型也非常简单。</p>
<h3 id="串行"><a class="markdownIt-Anchor" href="#串行"></a> 串行</h3>
<p>多个任务，执行完毕后再执行另一个。</p>
<p>例如：吃完饭后散步(先坐下吃饭、吃完后去散步)</p>
<h3 id="并行"><a class="markdownIt-Anchor" href="#并行"></a> 并行</h3>
<p>多个任务、交替执行</p>
<p>例如：做饭，一会放水洗菜、一会吸收(菜比较脏，洗下菜写下手，傲娇～)</p>
<h3 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h3>
<p>共同出发</p>
<p>边吃饭、边看电视</p>
<h3 id="阻塞与非阻塞"><a class="markdownIt-Anchor" href="#阻塞与非阻塞"></a> 阻塞与非阻塞</h3>
<h4 id="阻塞"><a class="markdownIt-Anchor" href="#阻塞"></a> 阻塞</h4>
<p>阻塞状态指程序未得到所需计算资源时被挂起的状态。程序在等待某个操作完成期间，自身无法继续处理其他的事情，则称该程序在该操作上是阻塞的。</p>
<p>常见的阻塞形式有：网络 I/O 阻塞、磁盘 I/O 阻塞、用户输入阻塞等。阻塞是无处不在的，包括 CPU<br />
切换上下文时，所有的进程都无法真正处理事情，它们也会被阻塞。如果是多核 CPU 则正在执行上下文切换操作的核不可被利用。</p>
<h4 id="非阻塞"><a class="markdownIt-Anchor" href="#非阻塞"></a> 非阻塞</h4>
<p>程序在等待某操作过程中，自身不被阻塞，可以继续处理其他的事情，则称该程序在该操作上是非阻塞的。</p>
<p>非阻塞并不是在任何程序级别、任何情况下都可以存在的。仅当程序封装的级别可以囊括独立的子程序单元时，它才可能存在非阻塞状态。</p>
<p>非阻塞的存在是因为阻塞存在，正因为某个操作阻塞导致的耗时与效率低下，我们才要把它变成非阻塞的。</p>
<h3 id="同步与异步"><a class="markdownIt-Anchor" href="#同步与异步"></a> 同步与异步</h3>
<h4 id="同步"><a class="markdownIt-Anchor" href="#同步"></a> 同步</h4>
<p>不同程序单元为了完成某个任务，在执行过程中需靠某种通信方式以协调一致，我们称这些程序单元是同步执行的。</p>
<p>例如购物系统中更新商品库存，需要用“行锁”作为通信信号，让不同的更新请求强制排队顺序执行，那更新库存的操作是同步的。</p>
<p>简言之，同步意味着有序。</p>
<h4 id="异步"><a class="markdownIt-Anchor" href="#异步"></a> 异步</h4>
<p>为完成某个任务，不同程序单元之间过程中无需通信协调，也能完成任务的方式，不相关的程序单元之间可以是异步的。</p>
<p>例如，爬虫下载网页。调度程序调用下载程序后，即可调度其他任务，而无需与该下载任务保持通信以协调行为。不同网页的下载、保存等操作都是无关的，也无需相互通知协调。这些异步操作的完成时刻并不确定。</p>
<h2 id="可异步与不可异步"><a class="markdownIt-Anchor" href="#可异步与不可异步"></a> 可异步与不可异步</h2>
<p>经过以上了解，又是进程、又是线程、等等一系列的骚东西，那是真的难受。不过相信你已经有个初步的概率，那么这里我们将更加深入的去了解<code>可异步</code><br />
与<code>不可异步</code>。</p>
<p>在此之前先总结一下，以上各种演进的路线，其实加速无非就是一句话，提高效率。（废话～）</p>
<p>那么提高效率的是两大因素，增加投入以求增加产出、尽可能避免不必要的损耗（例如：减少上下文切换等等）。</p>
<p>如何区分它是可异步代码还是不可异步呢，其实很简单那就是，它是否能够自主完成不需要我们参与的部分。</p>
<p>我们从结果反向思考，</p>
<p>例如我们发送一个网络请求，这之间拥有网络I/O阻塞，那么测试我们将它挂起、转而去做其他事情，等他响应了，我们在进行此阶段的下一步的操作。那么这个是可异步的</p>
<p>另外：写作业与上洗手间，我此时正在写着作业，突然，我想上洗手间了，走。上完洗手间后又回来继续写作业，在我去洗手间这段时间作业是不会有任何进展，所以我们可以理解为这是非异步</p>
<h2 id="goroutine"><a class="markdownIt-Anchor" href="#goroutine"></a> goroutine</h2>
<p>东扯一句，西扯一句，终于该上真家伙了，废话不多说。</p>
<p>如何实现只需定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行。</p>
<p>Go语言中的<code>goroutine</code>就是这样一种机制，<code>goroutine</code>的概念类似于线程，但 <code>goroutine</code><br />
是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine<br />
中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p>
<p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–<code>goroutine</code><br />
，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个<code>goroutine</code>去执行这个函数就可以了</p>
<h2 id="goroutine与线程"><a class="markdownIt-Anchor" href="#goroutine与线程"></a> goroutine与线程</h2>
<h3 id="可增长的栈"><a class="markdownIt-Anchor" href="#可增长的栈"></a> 可增长的栈</h3>
<p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个<code>goroutine</code><br />
的栈在其生命周期开始时只有很小的栈（典型情况下2KB），<code>goroutine</code><br />
的栈不是固定的，他可以按需增大和缩小，<code>goroutine</code><br />
的栈大小限制可以达到1GB，虽然极少会用到这么大。所以在Go语言中一次创建十万左右的<code>goroutine</code>也是可以的。</p>
<h3 id="goroutine模型"><a class="markdownIt-Anchor" href="#goroutine模型"></a> goroutine模型</h3>
<p><code>GPM</code>是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p>
<ul>
<li><code>G</code>很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</li>
<li><code>P</code><br />
管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</li>
<li><code>M（machine）</code>是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系，<br />
一个groutine最终是要放到M上执行的；</li>
</ul>
<p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G<br />
挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p>
<p>P的个数是通过<code>runtime.GOMAXPROCS</code>设定（最大256），Go1.5版本之后默认为物理线程数。<br />
在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p>
<p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，<code>goroutine</code><br />
则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:<br />
n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的，<br />
不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池，<br />
不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。<br />
另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上，<br />
再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p>
<h3 id="gomaxprocs"><a class="markdownIt-Anchor" href="#gomaxprocs"></a> GOMAXPROCS</h3>
<p>Go运行时的调度器使用<code>GOMAXPROCS</code><br />
参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:<br />
n调度中的n）。</p>
<p>Go语言中可以通过<code>runtime.GOMAXPROCS()</code>函数设置当前程序并发时占用的CPU逻辑核心数。</p>
<p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p>
<h2 id="goroutine的创建"><a class="markdownIt-Anchor" href="#goroutine的创建"></a> goroutine的创建</h2>
<p>使用<code>goroutine</code>非常简单，只需要在调用函数的时在函数名前面加上<code>go</code><br />
关键字，就可以为一个函数创建一个<code>goroutine</code>。</p>
<p>一个<code>goroutine</code>必定对应一个函数，当然也可以创建多个<code>goroutine</code>去执行相同的函数。</p>
<p>语法如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">go</span> 函数()[普通函数和匿名函数即可]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你此时兴致勃勃的想立马试试，我只想和你说，“少侠，请稍等～”，我话还没说完。以上我只说了如何创建<code>goroutine</code><br />
，可没说这样就是这样用的。嘻嘻～</p>
<p>首先我们先看看不用<code>goroutine</code>的代码，示例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"># example</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">example</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> <span class="comment">//fmt.Println(&quot;HelloWord~, stamp is&quot;, i)</span></span><br><span class="line"> time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// normal</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> startTime := time.Now()</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  example(i)</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Println(<span class="string">&quot;Main~&quot;</span>)</span><br><span class="line"> spendTime := time.Since(startTime)</span><br><span class="line"> fmt.Println(<span class="string">&quot;Spend Time:&quot;</span>, spendTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输入结果如下</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnalxc9lv8j31hk0oet9n.jpg" alt="" /></p>
</blockquote>
<p>那么我们来使用<code>goroutine</code>，运行</p>
<p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> &quot;fmt&quot;</span><br><span class="line"> &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func example(i int) &#123;</span><br><span class="line"> fmt.Println(&quot;HelloWord~, stamp is&quot;, i)</span><br><span class="line"> time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// normal</span><br><span class="line">func main() &#123;</span><br><span class="line"> startTime := time.Now()</span><br><span class="line"> // 创建十个goroutine</span><br><span class="line"> for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">  go example(i)</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Println(&quot;Main~&quot;)</span><br><span class="line"> spendTime := time.Since(startTime)</span><br><span class="line"> fmt.Println(&quot;Spend Time:&quot;, spendTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出如下</p>
<img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnalzq72m1j30zk0u0q56.jpg" style="zoom:50%;" />
</blockquote>
<p>乍一看，好家伙速度提升了简直不是一个量级啊，秒啊～</p>
<p>仔细看你会发现，7,9 跑去哪儿呢？不见了，盯～</p>
<p>谜底在下一篇揭晓～</p>
<p>期待下一篇，盘点Golang并发那些事儿之二，<code>goroutine</code>并发控制得心应手</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>盘点go并发那些事儿之二-并发控制得心应手</title>
    <url>/37640.html</url>
    <content><![CDATA[<h2 id="盘点golang并发那些事儿之二"><a class="markdownIt-Anchor" href="#盘点golang并发那些事儿之二"></a> 盘点Golang并发那些事儿之二</h2>
<p>上一节提到，golang中直接使用关键字<code>go</code>创建<code>goroutine</code>,无法满足我们的需求。主要问题如下</p>
<ul>
<li>无法有效的并发执行完成</li>
<li>无法有效的控制并发</li>
</ul>
<p>首先我们再来看看下面这个栗子，代码如下</p>
<span id="more"></span>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example-goroutine anonymous</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anonymous1</span><span class="params">()</span></span> &#123;</span><br><span class="line"> startTime := time.Now()</span><br><span class="line"> <span class="comment">// 创建十个goroutine</span></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;HelloWord~, stamp is&quot;</span>, i)</span><br><span class="line">  &#125;()</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Println(<span class="string">&quot;Main~&quot;</span>)</span><br><span class="line"> spendTime := time.Since(startTime)</span><br><span class="line"> fmt.Println(<span class="string">&quot;Spend Time:&quot;</span>, spendTime)</span><br><span class="line"> <span class="comment">// 防止goroutine提前退出</span></span><br><span class="line"> <span class="comment">// time.Sleep(time.Second)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// goroutine anonymous</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> anonymous2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnbcfbzjn2j31890u0wgd.jpg" style="zoom:25%;" />
<p>此时你会发现有些任务被多次执行了，但有些任务却又没有被执行。以上例子虽加速了运行，但带来的损失却也是巨大的。例如银行转账等，一旦出现以上情况多次付款也随之而来了。弊大于利</p>
<p>首先我们来分析以上代码，为什么会出现此种情况？虽然是个废品，但也是俺辛辛苦苦的写的不是，让俺做个明白鬼。</p>
<img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnbcxvhqt1j30oc0s0q33.jpg" style="zoom:50%;" />
<p>我们从里面往外分析<code>anonymous1</code>首先他是个匿名函数 + 立即执行函数，且变量<code>i</code><br />
并不是传递的参数，而是外部循环带进来的。由上图，我们知道，执行流程为先创建goroutine，执行逻辑，返回结果。</p>
<blockquote>
<p>请思考：</p>
<p>goroutine，越多越好么？为什么</p>
<p>如何避免以上情景？如何避免提前退出？</p>
</blockquote>
<h2 id="信道-channel"><a class="markdownIt-Anchor" href="#信道-channel"></a> 信道-Channel</h2>
<p>信道的英文是channel，在golang当中的关键字是chan。它的用途是用来<strong>在goroutine之间传输数据</strong><br />
，这里你可能要问了，为什么一定得是goroutine之间传输数据呢，函数之间传递不行吗？</p>
<p>因为正常的传输数据直接以参数的形式传递就可以了，只有在并发场景当中，多个线程彼此隔离的情况下，才需要一个特殊的结构传输数据。</p>
<p>Go语言的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡<strong>通过通信共享内存</strong>而不是*<br />
<em>通过共享内存而实现通信</em>*。</p>
<p>如果说<code>goroutine</code>是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<code>channel</code>是可以让一个<code>goroutine</code><br />
发送特定值到另一个<code>goroutine</code>的通信机制。</p>
<p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First<br />
Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p>
<blockquote>
<p>channel底层的实现为互斥锁</p>
</blockquote>
<h3 id="example"><a class="markdownIt-Anchor" href="#example"></a> example</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量 <span class="keyword">chan</span> 元素类型</span><br><span class="line"><span class="comment">// example-var</span></span><br><span class="line"><span class="comment">// 只声明</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> <span class="type">byte</span></span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">chan</span> []<span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">chan</span> []<span class="type">int</span></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line">a = <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//example-2(推荐使用)</span></span><br><span class="line">管道名称 := <span class="built_in">make</span>(<span class="keyword">chan</span> 数据类型 [缓冲区size])</span><br></pre></td></tr></table></figure>
<h3 id="无缓冲channel"><a class="markdownIt-Anchor" href="#无缓冲channel"></a> 无缓冲channel</h3>
<p>示例代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(intCh &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;Hello, Gopher. I am stamp[Id]&quot;</span>, &lt;-intCh)</span><br><span class="line"> time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> startTime := time.Now()</span><br><span class="line"> <span class="keyword">const</span> jobNumber = <span class="number">100</span> * <span class="number">100</span></span><br><span class="line"> <span class="comment">// create chan</span></span><br><span class="line"> intCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= jobNumber; i++ &#123;</span><br><span class="line">  <span class="comment">// create goroutine same number for jobNumber</span></span><br><span class="line">  <span class="keyword">go</span> hello(intCh)</span><br><span class="line">  intCh &lt;- i</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Println(<span class="string">&quot;Completed, Spend Time :&quot;</span>, time.Since(startTime))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnbiwoqycdj312e0u0mzi.jpg" style="zoom:50%;" />
<p>这速度可谓是非常的快啊</p>
<h3 id="带缓冲channel"><a class="markdownIt-Anchor" href="#带缓冲channel"></a> 带缓冲Channel</h3>
<p>带缓冲的 channel(buffered channel) 是一种在被接收前能存储一个或者多个值的通道。这种类型的通道并不强制要求<br />
goroutine<br />
之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也会不同。只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。这导致有缓冲的通道和无缓冲的通道之间的一个很大的不同：</p>
<p><strong>无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的通道没有这种保证</strong></p>
<p>来段代码压压惊</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(intCh &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;Hello, Gopher. I am stamp[Id]&quot;</span>, &lt;-intCh)</span><br><span class="line"> time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello1</span><span class="params">(intCh &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;Hello, Gopher1. I am stamp[Id]&quot;</span>, &lt;-intCh)</span><br><span class="line"> time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> startTime := time.Now()</span><br><span class="line"> <span class="keyword">const</span> jobNumber = <span class="number">100</span> * <span class="number">100</span></span><br><span class="line"> <span class="comment">// create chan</span></span><br><span class="line"> intCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= jobNumber; i++ &#123;</span><br><span class="line">  <span class="comment">// create goroutine same number for jobNumber</span></span><br><span class="line">  <span class="keyword">go</span> hello(intCh)</span><br><span class="line">  <span class="keyword">go</span> hello1(intCh)</span><br><span class="line">  intCh &lt;- i</span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Println(<span class="string">&quot;Completed, Spend Time :&quot;</span>, time.Since(startTime))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行效果如下</p>
<img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnbjwzeu0mj31bn0u0q55.jpg" style="zoom:50%;" />
<p>这速度杠杠滴哈，别急，同时也让我和你说执行流程，老规矩，上图</p>
<img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnbk988aw2j30o00oajrf.jpg" style="zoom:50%;" />
<p>首先开始执行把需要传递的数据打到channle里面，然后goroutine去取，执行。那么有留下几个问题</p>
<blockquote>
<p>还可以加速么？</p>
<p>加速的方法？</p>
<p>可能带来什么新的问题？</p>
<p>如何解决？</p>
</blockquote>
<h3 id="单向-channel"><a class="markdownIt-Anchor" href="#单向-channel"></a> 单向 channel</h3>
<p>有时候，我们有一些特殊的业务需求，比如限制一个 channel 只可以接收但是不能发送，或者限制一个 channel<br />
只能发送但不能接收，这种 channel 称为单向 channel。</p>
<p>单向 channel 的声明也很简单，只需要在声明的时候带上 &lt;- 操作符即可，如下面的代码所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">onlySend := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span><br><span class="line">onlyReceive:=<span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<p>使用单向 channel 的较多场景一般在函数参数中使用较多，这样可以防止一些操作影响了 channel。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//example channel</span></span><br><span class="line">onlySend := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span><br><span class="line">onlyReceive:=<span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//example function</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exs</span><span class="params">(accept &lt;-<span class="keyword">chan</span> <span class="type">int</span>, recipient <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> result := <span class="keyword">range</span> accept &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Received only sent channel a:&quot;</span>, result)</span><br><span class="line">  recipient &lt;- result + <span class="number">2</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//fmt.Println(&quot;Send Only&quot;, recipient)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">const</span> processNumber = <span class="number">100</span></span><br><span class="line"> sender := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, processNumber)</span><br><span class="line"> recipient := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, processNumber)</span><br><span class="line"> <span class="keyword">for</span> e := <span class="number">0</span>; e &lt; <span class="number">10</span>; e++ &#123;</span><br><span class="line">  <span class="keyword">go</span> exs(sender, recipient)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> s := <span class="number">0</span>; s &lt; processNumber; s++ &#123;</span><br><span class="line">  sender &lt;- s</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> r := <span class="number">0</span>; r &lt; processNumber; r++ &#123;</span><br><span class="line">  <span class="comment">//&lt;-recipient</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;recipient&quot;</span>, &lt;-recipient)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小技巧：箭头该谁指谁?这可把我整的不好了，别慌，我告诉你，到底该谁指谁。其实很简单</p>
<p>箭头一致向左指</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a &lt;- chan &lt;- b</span><br><span class="line"></span><br><span class="line">// 存入</span><br><span class="line">chan &lt;- b</span><br><span class="line"></span><br><span class="line">// 取出</span><br><span class="line">a := &lt;- chan </span><br></pre></td></tr></table></figure>
<p>Chan其实就是起到一个中间人的作用，箭头指向chan，那就是放入，chan指出去 就是拿出来。</p>
<p>相信你应该记住了吧，反正我记住了</p>
</blockquote>
<h3 id="多路复用channel"><a class="markdownIt-Anchor" href="#多路复用channel"></a> 多路复用Channel</h3>
<p>假设要从网上下载一个文件，启动了 5个 goroutine 进行下载，并把结果发送到 5 个 channel<br />
中。其中，哪个先下载好，就会使用哪个 channel 的结果。</p>
<p>在这种情况下，如果我们尝试获取第一个 channel 的结果，程序就会被阻塞，无法获取剩下4个 channel<br />
的结果，也无法判断哪个先下载好。这个时候就需要用到多路复用操作了，在 Go 语言中，通过 select<br />
语句可以实现多路复用，其语句格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> data := &lt;-ch2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> ch3&lt;-data:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        默认操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体结构和 switch 非常像，都有 case 和 default，只不过 select 的 case 是一个个可以操作的 channel。</p>
<blockquote>
<p>小提示：多路复用可以简单地理解为，N 个 channel 中，任意一个 channel 有数据产生，select 都可以监听到，然后执行相应的分</p>
<p>支，接收数据并处理。</p>
<p>使用<code>select</code>语句能提高代码的可读性。</p>
<ul>
<li>可处理一个或多个channel的发送/接收操作。</li>
<li>如果多个<code>case</code>同时满足，<code>select</code>会随机选择一个。</li>
<li>对于没有<code>case</code>的<code>select&#123;&#125;</code>会一直等待，可用于阻塞main函数。</li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example select</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        c1 &lt;- <span class="string">&quot;one&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        c2 &lt;- <span class="string">&quot;two&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> msg1 := &lt;-c1:</span><br><span class="line">            fmt.Println(<span class="string">&quot;received&quot;</span>, msg1)</span><br><span class="line">        <span class="keyword">case</span> msg2 := &lt;-c2:</span><br><span class="line">            fmt.Println(<span class="string">&quot;received&quot;</span>, msg2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结：关于数据流动、传递等情况的优先使用<code>channle</code>， 它是并发安全的，且性能优异</p>
<h2 id="sync深入并发控制"><a class="markdownIt-Anchor" href="#sync深入并发控制"></a> Sync深入并发控制</h2>
<h3 id="syncwaitgroup"><a class="markdownIt-Anchor" href="#syncwaitgroup"></a> sync.waitGroup</h3>
<p>在此之前我们先去，解决一个开启<code>goroutine</code>，提前退出的例子</p>
<p>示例代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> &quot;fmt&quot;</span><br><span class="line"> &quot;sync&quot;</span><br><span class="line"> //&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line">func main() &#123;</span><br><span class="line"> for i := 0; i &lt; 10 ; i++ &#123;</span><br><span class="line">  go exampleOut(i)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func exampleOut(i int)  &#123;</span><br><span class="line"> fmt.Println(&quot;Hello, Gopher, I am [Id]&quot;, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnbroyfdoyj319q0u00ue.jpg" style="zoom:50%;" />
<p>仔细看，你会发现根本就没有输出，原因是它开启<code>goroutine</code><br />
，也需要时间。main函数并会等待，当然我们也可以手动添加一个停止，但这个并不能有效的阻止(<br />
你我都知道需要多久才能把<code>goroutine</code>执行完成),那有没有办法。。。</p>
<p>答案当然是有滴，它就是<code>sync.WaitGroup</code></p>
<blockquote></blockquote>
<p>WaitGroup等待goroutine的集合完成。主goroutine调用添加以设置要等待的goroutine的数量。然后，每个goroutine都会运行并在完成后调用Done。同时，可以使用Wait来阻塞，直到所有goroutine完成。</p>
<blockquote>
<p>你可以理解为计数器</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `sync.WaitGroup`一共有三个方法,他们分别是：</span></span><br><span class="line">Add(delta <span class="type">int</span>)</span><br><span class="line"><span class="comment">//Add将可能为负数的增量添加到WaitGroup计数器中。如果计数器为零，则释放等待时阻塞的所有goroutine</span></span><br><span class="line">Done()</span><br><span class="line"><span class="comment">// 完成将WaitGroup计数器减一。</span></span><br><span class="line"> Wait()</span><br><span class="line"><span class="comment">// 等待块，直到WaitGroup计数器为零。</span></span><br></pre></td></tr></table></figure>
<p>example</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WaitGroup</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明WaitGroup</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  <span class="comment">// WaitGroup 计数器 + 1</span></span><br><span class="line">  <span class="comment">// 其delta为你开启的`groutine`数量</span></span><br><span class="line">  wg.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> exampleOut(i)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 等待 WaitGroup 计数器为0</span></span><br><span class="line"> wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exampleOut</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> <span class="comment">// WaitGroup 计数器 - 1</span></span><br><span class="line"> wg.Done()</span><br><span class="line"> fmt.Println(<span class="string">&quot;Hello, Gopher, I am [Id]&quot;</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="syncmutex"><a class="markdownIt-Anchor" href="#syncmutex"></a> sync.Mutex</h3>
<p>无论是前面的<code>channle</code>还是sync都是为了干一件事，那就是并发控制，也许你也和我一样有以下几个问题</p>
<ul>
<li>我们为什么需要并发控制，不要可以么？</li>
<li>并发控制到底是控制什么？</li>
<li>并发控制有哪几种方案，他们分别适用于哪种场景？</li>
<li>如何做好并发控制呢？</li>
</ul>
<p>以上几点就是我们此节需要了解、以及解决的问题</p>
<p>首先解决我们一起探究第一个问题，为什么需要并发控制？</p>
<p>首先有这么一个问题、以及相关的解决措施，绝对不是脱裤子放屁，多此一举。需要并发控制的原因有很多，总结一句话那就是资源竞争</p>
<blockquote>
<p>资源竞争</p>
<p>在一个 goroutine 中，如果分配的内存没有被其他 goroutine 访问，只在该 goroutine 中被使用，那么不存在资源竞争的问题。</p>
<p>但如果同一块内存被多个 goroutine 同时访问，就会产生不知道谁先访问也无法预料最后结果的情况。这就是资源竞争，这块内存可以称为共享的资源</p>
<p>还记得在channel中，我讲到 Go语言的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡*<br />
<em>通过通信共享内存<strong>而不是</strong>通过共享内存而实现通信</em>*，这点尤为重要需要我们去记住与掌握</p>
</blockquote>
<p>首先我们来看一个累加求和的例子，代码如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"> x <span class="type">int64</span></span><br><span class="line"> wg sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">  x = x + <span class="number">1</span></span><br><span class="line"> &#125;</span><br><span class="line"> wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> wg.Add(<span class="number">5</span>)</span><br><span class="line"> <span class="keyword">go</span> add()</span><br><span class="line"> <span class="keyword">go</span> add()</span><br><span class="line"> <span class="keyword">go</span> add()</span><br><span class="line"> <span class="keyword">go</span> add()</span><br><span class="line"> <span class="keyword">go</span> add()</span><br><span class="line"> wg.Wait()</span><br><span class="line"> fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>期待输出值为<code>25000</code>，sum + 10 加和 5000次,执行五次，我们口算答案是<code>5000</code>,可输出结果却是<code>3048</code><br />
,而且每次答案还不一样。好家伙</p>
<img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnbt36anhqj319i0u0q43.jpg" style="zoom:50%;" />
<p>这是为什么呢?,靓仔疑惑～</p>
<p>其根本的原因就是资源恶意竞争</p>
<blockquote>
<p>精囊妙计：</p>
<p>使用 go build、go run、go test 这些 Go 语言工具链提供的命令时，添加 -race 标识可以帮你检查 Go<br />
语言代码是否存在资源竞争。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">go</span> run -race demo3.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>那么该怎么解决呢？</p>
<p><code>sync.Mutex</code>互斥锁，顾名思义，指的是在同一时刻只有一个<code>goroutine</code>执行某段代码，其他<code>goroutine</code><br />
都要等待该<code>goroutine</code>执行完毕后才能继续执行。</p>
<p>在下面的示例中，我声明了一个互斥锁 mutex，然后修改 add 函数，对 sum+=i<br />
这段代码加锁保护。这样这段访问共享资源的代码片段就并发安全了，可以得到正确的结果</p>
<p><code>sync.Mutex</code>为我们提供了两个方法，加锁与解锁,修改时先获取锁，修改后释放锁</p>
<p>代码修改如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"> x    <span class="type">int64</span></span><br><span class="line"> lock sync.Mutex</span><br><span class="line"> wg   sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">  lock.Lock() <span class="comment">// 加锁</span></span><br><span class="line">  x += <span class="number">1</span></span><br><span class="line">  lock.Unlock() <span class="comment">// 解锁</span></span><br><span class="line"> &#125;</span><br><span class="line"> wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> wg.Add(<span class="number">5</span>)</span><br><span class="line"> <span class="keyword">go</span> add()</span><br><span class="line"> <span class="keyword">go</span> add()</span><br><span class="line"> <span class="keyword">go</span> add()</span><br><span class="line"> <span class="keyword">go</span> add()</span><br><span class="line"> <span class="keyword">go</span> add()</span><br><span class="line"> wg.Wait()</span><br><span class="line"> fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>女少啊～</p>
<blockquote>
<p>在以上示例代码中<code>x += 1</code>，部分被称之为临界区</p>
</blockquote>
<p>在同步的程序设计中，临界区段指的是一个访问共享资源的程序片段，而这些共享资源又有无法同时被多个<code>goroutine</code><br />
访问的特性。 当有协程进入临界区段时，其他协程必须等待，这样就保证了临界区的并发安全。</p>
<h3 id="syncrwmutex"><a class="markdownIt-Anchor" href="#syncrwmutex"></a> sync.RWMutex</h3>
<p>互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用<code>sync</code><br />
包中的<code>RWMutex</code>类型。</p>
<p>读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的<code>goroutine</code><br />
如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个<code>goroutine</code>获取写锁之后，其他的<code>goroutine</code><br />
无论是获取读锁还是写锁都会等待。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line"> x      <span class="type">int64</span></span><br><span class="line"> wg     sync.WaitGroup</span><br><span class="line"> lock   sync.Mutex</span><br><span class="line"> rwlock sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// lock.Lock()              // 加互斥锁</span></span><br><span class="line"> rwlock.Lock()             <span class="comment">// 加写锁</span></span><br><span class="line"> x = x + <span class="number">1</span></span><br><span class="line"> time.Sleep(<span class="number">10</span> * time.Millisecond)   <span class="comment">// 假设读操作耗时10毫秒</span></span><br><span class="line"> rwlock.Unlock()                     <span class="comment">// 解写锁</span></span><br><span class="line"> <span class="comment">// lock.Unlock()                      // 解互斥锁</span></span><br><span class="line"> wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// lock.Lock()                     // 加互斥锁</span></span><br><span class="line"> rwlock.RLock()                    <span class="comment">// 加读锁</span></span><br><span class="line"> time.Sleep(<span class="number">1</span>)             <span class="comment">// 假设读操作耗时1秒</span></span><br><span class="line"> rwlock.RUnlock()                  <span class="comment">// 解读锁</span></span><br><span class="line"> <span class="comment">// lock.Unlock()                   // 解互斥锁</span></span><br><span class="line"> wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> start := time.Now()</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  wg.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> write()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">  wg.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> read()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> wg.Wait()</span><br><span class="line"> end := time.Now()</span><br><span class="line"> fmt.Println(end.Sub(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们解决了多个 goroutine 同时读写的资源竞争问题，但是又遇到另外一个问题——性能。因为每次读写共享资源都要加锁，所以性能低下，这该怎么解决呢？</p>
<p>现在我们分析读写这个特殊场景，有以下几种情况：</p>
<ol>
<li>写的时候不能同时读，因为这个时候读取的话可能读到脏数据（不正确的数据）；</li>
<li>读的时候不能同时写，因为也可能产生不可预料的结果；</li>
<li>读的时候可以同时读，因为数据不会改变，所以不管多少个 goroutine 读都是并发安全的。</li>
</ol>
<p>所以就可以通过读写锁 sync.RWMutex 来优化这段代码，提升性能。</p>
<h3 id="synconce"><a class="markdownIt-Anchor" href="#synconce"></a> sync.Once</h3>
<p>在实际的工作中，你可能会有这样的需求：让代码只执行一次，哪怕是在高并发的情况下，比如创建一个单例。</p>
<p>针对这种情形，Go 语言为我们提供了 sync.Once 来保证代码只执行一次，例如只加载一次配置文件、只关闭一次通道等。</p>
<p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案–<code>sync.Once</code>。</p>
<p><code>sync.Once</code>只有一个<code>Do</code>方法，其签名如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 如果要执行的函数f需要传递参数就需要搭配闭包来使用。</span></span><br></pre></td></tr></table></figure>
<p>这是 Go 语言自带的一个示例，虽然启动了 10 个<code>goroutine</code>来执行 onceBody 函数，但是因为用了 <span class="exturl" data-url="aHR0cDovL29uY2UuRG8=">once.Do<i class="fa fa-external-link-alt"></i></span><br />
方法，所以函数 onceBody 只会被执行一次。也就是说在高并发的情况下，sync.Once 也会保证<br />
onceBody 函数只执行一次。</p>
<p>sync.Once 适用于创建某个对象的单例、只加载一次的资源等只执行一次的场景。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// example</span><br><span class="line">func main() &#123;</span><br><span class="line">   doOnce()</span><br><span class="line">&#125;</span><br><span class="line">func doOnce() &#123;</span><br><span class="line">   var once sync.Once</span><br><span class="line">   onceBody := func() &#123;</span><br><span class="line">      fmt.Println(&quot;Only once&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">   //用于等待`goroutine`执行完毕</span><br><span class="line">   done := make(chan bool)</span><br><span class="line">   //启动10个协程执行once.Do(onceBody)</span><br><span class="line">   for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">      go func() &#123;</span><br><span class="line">         //把要执行的函数(方法)作为参数传给once.Do方法即可</span><br><span class="line">         once.Do(onceBody)</span><br><span class="line">         done &lt;- true</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line">   for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">      &lt;-done</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="syncmap"><a class="markdownIt-Anchor" href="#syncmap"></a> sync.Map</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var m = make(map[string]int)</span><br><span class="line"></span><br><span class="line">func get(key string) int &#123;</span><br><span class="line"> return m[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func set(key string, value int) &#123;</span><br><span class="line"> m[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"> wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"> for i := 0; i &lt; 20; i++ &#123;</span><br><span class="line">  wg.Add(1)</span><br><span class="line">  go func(n int) &#123;</span><br><span class="line">   key := strconv.Itoa(n)</span><br><span class="line">   set(key, n)</span><br><span class="line">   fmt.Printf(&quot;k=:%v,v:=%v\n&quot;, key, get(key))</span><br><span class="line">   wg.Done()</span><br><span class="line">  &#125;(i)</span><br><span class="line"> &#125;</span><br><span class="line"> wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码开启少量几个<code>goroutine</code>的时候可能没什么问题，当并发多了之后执行上面的代码就会报错误。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnbtrqdjtaj31ak0u0gng.jpg" alt="" /></p>
<p>像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的<code>sync</code><br />
包中提供了一个开箱即用的并发安全版map–<code>sync.Map</code><br />
。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时<code>sync.Map</code><br />
内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p>
<p>一个简单的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">  wg.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   key := strconv.Itoa(n)</span><br><span class="line">   m.Store(key, n)</span><br><span class="line">   value, _ := m.Load(key)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;k=:%v,v:=%v\n&quot;</span>, key, value)</span><br><span class="line">   wg.Done()</span><br><span class="line">  &#125;(i)</span><br><span class="line"> &#125;</span><br><span class="line"> wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原子操作"><a class="markdownIt-Anchor" href="#原子操作"></a> 原子操作</h3>
<p>代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库<code>sync/atomic</code><br />
提供。</p>
<h4 id="atomic包"><a class="markdownIt-Anchor" href="#atomic包"></a> atomic包</h4>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">func LoadInt32(addr <em>int32) (val int32) func LoadInt64(addr</em>int64) (val int64) func LoadUint32(addr <em>uint32) (val uint32) func LoadUint64(addr</em>uint64) (val uint64) func LoadUintptr(addr <em>uintptr) (val uintptr) func LoadPointer(addr</em>unsafe.Pointer) (val unsafe.Pointer)</td>
<td style="text-align:center">读取操作</td>
</tr>
<tr>
<td style="text-align:center">func StoreInt32(addr <em>int32, val int32) func StoreInt64(addr</em>int64, val int64) func StoreUint32(addr <em>uint32, val uint32) func StoreUint64(addr</em>uint64, val uint64) func StoreUintptr(addr <em>uintptr, val uintptr) func StorePointer(addr</em>unsafe.Pointer, val unsafe.Pointer)</td>
<td style="text-align:center">写入操作</td>
</tr>
<tr>
<td style="text-align:center">func AddInt32(addr <em>int32, delta int32) (new int32) func AddInt64(addr</em>int64, delta int64) (new int64) func AddUint32(addr <em>uint32, delta uint32) (new uint32) func AddUint64(addr</em>uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</td>
<td style="text-align:center">修改操作</td>
</tr>
<tr>
<td style="text-align:center">func SwapInt32(addr <em>int32, new int32) (old int32) func SwapInt64(addr</em>int64, new int64) (old int64) func SwapUint32(addr <em>uint32, new uint32) (old uint32) func SwapUint64(addr</em>uint64, new uint64) (old uint64) func SwapUintptr(addr <em>uintptr, new uintptr) (old uintptr) func SwapPointer(addr</em>unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</td>
<td style="text-align:center">交换操作</td>
</tr>
<tr>
<td style="text-align:center">func CompareAndSwapInt32(addr <em>int32, old, new int32) (swapped bool) func CompareAndSwapInt64(addr</em>int64, old, new int64) (swapped bool) func CompareAndSwapUint32(addr <em>uint32, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr</em>uint64, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr <em>uintptr, old, new uintptr) (swapped bool) func CompareAndSwapPointer(addr</em>unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</td>
<td style="text-align:center">比较并交换操作</td>
</tr>
</tbody>
</table>
<h4 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h4>
<p>我们填写一个示例来比较下互斥锁和原子操作的性能。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;sync&quot;</span></span><br><span class="line"> <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line"> <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">interface</span> &#123;</span><br><span class="line"> Inc()</span><br><span class="line"> Load() <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通版</span></span><br><span class="line"><span class="keyword">type</span> CommonCounter <span class="keyword">struct</span> &#123;</span><br><span class="line"> counter <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CommonCounter)</span></span> Inc() &#123;</span><br><span class="line"> c.counter++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CommonCounter)</span></span> Load() <span class="type">int64</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> c.counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁版</span></span><br><span class="line"><span class="keyword">type</span> MutexCounter <span class="keyword">struct</span> &#123;</span><br><span class="line"> counter <span class="type">int64</span></span><br><span class="line"> lock    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexCounter)</span></span> Inc() &#123;</span><br><span class="line"> m.lock.Lock()</span><br><span class="line"> <span class="keyword">defer</span> m.lock.Unlock()</span><br><span class="line"> m.counter++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexCounter)</span></span> Load() <span class="type">int64</span> &#123;</span><br><span class="line"> m.lock.Lock()</span><br><span class="line"> <span class="keyword">defer</span> m.lock.Unlock()</span><br><span class="line"> <span class="keyword">return</span> m.counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子操作版</span></span><br><span class="line"><span class="keyword">type</span> AtomicCounter <span class="keyword">struct</span> &#123;</span><br><span class="line"> counter <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AtomicCounter)</span></span> Inc() &#123;</span><br><span class="line"> atomic.AddInt64(&amp;a.counter, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AtomicCounter)</span></span> Load() <span class="type">int64</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> atomic.LoadInt64(&amp;a.counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(c Counter)</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"> start := time.Now()</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">  wg.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   c.Inc()</span><br><span class="line">   wg.Done()</span><br><span class="line">  &#125;()</span><br><span class="line"> &#125;</span><br><span class="line"> wg.Wait()</span><br><span class="line"> end := time.Now()</span><br><span class="line"> fmt.Println(c.Load(), end.Sub(start))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> c1 := CommonCounter&#123;&#125; <span class="comment">// 非并发安全</span></span><br><span class="line"> test(c1)</span><br><span class="line"> c2 := MutexCounter&#123;&#125; <span class="comment">// 使用互斥锁实现并发安全</span></span><br><span class="line"> test(&amp;c2)</span><br><span class="line"> c3 := AtomicCounter&#123;&#125; <span class="comment">// 并发安全且比互斥锁效率更高</span></span><br><span class="line"> test(&amp;c3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>atomic</code>包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。</p>
<h3 id="synccond"><a class="markdownIt-Anchor" href="#synccond"></a> sync.Cond</h3>
<blockquote>
<p>Cond实现了一个条件变量，它是goroutines等待或宣布事件发生的集合点。每个Cond都有一个关联的Locker<br />
L（通常是Mutex或RWMutex），在更改条件和调用Wait方法时必须将其保留。第一次使用后，不得复制条件</p>
</blockquote>
<p>在 Go 语言中，sync.WaitGroup 用于最终完成的场景，关键点在于一定要等待所有<code>goroutine</code>都执行完毕。</p>
<p>而 sync.Cond 可以用于发号施令，一声令下所有<code>goroutine</code>都可以开始执行，关键点在于<code>goroutine</code><br />
开始的时候是等待的，要等待 sync.Cond 唤醒才能执行。</p>
<p>sync.Cond 从字面意思看是条件变量，它具有阻塞协程和唤醒协程的功能，所以可以在满足一定条件的情况下唤醒协程，但条件变量只是它的一种使用场景。</p>
<p>sync.Cond 有三个方法，它们分别是：</p>
<ol>
<li><strong>Wait</strong>，Wait原子地解锁c.L并中止调用goroutine的执行。稍后恢复执行后，等待锁定c.L才返回。与其他系统不同，等待不会返回，除非被广播或信号唤醒。</li>
<li><strong>Signal</strong>，信号唤醒一个等待在c的goroutin</li>
<li><strong>Broadcast</strong>，唤醒所有等待c的goroutine</li>
</ol>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> &quot;fmt&quot;</span><br><span class="line"> &quot;sync&quot;</span><br><span class="line"> &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//10个人赛跑，1个裁判发号施令</span><br><span class="line">func race() &#123;</span><br><span class="line"> cond := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line"> var wg sync.WaitGroup</span><br><span class="line"> wg.Add(11)</span><br><span class="line"> for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">  go func(num int) &#123;</span><br><span class="line">   defer wg.Done()</span><br><span class="line">   fmt.Println(num, &quot;号已经就位&quot;)</span><br><span class="line">   cond.L.Lock()</span><br><span class="line">   cond.Wait() //等待发令枪响</span><br><span class="line">   fmt.Println(num, &quot;号开始跑……&quot;)</span><br><span class="line">   cond.L.Unlock()</span><br><span class="line">  &#125;(i)</span><br><span class="line"> &#125;</span><br><span class="line"> //等待所有goroutine都进入wait状态</span><br><span class="line"> time.Sleep(2 * time.Second)</span><br><span class="line"> go func() &#123;</span><br><span class="line">  defer wg.Done()</span><br><span class="line">  fmt.Println(&quot;裁判已经就位，准备发令枪&quot;)</span><br><span class="line">  fmt.Println(&quot;比赛开始，大家准备跑&quot;)</span><br><span class="line">  cond.Broadcast() //发令枪响</span><br><span class="line"> &#125;()</span><br><span class="line"> //防止函数提前返回退出</span><br><span class="line"> wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>这一节我们巴拉巴拉搞了很多，到底什么情况用哪个。相信你也可能和我一样半懵半醒，那么我们来总结一下。他们的使用场景,啥是啥？</p>
<p>需知：<strong>goroutine与线程</strong></p>
<ul>
<li>Go语言的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡<strong>通过通信共享内存</strong>而不是*<br />
<em>通过共享内存而实现通信</em>*。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可增长的栈</span><br><span class="line">OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine的栈不是固定的，他可以按需增大和缩小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这么大。所以在Go语言中一次创建十万左右的goroutine也是可以的。</span><br><span class="line"></span><br><span class="line">goroutine调度</span><br><span class="line">GPM是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</span><br><span class="line"></span><br><span class="line">G很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</span><br><span class="line">P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</span><br><span class="line">M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</span><br><span class="line">P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</span><br><span class="line"></span><br><span class="line">P的个数是通过runtime.GOMAXPROCS设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</span><br></pre></td></tr></table></figure>
<p><strong>使用场景</strong></p>
<ul>
<li>
<p>Channel:关于数据流动、传递等情况的优先使用<code>channle</code>， 它是并发安全的，且性能优异, channel底层的实现为互斥锁</p>
</li>
<li>
<p>sync.Once：让代码只执行一次，哪怕是在高并发的情况下，比如创建一个单例。</p>
</li>
<li>
<p>Sync.WaitGroup:<br />
用于最终完成的场景，关键点在于一定要等待所有协程都执行完毕。有了它我们再也不用为了等待协程执行完成而添加<code>time.sleep</code><br />
了</p>
</li>
<li>
<p>Sync.Mutew: 当资源发现竞争时，我们可以使用<code>Sync.Mutew</code>，加互斥锁保证并发安全</p>
</li>
<li>
<p>Sync.RWMutew: <code>Sync.Mutew</code>进阶使用，当读多写少的时候，可以使用读写锁来保证并发安全，同时也提高了并发效率</p>
</li>
<li>
<p>sync.Map:高并发的情况下，原始的map并不安全，使用sync.Map可用让我们的map在并发情况下也保证安全</p>
</li>
<li>
<p>sync.Cond:sync.Cond 可以用于发号施令，一声令下所有<code>goroutine</code>都可以开始执行，关键点在于<code>goroutine</code><br />
开始的时候是等待的，要等待 sync.Cond 唤醒才能执行。</p>
</li>
</ul>
<p>说了这么多，这么多花里胡哨的，注意一点，Sync.Mutew，互斥锁，所有的锁的爸爸，原子操作。互斥锁的叔叔。</p>
<p>感谢您的阅读，如果感觉不错。也可以点赞、收藏、在读、当然推荐给身边的哥们也是不错的选择，同时欢迎关注我。一起从0到1</p>
<p>期待下一章节，铁索连环-context</p>
<p>以及下下章节：并发模式</p>
<p>我会在<code>并发模式</code>中与你探讨：</p>
<p><code>channle</code>缓存区多大比较合适,</p>
<p>Goroutine Work Pool，减少<code>Goroutine</code>过多重复的创建与销毁</p>
<p>Pipeline 模式：流水线工作模式，对任务中的部分进行剖析</p>
<p>扇出和扇入模式：对流水线工作模式进行优化，实现更高效的<code>扇出和扇入模式</code></p>
<p>Futures 模式:未来模式，主协程不用等待子协程返回的结果，可以先去做其他事情，等未来需要子协程结果的时候再来取</p>
<p>同时再一次去搞一下，到底什么是可异步、并发的代码，并加以分析与优化</p>
<p>未来已来。Let‘s Go～</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>秒懂二叉树遍历</title>
    <url>/24880.html</url>
    <content><![CDATA[<h2 id="brush-the-topic-binarytree"><a class="markdownIt-Anchor" href="#brush-the-topic-binarytree"></a> Brush the topic-BinaryTree</h2>
<p>大家好，这是Brush the topic的第一章节,BinaryTree。首先我说一下为什么把这个放在刷题的第一节呢？</p>
<p>原因如下:</p>
<ul>
<li>培养、训练自己的计算机的思维。</li>
<li>锻炼模版化，抽象化思维</li>
</ul>
<p>下面让我们一起去完成一个壮举，那就是完全解决二叉树的遍历问题，以及相关问题。are you ok？</p>
<h2 id="二叉树的遍历"><a class="markdownIt-Anchor" href="#二叉树的遍历"></a> 二叉树的遍历</h2>
<p>由于对于二叉树的遍历顺序不同，构造出三种不同的遍历方式</p>
<ul>
<li>前序遍历-根左右</li>
<li>中序遍历-左根右</li>
<li>后序遍历-左右根</li>
</ul>
<h3 id="递归代码模版如下"><a class="markdownIt-Anchor" href="#递归代码模版如下"></a> 递归代码模版如下</h3>
<p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前序遍历</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preOreder</span>(<span class="params">self, root</span>):</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        <span class="variable language_">self</span>.traverse_path.append(root.val)</span><br><span class="line">        preOreder(<span class="variable language_">self</span>.left)</span><br><span class="line">        preOreder(<span class="variable language_">self</span>.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中序遍历</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inOreder</span>(<span class="params">self, root</span>):</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        preOreder(<span class="variable language_">self</span>.left)</span><br><span class="line">        <span class="variable language_">self</span>.traverse_path.append(root.val)</span><br><span class="line">        preOreder(<span class="variable language_">self</span>.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 后序遍历</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">postOreder</span>(<span class="params">self, root</span>):</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        preOreder(<span class="variable language_">self</span>.left)</span><br><span class="line">        preOreder(<span class="variable language_">self</span>.right)</span><br><span class="line">        <span class="variable language_">self</span>.traverse_path.append(root.val)</span><br></pre></td></tr></table></figure>
<p><strong>Go</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preOreder</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">  result := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">  result  = <span class="built_in">append</span>(result, root.value)</span><br><span class="line">  preOreder(root.Left)</span><br><span class="line">  preOreder(root.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inOreder</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">  result := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">  preOreder(root.Left)</span><br><span class="line">  result  = <span class="built_in">append</span>(result, root.value)</span><br><span class="line">  preOreder(root.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postOreder</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">  result := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">  postOreder(root.Left)</span><br><span class="line">  postOreder(root.Right)</span><br><span class="line">  result  = <span class="built_in">append</span>(result, root.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="practice"><a class="markdownIt-Anchor" href="#practice"></a> practice</h3>
<p>基于此我们可以拿下以下题目,完全二叉树递归模版解题</p>
<h2 id="144-二叉树的前序遍历"><a class="markdownIt-Anchor" href="#144-二叉树的前序遍历"></a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtcHJlb3JkZXItdHJhdmVyc2FsLw==">144. 二叉树的前序遍历<i class="fa fa-external-link-alt"></i></span>-Python</h2>
<h3 id="recursive"><a class="markdownIt-Anchor" href="#recursive"></a> <strong>Recursive</strong></h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Recursive-1 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="variable language_">self</span>.helper(root, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">self, root, result</span>):</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span></span><br><span class="line">        result.append(root.val)</span><br><span class="line">        <span class="variable language_">self</span>.helper(root.left, result)</span><br><span class="line">        <span class="variable language_">self</span>.helper(root.right, result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Recursive-2 Another way Anonymous function</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">root: TreeNode</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            res.append(root.val)</span><br><span class="line">            helper(root.left)</span><br><span class="line">            helper(root.right)</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Recursive-3 more clean code</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        res.append(root.val)</span><br><span class="line">        res += <span class="variable language_">self</span>.preorderTraversal(root.left)</span><br><span class="line">        res += <span class="variable language_">self</span>.preorderTraversal(root.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="iterative"><a class="markdownIt-Anchor" href="#iterative"></a> <strong>Iterative</strong></h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution-1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack, result = [], []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                <span class="comment"># 前序遍历-根左右，先拿根</span></span><br><span class="line">                result.append(root.val)</span><br><span class="line">                <span class="comment"># 压栈</span></span><br><span class="line">                stack.append(root)</span><br><span class="line">                <span class="comment"># 拿完根之后拿左儿子</span></span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="comment"># 左儿子拿出来，拿右儿子</span></span><br><span class="line">            node = stack.pop()</span><br><span class="line">            root = node.right</span><br><span class="line">        <span class="comment"># # 完成</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution-2 简化Solution-1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack, result = [], []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                result.append(root.val)</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                root = node.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution-3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack, result = [root], []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            <span class="comment"># 拿出根</span></span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                <span class="comment"># 前序遍历拿出，先拿根的值                </span></span><br><span class="line">                result.append(node.val)</span><br><span class="line">                <span class="comment"># 模仿栈，先入后出。后拿右孩子</span></span><br><span class="line">                stack.append(node.right)</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="94-二叉树的中序遍历"><a class="markdownIt-Anchor" href="#94-二叉树的中序遍历"></a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtaW5vcmRlci10cmF2ZXJzYWwv">94. 二叉树的中序遍历<i class="fa fa-external-link-alt"></i></span>-Python</h2>
<h3 id="recursive-2"><a class="markdownIt-Anchor" href="#recursive-2"></a> <strong>Recursive</strong></h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Recursive-1 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="variable language_">self</span>.helper(root, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">self, root, result</span>):</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span></span><br><span class="line">        <span class="variable language_">self</span>.helper(root.left, result)</span><br><span class="line">        result.append(root.val)</span><br><span class="line">        <span class="variable language_">self</span>.helper(root.right, result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Recursive-2 Another way Anonymous function</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">root: TreeNode</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            helper(root.left)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            helper(root.right)</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Recursive-3 more clean code</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        res += <span class="variable language_">self</span>.preorderTraversal(root.left)</span><br><span class="line">        res.append(root.val)</span><br><span class="line">        res += <span class="variable language_">self</span>.preorderTraversal(root.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="iterative-2"><a class="markdownIt-Anchor" href="#iterative-2"></a> <strong>Iterative</strong></h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution - 1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        stack, result = [], []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            root = node.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution - 2 简化Solution-1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack, result = [], []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                result.append(node.val)</span><br><span class="line">                root = node.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution - 3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack, result = [], []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                result.append(node.val)</span><br><span class="line">                root = node.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="145-二叉树的后序遍历"><a class="markdownIt-Anchor" href="#145-二叉树的后序遍历"></a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtcG9zdG9yZGVyLXRyYXZlcnNhbC8=">145. 二叉树的后序遍历<i class="fa fa-external-link-alt"></i></span></h2>
<h3 id="recursive-3"><a class="markdownIt-Anchor" href="#recursive-3"></a> <strong>Recursive</strong></h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Recursive-1 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="variable language_">self</span>.helper(root, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">self, root, result</span>):</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span></span><br><span class="line">        <span class="variable language_">self</span>.helper(root.left, result)</span><br><span class="line">        <span class="variable language_">self</span>.helper(root.right, result)</span><br><span class="line">        result.append(root.val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Recursive-2 Another way Anonymous function</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">root: TreeNode</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            helper(root.left)</span><br><span class="line">            helper(root.right)</span><br><span class="line">            res.append(root.val)</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Recursive-3 more clean code</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        res += <span class="variable language_">self</span>.preorderTraversal(root.left)</span><br><span class="line">        res += <span class="variable language_">self</span>.preorderTraversal(root.right)</span><br><span class="line">        res.append(root.val)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="iterative-3"><a class="markdownIt-Anchor" href="#iterative-3"></a> <strong>Iterative</strong></h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Solution - 1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack, result = [], []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                result.append(root.val)</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.right</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            root = node.left</span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution - 2    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack, result = [], []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                result.append(root.val)</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                root = node.left</span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution - 3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        stack, result = [root], []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                result.append(node.val)</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>二叉树迭代遍历模版-Python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 前序遍历</span></span><br><span class="line"><span class="comment"># Solution-1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        stack, result = [], []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                result.append(root.val)</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            tmp = stack.pop()</span><br><span class="line">            root = tmp.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        stack, result = [], []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            root = node.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>由递归到迭代，基本的思想就是由递归中由系统维护的栈，转为手动维护。</p>
]]></content>
      <categories>
        <category>bin-tree</category>
        <category>algo</category>
      </categories>
      <tags>
        <tag>bin-tree</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-复杂度分析</title>
    <url>/51143.html</url>
    <content><![CDATA[<p>算法其核心主要思考的是快和省的问题，而算法复杂度可细分为<strong>时间复杂度</strong>和<strong>空间复杂度</strong><br />
。时间复杂度是指执行所需要的工作量，空间复杂度是指执行所需要的<strong>内存</strong>空间。</p>
<h2 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h2>
<h3 id="big-o-notation"><a class="markdownIt-Anchor" href="#big-o-notation"></a> Big O Notation</h3>
<p>所有代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = O(f(n))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
<p>这就是大 O 时间复杂度表示法。</p>
<p>大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic<br />
time complexity），简称时间复杂度。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gxp9wibw53j30oa0gcdh3.jpg" alt="image-20211224220519869" /></p>
<h3 id="常见时间复杂度"><a class="markdownIt-Anchor" href="#常见时间复杂度"></a> 常见时间复杂度</h3>
<blockquote>
<p>从小到大</p>
</blockquote>
<table>
<thead>
<tr>
<th>T(n)</th>
<th>desc</th>
</tr>
</thead>
<tbody>
<tr>
<td>$$O(1)$$</td>
<td>Constant Complexity（常数复杂度）</td>
</tr>
<tr>
<td>$$O（log n）$$</td>
<td>Logarithmic Complexity（对数复杂度）</td>
</tr>
<tr>
<td>$$O（n）$$</td>
<td>Linear Complexity（线性复杂度）</td>
</tr>
<tr>
<td>$$O（n ^ 2）$$</td>
<td>N Square Complexity（平方复杂度）</td>
</tr>
<tr>
<td>$$O（n ^ 3）$$</td>
<td>N cubic Complexity（立方复杂度）</td>
</tr>
<tr>
<td>$$O（2 ^ n）$$</td>
<td>Exponential Growth(指数)</td>
</tr>
<tr>
<td>$$O（n!）$$</td>
<td>Factorial (阶乘)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>并列相加，嵌套相乘</p>
<p>每次折半log N,递归<strong>一般</strong>为指数</p>
</blockquote>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gxpaoxdc8yj30ki04y0tg.jpg" alt="image-20211224223240782" /></p>
<h3 id="时间复杂度分析"><a class="markdownIt-Anchor" href="#时间复杂度分析"></a> 时间复杂度分析</h3>
<ol>
<li>只关注循环执行次数最多代码块</li>
<li>加法原则：总复杂度等于量级最大的代码块的复杂度</li>
<li>乘法原则：嵌套代码的复杂度等于嵌套内外代码块复杂度的乘积</li>
</ol>
<h4 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h4>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">y = <span class="number">2</span></span><br><span class="line">z = x + y</span><br></pre></td></tr></table></figure>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log _ n) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">100</span>):</span><br><span class="line">    i *= <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">y = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (x &lt;= <span class="number">100</span>):</span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (x &lt;= <span class="number">1000</span>):</span><br><span class="line">    y += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m * n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, x + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;y&#125;</span> ^ <span class="subst">&#123;x&#125;</span> = <span class="subst">&#123;x * y&#125;</span>&quot;</span>, end=<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, x + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;y&#125;</span> ^ <span class="subst">&#123;x&#125;</span> = <span class="subst">&#123;x * y&#125;</span>&quot;</span>, end=<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tip: x 为长， y 为高</p>
</blockquote>
<h3 id="最好-最坏-平均复杂度"><a class="markdownIt-Anchor" href="#最好-最坏-平均复杂度"></a> 最好、最坏、平均复杂度</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_Girl</span>(<span class="params">girl: <span class="built_in">list</span>[<span class="built_in">int</span>], number: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    i, pos, n = <span class="number">0</span>, -<span class="number">1</span>, <span class="built_in">len</span>(girl)</span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        <span class="keyword">if</span> girl[i] == number:</span><br><span class="line">            pos = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> pos</span><br></pre></td></tr></table></figure>
<p>最好情况时间复杂度（best case time complexity）：最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度</p>
<p>最坏情况时间复杂度（worst case time complexity）：最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度</p>
<p>平均情况时间复杂度（average case time complexity）：</p>
<p>最好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的代码复杂度，发生的概率其实都并不大。为了更好地表示平均情况下的复杂度,<br />
使用<strong>平均情况时间复杂度</strong><br />
平均复杂度，顾名思义就是出现情况的概率，这个值就是概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。</p>
<h3 id="均摊时间复杂度"><a class="markdownIt-Anchor" href="#均摊时间复杂度"></a> 均摊时间复杂度</h3>
<p>均摊时间复杂度（amortized time complexity）：</p>
<p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。尽管很多数据结构和算法书籍都花了很大力气来区分平均时间复杂度和均摊时间复杂度，均摊时间复杂度就是一种特殊的<br />
<strong>平均时间复杂度</strong></p>
<h2 id="空间复杂度"><a class="markdownIt-Anchor" href="#空间复杂度"></a> 空间复杂度</h2>
<p>空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。</p>
<h3 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h3>
<p><em>空间复杂度</em>(Space Complexity) 是对一个算法在运行过程中<strong>新开辟</strong>存储空间大小的量度.</p>
<p>记做</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>s</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s(n) = O(f(n))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
<h3 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h3>
<p>不做任何优化，一般为指数阶。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlnb2NoZWF0c2hlZXQuY29tLw==">bigocheatsheet<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>algo</category>
      </categories>
      <tags>
        <tag>algo</tag>
      </tags>
  </entry>
  <entry>
    <title>粗谈Redis事物</title>
    <url>/22168.html</url>
    <content><![CDATA[<h2 id="redis-事务是什么东东"><a class="markdownIt-Anchor" href="#redis-事务是什么东东"></a> Redis 事务是什么东东</h2>
<p>一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<blockquote>
<p>简单来说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p>
</blockquote>
<span id="more"></span>
<h2 id="redis事务解析"><a class="markdownIt-Anchor" href="#redis事务解析"></a> Redis事务解析</h2>
<h3 id="redis事务的三个阶段"><a class="markdownIt-Anchor" href="#redis事务的三个阶段"></a> Redis事务的三个阶段</h3>
<ul>
<li>开始事务</li>
<li>命令入队</li>
<li>执行事务</li>
</ul>
<h3 id="redis事务相关命令"><a class="markdownIt-Anchor" href="#redis事务相关命令"></a> <strong>Redis事务相关命令：</strong></h3>
<p>watch key1 key2 … : 监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则事务被打断 （<br />
类似乐观锁 ）</p>
<p>multi : 标记一个事务块的开始（ queued ）</p>
<p>exec : 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ）</p>
<p>discard : 取消事务，放弃事务块中的所有命令</p>
<p>unwatch : 取消watch对所有key的监控</p>
<h2 id="锁"><a class="markdownIt-Anchor" href="#锁"></a> 锁</h2>
<p>说到Redis事物，那么便不得不谈一下它的锁,</p>
<p>悲观锁：很悲观，认为什么时候都会出现问题，无论做什么都会加锁</p>
<p>乐观锁：很乐观，认为什么时候都不会出现问题，所以不会上锁。更新数据的时候会去判断一下在此期间是否被修改此数据</p>
<ul>
<li>获取version</li>
<li>比较version</li>
<li>更新</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 1000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> out 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; WATCH money    <span class="comment"># 监视money</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI        <span class="comment"># 开始执行事物 </span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRby money 50  <span class="comment"># 用掉50  </span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY out 50    <span class="comment"># 减少50</span></span><br><span class="line">QUEUED </span><br><span class="line">127.0.0.1:6379&gt; EXEC       <span class="comment"># 执行</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 950</span><br><span class="line">2) (<span class="built_in">integer</span>) 50</span><br></pre></td></tr></table></figure>
<p>执行期间数据money未改变，事物正常执行</p>
<blockquote>
<p>此处的watch 相当于乐观锁</p>
</blockquote>
<h2 id="redis事务注意点"><a class="markdownIt-Anchor" href="#redis事务注意点"></a> Redis事务注意点</h2>
<p><strong>Redis事务没有隔离级别的概念</strong></p>
<p>批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到</p>
<p><strong>Redis不保证原子性</strong></p>
<p>Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>一但执行 EXEC 开启事务的执行后，无论事务使用执行成功， WARCH<br />
对变量的监控都将被取消。故当事务执行失败后，需重新执行WATCH命令对变量进行监控，并开启新的事务进行操作。</p>
<p>watch指令类似于乐观锁，在事务提交时，如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用EXEC执行事务时，事务队列将不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>结构化思考</title>
    <url>/52045.html</url>
    <content><![CDATA[<h2 id="第一步明确目的找到分解角度"><a class="markdownIt-Anchor" href="#第一步明确目的找到分解角度"></a> 第一步，明确目的，找到分解角度</h2>
<p>先弄清楚分解的目的是什么，然后根据目的进行拆解与结构化</p>
<h2 id="第二步按照mece原则组成结构"><a class="markdownIt-Anchor" href="#第二步按照mece原则组成结构"></a> 第二步，按照MECE原则，组成结构</h2>
<h3 id="方法1金字塔原理"><a class="markdownIt-Anchor" href="#方法1金字塔原理"></a> 方法1：金字塔原理</h3>
<ul>
<li>自上而下「使用演绎法」设计结构</li>
<li>自下而上「使用归纳法」提炼结构</li>
</ul>
<h3 id="方法二切割法"><a class="markdownIt-Anchor" href="#方法二切割法"></a> 方法二：切割法</h3>
<p>二维</p>
<ul>
<li>时间管理矩阵：重要/不重要；紧急/不紧急</li>
<li>乔韩窗口理论：自己知道/不知道；别人知道/不知道</li>
<li>波斯顿矩阵：市场份额高/低；市场增长率快/慢</li>
<li>SWOT分析：内部优/劣势；外部威胁/机遇</li>
</ul>
<p>三维</p>
<ul>
<li>增加过度状态：黑灰白；好/一般/差；事前/事中/事后</li>
</ul>
<h3 id="方法三组合使用"><a class="markdownIt-Anchor" href="#方法三组合使用"></a> 方法三：组合使用</h3>
<p>比如，让你思维更加缜密的「5W2H结构」<br />
比如，让你快速理清商业模式的「商业模式画布」<br />
比如，让你能全面分析企业发展问题的「麦肯锡7S」</p>
<h2 id="第三步调整结构给出方案"><a class="markdownIt-Anchor" href="#第三步调整结构给出方案"></a> 第三步，调整结构，给出方案</h2>
<p>PREP法则：Point结论，Reason理由，Example理由，Ponit重复结论</p>
<h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2>
<p>先 split, 在排列组合(套路或任意), merge.</p>
]]></content>
      <categories>
        <category>思考</category>
        <category>结构化</category>
        <category>结构化思考</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>网站防护总结之pc</title>
    <url>/63974.html</url>
    <content><![CDATA[<h2 id="为什么需要数据防护"><a class="markdownIt-Anchor" href="#为什么需要数据防护"></a> 为什么需要数据防护？</h2>
<p>当今如今大数据时代，数据重要不言而喻，网页和 App<br />
作为主流的数据载体，如果其数据没有任何的保护措施，在爬虫工程师解决了一些基本的反爬如User-Agent、cookies、验证码等的防护措施之后，那么数据依旧可被轻易的获取。</p>
<h2 id="数据防护主要体现在何处"><a class="markdownIt-Anchor" href="#数据防护主要体现在何处"></a> 数据防护主要体现在何处？</h2>
<span id="more"></span>
<p>数据防护可简略的划分为请求防护、数据内容防护、验证码</p>
<h3 id="请求防护"><a class="markdownIt-Anchor" href="#请求防护"></a> 请求防护</h3>
<ul>
<li>User-Agent</li>
<li>Cookie</li>
<li>签名验证</li>
<li>握手验证</li>
<li>协议</li>
<li>。。。</li>
</ul>
<h3 id="数据内容防护"><a class="markdownIt-Anchor" href="#数据内容防护"></a> 数据内容防护</h3>
<ul>
<li>CSS字体偏移</li>
<li>SVG字体映射</li>
<li>图片数据</li>
<li>。。。</li>
</ul>
<h3 id="验证码"><a class="markdownIt-Anchor" href="#验证码"></a> 验证码</h3>
<p>个人总结为以下几种类型，具体体现不在过多赘述。（注，几者之间无明显的分割标准，在此以侧重点划分）</p>
<ul>
<li>识别点选或输入型</li>
<li>滑轨、滑块型</li>
<li>短信或语音验证型</li>
</ul>
<h2 id="思"><a class="markdownIt-Anchor" href="#思"></a> 思</h2>
<p>实现这一切的一切，这些究竟是基于什么实现的？这一切绝可能是凭空出现！！！</p>
<p>其实无论是ajax，User-Agent、还是Cookie等等大部分都是基于Javascript实现。而且由于JavaScript在客户端中为完全透明，用户可以随意的查看与调试，这无异于代码裸奔。虽然以上的反爬虫虽然不错，但如果仔细分析的，这难度也仅是“工作量”的问题。</p>
<h2 id="javascript防护分类"><a class="markdownIt-Anchor" href="#javascript防护分类"></a> Javascript防护分类</h2>
<p>完全透明的JS代码，虽然可以有效的防止。但这还不够，其根本原因还是JavaScript为明文。而这一切的一切都是“治标不治本”，虽然可以但还不够。也正因为对JavaScript的各种防护，所以才让这些加密“动”起来，无法轻易的分析。对JavaScript“加密”可分为如下几种大类</p>
<h3 id="代码压缩"><a class="markdownIt-Anchor" href="#代码压缩"></a> 代码压缩</h3>
<p>JavaScript 压缩是指去除 JavaScript<br />
代码中的不必要的空格、换行等内容，或者将一些可能公用的代码进行处理实现共享，最后输出的结果都被压缩为几行内容，代码可读性变差，提高分析难度同时也能提高网站加载速度。</p>
<p>整体来说，压缩技术只能在很小的程度上起到防护作用，要想真正提高防护效果还得依靠混淆与加密技术。</p>
<h3 id="代码混淆"><a class="markdownIt-Anchor" href="#代码混淆"></a> 代码混淆</h3>
<p>代码混淆是增加分析难度而牺牲部分性能的一种方案，此方案大部分是体现在通过逻辑转换换等方式将代码转化为难以分析的代码。难以分析是混淆的目的，等价转换是需要确保混淆前后的代码需不影响运行的功能。对于混淆可以又分为如下四种：布局混淆、数据混淆、控制混淆、预防混淆</p>
<h4 id="布局混淆"><a class="markdownIt-Anchor" href="#布局混淆"></a> 布局混淆</h4>
<p>布局混淆指在源代码中删除原有无用代码，处理常量名、变量名函数名等标识符，增加对于代码的阅读与分析。</p>
<p>无用代码：注释、调试信息、缩进、换行、无用函数与数据等</p>
<p>处理常量名、变量名函数名等标识符：</p>
<ul>
<li>标识重命名：将原有代码重命名为无具体意义的字符，例如 将name 重命名为a</li>
</ul>
<p>注意点：</p>
<ul>
<li>作用域内标识符碰撞情况</li>
</ul>
<p><strong>小结</strong></p>
<p>布局混淆并不会影响执行的过程、内存开销，甚至代码体积反而减少了。</p>
<h4 id="数据混淆"><a class="markdownIt-Anchor" href="#数据混淆"></a> 数据混淆</h4>
<p>JS拥有常见的7种数据类型，number、string、boolean、unfined、null、Object</p>
<p><strong>数字混淆</strong></p>
<p>数据混淆有常见：进制转换、数字分治、其他</p>
<ul>
<li>进制转换</li>
</ul>
<p>将十进制转化为二进制、八进制、十六进制等，从而达到“混淆”的目的</p>
<ul>
<li><strong>数学分治</strong></li>
</ul>
<p>简而言之就是将数拆开，例如 2 = 1 + 1，再辅以数学公式等</p>
<ul>
<li>
<p>其他</p>
<p>重新赋值等</p>
</li>
</ul>
<p><strong>字符串混淆</strong></p>
<p>字符串混淆常见的有编码转换、加密。常见的有hash、base64、md5等</p>
<p><strong>boolean</strong></p>
<p>我们都知道Boolean值为True、False。根据对boolean的处理，变成难以显示阅读的代码。例如![] = False, !![] =<br />
True.</p>
<p><strong>控制混淆</strong></p>
<p>控制混淆是指对程序的控制流进行转换变化，常见的方式有插入僵尸代码、控制流平坦化</p>
<p>插入僵尸代码：插入僵尸代码即插入无用的代码，增强调试难度</p>
<p>控制流平坦化：控制流平坦化,将原本的的执行流程平坦化。具体可自行搜索</p>
<p><strong>预防混淆</strong></p>
<p>主要体现在 提高反混淆的难度或检测现有混淆器中的漏洞设计</p>
<h3 id="代码混淆总结"><a class="markdownIt-Anchor" href="#代码混淆总结"></a> 代码混淆总结</h3>
<p>万变不离其宗，无论是代码压缩、代码混淆都离不开一个宗旨，在不改变原有的<strong>结果</strong><br />
情况下对代码（这里指JS）进行处理。处理的方式包含但不限于，等值转换、运算分割。</p>
<h2 id="设备指纹防护"><a class="markdownIt-Anchor" href="#设备指纹防护"></a> 设备指纹防护</h2>
<p>设备指纹通过收集客户端设备的特征信息对用户与“机器人”进行甄别。web设备指纹主要包含：</p>
<p>浏览器端环境检测</p>
<p>浏览器设别标识</p>
<p>特征识别Hook</p>
<p>JS特征识别</p>
<p>做爬虫的朋友一定使用过NodeJs，这个工具。也时常借用与Nodejs来模拟JS，但Nodejs的api和指纹浏览器有不一样。如果服务端获取到客户端，那么就可以对指纹不一致的机器人，进行防范。</p>
<p>正如你我所知的那般，知道的越多，不知道的越多。</p>
<h2 id="推荐阅读与了解"><a class="markdownIt-Anchor" href="#推荐阅读与了解"></a> 推荐阅读与了解</h2>
<p>风控要略：互联网业务反欺诈之路</p>
<p>Jsfuck（github）：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FlbWtlaS9qc2Z1Y2s=">https://github.com/aemkei/jsfuck<i class="fa fa-external-link-alt"></i></span></p>
<p>基于控制混淆和布局混淆的代码混淆系统-王岩（论文）</p>
]]></content>
      <categories>
        <category>spider</category>
        <category>crawler</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>网页调试之JSHook</title>
    <url>/33650.html</url>
    <content><![CDATA[<h2 id="网页调试之jshook"><a class="markdownIt-Anchor" href="#网页调试之jshook"></a> 网页调试之JSHook</h2>
<h3 id="什么是hook"><a class="markdownIt-Anchor" href="#什么是hook"></a> 什么是Hook？</h3>
<p>Hook<br />
又叫作钩子技术，它就是在程序运行的过程中，对其中的某个方法进行重写，在原有的方法前后自定义的代码。相当于在系统没有调用该函数之前，钩子程序就先捕获该消息，可以先得到控制权，这时钩子函数便可以加工处理（改变）该函数的执行行为。执行函数后释放控制权限，继续运行原有逻辑。</p>
<span id="more"></span>
<h3 id="hook执行流程图"><a class="markdownIt-Anchor" href="#hook执行流程图"></a> Hook执行流程图</h3>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gqxgrt9q3sj30kv0j3wej.jpg" alt="" /></p>
<h3 id="hook思路"><a class="markdownIt-Anchor" href="#hook思路"></a> Hook思路</h3>
<ol>
<li>寻找hook点</li>
<li>hook</li>
<li>伪装hooker</li>
<li>调试(堆栈)</li>
</ol>
<h3 id="hook公式"><a class="markdownIt-Anchor" href="#hook公式"></a> Hook公式</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数hooker</span></span><br><span class="line"><span class="keyword">var</span> func_copy = func</span><br><span class="line">func = <span class="keyword">function</span> (<span class="params">argument</span>) &#123;</span><br><span class="line">  <span class="comment">// hooker</span></span><br><span class="line">  <span class="keyword">return</span> func.<span class="title function_">apply</span>(obj, argument)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性hooker</span></span><br><span class="line"><span class="keyword">var</span> attr_copy = obj.<span class="property">attr</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProprety</span>(obj, <span class="string">&#x27;attr&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">get</span>:<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// your code</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">set</span>:<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// your code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hook实例"><a class="markdownIt-Anchor" href="#hook实例"></a> Hook实例</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hook btoa</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span></span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;Start Hooking ...&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">hook</span>(<span class="params">obj, attr</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> func = obj[attr]</span><br><span class="line">    obj[attr] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hooked&#x27;</span>, obj, attr, <span class="variable language_">arguments</span>)</span><br><span class="line">      <span class="keyword">var</span> ret = func.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>)</span><br><span class="line">      <span class="keyword">debugger</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result&#x27;</span>, ret)</span><br><span class="line">      <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Disguise the prototype</span></span><br><span class="line">    attr.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;function btoa() &#123; [native code] &#125;&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    attr.<span class="property">length</span> = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">hook</span>(<span class="variable language_">window</span>, <span class="string">&#x27;btoa&#x27;</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// hook eval</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;Start Hooking ...&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Hooker</span>(<span class="params">obj, attr</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> func = obj[attr]</span><br><span class="line">    obj[attr] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hooked&#x27;</span>, obj, attr, <span class="variable language_">arguments</span>);</span><br><span class="line">      <span class="keyword">var</span> result = func.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>);</span><br><span class="line">      <span class="keyword">debugger</span>;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result&#x27;</span>, result);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Disguise the prototype</span></span><br><span class="line">    attr.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;function eval() &#123; [native code] &#125;&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    attr.<span class="property">length</span> = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Hooker</span>(<span class="variable language_">window</span>, <span class="string">&#x27;eval&#x27;</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// hook document.cookie</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="hook-优与劣"><a class="markdownIt-Anchor" href="#hook-优与劣"></a> Hook 优与劣</h3>
<h4 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h4>
<ol>
<li>快速定位函数，方便调试</li>
<li>注入，不影响原本逻辑</li>
</ol>
<h4 id="弊端"><a class="markdownIt-Anchor" href="#弊端"></a> 弊端</h4>
<ol>
<li>新手难以有效的hook</li>
<li>反hook往往需要分析与绕过（类似于包装类、浏览器指纹、内部类等）</li>
</ol>
<h4 id="hook伪装"><a class="markdownIt-Anchor" href="#hook伪装"></a> Hook伪装</h4>
<blockquote>
<p>函数hook伪装</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Disguise the prototype</span></span><br><span class="line">attr.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;function btoa() &#123; [native code] &#125;&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">attr.<span class="property">length</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1grgwa9ysgcj31d00bcjv6.jpg" alt="" /></p>
<h3 id="更底层的hook原型链hook"><a class="markdownIt-Anchor" href="#更底层的hook原型链hook"></a> 更底层的Hook(原型链Hook)</h3>
<p>在以上，我们对于函数进行了hook的总结，但若需要hook更加底层的函数该如何？</p>
<p>如果想要hook 例如 字符串的split方法,match方法。该如何？使用以上的方法将无法有效的实现hook。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func = <span class="string">&quot;需Hook处&quot;</span></span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">常规hook思路(错误示例)</span><br><span class="line"><span class="number">1.</span></span><br><span class="line">保存改写函数</span><br><span class="line"><span class="number">2.</span></span><br><span class="line">重写hook函数</span><br><span class="line"><span class="number">3.</span></span><br><span class="line">下<span class="keyword">debugger</span>或其他调试逻辑</span><br><span class="line"></span><br><span class="line">split = <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">debugger</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gs2rfrdgp1j307p04dq2t.jpg" alt="" /></p>
<p>可正常操作</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gs2rhklerfj30830493yd.jpg" alt="" /></p>
<p>无法实现对于split的hook，常规方案无法实现hook。</p>
<blockquote>
<p>思考：为什么无法hook split -&gt; 没有hook到split</p>
<p>为什么无法hook split？ -&gt; 没有hook到split</p>
<p>Split 的“原函数”在哪里？-&gt; 原型链 -&gt; String的方法</p>
</blockquote>
<p>所以如果需要hook，就需要从原型链处进行入手,发现其实as.split 与 String.prototype 是同一个东西</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gs2rrew34wj307a029a9v.jpg" alt="" /></p>
<p>那么我们直接对于进行如下操作,在控制台（console）中输入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">as</span> = “hook</span><br><span class="line">mark”;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">rewrite</span><br><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">split</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;val&#x27;</span>);</span><br><span class="line">  <span class="keyword">debugger</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时调用split函数，就会发现已经完成对split的hook</p>
<p>![image-20210702181800770](/Users/stringle-004/Library/Application Support/typora-user-images/image-20210702181800770.png)</p>
<p>随之而来的又是一个新问题，hook的为只要字符串调用split方法就都会被debugger到。显然并不适合在实践中进行调试。如下给出完整的hook<br />
split的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create split cache from proto</span></span><br><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">split_cache</span> = <span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">split</span></span><br><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">split</span> = <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="comment">// Gets the variable of the current scope</span></span><br><span class="line">  str = <span class="variable language_">this</span>.<span class="title class_">String</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Arguments:&#x27;</span>, val)</span><br><span class="line">  <span class="keyword">debugger</span>;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">split_cache</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果感觉不明白为什么需要这样写的，或许需要复习一下js 原型链相关知识</p>
</blockquote>
<h3 id="hook失败原因归纳"><a class="markdownIt-Anchor" href="#hook失败原因归纳"></a> Hook失败原因归纳</h3>
<p>Hook函数有时也会出现hook失败或者hook失效的情况，个人总结如下：</p>
<ol>
<li>函数hook一般情况下Hook不会失败，若失败一定是对于该函数的<code>__proto__</code><br />
进行检测，此时只需要对<code>__proto__</code>,进行伪装即可</li>
<li>当目标网站的所有逻辑都采用了<code>Object.defineProperty</code>时，属性Hook就会失效</li>
<li>当Hook的函数为“内部”函数时，需要特殊的手段进行处理。例如将该函数加入到内存中。（当未加载页面，也会造成Hook失效）</li>
</ol>
<h3 id="常用hook逻辑"><a class="markdownIt-Anchor" href="#常用hook逻辑"></a> 常用Hook逻辑</h3>
<p>具体示例请参考：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1BheW5lLVd1L0pzSG9va1NjcmlwdA==">https://github.com/Payne-Wu/JsHookScript<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>spider</category>
        <category>crawler</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>网页调试之debugger原理与绕过</title>
    <url>/2477.html</url>
    <content><![CDATA[<h2 id="网页调试之debugger原理与绕过"><a class="markdownIt-Anchor" href="#网页调试之debugger原理与绕过"></a> 网页调试之debugger原理与绕过</h2>
<p>debugger 语句用于停止执行 JavaScript(以下简称JS)，并调用 (如果可用) 调试函数。</p>
<p>使用 debugger 语句类似于在代码中设置断点。</p>
<span id="more"></span>
<p><strong>注意：</strong> <strong>如果调试工具不可用，则调试语句将无法工作。</strong></p>
<h3 id="实现debugger功能"><a class="markdownIt-Anchor" href="#实现debugger功能"></a> 实现debugger功能</h3>
<h4 id="直接使用书写debugger"><a class="markdownIt-Anchor" href="#直接使用书写debugger"></a> 直接使用书写debugger</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span></span><br><span class="line">html &gt;</span><br><span class="line">&lt; html</span><br><span class="line">lang = <span class="string">&quot;en&quot;</span> &gt;</span><br><span class="line"></span><br><span class="line">    &lt; head &gt;</span><br><span class="line">    &lt; meta</span><br><span class="line">charset = <span class="string">&quot;UTF-8&quot;</span> &gt;</span><br><span class="line">    &lt; meta</span><br><span class="line">http - equiv = <span class="string">&quot;X-UA-Compatible&quot;</span></span><br><span class="line">content = <span class="string">&quot;IE=edge&quot;</span> &gt;</span><br><span class="line">    &lt; title &gt; <span class="title class_">Example</span></span><br><span class="line"><span class="variable constant_">DEBUGGER</span> &lt; /title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">debugger</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>当我们使用浏览器打开Devtools即执行debugger；如下图所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1grbr2fe8bsj30wp05hq32.jpg" alt="" /></p>
<h4 id="eval配合debugger"><a class="markdownIt-Anchor" href="#eval配合debugger"></a> eval配合debugger</h4>
<blockquote>
<p>eval() 函数计算 JavaScript 字符串，并把它作为脚本代码来执行。</p>
<p>如果参数是一个表达式，eval() 函数将执行表达式。如果参数是Javascript语句，eval()将执行 Javascript 语句。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Example DEBUGGER&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var a = 1;</span><br><span class="line">        eval(&quot;var 1 = 1;debugger&quot;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当使用eval执行时，将会在虚拟机中执行，也就是说非同一作用域。</p>
<p>同时也由于<code>将字符串当作表达式来执行</code>，那么里面常常伴随着代码混淆</p>
</blockquote>
<h4 id="函数内执行debugger"><a class="markdownIt-Anchor" href="#函数内执行debugger"></a> 函数内执行debugger</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span></span><br><span class="line">html &gt;</span><br><span class="line">&lt; html</span><br><span class="line">lang = <span class="string">&quot;en&quot;</span> &gt;</span><br><span class="line"></span><br><span class="line">    &lt; head &gt;</span><br><span class="line">    &lt; meta</span><br><span class="line">charset = <span class="string">&quot;UTF-8&quot;</span> &gt;</span><br><span class="line">    &lt; meta</span><br><span class="line">http - equiv = <span class="string">&quot;X-UA-Compatible&quot;</span></span><br><span class="line">content = <span class="string">&quot;IE=edge&quot;</span> &gt;</span><br><span class="line">    &lt; title &gt; <span class="title class_">Example</span></span><br><span class="line"><span class="variable constant_">DEBUGGER</span> &lt; /title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    (<span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> data = <span class="title class_">Date</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">alert</span>(data);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">debugger</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;())</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>因为以上三种体现形式，在debugger上所设计的方案十分多。例如常见的无限制debugger、配合settimeout延迟debugger、代码混淆+debugger等等。</p>
<p>设置debugger的原理去对抗反爬，其核心原理就是<code>如果调试工具可用，则调试语句将执行</code>.也就是经常一打开就跳出debugger。</p>
<blockquote>
<p>无限debugger，其实是一种泛指的概念，无限泛指多，而非真的无限</p>
<p>其基于debugger之上，在此加入多次执行debugger的语句从而实现“无限debugger”。“反正只要chrome<br />
Devtools不开debugger便不会执行”.（经过调试是这样的，如果不准确请自行完善哦）</p>
</blockquote>
<h3 id="debugger绕过原理"><a class="markdownIt-Anchor" href="#debugger绕过原理"></a> debugger绕过原理</h3>
<p>debugger的绕过也很简单，我个人总结共有两种大的方向。它们分别是替换、掠过。其原理都是不让debugger执行。个人并不推荐新手使用替换法中的方法</p>
<ul>
<li>替换法
<ul>
<li>JS注入</li>
<li>重写(Hook)</li>
</ul>
</li>
<li>掠过法
<ul>
<li>Never pause here</li>
<li>条件断点</li>
</ul>
</li>
</ul>
<h4 id="js注入"><a class="markdownIt-Anchor" href="#js注入"></a> JS注入</h4>
<p>实现js注入的方式有很多，例如chrome Devtools的overrides、fiddler autoresponse、 mitmproxy、Charles的map<br />
local等等。若有兴趣自行搜索其使用方式</p>
<h4 id="never-pause-here"><a class="markdownIt-Anchor" href="#never-pause-here"></a> Never pause here</h4>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1grfmlz26gtj30gk04hmxb.jpg" alt="" /></p>
<p>找到debugger前面的行号，鼠标右键点击该行号，点击Never pause here。便会跳过此断点</p>
<h4 id="条件断点"><a class="markdownIt-Anchor" href="#条件断点"></a> 条件断点</h4>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1grfmohbkekj30b7029wee.jpg" alt="" /></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1grfmqch8l2j30gz02j3yd.jpg" alt="" /></p>
<p>找到debugger前面的行号，鼠标右键点击该行号，点击 Add conditional breakpoint，直接写false。回车即可</p>
<h4 id="deactivate-breakpoints"><a class="markdownIt-Anchor" href="#deactivate-breakpoints"></a> Deactivate breakpoints</h4>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gro1s7b06wj30a401m0si.jpg" alt="" /></p>
<p>打开这个图标如下图所示（高亮为打开）</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gro1somwu8j301w01aa9t.jpg" alt="" /></p>
<p>当遇见breakpoints时会执行一次断点，鼠标单击如下图标</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gro1svh0onj301m01c3y9.jpg" alt="" /></p>
<p>即可直接跳过breakpoints。</p>
<blockquote>
<p>小技巧：Deactivate breakpoints可以配合xhr、dom、Script等断点使用，便于调试</p>
</blockquote>
<h4 id="hook绕过"><a class="markdownIt-Anchor" href="#hook绕过"></a> Hook绕过</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">&quot;debugger&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    var eval_cache = eval;</span><br><span class="line">    eval = function(obj) &#123;</span><br><span class="line">        if (obj.indexof(&#x27;debugger&#x27;) === -1) &#123;</span><br><span class="line">            eval_cache(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此方法有局限性，若在此函数(在这里指函数a)若没有借用相关函数（eval），那么就无法使用此方法绕过</p>
</blockquote>
<h4 id="函数滞空法"><a class="markdownIt-Anchor" href="#函数滞空法"></a> 函数滞空法</h4>
<p>当遇见断点时，回退一次堆栈。将对应函数滞空即可,例如遇见如下的debugger</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">debugger</span>;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">&quot;debugger&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接在控制台输入如下内容即可。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gro22wyydqj30zk06qt8s.jpg" alt="" /></p>
<blockquote>
<p>此方法有局限性，若在此函数中还参杂了关键代码，将可能无法访问或调试等</p>
</blockquote>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>Debugger绕过其实并不难，但在调试中仅仅是一道“开胃菜”，本节总结了debugger的实现方式，以及触发机制。当然也总结了几种我已知的所有绕过方案。</p>
<h3 id="展望"><a class="markdownIt-Anchor" href="#展望"></a> 展望</h3>
<p>如何hook“变量”debugger？如果可以实现那么就可以实现反调试的debugger“通杀”，当然目前我也有在探究此方案。在加到hook函数中，那么调试便可以近似于一步到位。</p>
]]></content>
      <categories>
        <category>spider</category>
        <category>crawler</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>网页调试干扰总结</title>
    <url>/14277.html</url>
    <content><![CDATA[<h2 id="网页反调试总结"><a class="markdownIt-Anchor" href="#网页反调试总结"></a> 网页反调试总结</h2>
<p>网站除了对代码进行加密进行保护，还时常携带了反调试手段。例如无限debugger；内存爆破，控制台检测。</p>
<p>相关无限debugger进行反调试阻挠请参考上文，不在此过多赘述。本节主要学习内存爆破原理与绕过思想、控制台检测原理与绕过，</p>
<span id="more"></span>
<h3 id="内存爆破"><a class="markdownIt-Anchor" href="#内存爆破"></a> 内存爆破</h3>
<p>通俗来理解是通过“特殊手段”不断开辟新内存，造成内存存储不足，从而使程序或电脑宕机。内存爆破并没有一种具体的实现方式，如果实现了内存爆破的效果都可以称之为内存爆破。</p>
<blockquote>
<p>当我们在编程的时候，每当声明一个变量、初始化一个函数。都会在开辟一块内存。</p>
</blockquote>
<h4 id="内存爆破实现的流程"><a class="markdownIt-Anchor" href="#内存爆破实现的流程"></a> 内存爆破实现的流程</h4>
<p>检测环境</p>
<p>实现内存爆破</p>
<blockquote>
<p>此处的环境为泛指，当与正常用户访问相悖或有差异均可以以此为为“入口”，开始内存爆破</p>
</blockquote>
<h4 id="内存爆破常见入口点"><a class="markdownIt-Anchor" href="#内存爆破常见入口点"></a> 内存爆破常见入口点</h4>
<p>hook检测</p>
<blockquote>
<p>监听函数情况，当函数被hook，且未完善的伪装hook时。</p>
</blockquote>
<p>代码格式化检测</p>
<blockquote>
<p>正常情况下，代码被压缩成一行或几行。但在运行时不符。</p>
</blockquote>
<p>浏览器指纹检测</p>
<blockquote>
<p>当运行环境与所规定的环境不同时</p>
</blockquote>
<p>控制台检测</p>
<blockquote>
<p>监听控制台，当控制台被打开时。</p>
</blockquote>
<h4 id="内存爆破特征"><a class="markdownIt-Anchor" href="#内存爆破特征"></a> 内存爆破特征</h4>
<ol>
<li>检测环境</li>
<li>与预期环境不符合，死循环；符合，正常退出</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内存爆破示例代码</span></span><br><span class="line">h = <span class="keyword">function</span> (<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="comment">// 检测</span></span><br><span class="line">  <span class="keyword">if</span> (a &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;正常执行&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 进入陷阱</span></span><br><span class="line">    <span class="keyword">while</span> (!![]) &#123;</span><br><span class="line">      c = <span class="keyword">new</span> <span class="title class_">Array</span>().<span class="title function_">push</span>(<span class="keyword">void</span> <span class="number">0</span>);</span><br><span class="line">      ;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;内存爆破， 危！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在浏览器中执行<strong>内存爆破示例代码</strong>， 如下图所示</p>
<p>符合预期，正常情况下：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gs44y083cmj310o0pm75b.jpg" alt="" /></p>
<p>不符合，触发内存爆破</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gs450veqckj31lk0u0n1b.jpg" alt="" /></p>
<p>过了一小会，你就会发现，崩溃了！！！</p>
<h4 id="内存爆破总结"><a class="markdownIt-Anchor" href="#内存爆破总结"></a> 内存爆破总结</h4>
<p>内存爆破，更像一种陷阱。如果触发了该陷阱，有了这个“入口”，便开始内存爆破。</p>
<h4 id="如何绕过内存爆破"><a class="markdownIt-Anchor" href="#如何绕过内存爆破"></a> 如何绕过内存爆破？</h4>
<p>由于内存爆破的“入口”并不一致，所以内存爆破也并没有通用的解决方案。可提供的思路为“阻断”进入内存爆破，便为绕过。</p>
<p>例如</p>
<p>hook检测，伪装hook原型链即可</p>
<p>代码格式化检测，在检测处进行处理即可</p>
<p>浏览器指纹检测，伪装浏览器指纹，保持一致即可</p>
<p>控制台检测，处理检测代码即可。</p>
<h2 id="控制台检测原理与绕过"><a class="markdownIt-Anchor" href="#控制台检测原理与绕过"></a> 控制台检测原理与绕过</h2>
<p>不知你也是否和我一样遇见过这种情况，当打开控制台时。浏览器就直接崩溃，获取其他情况。</p>
<h4 id="控制台检测原理"><a class="markdownIt-Anchor" href="#控制台检测原理"></a> 控制台检测原理</h4>
<p>检测原理为与“正常”浏览网站有差异</p>
<p>当打开控制台的时候,会触发如下两种情况</p>
<ol>
<li>debugger可执行了</li>
<li>div会自动获取id属性</li>
</ol>
<p>第一种也就是我们常说的debugger调试干扰，</p>
<blockquote>
<p>只要控制台打开，debugger便会执行。一直相关联的无限deugger便会随之而来（如果有）</p>
</blockquote>
<p>第二种，当浏览器有使用<code>document.createElement</code>创建标签时，会创建该标签。**当控制台打开会自动获取其id属性<br />
**。</p>
<p>如果在绑定他，在对他进行内存爆破等操作。那么就。。。</p>
<h4 id="绕过"><a class="markdownIt-Anchor" href="#绕过"></a> 绕过</h4>
<p>滞空该标签即可</p>
<p>pass</p>
]]></content>
      <categories>
        <category>spider</category>
        <category>crawler</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊工程化</title>
    <url>/41701.html</url>
    <content><![CDATA[<p>在聊工程化之前，对于“工程”我们进行再一次剖析。</p>
<p>首先，何为工程化。 我个人认为即为了适应纷繁复杂的软件变化和演进而提出的相关方式方法，其目的是为了更好的排兵布阵、分工协作。</p>
<blockquote>
<p>工程过程中也意味着取舍</p>
</blockquote>
<p>软件工程，将工程化的概念左移，在软件设计之初就引入工程化的思想，囊括住软件的全生命周期。</p>
<h2 id="研发效能"><a class="markdownIt-Anchor" href="#研发效能"></a> 研发效能</h2>
<p>当我们在谈”工程化“，我们究竟在谈什么？<br />
有人讨论，是因为存在问题，而问题就在于实际的研发效率，已经远远低于预期了。<br />
企业初创期，一个idea从形成到上线，也许只需要1~2小时，而随着企业的发展，类似的事情的执行与落地往往需要多个团队协同，花费数周甚至是数月才能完成。 这便造成了鲜明的对比，而这一对比，对于没有深入理解软件工程的人来说，显得难以理解，可有往往无计可施。</p>
<ul>
<li>效能：衡量产品的经济效应</li>
<li>效率：提升业务的响应能力，提高吞吐，降低成本</li>
</ul>
<h2 id="本质复杂度与偶然复杂度"><a class="markdownIt-Anchor" href="#本质复杂度与偶然复杂度"></a> 本质复杂度与偶然复杂度</h2>
<p>21世纪初，早期的互联网从业者开发简易的网站只需要学会使用Linux、Apache、MySQL、PHP（Perl）即可。可如今，在大型互联网公司工作的开发者，，需要学习理解的技术栈早就不知道上升了几个量基本别。如开发框架、分布式、微服务、云原生等等。</p>
<p>如果仅仅是这些复杂度还好，毕竟都是行业的标准技术，以开发者的学习能力，很快就能掌握。令人生畏的是，大型公司中都有一套或多套软件系统，这些软件系统的代码规模往往在百万行以上，质量有好坏而开发者必须基于这些系统开展工作。因此研发效率大幅度降低，其中一个核心的因素——软件复杂度的指数级上升。</p>
<p>Fred Brooks 在其经典著作《人月神话》的【没有饮弹】一文中对于软件的复杂度有着精彩的论述，他将软件复杂度分为本质复杂度与偶然复杂度。</p>
<blockquote>
<p>本质复杂度与偶然复杂度这2个词来源于亚里士多德的《形而上学》，在亚里士多德那里，本质属性是一个物体必然拥有的属性，而偶然属性是一个物体可以（也可以不）拥有的属性。</p>
</blockquote>
<ul>
<li>例1、一个电商系统必然会包含交易、支付、商品等业务复杂度，而这个复杂度是天然就有的，故称之为本质复杂度。</li>
<li>例2、一个电商软件可以是基于容器技术进行管理部署，技术体系选型为Java。而这些间接引入的复杂度，称之为偶然复杂度。</li>
</ul>
<p>Fred Brooks 所描述的本质复杂度，指的是来自问题域本身的复杂度，除非缩小问题域的范围。 否则是无法消除本质复杂度的，而偶然复杂度是由于解决方案带来的。</p>
<p>我们还可以从所谓的问题空间（Problem Space）和方案空间（Solution Space）来理解这2个复杂度，问题空间就是现实的初始状态和期望状态，以及一系列约束规则（我们通常称之为业务），方案空间就是工程师设计实现的，一些从初始状态达到期望状态的步骤。缺乏经验的工程师往往在还没理解清楚问题的情况下就急于写代码，就是缺乏对于问题空间和方案空间的理解，而近年来领域驱动设计为那么多工程师所推崇，其核心原因就是它指导了大家重视问题空间，去直面本质复杂度。</p>
<p>《人月神话》写于1975年，距今已有47了，Brooks认为软件的复杂度是无法得到本质上的降低的，同时认为随着高级变成语言的演进，开发环境的发展，偶然复杂度会得到本质的降低。</p>
<h2 id="如何进行高效的工程化实践"><a class="markdownIt-Anchor" href="#如何进行高效的工程化实践"></a> 如何进行高效的工程化实践</h2>
<ol>
<li>统一概念</li>
<li>树立指导思想与标准</li>
<li>沉淀最佳实践（软件设计,代码风格,安全编码）</li>
<li>工具\平台以及自动化</li>
<li>方式方法与规律</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>论优化</title>
    <url>/15778.html</url>
    <content><![CDATA[<p>时代高速发展，技术日新月异。各司左手分布式，右手高并发。嘴上骂骂咧咧动不动优化的卷王，近日出现的可真不少。</p>
<p>他卷任他卷，躺平治百痛，吾可被累死，但也要卷死尔等。</p>
<p>那么今天咱们也聊聊“代码优化”？</p>
<h2 id="如何写出更快更好的代码"><a class="markdownIt-Anchor" href="#如何写出更快更好的代码"></a> 如何写出更快更好的代码？</h2>
<p>编程技巧</p>
<ul>
<li>更清晰的代码组织结构</li>
<li>更明了的命名，更好的逻辑结构</li>
</ul>
<p>编码技巧</p>
<ul>
<li>更少的占用</li>
<li>更快的运行</li>
</ul>
<p>其实说到这个往细致了说就是 <strong>算法和数据结构</strong>的事儿，但为什么我觉得差点意思呢？</p>
<h2 id="优化原则"><a class="markdownIt-Anchor" href="#优化原则"></a> 优化原则</h2>
<ol>
<li>保证代码正常工作</li>
<li>权衡“优化”代价</li>
<li>定义性能指标，集中力量解决首要问题</li>
<li>不要忽略可读性</li>
</ol>
<h2 id="优化代码"><a class="markdownIt-Anchor" href="#优化代码"></a> 优化代码</h2>
<p>发现<strong>烂</strong>代码</p>
<p>测试与分析</p>
<ul>
<li>
<p>单元测试、基准测试</p>
</li>
<li>
<p>性能分析、代码覆盖率分析、时间、空间负责度分析</p>
</li>
</ul>
<p>修改<strong>烂</strong>代码</p>
<ul>
<li>更低的代码覆盖率，更多的可重用代码</li>
<li>更好更省的算法</li>
<li>更符合的语言特性</li>
<li>更顺应度调度</li>
</ul>
<p>保持书写<strong>好</strong>代码的习惯</p>
<h2 id="python优化技巧"><a class="markdownIt-Anchor" href="#python优化技巧"></a> Python优化技巧</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<ul>
<li>最懒的性能分析：Unix time</li>
<li>内存分析：memory_profiler</li>
<li>引用分析：Obj graph</li>
<li>最详细的性能分析：cProfile、</li>
<li>pytest</li>
</ul>
<h3 id="建议"><a class="markdownIt-Anchor" href="#建议"></a> 建议</h3>
<ol>
<li>使用尽量低和省的算法与数据结构</li>
<li>尽量使用内置数据类型，尽量使用内置函数</li>
<li>使用LRU_Cache 缓存数据</li>
<li>尽量使用局部变量：与每个作用域内查找变量的速度有关，局部变量最快，类级属性中等，全局变量最慢</li>
<li>使用函数</li>
<li>提防字符串：在循环中运行 模数（%s）或 .format() 会变量，优先用 f-string</li>
<li>巧用多重赋值</li>
<li>使用生成器</li>
<li>使用MultiProcessing克服GIL、使用线程池、使用Coroutine</li>
<li>使用C/C++ 模块提高性能，使用Cython</li>
<li>使用JIT</li>
</ol>
<p>一些分析工具：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL252ZHYvdnByb2Y=">vprof<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvZXJpY2svcHlpbnN0cnVtZW50">pyinstrument<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BsYXNtYS11bWFzcy9zY2FsZW5l">scalene<i class="fa fa-external-link-alt"></i></span></p>
<p>阿姆达尔定律：<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQW1kYWhsJ3MlMjBsYXc=">Amdahl’s law<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
  </entry>
  <entry>
    <title>认识设备指纹</title>
    <url>/15990.html</url>
    <content><![CDATA[<h2 id="认识指纹"><a class="markdownIt-Anchor" href="#认识指纹"></a> 认识指纹</h2>
<h3 id="什么是指纹"><a class="markdownIt-Anchor" href="#什么是指纹"></a> 什么是指纹</h3>
<p>设备指纹、浏览器指纹也是同理根据软硬件信息，设备版本、设备操作系统等差异性从而生成唯一的设备指纹。</p>
<blockquote>
<p>人的手有手指、手掌握纹，通过凹凸规则、分布状态的差异造就了<strong>相对</strong>其独一无二的特征。</p>
</blockquote>
<span id="more"></span>
<h3 id="指纹是怎么产生"><a class="markdownIt-Anchor" href="#指纹是怎么产生"></a> 指纹是怎么产生</h3>
<p>手机的操作系统、浏览器厂商为了方便用户与开发者获取用户的设备信息预留了一些API供程序使用，用户和开发者可以通过这些API获取客户端相关的软硬件信息</p>
<p>这些信息因人而异通过部分信息来产生<strong>相对差异</strong>的信息来生成生成相对独立的设备ID。</p>
<blockquote>
<p>简单理解就是软件信息（部分或全部）、硬件信息（部分或全部）+ 指纹生成算法=生成指纹</p>
</blockquote>
<p>辨识度的信息可以是系统信息、软件信息、地理位置、时区、语言等等，所给予的信息决定了浏览器指纹的准确性。</p>
<h3 id="设备指纹究竟是如何区分的唯一"><a class="markdownIt-Anchor" href="#设备指纹究竟是如何区分的唯一"></a> 设备指纹究竟是如何区分的“唯一”</h3>
<p>在一般情况下单一维度的差异性并不能形成标识设备的稳定特性，但可以经过收集大量的隐形特征通过数据分析、建模等方式等组合使用，可以更加精准的区分唯一</p>
<blockquote>
<p>例如：我们常见的双胞胎，它们长相相似、声音神似但根据以上两种特征无法有效的区分，但却可以根据更深层的习惯、喜好，甚至是某种条件反射的特殊因子，还是可以较为有效的降低“指纹”的碰撞率</p>
</blockquote>
<h3 id="什么信息是不能包含作为设备指纹"><a class="markdownIt-Anchor" href="#什么信息是不能包含作为设备指纹"></a> 什么信息是不能包含作为设备指纹？</h3>
<p>根据国家法律要求，以下信息不能被作为指纹的因素</p>
<ul>
<li>手机号</li>
<li>通话记录</li>
<li>短信</li>
<li>通讯录</li>
<li>身份证号</li>
<li>等</li>
</ul>
<blockquote>
<p>虽然这些信息有非常强的一致性，可以非常有效的提高设备指纹的准确性</p>
<p>但是涉猎个人隐私的数据都是不可触碰的信息。网上绝非法外之地</p>
</blockquote>
<h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3>
<p>设备指纹相同，很大概率上是同一设备或用户；但设备指纹不同时，不一定不是同一设备或用户</p>
<h2 id="设备指纹实现原理与检测"><a class="markdownIt-Anchor" href="#设备指纹实现原理与检测"></a> 设备指纹实现原理与检测</h2>
<p>采集设备指纹需要满足两大特征：较为稳定的环境、篡改监测</p>
<h3 id="手机之android设备指纹"><a class="markdownIt-Anchor" href="#手机之android设备指纹"></a> 手机之Android设备指纹</h3>
<p>设备的Id需要兼具稳定性、唯一性，但Android系统的开源和碎片化导致API函数实现不尽相同。下表是Android系统比较稳定的设备参数</p>
<table>
<thead>
<tr>
<th style="text-align:center">采集项</th>
<th style="text-align:center">中文含义</th>
<th style="text-align:center">特征</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Android ID</td>
<td style="text-align:center">设备首次启动时自动随机生成的设备ID</td>
<td style="text-align:center">1.不需要授权，相同信号的手机小概率碰撞<br />2.恢复出厂设置将被重置</td>
</tr>
<tr>
<td style="text-align:center">IMEI/MEID</td>
<td style="text-align:center">设备码<br />移动、联通获取IMEI<br />电信获取MEID</td>
<td style="text-align:center">1.唯一性质较好，还是存在小概率碰撞<br />2.需要READ_PHONE_STATE权限<br />3.未含有卡槽的设备无法获取</td>
</tr>
<tr>
<td style="text-align:center">IMSI</td>
<td style="text-align:center">手机SIM卡识别</td>
<td style="text-align:center">1.需要READ_PHONE_STATE权限<br />2.更换手机卡会改变</td>
</tr>
<tr>
<td style="text-align:center">WI-FI MAC</td>
<td style="text-align:center">网卡MAC地址</td>
<td style="text-align:center">1.当未连接WI-FI时，有概率获取失败<br />2.个别只读存储器恢复出厂设置会被重置</td>
</tr>
<tr>
<td style="text-align:center">Bluetooth MAC</td>
<td style="text-align:center">蓝牙MAC地址</td>
<td style="text-align:center">高版本Android系统无法获取（约8.0以上）</td>
</tr>
<tr>
<td style="text-align:center">Serial</td>
<td style="text-align:center">设备串号</td>
<td style="text-align:center">同类型号的手机碰撞概率高</td>
</tr>
<tr>
<td style="text-align:center">Fingerprint</td>
<td style="text-align:center">设备多个硬件编号统称</td>
<td style="text-align:center">同类型号的手机碰撞概率高</td>
</tr>
<tr>
<td style="text-align:center">Storage</td>
<td style="text-align:center">内存、磁盘空间</td>
<td style="text-align:center">同类型号的手机碰撞概率高</td>
</tr>
<tr>
<td style="text-align:center">Adverting ID</td>
<td style="text-align:center">Google Play广告ID</td>
<td style="text-align:center">仅限于Google服务用户使用</td>
</tr>
</tbody>
</table>
<p>Android设备所有采集的项都是Android公开的API，采集项被大面积篡改的情况下不能保持设备ID不变，通常有效的方式就是<br />
<strong>检测和监控运行环境</strong>，针对Android设备指纹检测可归纳为</p>
<ol>
<li>通过安装安装包检测安装环境</li>
<li>通过特定的特征识别root环境</li>
<li>通过多种方案采集同一字段信息检测环境是否<strong>异常</strong></li>
<li>通过通用的修改方式识别（例如中间人攻击、注入、Hook、重放攻击等），从而达到检测环境的效果</li>
<li>通过特定特征识别（例如Xpose、Frida、模拟器等）检测</li>
</ol>
<h3 id="手机之ios设备指纹"><a class="markdownIt-Anchor" href="#手机之ios设备指纹"></a> 手机之IOS设备指纹</h3>
<p>IOS相对开源的Android系统权限更加严格，且手机型号、系统版本较与Android更单一。由于权限等影响IOS能够获取的设备参数较少。如下表列举了较稳定的IOS设备参数</p>
<table>
<thead>
<tr>
<th style="text-align:center">采集项</th>
<th style="text-align:center">中文含义</th>
<th style="text-align:center">特征</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DeviceName</td>
<td style="text-align:center">设备名称</td>
<td style="text-align:center">1.用户可以自行修改，默认值存在很大的碰撞<br />2.自定义值有较强的特征</td>
</tr>
<tr>
<td style="text-align:center">WI-FI MAC</td>
<td style="text-align:center">网卡MAC地址</td>
<td style="text-align:center">唯一性好，高版本手机不能稳定性采集</td>
</tr>
<tr>
<td style="text-align:center">Boot time</td>
<td style="text-align:center">系统开机时间（μs微秒）</td>
<td style="text-align:center">1.存在少量碰撞，重启会发生改变<br />2.采集多次可能会发生变化</td>
</tr>
<tr>
<td style="text-align:center">Storage</td>
<td style="text-align:center">内存、磁盘空间</td>
<td style="text-align:center">同类型号的手机碰撞概率高</td>
</tr>
<tr>
<td style="text-align:center">IDFV</td>
<td style="text-align:center">厂商标识符</td>
<td style="text-align:center">1.不能跨合作方<br />2.删除本合作方APP后重新安装发生改变</td>
</tr>
<tr>
<td style="text-align:center">IDFA</td>
<td style="text-align:center">广告标识符</td>
<td style="text-align:center">1.需要广告权限<br />2。用户可以限制广告追踪</td>
</tr>
</tbody>
</table>
<p>IOS大部分篡改都是基于Hook进行改机，以及模拟器。</p>
<blockquote>
<p>IOS模拟器其本质为在X86_64架构上运行iPhone自带的模拟器，同时APP需要页数适配才能被安装</p>
</blockquote>
<p>IOS采集指纹检测可分为如下</p>
<ul>
<li>通过通用的Hook原理进行识别</li>
<li>通过特定的工具特征识别</li>
<li>寻找特定空间存储设备标识进行识别</li>
<li>对抗备份、抹机，进行识别</li>
</ul>
<h3 id="web设备指纹"><a class="markdownIt-Anchor" href="#web设备指纹"></a> Web设备指纹</h3>
<p>Web设备指纹（浏览器指纹）是指用户硬件、软件信息综合计算产生标识</p>
<h4 id="web指纹特点"><a class="markdownIt-Anchor" href="#web指纹特点"></a> Web指纹特点</h4>
<p>通过Javascript采集信息生成对应设备ID，与传统的Cookie技术相比较，Web设备指纹更加稳定</p>
<p>稳定浏览器版本采集参数，如下表所示</p>
<table>
<thead>
<tr>
<th style="text-align:center">采集项</th>
<th style="text-align:center">中文含义</th>
<th style="text-align:center">特征</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">UserAgent</td>
<td style="text-align:center">浏览器客户端标识</td>
<td style="text-align:center">可以任意伪装与修改</td>
</tr>
<tr>
<td style="text-align:center">Gpu</td>
<td style="text-align:center">设备GPU特征</td>
<td style="text-align:center">1.碰撞率高<br />2.可跨浏览器</td>
</tr>
<tr>
<td style="text-align:center">Canvas</td>
<td style="text-align:center">2D指纹</td>
<td style="text-align:center">唯一性好（不同浏览器的指纹不同）</td>
</tr>
<tr>
<td style="text-align:center">Webgl</td>
<td style="text-align:center">3D指纹</td>
<td style="text-align:center">1.碰撞率高<br />2.可跨浏览器</td>
</tr>
<tr>
<td style="text-align:center">Plugin List</td>
<td style="text-align:center">浏览器自带插件列表</td>
<td style="text-align:center">当用户安装特殊插件，相同浏览器碰撞率高</td>
</tr>
<tr>
<td style="text-align:center">FontList</td>
<td style="text-align:center">字体列表</td>
<td style="text-align:center">当用户安装特殊字体，相同浏览器碰撞率高</td>
</tr>
<tr>
<td style="text-align:center">IP</td>
<td style="text-align:center">内网IP/外网IP</td>
<td style="text-align:center">1.切换网络会改变<br />2.内网采集局限性大</td>
</tr>
<tr>
<td style="text-align:center">TCP</td>
<td style="text-align:center">网络协议</td>
<td style="text-align:center">1. 不同操作系统协议差异大<br />2.不易被修改<br />3.用户无感知<br />4.碰撞率极高</td>
</tr>
<tr>
<td style="text-align:center">Navigator</td>
<td style="text-align:center">有关浏览器的信息</td>
<td style="text-align:center">相同系统、相同版本碰撞率极大</td>
</tr>
</tbody>
</table>
<p>Web指纹采集检测可如下</p>
<ol>
<li>识别浏览器异常环境</li>
<li>特征检测（原型链）检测Hook</li>
<li>特定特征识别JS是否调试与检测（控制台、debugger等）</li>
<li>特殊方式存储浏览器设备标识（如localStorage）</li>
</ol>
<p>Web指纹采集检测原理可如下</p>
<p><strong>无头浏览器识别</strong></p>
<ul>
<li>UA识别：检测/Headless Chrome/.test(Navigator.userAgent)</li>
<li>Webdriver检测: Webdriver是否在 navigator</li>
<li>selenium检测：检测<code>window.seleium</code></li>
<li>PhantomJS\nightmare-JS 检测</li>
<li>等</li>
</ul>
<p><strong>隐身模式识别</strong></p>
<p>Chrome：在隐身模式下，FileSystem API禁止，使用报异常</p>
<p>Firefox：在隐身模式下，IndexedDB执行Open报异常</p>
<p>Safari：在隐身模式下，localStorage对象存在，但运行setItem方法报异常</p>
<p><strong>控制台检测</strong><br />
设备 隐式调用元素Id</p>
<p>隐式调用Regexp等toString</p>
<p><strong>Hook检测</strong></p>
<p>自定义Hook检测：在定义函数时将函数整体作为参数生成Hash值在执行该函数时校验Hash值</p>
<p>函数检测：采集调用toString方法对内容进行校验（伪造toString方法即可绕过）</p>
<p>对象检测：通过<code>Object.defineProperty</code>方法修改属性是不可更改的（可复写debugger即可）</p>
<p>其他检测：</p>
<p>SSL/TLS检测（产品：akamai）</p>
<h2 id="推荐阅读"><a class="markdownIt-Anchor" href="#推荐阅读"></a> 推荐阅读</h2>
<p>浏览器指纹在线检测：<span class="exturl" data-url="aHR0cDovL2YudmlzaW9uLw==">http://f.vision/<i class="fa fa-external-link-alt"></i></span></p>
<p>修改浏览器指纹：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vNjh4aS9wLzEzMzUzMTQwLmh0bWw=">https://www.cnblogs.com/68xi/p/13353140.html<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>spider</category>
        <category>crawler</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>详探Redis.conf</title>
    <url>/12856.html</url>
    <content><![CDATA[<blockquote>
<p>Redis版本：6.0.10</p>
<p>redis.conf 默认路径：/opt/redis-6.0.10 路径下（如果为自定制安装，则在您设置的redis路径下）</p>
</blockquote>
<p>还记得我刚入行的时候，我的师傅就经常告诉我们<code>配置比开发更重要</code>，因为很多时候就是由于配置不当，而造成后期的难以预想的各种问题，<br />
以至于项目难以维护等等由于配置。进入一个公司首先的也是看相关项目的文档。so，如果需要对于redis有更深入的了解，与使用配置文件不可不读。<br />
为CURD，但不止于CURD。那么接下来我们对于<code>redis.conf</code>有个了解，话不多说，开干。</p>
<span id="more"></span>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">Redis configuration file example.</span><br><span class="line"></span><br><span class="line">Note that in order to read the configuration file, Redis must be</span><br><span class="line">started with the file path as first argument :</span><br><span class="line"></span><br><span class="line">./redis-server /path/to/redis.conf</span><br><span class="line"></span><br><span class="line">Note on units : when memory size is needed, it is possible to specify</span><br><span class="line">it in the usual form of 1k 5GB 4M and so forth :</span><br><span class="line"></span><br><span class="line"><span class="attr">1k</span> = &gt; <span class="number">1000</span> bytes</span><br><span class="line"><span class="attr">1kb</span> = &gt; <span class="number">1024</span> bytes</span><br><span class="line"><span class="attr">1m</span> = &gt; <span class="number">1000000</span> bytes</span><br><span class="line"><span class="attr">1mb</span> = &gt; <span class="number">1024</span>*<span class="number">1024</span> bytes</span><br><span class="line"><span class="attr">1g</span> = &gt; <span class="number">1000000000</span> bytes</span><br><span class="line"><span class="attr">1gb</span> = &gt; <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span> bytes</span><br><span class="line"></span><br><span class="line">units are case insensitive so 1GB 1Gb 1gB are all the same.</span><br></pre></td></tr></table></figure>
<p>Redis启动必须指定配置文件路径(如果没有则使用默认的配置文件)，</p>
<blockquote>
<p>说明如果我们把<code>默认的</code>配置文件给删除了，是无法启动redis的。</p>
<p>同理既然可以指定路径，那么我们也可以参考默认配置文件，定制化配置Redis</p>
</blockquote>
<p>需要使用内存大小时，可以指定单位，通常是以 k,gb,m的形式出现，并且<strong>单位不区分大小写</strong>。</p>
<p>仔细看你会发现它只支持<code>bytes</code>类型，不支持``bit`等类型</p>
<h2 id="includes"><a class="markdownIt-Anchor" href="#includes"></a> INCLUDES</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">Include one or more other config files here.  This is useful if you</span><br><span class="line">have a standard template that goes to all Redis servers but also need</span><br><span class="line">to customize a few per-server settings.  Include files can include</span><br><span class="line">other files, so use this wisely.</span><br><span class="line"><span class="comment"># 在此处包括一个或多个其他配置文件。如果您具有可用于所有Redis服务器的标准模板，但还需要自定义一些每台服务器设置，则此功能很有用。包含文件可以包含其他文件，因此请明智地使用它</span></span><br><span class="line">Note that option &quot;include&quot; won&#x27;t be rewritten by command &quot;CONFIG REWRITE&quot;</span><br><span class="line">from admin or Redis Sentinel. Since Redis always uses the last processed</span><br><span class="line">line as value of a configuration directive, you&#x27;d better put includes</span><br><span class="line">at the beginning of this file to avoid overwriting config change at runtime.</span><br><span class="line"><span class="comment"># 请注意，选项“ include”将不会被admin或Redis Sentinel中的命令“ CONFIG REWRITE”重写。由于Redis始终使用最后处理的行作为配置指令的值，因此最好将include放在此文件的开头，以避免在运行时覆盖配置更改</span></span><br><span class="line">If instead you are interested in using includes to override configuration</span><br><span class="line">options, it is better to use include as the last line.</span><br><span class="line"><span class="comment"># 相反，如果您有兴趣使用include覆盖配置选项，则最好使用include作为最后一行</span></span><br><span class="line">include /path/to/local.conf</span><br><span class="line">include /path/to/other.conf</span><br></pre></td></tr></table></figure>
<p>我们知道Redis只有一个配置文件，如果多个人进行开发维护，那么就需要多个这样的配置文件，这时候多个配置文件就可以在此通过<br />
include /path/to/local.conf 配置进来，而原本的 redis.conf<br />
配置文件就作为一个总闸。</p>
<p>另外需要注意的时，如果将此配置写在redis.conf 文件的开头，那么后面的配置会覆盖引入文件的配置，如果想以引入文件的配置为主，那么需要将<br />
include 配置写在 redis.conf 文件的末尾。</p>
<h2 id="modules"><a class="markdownIt-Anchor" href="#modules"></a> MODULES</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">Load modules at startup. If the server is not able to load modules</span><br><span class="line">it will abort. It is possible to use multiple loadmodule directives.</span><br><span class="line"></span><br><span class="line">loadmodule /path/to/my_module.so</span><br><span class="line">loadmodule /path/to/other_module.so</span><br></pre></td></tr></table></figure>
<p>通过这里的 loadmodule 配置将引入自定义模块来新增一些功能。</p>
<h2 id="network重要"><a class="markdownIt-Anchor" href="#network重要"></a> NETWORK(重要)</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">By default, if no &quot;bind&quot; configuration directive is specified, Redis listens</span><br><span class="line">for connections from all available network interfaces on the host machine.</span><br><span class="line">It is possible to listen to just one or multiple selected interfaces using</span><br><span class="line">the &quot;bind&quot; configuration directive, followed by one or more IP addresses.</span><br><span class="line"><span class="comment"># 默认情况下，如果未指定“ bind”配置指令，则Redis侦听主机上所有可用网络接口的连接。可以使用“ bind”配置指令仅侦听一个或多个所选接口，然后侦听一个或多个IP地址</span></span><br><span class="line">Examples :</span><br><span class="line"></span><br><span class="line">bind 192.168.1.100 10.0.0.1</span><br><span class="line">bind 127.0.0.1 : :1</span><br><span class="line"></span><br><span class="line">~~~ WARNING ~~~ If the computer running Redis is directly exposed to the</span><br><span class="line">internet, binding to all the interfaces is dangerous and will expose the</span><br><span class="line">instance to everybody on the internet. So by default we uncomment the</span><br><span class="line">following bind directive, that will force Redis to listen only on the</span><br><span class="line">IPv4 loopback interface address (this means Redis will only be able to</span><br><span class="line">accept client connections from the same host that it is running on).</span><br><span class="line"><span class="comment"># ~~~警告~~~如果运行Redis的计算机直接暴露于Internet，则绑定到所有接口都是很危险的，并且会将实例暴露给Internet上的所有人。因此，默认情况下，我们取消注释以下bind指令，这将强制Redis仅在IPv4环回接口地址上侦听（这意味着Redis将只能接受来自其运行所在主机的客户端连接）</span></span><br><span class="line">IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES</span><br><span class="line">JUST COMMENT OUT THE FOLLOWING LINE.</span><br><span class="line"><span class="comment"># 如果您确定要立即侦听所有接口，只需在后续行中注明即可。</span></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">bind 127.0.0.1 : :1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Protected mode is a layer of security protection, in order to avoid that</span><br><span class="line">Redis instances left open on the internet are accessed and exploited.</span><br><span class="line"><span class="comment"># 保护模式是安全保护的一层，目的是避免访问和利用Internet上打开的Redis实例。</span></span><br><span class="line">When protected mode is on and if :</span><br><span class="line"><span class="comment"># 当保护模式开启时，如果</span></span><br><span class="line">1) The server is not binding explicitly to a set of addresses using the</span><br><span class="line">&quot;bind&quot; directive.</span><br><span class="line"><span class="comment"># 服务器未使用“ bind”指令显式绑定到一组地址</span></span><br><span class="line">2) No password is configured.</span><br><span class="line"><span class="comment"># 没有配置密码</span></span><br><span class="line">The server only accepts connections from clients connecting from the</span><br><span class="line">IPv4 and IPv6 loopback addresses 127.0.0.1 and : :1, and from Unix domain</span><br><span class="line">sockets.</span><br><span class="line"><span class="comment"># 服务器仅接受来自客户端的连接，这些客户端从IPv4和IPv6回送地址127.0.0.1和:: 1以及Unix域套接字连接</span></span><br></pre></td></tr></table></figure>
<p>bind:<br />
绑定redis服务器网卡IP，默认为127.0.0.1,即本地回环地址。这样的话，访问redis服务只能通过本机的客户端连接，而无法通过远程连接。如果bind选项为空的话，那会接受所有来自于可用网络接口的连接。</p>
<p>同时需要注意的是 如果注释掉<code>bind</code><br />
后面的内容，运行Redis的计算机将直接暴露于在internet上，绑定到所有接口是危险的，并且会暴露向互联网上的每个人提供实例。需谨慎选择</p>
<blockquote>
<p>至少也得加个密码(见下文)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">By default protected mode is enabled. You should disable it only if</span><br><span class="line">you are sure you want clients from other hosts to connect to Redis</span><br><span class="line">even if no authentication is configured, nor a specific set of interfaces</span><br><span class="line">are explicitly listed using the &quot;bind&quot; directive.</span><br><span class="line"># 默认情况下启用保护模式。仅当您确定您希望其他主机的客户端连接到Redis时，即使未配置身份验证，也不要使用“ bind”指令显式列出一组特定的接口，才应禁用它</span><br><span class="line">protected-mode yes</span><br></pre></td></tr></table></figure>
<p>默认情况下，启用保护模式。只有当您确定希望来自其他主机的客户端连接到Redis时才应该禁用它，即使没有配置身份验证，也没有使用“bind”指令显式列出一组特定的接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept connections on the specified port, default is 6379 (IANA 815344).</span><br><span class="line">If port 0 is specified Redis will not listen on a TCP socket.</span><br><span class="line"># 接受指定端口上的连接，默认为6379（IANA 815344）。如果指定了端口0，则Redis将不会在TCP套接字上侦听</span><br><span class="line">port 6379</span><br></pre></td></tr></table></figure>
<p>接受指定端口上的连接，默认值为6379。如果指定了端口0，Redis将不会侦听TCP套接字。由于Redis是单线程模型，因此单机开多个Redis进程的时候需要修改端口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCP listen() backlog.</span><br><span class="line"></span><br><span class="line">In high requests-per-second environments you need a high backlog in order</span><br><span class="line">to avoid slow clients connection issues. Note that the Linux kernel</span><br><span class="line">will silently truncate it to the value of /proc/sys/net/core/somaxconn so</span><br><span class="line">make sure to raise both the value of somaxconn and tcp_max_syn_backlog</span><br><span class="line">in order to get the desired effect.</span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line">在每秒高请求的环境中，您需要一个高积压工作，以避免客户端连接速度慢的问题。请注意，Linux内核将静默地将其截断为/proc/sys/net/core/somaxconn so的值</span><br><span class="line">确保同时提高somaxconn和tcp\u max\u syn\u backlog的值以获得所需的效果</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认值 511<br />
tcp-backlog：511</p>
<p>此参数确定了TCP连接中已完成队列(完成三次握手之后)的长度，</p>
</blockquote>
<p>当然此值必须不大于Linux系统定义的/proc/sys/net/core/somaxconn值，默认是511，而Linux的默认参数值是128。当系统并发量大并且客户端速度缓慢的时候，可以将这二个参数一起参考设定。</p>
<blockquote>
<p>建议修改为 2048<br />
修改somaxconn</p>
<p>该内核参数默认值一般是128，对于负载很大的服务程序来说大大的不够。一般会将它修改为2048或者更大。</p>
<p>echo 2048 &gt; /proc/sys/net/core/somaxconn 但是这样系统重启后保存不了</p>
<p>在/etc/sysctl.conf中添加如下</p>
<p>net.core.somaxconn = 2048</p>
<p>然后在终端中执行</p>
<p>sysctl -p</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unix socket.</span><br><span class="line"></span><br><span class="line">Specify the path for the Unix socket that will be used to listen for</span><br><span class="line">incoming connections. There is no default, so Redis will not listen</span><br><span class="line">on a unix socket when not specified.</span><br><span class="line"></span><br><span class="line">unixsocket /tmp/redis.sock</span><br><span class="line">unixsocketperm 700</span><br></pre></td></tr></table></figure>
<p>指定用于侦听传入连接的Unix套接字的路径。没有默认值，因此Redis在未指定时不会侦听unix套接字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Close the connection after a client is idle for N seconds (0 to disable)</span><br><span class="line">timeout 0</span><br></pre></td></tr></table></figure>
<p>客户端空闲N秒后关闭连接（0表示禁用）</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">TCP keepalive.</span><br><span class="line"></span><br><span class="line">If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence</span><br><span class="line">of communication. This is useful for two reasons :</span><br><span class="line"><span class="comment"># 如果不为零，请在没有通信的情况下使用SO_KEEPALIVE向客户端发送TCP ACK。这很有用，有两个原因：</span></span><br><span class="line">1) Detect dead peers.   <span class="comment"># 检测死者</span></span><br><span class="line">2) Force network equipment in the middle to consider the connection to be</span><br><span class="line">alive.                  <span class="comment"># 强制中间的网络设备考虑连接处于活动状态。</span></span><br><span class="line"></span><br><span class="line">On Linux, the specified value (in seconds) is the period used to send ACKs.</span><br><span class="line">Note that to close the connection the double of the time is needed.</span><br><span class="line">On other kernels the period depends on the kernel configuration.</span><br><span class="line"><span class="comment"># 在Linux上，指定的值（以秒为单位）是用于发送ACK的时间段。请注意，关闭连接需要两倍的时间。在其他内核上，周期取决于内核配置</span></span><br><span class="line">A reasonable value for this option is 300 seconds, which is the new</span><br><span class="line">Redis default starting with Redis 3.2.1.</span><br><span class="line"><span class="comment"># 此选项的合理值是300秒，这是从Redis 3.2.1开始的新Redis默认值。</span></span><br><span class="line">tcp-keepalive 300</span><br></pre></td></tr></table></figure>
<p>TCP保持连接。</p>
<p>如果非零，则在没有通信的情况下，使用SO_KEEPALIVE向客户端发送TCP确认。这有两个原因：</p>
<p>1） 检测死掉的同伴。</p>
<p>2） 强制中间的网络设备认为连接是活动的。</p>
<p>在Linux上，指定的值（以秒为单位）是用于发送ACK的时间段。请注意，要关闭连接，需要两倍的时间。</p>
<p>在其他内核上，周期取决于内核配置。</p>
<p>这个选项的合理值是300秒，这是从redis3.2.1开始的新Redis默认值。</p>
<p>tcp保持300</p>
<h2 id="tlsssl"><a class="markdownIt-Anchor" href="#tlsssl"></a> TLS/SSL</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">By default, TLS/SSL is disabled. To enable it, the &quot;tls-port&quot; configuration</span><br><span class="line">directive can be used to define TLS-listening ports. To enable TLS on the</span><br><span class="line">default port, use:</span><br><span class="line"># 默认情况下，TLSSSL被禁用。要启用它，可以使用“ tls-port”配置指令来定义TLS侦听端口。要在默认端口上启用TLS，请使用</span><br><span class="line">port 0</span><br><span class="line">tls-port 6379</span><br></pre></td></tr></table></figure>
<p>默认情况下，TLS/SSL处于禁用状态。要启用它，“tls端口”配置</p>
<p>指令可用于定义TLS侦听端口。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">Configure a X.509 certificate and private key to use for authenticating the</span><br><span class="line">server to connected clients, masters or cluster peers.  These files should be</span><br><span class="line">PEM formatted.</span><br><span class="line"><span class="comment"># 配置X.509证书和私钥，用于对连接的客户端，主服务器或集群对等服务器进行身份验证。这些文件应为PEM格式</span></span><br><span class="line">tls-cert-file redis.crt</span><br><span class="line">tls-key-file redis.key</span><br><span class="line"></span><br><span class="line">Configure a DH parameters file to enable Diffie-Hellman (DH) key exchange :</span><br><span class="line"></span><br><span class="line">tls-dh-params-file redis.dh</span><br><span class="line"></span><br><span class="line">Configure a CA certificate(s) bundle or directory to authenticate TLS/SSL</span><br><span class="line">clients and peers.  Redis requires an explicit configuration of at least one</span><br><span class="line">of these, and will not implicitly use the system wide configuration.</span><br><span class="line"></span><br><span class="line">tls-ca-cert-file ca.crt</span><br><span class="line">tls-ca-cert-dir /etc/ssl/certs</span><br><span class="line"></span><br><span class="line">By default, clients (including replica servers) on a TLS port are required</span><br><span class="line">to authenticate using valid client side certificates.</span><br><span class="line"><span class="comment"># 默认情况下，要求TLS端口上的客户端（包括副本服务器）使用有效的客户端证书进行身份验证</span></span><br><span class="line">If &quot;no&quot; is specified, client certificates are not required and not accepted.</span><br><span class="line">If &quot;optional&quot; is specified, client certificates are accepted and must be</span><br><span class="line">valid if provided, but are not required.</span><br><span class="line"><span class="comment"># 如果指定“否”，则不需要也不接受客户端证书。如果指定了“可选”，则接受客户端证书，并且如果提供的话，客户端证书必须有效，但不是必需的</span></span><br><span class="line">tls-auth-clients no</span><br><span class="line">tls-auth-clients optional</span><br><span class="line"></span><br><span class="line">By default, a Redis replica does not attempt to establish a TLS connection</span><br><span class="line">with its master.</span><br><span class="line"><span class="comment"># 默认情况下，Redis副本不会尝试与其主服务器建立TLS连接</span></span><br><span class="line">Use the following directive to enable TLS on replication links.</span><br><span class="line"><span class="comment"># 使用以下指令在复制链接上启用TLS</span></span><br><span class="line">tls-replication yes</span><br><span class="line"></span><br><span class="line">By default, the Redis Cluster bus uses a plain TCP connection. To enable</span><br><span class="line">TLS for the bus protocol, use the following directive :</span><br><span class="line"></span><br><span class="line">tls-cluster yes</span><br><span class="line"></span><br><span class="line">Explicitly specify TLS versions to support. Allowed values are case insensitive</span><br><span class="line">and include &quot;TLSv1&quot;, &quot;TLSv1.1&quot;, &quot;TLSv1.2&quot;, &quot;TLSv1.3&quot; (OpenSSL &gt; = 1.1.1) or</span><br><span class="line">any combination. To enable only TLSv1.2 and TLSv1.3, use :</span><br><span class="line"></span><br><span class="line">tls-protocols &quot;TLSv1.2 TLSv1.3&quot;</span><br><span class="line"></span><br><span class="line">Configure allowed ciphers.  See the ciphers(1ssl) manpage for more information</span><br><span class="line">about the syntax of this string.</span><br><span class="line"></span><br><span class="line">Note : this configuration applies only to &lt;= TLSv1.2.</span><br><span class="line"></span><br><span class="line">tls-ciphers DEFAULT : !MEDIUM</span><br><span class="line"></span><br><span class="line">Configure allowed TLSv1.3 ciphersuites.  See the ciphers(1ssl) manpage for more</span><br><span class="line">information about the syntax of this string, and specifically for TLSv1.3</span><br><span class="line">ciphersuites.</span><br><span class="line"></span><br><span class="line">tls-ciphersuites TLS_CHACHA20_POLY1305_SHA256</span><br><span class="line"></span><br><span class="line">When choosing a cipher, use the server&#x27;s preference instead of the client</span><br><span class="line">preference. By default, the server follows the client&#x27;s preference.</span><br><span class="line"></span><br><span class="line">tls-prefer-server-ciphers yes</span><br><span class="line"></span><br><span class="line">By default, TLS session caching is enabled to allow faster and less expensive</span><br><span class="line">reconnections by clients that support it. Use the following directive to disable</span><br><span class="line">caching.</span><br><span class="line"></span><br><span class="line">tls-session-caching no</span><br><span class="line"></span><br><span class="line">Change the default number of TLS sessions cached. A zero value sets the cache</span><br><span class="line">to unlimited size. The default size is 20480.</span><br><span class="line"></span><br><span class="line">tls-session-cache-size 5000</span><br><span class="line"></span><br><span class="line">Change the default timeout of cached TLS sessions. The default timeout is 300</span><br><span class="line">seconds.</span><br><span class="line"></span><br><span class="line">tls-session-cache-timeout 60</span><br></pre></td></tr></table></figure>
<h2 id="general"><a class="markdownIt-Anchor" href="#general"></a> GENERAL</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">By default Redis does not run as a daemon. Use &#x27;yes&#x27; if you need it.</span><br><span class="line">Note that Redis will write a pid file in /usr/local/var/run/redis.pid when daemonized.</span><br><span class="line">daemonize no</span><br></pre></td></tr></table></figure>
<p>daemonize:设置为yes表示指定Redis以守护进程的方式启动（即后台启动）。默认值为 no</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">If you run Redis from upstart or systemd, Redis can interact with your</span><br><span class="line">supervision tree. Options:</span><br><span class="line">supervised no      - no supervision interaction</span><br><span class="line">supervised upstart - signal upstart by putting Redis into SIGSTOP mode</span><br><span class="line">                    requires &quot;expect stop&quot; in your upstart job config</span><br><span class="line">supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET</span><br><span class="line">supervised auto    - detect upstart or systemd method based on</span><br><span class="line">                    UPSTART_JOB or NOTIFY_SOCKET environment variables</span><br><span class="line">Note: these supervision methods only signal &quot;process is ready.&quot;</span><br><span class="line">   They do not enable continuous pings back to your supervisor.</span><br><span class="line">supervised no</span><br></pre></td></tr></table></figure>
<p>如果你使用系统的<code>upstart</code>或者<code>systemd</code>运行redis。他们可以管理监控redis。默认不启用</p>
<p>参数</p>
<p>supervised no： - no supervision interaction（无监督-无监督互动）</p>
<p>supervised upstart - 监督upstart-通过将Redis置于SIGSTOP模式来发出upstart信号在upstart作业配置中需要“expect<br />
stop”</p>
<p>supervised systemd - 受监控的systemd-通过写入READY=1到$NOTIFY\u SOCKET发送信号systemd</p>
<p>supervised auto - 基于upstart\u JOB或NOTIFY\u SOCKET环境变量检测upstart或systemd方法</p>
<blockquote>
<p>注意：这些监督方法仅表示“过程准备就绪”，它们不支持连续ping返回到您的主管。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">If a pid file is specified, Redis writes it where specified at startup</span><br><span class="line">and removes it at exit.</span><br><span class="line"></span><br><span class="line">When the server runs non daemonized, no pid file is created if none is</span><br><span class="line">specified in the configuration. When the server is daemonized, the pid file</span><br><span class="line">is used even if not specified, defaulting to &quot;/usr/local/var/run/redis.pid&quot;.</span><br><span class="line"></span><br><span class="line">Creating a pid file is best effort: if Redis is not able to create it</span><br><span class="line">nothing bad happens, the server will start and run normally.</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br></pre></td></tr></table></figure>
<p>pidfile: 配置PID文件路径，当redis作为守护进程运行的时候，它会把 pid 默认写到<br />
/var/redis/run/redis_6379.pid 文件里面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Specify the server verbosity level.</span><br><span class="line">This can be one of:</span><br><span class="line">debug (a lot of information, useful for development/testing)</span><br><span class="line">verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="line">notice (moderately verbose, what you want in production probably)</span><br><span class="line">warning (only very important / critical messages are logged)</span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line">Specify the log file name. Also the empty string can be used to force</span><br><span class="line">Redis to log on the standard output. Note that if you use standard</span><br><span class="line">output for logging but daemonize, logs will be sent to /dev/null</span><br><span class="line">logfile &quot;&quot;</span><br></pre></td></tr></table></figure>
<p>loglevel ：定义日志级别。默认值为notice，有如下4种取值：</p>
<blockquote>
<p>debug（大量信息，对开发/测试有用）</p>
<p>verbose（许多很少有用的信息，但不像调试级别那样混乱）</p>
<p>notice（适度冗长，可能是生产中需要的内容）</p>
<p>warning（只记录非常重要/关键的消息）</p>
</blockquote>
<p>logfile ：配置log文件地址,默认打印在命令行终端的窗口上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">To enable logging to the system logger, just set &#x27;syslog-enabled&#x27; to yes,</span><br><span class="line">and optionally update the other syslog parameters to suit your needs.</span><br><span class="line">syslog-enabled no</span><br><span class="line"></span><br><span class="line">Specify the syslog identity.</span><br><span class="line">syslog-ident redis</span><br><span class="line"></span><br><span class="line">Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.</span><br><span class="line">syslog-facility local0</span><br><span class="line"></span><br><span class="line">Set the number of databases. The default database is DB 0, you can select</span><br><span class="line">a different one on a per-connection basis using SELECT &lt;dbid&gt; where</span><br><span class="line">dbid is a number between 0 and &#x27;databases&#x27;-1</span><br><span class="line">databases 16</span><br></pre></td></tr></table></figure>
<p>databases：设置数据库的数目。默认的数据库是DB 0 ，可以在每个连接上使用select <dbid><br />
命令选择一个不同的数据库，dbid是一个介于0到databases - 1 之间的数值。默认值是<br />
16，也就是说默认Redis有16个数据库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">By default Redis shows an ASCII art logo only when started to log to the</span><br><span class="line">standard output and if the standard output is a TTY. Basically this means</span><br><span class="line">that normally a logo is displayed only in interactive sessions.</span><br><span class="line"></span><br><span class="line">However it is possible to force the pre-4.0 behavior and always show a</span><br><span class="line">ASCII art logo in startup logs by setting the following option to yes.</span><br><span class="line">always-show-logo yes</span><br></pre></td></tr></table></figure>
<h2 id="snapshotting快照重要"><a class="markdownIt-Anchor" href="#snapshotting快照重要"></a> SNAPSHOTTING（快照，重要！！！）</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Save the DB on disk:</span><br><span class="line"></span><br><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"></span><br><span class="line">Will save the DB if both the given number of seconds and the given</span><br><span class="line">number of write operations against the DB occurred.</span><br><span class="line"></span><br><span class="line">In the example below the behavior will be to save:</span><br><span class="line">after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">after 60 sec if at least 10000 keys changed</span><br><span class="line"></span><br><span class="line">Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="line"></span><br><span class="line">It is also possible to remove all the previously configured save</span><br><span class="line">points by adding a save directive with a single empty string argument</span><br><span class="line">like in the following example:</span><br><span class="line"></span><br><span class="line">save &quot;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>save 900 1 save 300 10 save 60 10000</p>
<p>save：这里是用来配置触发 Redis的持久化条件，也就是什么时候将内存中的数据保存到硬盘。默认如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save 900 1：表示900 秒内如果至少有 1 个 key 的值变化，则保存</span><br><span class="line">save 300 10：表示300 秒内如果至少有 10 个 key 的值变化，则保存</span><br><span class="line">save 60 10000：表示60 秒内如果至少有 10000 个 key 的值变化，则保存</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">By default Redis will stop accepting writes if RDB snapshots are enabled</span><br><span class="line"> (at least one save point) and the latest background save failed.</span><br><span class="line"> This will make the user aware (in a hard way) that data is not persisting</span><br><span class="line"> on disk properly, otherwise chances are that no one will notice and some</span><br><span class="line"> disaster will happen.</span><br><span class="line"> </span><br><span class="line">  If the background saving process will start working again Redis will</span><br><span class="line"> automatically allow writes again.</span><br><span class="line"> </span><br><span class="line">  However if you have setup your proper monitoring of the Redis server</span><br><span class="line"> and persistence, you may want to disable this feature so that Redis will</span><br><span class="line"> continue to work as usual even if there are problems with disk,</span><br><span class="line"> permissions, and so forth.</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br></pre></td></tr></table></figure>
<p>默认情况下，如果启用RDB快照，Redis将停止接受写操作</p>
<p>（至少一个保存点）和最新的后台保存失败。</p>
<p>这将使用户意识到（以一种困难的方式）数据没有持久化</p>
<p>在磁盘上正确，否则很可能没有人会注意到和一些</p>
<p>灾难就会发生。</p>
<p>如果后台保存过程将重新开始工作，Redis将自动允许再次写入。但是，如果您已经设置了对Redis服务器的适当监视</p>
<p>和持久性，您可能希望禁用此功能，以便Redis</p>
<p>即使磁盘、权限等出现问题，也要继续正常工作。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Compress string objects using LZF when dump .rdb databases?</span><br><span class="line">By default compression is enabled as it&#x27;s almost always a win.</span><br><span class="line">If you want to save some CPU in the saving child set it to &#x27;no&#x27; but</span><br><span class="line">the dataset will likely be bigger if you have compressible values or keys.</span><br><span class="line">rdbcompression yes</span><br></pre></td></tr></table></figure>
<p>转储.rdb数据库时使用LZF压缩字符串对象？</p>
<p>默认情况下，压缩是启用的，因为它几乎总是一个胜利。</p>
<p>如果您想在保存子进程中保存一些CPU，请将其设置为“否”，但是</p>
<p>如果有可压缩的值或键，数据集可能会更大。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span><br><span class="line">This makes the format more resistant to corruption but there is a performance</span><br><span class="line">hit to pay (around 10%) when saving and loading RDB files, so you can disable it</span><br><span class="line">for maximum performances.</span><br><span class="line"></span><br><span class="line">RDB files created with checksum disabled have a checksum of zero that will</span><br><span class="line">tell the loading code to skip the check.</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line">由于RDB版本5，CRC64校验和放在文件的末尾。这使格式更能抵抗损坏，但在保存和加载RDB文件时，性能会受到影响（约10%），因此可以禁用它以获得最大性能。在禁用校验和的情况下创建的RDB文件的校验和为零，这将告诉加载代码跳过检查。</span><br></pre></td></tr></table></figure>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">The filename where to dump the DB</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line">将数据库转储到的文件名</span><br></pre></td></tr></table></figure>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Remove RDB files used by replication in instances without persistence</span><br><span class="line">enabled. By default this option is disabled, however there are environments</span><br><span class="line">where for regulations or other security concerns, RDB files persisted on</span><br><span class="line">disk by masters in order to feed replicas, or stored on disk by replicas</span><br><span class="line">in order to load them for the initial synchronization, should be deleted</span><br><span class="line">ASAP. Note that this option ONLY WORKS in instances that have both AOF</span><br><span class="line">and RDB persistence disabled, otherwise is completely ignored.</span><br><span class="line"></span><br><span class="line">An alternative (and sometimes better) way to obtain the same effect is</span><br><span class="line">to use diskless replication on both master and replicas instances. However</span><br><span class="line">in the case of replicas, diskless is not always an option.</span><br><span class="line">rdb-del-sync-files no</span><br><span class="line"></span><br><span class="line">The working directory.</span><br><span class="line"></span><br><span class="line">The DB will be written inside this directory, with the filename specified</span><br><span class="line">above using the &#x27;dbfilename&#x27; configuration directive.</span><br><span class="line"></span><br><span class="line">The Append Only File will also be created inside this directory.</span><br><span class="line"></span><br><span class="line">Note that you must specify a directory here, not a file name.</span><br><span class="line"></span><br><span class="line">dir /usr/local/var/db/redis/</span><br><span class="line"></span><br><span class="line">在没有持久性的实例中删除复制使用的RDB文件启用。默认情况下，此选项处于禁用状态，但是在某些环境中，出于管理法规或其他安全考虑，应尽快删除由主服务器保留在磁盘上以馈送副本的RDB文件，或由副本存储在磁盘上以加载它们以进行初始同步。请注意，此选项仅适用于同时禁用AOF和RDB持久性的实例，否则将完全忽略。</span><br><span class="line">另一种（有时更好）获得相同效果的方法是在主实例和副本实例上使用无盘复制。但是，对于副本，无磁盘并不是一种好的选择。</span><br><span class="line">rdb del同步文件编号</span><br><span class="line">工作目录。</span><br><span class="line">数据库将被写入这个目录，并指定文件名</span><br><span class="line">使用“dbfilename”配置指令。</span><br><span class="line">只附加的文件也将在这个目录中创建。</span><br><span class="line">请注意，必须在此处指定目录，而不是文件名。</span><br></pre></td></tr></table></figure>
<p>dbfilename ：设置快照的文件名，默认是 dump.rdb</p>
<p>⑥、dir：设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。使用上面的 dbfilename 作为保存的文件名。</p>
<h2 id="replication主从复制"><a class="markdownIt-Anchor" href="#replication主从复制"></a> REPLICATION（主从复制）</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">REPLICATION</span><br><span class="line"></span><br><span class="line">Master-Replica replication. Use replicaof to make a Redis instance a copy of</span><br><span class="line">another Redis server. A few things to understand ASAP about Redis replication.</span><br><span class="line"></span><br><span class="line">+------------------+      +---------------+</span><br><span class="line">|      Master      | ---&gt; |    Replica    |</span><br><span class="line">| (receive writes) |      |  (exact copy) |</span><br><span class="line">+------------------+      +---------------+</span><br><span class="line"></span><br><span class="line">1) Redis replication is asynchronous, but you can configure a master to</span><br><span class="line">stop accepting writes if it appears to be not connected with at least</span><br><span class="line">a given number of replicas.</span><br><span class="line"><span class="comment"># Redis复制是异步的，但是您可以配置一个主机，如果它看起来没有连接到至少给定数量的副本，那么它就停止接受写操作。</span></span><br><span class="line">2) Redis replicas are able to perform a partial resynchronization with the</span><br><span class="line">master if the replication link is lost for a relatively small amount of</span><br><span class="line">time. You may want to configure the replication backlog size (see the next</span><br><span class="line">sections of this file) with a sensible value depending on your needs.</span><br><span class="line"><span class="comment"># 如果复制链路丢失的时间相对较短，Redis复制副本可以执行与主机的部分重新同步。您可能需要根据需要使用合理的值来配置复制积压工作大小（请参阅本文件的下一节）。</span></span><br><span class="line">3) Replication is automatic and does not need user intervention. After a</span><br><span class="line">network partition replicas automatically try to reconnect to masters</span><br><span class="line">and resynchronize with them.</span><br><span class="line"><span class="comment"># 复制是自动的，不需要用户干预。在网络分区之后，复制副本会自动尝试重新连接到主机并与它们重新同步。</span></span><br><span class="line"></span><br><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line">If the master is password protected (using the &quot;requirepass&quot; configuration</span><br><span class="line">directive below) it is possible to tell the replica to authenticate before</span><br><span class="line">starting the replication synchronization process, otherwise the master will</span><br><span class="line">refuse the replica request.</span><br><span class="line"><span class="comment"># 如果主机受密码保护（使用下面的“requirepass”配置指令），则可以在启动复制同步过程之前通知复制副本进行身份验证，否则主机将拒绝副本请求。</span></span><br><span class="line"></span><br><span class="line">masterauth &lt;master-password&gt;</span><br><span class="line"></span><br><span class="line">However this is not enough if you are using Redis ACLs (for Redis version</span><br><span class="line">6 or greater), and the default user is not capable of running the PSYNC</span><br><span class="line">command and/or other commands needed for replication. In this case it&#x27;s</span><br><span class="line">better to configure a special user to use with replication, and specify the</span><br><span class="line">masteruser configuration as such :</span><br><span class="line"><span class="comment"># 但是，如果您正在使用Redis ACL（用于Redis版本6或更高版本），并且默认用户无法运行PSYNC命令和/或其他复制所需的命令，这还不够。在这种情况下，最好配置一个特殊用户以用于复制</span></span><br><span class="line">masteruser &lt;username&gt;</span><br><span class="line"></span><br><span class="line">When masteruser is specified, the replica will authenticate against its</span><br><span class="line">master using the new AUTH form : AUTH &lt;username&gt; &lt;password&gt;.</span><br><span class="line"><span class="comment"># 指定masteruser时，副本将使用新的AUTH表单针对其主服务器进行身份验证</span></span><br><span class="line">When a replica loses its connection with the master, or when the replication</span><br><span class="line">is still in progress, the replica can act in two different ways :</span><br><span class="line"><span class="comment"># 当副本失去与主数据库的连接时，或者仍在进行复制时，副本可以采取两种不同的方式进行操作</span></span><br><span class="line">1) if replica-serve-stale-data is set to &#x27;yes&#x27; (the default) the replica will</span><br><span class="line">still reply to client requests, possibly with out of date data, or the</span><br><span class="line">data set may just be empty if this is the first synchronization.</span><br><span class="line"><span class="comment"># 如果复制副本服务过时数据设置为“是”（默认值），则复制副本仍将回复客户端请求，可能包含过期数据，或者如果这是第一次同步，则数据集可能只是空的。</span></span><br><span class="line">2) If replica-serve-stale-data is set to &#x27;no&#x27; the replica will reply with</span><br><span class="line">an error &quot;SYNC with master in progress&quot; to all commands except :</span><br><span class="line">INFO, REPLICAOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG, SUBSCRIBE,</span><br><span class="line">UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB, COMMAND, POST,</span><br><span class="line">HOST and LATENCY.</span><br><span class="line"><span class="comment"># 如果将replica-serve-stale-data设置为“ no”，则该副本将对所有命令（“ INFO，REPLICAOF，AUTH，PING，SHUTDOWN，REPLCONF，ROLE，CONFIG，SUBSCRIBE）进行错误答复” ，退订，PSUBSCRIBE，PUNSUBSCRIBE，PUBLISH，PUBSUB，COMMAND，POST，HOST和LATENCY。</span></span><br><span class="line">replica-serve-stale-data yes</span><br><span class="line"></span><br><span class="line">You can configure a replica instance to accept writes or not. Writing against</span><br><span class="line">a replica instance may be useful to store some ephemeral data (because data</span><br><span class="line">written on a replica will be easily deleted after resync with the master) but</span><br><span class="line">may also cause problems if clients are writing to it because of a</span><br><span class="line">misconfiguration.</span><br><span class="line"><span class="comment"># 您可以配置副本实例以接受或不接受写入。针对副本实例进行写操作可能对存储一些临时数据很有用（因为与主实例重新同步后，写入副本上的数据将很容易删除），但是如果客户端由于配置错误而向其进行写操作，也会导致问题。</span></span><br><span class="line">Since Redis 2.6 by default replicas are read-only.</span><br><span class="line"></span><br><span class="line">Note : read only replicas are not designed to be exposed to untrusted clients</span><br><span class="line">on the internet. It&#x27;s just a protection layer against misuse of the instance.</span><br><span class="line">Still a read only replica exports by default all the administrative commands</span><br><span class="line">such as CONFIG, DEBUG, and so forth. To a limited extent you can improve</span><br><span class="line">security of read only replicas using &#x27;rename-command&#x27; to shadow all the</span><br><span class="line">administrative / dangerous commands.</span><br><span class="line"><span class="comment"># 只读副本并非旨在向Internet上不受信任的客户端公开。它只是防止实例滥用的保护层。默认情况下，只读副本仍会导出所有管理命令，例如CONFIG，DEBUG等。在一定程度上，您可以使用&#x27;rename-command&#x27;隐藏所有管理危险命令来提高只读副本的安全性</span></span><br><span class="line">replica-read-only yes</span><br><span class="line">Replication SYNC strategy : disk or socket.</span><br><span class="line"></span><br><span class="line">New replicas and reconnecting replicas that are not able to continue the</span><br><span class="line">replication process just receiving differences, need to do what is called a</span><br><span class="line">&quot;full synchronization&quot;. An RDB file is transmitted from the master to the</span><br><span class="line">replicas.</span><br><span class="line"><span class="comment"># 仅仅接受差异就无法继续复制过程的新副本和重新连接的副本需要进行所谓的“完全同步”。 RDB文件从主数据库传输到副本数据库</span></span><br><span class="line">The transmission can happen in two different ways :</span><br><span class="line"></span><br><span class="line">1) Disk-backed : The Redis master creates a new process that writes the RDB</span><br><span class="line">                 file on disk. Later the file is transferred by the parent</span><br><span class="line">                 process to the replicas incrementally.</span><br><span class="line">2) Diskless : The Redis master creates a new process that directly writes the</span><br><span class="line">              RDB file to replica sockets, without touching the disk at all.</span><br><span class="line"></span><br><span class="line">With disk-backed replication, while the RDB file is generated, more replicas</span><br><span class="line">can be queued and served with the RDB file as soon as the current child</span><br><span class="line">producing the RDB file finishes its work. With diskless replication instead</span><br><span class="line">once the transfer starts, new replicas arriving will be queued and a new</span><br><span class="line">transfer will start when the current one terminates.</span><br><span class="line"><span class="comment"># 使用磁盘支持的复制，当生成RDB文件时，只要生成RDB文件的当前子级完成工作，就可以将更多副本排入队列并与RDB文件一起使用。如果使用无盘复制，则一旦传输开始，新的副本将排队，并且当当前副本终止时将开始新的传输</span></span><br><span class="line">When diskless replication is used, the master waits a configurable amount of</span><br><span class="line">time (in seconds) before starting the transfer in the hope that multiple</span><br><span class="line">replicas will arrive and the transfer can be parallelized.</span><br><span class="line"><span class="comment"># 使用无盘复制时，主服务器在开始传输之前等待一段可配置的时间（以秒为单位），以希望多个副本可以到达并且传输可以并行化</span></span><br><span class="line">With slow disks and fast (large bandwidth) networks, diskless replication</span><br><span class="line">works better.</span><br><span class="line"><span class="comment"># 对于慢速磁盘和快速（大带宽）网络，无盘复制效果更好</span></span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line">When diskless replication is enabled, it is possible to configure the delay</span><br><span class="line">the server waits in order to spawn the child that transfers the RDB via socket</span><br><span class="line">to the replicas.</span><br><span class="line"><span class="comment"># 启用无盘复制后，可以配置服务器等待的延迟，以便生成通过套接字将RDB传输到副本的子代。</span></span><br><span class="line">This is important since once the transfer starts, it is not possible to serve</span><br><span class="line">new replicas arriving, that will be queued for the next RDB transfer, so the</span><br><span class="line">server waits a delay in order to let more replicas arrive.</span><br><span class="line"><span class="comment"># 这一点很重要，因为一旦传输开始，就无法为到达下一个RDB传输的新副本提供服务，因此服务器会等待一段时间才能让更多副本到达。</span></span><br><span class="line">The delay is specified in seconds, and by default is 5 seconds. To disable</span><br><span class="line">it entirely just set it to 0 seconds and the transfer will start ASAP.</span><br><span class="line"><span class="comment"># 延迟以秒为单位指定，默认情况下为5秒。要完全禁用它，只需将其设置为0秒，传输就会尽快开始。</span></span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">WARNING : RDB diskless load is experimental. Since in this setup the replica</span><br><span class="line">does not immediately store an RDB on disk, it may cause data loss during</span><br><span class="line">failovers. RDB diskless load + Redis modules not handling I/O reads may also</span><br><span class="line">cause Redis to abort in case of I/O errors during the initial synchronization</span><br><span class="line">stage with the master. Use only if your do what you are doing.</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># 警告：RDB无盘加载是实验性的。因为在此设置中，副本不会立即在磁盘上存储RDB，所以它可能会导致故障转移期间的数据丢失。在与主机的初始同步阶段，如果IO错误，则RDB无盘负载+ Redis模块不处理IO读取也可能导致Redis中止。仅在执行自己的操作时使用</span></span><br><span class="line">Replica can load the RDB it reads from the replication link directly from the</span><br><span class="line">socket, or store the RDB to a file and read that file after it was completely</span><br><span class="line">received from the master.</span><br><span class="line"><span class="comment"># 副本可以直接从套接字加载从复制链接读取的RDB，也可以将RDB存储到文件中，并在从主服务器完全接收到该文件后读取该文件。</span></span><br><span class="line">In many cases the disk is slower than the network, and storing and loading</span><br><span class="line">the RDB file may increase replication time (and even increase the master&#x27;s</span><br><span class="line">Copy on Write memory and salve buffers).</span><br><span class="line">However, parsing the RDB file directly from the socket may mean that we have</span><br><span class="line">to flush the contents of the current database before the full rdb was</span><br><span class="line">received. For this reason we have the following options :</span><br><span class="line"><span class="comment"># 在许多情况下，磁盘的速度比网络慢，并且存储和加载RDB文件可能会增加复制时间（甚至会增加主服务器的“写时复制”内存和从属缓冲区）。但是，直接从套接字解析RDB文件可能意味着我们必须在收到完整的rdb之前刷新当前数据库的内容。因此，我们有以下选择</span></span><br><span class="line">&quot;disabled&quot;    - Don&#x27;t use diskless load (store the rdb file to the disk first)</span><br><span class="line"><span class="comment"># 不要使用无盘负载（首先将rdb文件存储到磁盘）</span></span><br><span class="line">&quot;on-empty-db&quot; - Use diskless load only when it is completely safe.</span><br><span class="line"><span class="comment"># 仅在完全安全的情况下使用无盘加载</span></span><br><span class="line">&quot;swapdb&quot;      - Keep a copy of the current db contents in RAM while parsin</span><br><span class="line">the data directly from the socket. note that this requires sufficient memory, if you don&#x27;t have it, you risk an OOM kill.</span><br><span class="line"><span class="comment"># 直接从套接字解析数据时，将当前数据库内容的副本保留在RAM中。请注意，这需要足够的内存，如果没有足够的内存，则可能会杀死OOM</span></span><br><span class="line">repl-diskless-load disabled</span><br><span class="line"></span><br><span class="line">Replicas send PINGs to server in a predefined interval. It&#x27;s possible to</span><br><span class="line">change this interval with the repl_ping_replica_period option. The default</span><br><span class="line">value is 10 seconds.</span><br><span class="line"><span class="comment"># 副本以预定义的时间间隔将PING发送到服务器。可以使用repl_ping_replica_period选项更改此间隔。默认值为10秒</span></span><br><span class="line">repl-ping-replica-period 10</span><br><span class="line"></span><br><span class="line">The following option sets the replication timeout for :</span><br><span class="line"><span class="comment"># 以下选项设置了复制超时</span></span><br><span class="line">1) Bulk transfer I/O during SYNC, from the point of view of replica.</span><br><span class="line"><span class="comment"># 从副本的角度来看，在SYNC期间进行批量传输IO。</span></span><br><span class="line">2) Master timeout from the point of view of replicas (data, pings).</span><br><span class="line"><span class="comment"># 从副本（数据，ping）的角度来看主超时</span></span><br><span class="line">3) Replica timeout from the point of view of masters (REPLCONF ACK pings).</span><br><span class="line"><span class="comment"># 从主服务器角度来看副本超时（REPLCONF ACK ping）</span></span><br><span class="line">It is important to make sure that this value is greater than the value</span><br><span class="line">specified for repl-ping-replica-period otherwise a timeout will be detected</span><br><span class="line">every time there is low traffic between the master and the replica. The default</span><br><span class="line">value is 60 seconds.</span><br><span class="line"><span class="comment"># 重要的是要确保该值大于为repl-ping-replica-period指定的值，否则，每当主机和副本之间的通信量较低时，就会检测到超时。默认值为60秒。</span></span><br><span class="line">repl-timeout 60</span><br><span class="line"></span><br><span class="line">Disable TCP_NODELAY on the replica socket after SYNC?</span><br><span class="line"><span class="comment"># 同步后在副本套接字上禁用TCP_NODELAY</span></span><br><span class="line"></span><br><span class="line">If you select &quot;yes&quot; Redis will use a smaller number of TCP packets and</span><br><span class="line">less bandwidth to send data to replicas. But this can add a delay for</span><br><span class="line">the data to appear on the replica side, up to 40 milliseconds with</span><br><span class="line">Linux kernels using a default configuration.</span><br><span class="line"><span class="comment"># 如果选择“是”，则Redis将使用更少的TCP数据包和更少的带宽将数据发送到副本。但这会增加数据在副本端显示的延迟，对于使用默认配置的Linux内核，此延迟最多40毫秒</span></span><br><span class="line">If you select &quot;no&quot; the delay for data to appear on the replica side will</span><br><span class="line">be reduced but more bandwidth will be used for replication.</span><br><span class="line"><span class="comment"># 如果选择“否”，则将减少数据在副本侧出现的延迟，但将使用更多带宽进行复制</span></span><br><span class="line">By default we optimize for low latency, but in very high traffic conditions</span><br><span class="line">or when the master and replicas are many hops away, turning this to &quot;yes&quot; may</span><br><span class="line">be a good idea.</span><br><span class="line"><span class="comment"># 默认情况下，我们会针对低延迟进行优化，但是在流量非常高的情况下，或者当主服务器和副本距离很多跳时，将其设置为“是”可能是个好主意</span></span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line">Set the replication backlog size. The backlog is a buffer that accumulates</span><br><span class="line">replica data when replicas are disconnected for some time, so that when a</span><br><span class="line">replica wants to reconnect again, often a full resync is not needed, but a</span><br><span class="line">partial resync is enough, just passing the portion of data the replica</span><br><span class="line">missed while disconnected.</span><br><span class="line"><span class="comment"># 设置复制积压大小。待办事项是一个缓冲区，当副本断开连接一段时间后，该缓冲区将累积副本数据，因此，当副本要重新连接时，通常不需要完全重新同步，但是部分重新同步就足够了，只需传递副本中的部分数据断开连接时错过</span></span><br><span class="line">The bigger the replication backlog, the longer the replica can endure the</span><br><span class="line">disconnect and later be able to perform a partial resynchronization.</span><br><span class="line"><span class="comment"># 复制积压量越大，副本可以承受断开连接并随后能够执行部分重新同步的时间越长</span></span><br><span class="line">The backlog is only allocated if there is at least one replica connected.</span><br><span class="line"><span class="comment"># 仅在连接至少一个副本时分配积压</span></span><br><span class="line">repl-backlog-size 1mb</span><br><span class="line"></span><br><span class="line">After a master has no connected replicas for some time, the backlog will be</span><br><span class="line">freed. The following option configures the amount of seconds that need to</span><br><span class="line">elapse, starting from the time the last replica disconnected, for the backlog</span><br><span class="line">buffer to be freed.</span><br><span class="line"><span class="comment"># 主服务器在一段时间内没有连接的副本后，积压的订单将被释放。以下选项配置了从断开最后一个副本的时间开始，释放待办事项缓冲区所需的秒数</span></span><br><span class="line">Note that replicas never free the backlog for timeout, since they may be</span><br><span class="line">promoted to masters later, and should be able to correctly &quot;partially</span><br><span class="line">resynchronize&quot; with other replicas : hence they should always accumulate backlog.</span><br><span class="line"><span class="comment"># 请注意，副本永远不会释放积压的超时，因为它们可能稍后会升级为主副本，并且应该能够与其他副本正确“部分重新同步”：因此，它们应始终累积积压。</span></span><br><span class="line">A value of 0 means to never release the backlog.</span><br><span class="line"><span class="comment"># 值为0表示永不释放积压</span></span><br><span class="line">repl-backlog-ttl 3600</span><br><span class="line"></span><br><span class="line">The replica priority is an integer number published by Redis in the INFO</span><br><span class="line">output. It is used by Redis Sentinel in order to select a replica to promote</span><br><span class="line">into a master if the master is no longer working correctly.</span><br><span class="line"><span class="comment"># 副本优先级是Redis在INFO输出中发布的整数。如果主服务器不再正常工作，Redis Sentinel会使用它来选择要升级为主服务器的副本</span></span><br><span class="line">A replica with a low priority number is considered better for promotion, so</span><br><span class="line">for instance if there are three replicas with priority 10, 100, 25 Sentinel</span><br><span class="line">will pick the one with priority 10, that is the lowest.</span><br><span class="line"><span class="comment"># 优先级数字低的副本被认为更适合升级，例如，如果有三个副本的优先级分别为10、100和25，Sentinel将选择优先级为10的副本，这是最低的</span></span><br><span class="line">However a special priority of 0 marks the replica as not able to perform the</span><br><span class="line">role of master, so a replica with priority of 0 will never be selected by</span><br><span class="line">Redis Sentinel for promotion.</span><br><span class="line"><span class="comment"># 但是，特殊优先级0会将副本标记为不能执行主角色，因此Redis Sentinel永远不会选择优先级为0的副本进行升级，默认情况下，优先级为100</span></span><br><span class="line">By default the priority is 100.</span><br><span class="line">replica-priority 100</span><br><span class="line"></span><br><span class="line">It is possible for a master to stop accepting writes if there are less than</span><br><span class="line">N replicas connected, having a lag less or equal than M seconds.</span><br><span class="line"><span class="comment"># 如果连接的副本少于N个，且延迟小于或等于M秒，则主服务器可能会停止接受写入</span></span><br><span class="line">The N replicas need to be in &quot;online&quot; state.</span><br><span class="line"><span class="comment"># N个副本需要处于“联机”状态</span></span><br><span class="line">The lag in seconds, that must be &lt; = the specified value, is calculated from</span><br><span class="line">the last ping received from the replica, that is usually sent every second.</span><br><span class="line"><span class="comment"># 延迟（以秒为单位）必须小于等于指定值，该延迟是从副本接收到的最后一次ping计算得出的，通常每秒钟发送一次</span></span><br><span class="line">This option does not GUARANTEE that N replicas will accept the write, but</span><br><span class="line">will limit the window of exposure for lost writes in case not enough replicas</span><br><span class="line">are available, to the specified number of seconds.</span><br><span class="line"><span class="comment"># 此选项不能保证N个副本将接受写操作，但是如果没有足够的副本可用，则会将丢失写操作的暴露窗口限制为指定的秒数</span></span><br><span class="line">For example to require at least 3 replicas with a lag &lt; = 10 seconds use:</span><br><span class="line"><span class="comment"># 例如，要求至少3个副本的延迟&lt;= 10秒，请使用</span></span><br><span class="line">min-replicas-to-write 3</span><br><span class="line">min-replicas-max-lag 10</span><br><span class="line"></span><br><span class="line">Setting one or the other to 0 disables the feature.</span><br><span class="line"><span class="comment"># 将一个或另一个设置为0将禁用该功能</span></span><br><span class="line">By default min-replicas-to-write is set to 0 (feature disabled) and</span><br><span class="line">min-replicas-max-lag is set to 10.</span><br><span class="line"><span class="comment"># 默认情况下，将要写入的最小副本设置为0（禁用功能），并且将最小副本最大延迟设置为10</span></span><br><span class="line">A Redis master is able to list the address and port of the attached</span><br><span class="line">replicas in different ways. For example the &quot;INFO replication&quot; section</span><br><span class="line">offers this information, which is used, among other tools, by</span><br><span class="line">Redis Sentinel in order to discover replica instances.</span><br><span class="line">Another place where this info is available is in the output of the</span><br><span class="line">&quot;ROLE&quot; command of a master.</span><br><span class="line"><span class="comment"># Redis主服务器能够以不同方式列出附加副本的地址和端口。例如，“ INFO复制”部分提供了此信息，Redis Sentinel使用此信息以及其他工具来发现副本实例。该信息可用的另一个位置是主服务器的“ ROLE”命令的输出</span></span><br><span class="line">The listed IP address and port normally reported by a replica is</span><br><span class="line">obtained in the following way :</span><br><span class="line"><span class="comment"># 副本通常报告的列出的IP地址和端口可以通过以下方式获得</span></span><br><span class="line">IP : The address is auto detected by checking the peer address</span><br><span class="line">of the socket used by the replica to connect with the master.</span><br><span class="line"><span class="comment"># IP：通过检查副本用来与主服务器连接的套接字的对等地址来自动检测该地址</span></span><br><span class="line">Port : The port is communicated by the replica during the replication</span><br><span class="line">handshake, and is normally the port that the replica is using to</span><br><span class="line">listen for connections.</span><br><span class="line"><span class="comment"># 端口：端口在复制握手期间由副本进行通信，通常是副本用来侦听连接的端口。</span></span><br><span class="line">However when port forwarding or Network Address Translation (NAT) is</span><br><span class="line">used, the replica may actually be reachable via different IP and port</span><br><span class="line">pairs. The following two options can be used by a replica in order to</span><br><span class="line">report to its master a specific set of IP and port, so that both INFO</span><br><span class="line">and ROLE will report those values.</span><br><span class="line"><span class="comment"># 但是，当使用端口转发或网络地址转换（NAT）时，实际上可以通过不同的IP和端口对访问该副本。副本可以使用以下两个选项，以便向其主服务器报告特定的IP和端口集，以便INFO和ROLE都将报告这些值</span></span><br><span class="line">There is no need to use both the options if you need to override just</span><br><span class="line">the port or the IP address.</span><br><span class="line"><span class="comment"># 如果只需要覆盖端口或IP地址，则无需使用这两个选项。</span></span><br><span class="line">replica-announce-ip 5.5.5.5</span><br><span class="line">replica-announce-port 1234</span><br></pre></td></tr></table></figure>
<p>①、slave-serve-stale-data：默认值为yes。当一个 slave 与 master 失去联系，或者复制正在进行的时候，slave<br />
可能会有两种表现：</p>
<ol>
<li>
<p>如果为 yes ，slave 仍然会应答客户端请求，但返回的数据可能是过时，或者数据可能是空的在第一次同步的时候</p>
</li>
<li>
<p>如果为 no ，在你执行除了 info he salveof 之外的其他命令时，slave 都将返回一个 “SYNC with master in<br />
progress” 的错误</p>
</li>
</ol>
<p>②、slave-read-only：配置Redis的Slave实例是否接受写操作，即Slave是否为只读Redis。默认值为yes。</p>
<p>③、repl-diskless-sync：主从数据复制是否使用无硬盘复制功能。默认值为no。</p>
<p>④、repl-diskless-sync-delay：当启用无硬盘备份，服务器等待一段时间后才会通过套接字向从站传送RDB文件，这个等待时间是可配置的。<br />
这一点很重要，因为一旦传送开始，就不可能再为一个新到达的从站服务。从站则要排队等待下一次RDB传送。因此服务器等待一段<br />
时间以期更多的从站到达。延迟时间以秒为单位，默认为5秒。要关掉这一功能，只需将它设置为0秒，传送会立即启动。默认值为5。</p>
<p>⑤、repl-disable-tcp-nodelay：同步之后是否禁用从站上的TCP_NODELAY<br />
如果你选择yes，redis会使用较少量的TCP包和带宽向从站发送数据。但这会导致在从站增加一点数据的延时。<br />
Linux内核默认配置情况下最多40毫秒的延时。如果选择no，从站的数据延时不会那么多，但备份需要的带宽相对较多。默认情况下我们将潜在因素优化，但在高负载情况下或者在主从站都跳的情况下，把它切换为yes是个好主意。默认值为no。</p>
<h2 id="keys-tracking"><a class="markdownIt-Anchor" href="#keys-tracking"></a> KEYS TRACKING</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">KEYS TRACKING</span><br><span class="line"><span class="comment"># Redis为客户端的值缓存实现服务器辅助的支持。这是使用无效表实现的，该无效表使用1600万个插槽记住哪些客户端可能具有某些键子集。依次将其用于向客户端发送无效消息</span></span><br><span class="line">Redis implements server assisted support for client side caching of values.</span><br><span class="line">This is implemented using an invalidation table that remembers, using</span><br><span class="line">16 millions of slots, what clients may have certain subsets of keys. In turn</span><br><span class="line">this is used in order to send invalidation messages to clients. Please</span><br><span class="line">check this page to understand more about the feature :</span><br><span class="line"></span><br><span class="line">https : //redis.io/topics/client-side-caching</span><br><span class="line"></span><br><span class="line">When tracking is enabled for a client, all the read only queries are assumed</span><br><span class="line">to be cached : this will force Redis to store information in the invalidation</span><br><span class="line">table. When keys are modified, such information is flushed away, and</span><br><span class="line">invalidation messages are sent to the clients. However if the workload is</span><br><span class="line">heavily dominated by reads, Redis could use more and more memory in order</span><br><span class="line">to track the keys fetched by many clients.</span><br><span class="line"><span class="comment"># 为客户端启用跟踪时，假定所有只读查询都已缓存：这将强制Redis将信息存储在失效表中。修改密钥后，将清除此类信息，并将无效消息发送给客户端。但是，如果工作负载主要由读取控制，则Redis可能会使用越来越多的内存来跟踪许多客户端获取的密钥</span></span><br><span class="line">For this reason it is possible to configure a maximum fill value for the</span><br><span class="line">invalidation table. By default it is set to 1M of keys, and once this limit</span><br><span class="line">is reached, Redis will start to evict keys in the invalidation table</span><br><span class="line">even if they were not modified, just to reclaim memory : this will in turn</span><br><span class="line">force the clients to invalidate the cached values. Basically the table</span><br><span class="line">maximum size is a trade off between the memory you want to spend server</span><br><span class="line">side to track information about who cached what, and the ability of clients</span><br><span class="line">to retain cached objects in memory.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果将值设置为0，则表示没有限制，Redis将在失效表中保留所需数量的键。在“统计信息”信息部分中，您可以找到有关每个给定时刻失效表中的键数的信息。</span></span><br><span class="line">If you set the value to 0, it means there are no limits, and Redis will</span><br><span class="line">retain as many keys as needed in the invalidation table.</span><br><span class="line">In the &quot;stats&quot; INFO section, you can find information about the number of</span><br><span class="line">keys in the invalidation table at every given moment.</span><br><span class="line"></span><br><span class="line">Note : when key tracking is used in broadcasting mode, no memory is used</span><br><span class="line">in the server side so this setting is useless.</span><br><span class="line"></span><br><span class="line">tracking-table-max-keys 1000000</span><br></pre></td></tr></table></figure>
<h2 id="security重要"><a class="markdownIt-Anchor" href="#security重要"></a> SECURITY(重要)</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">SECURITY</span><br><span class="line"></span><br><span class="line">Warning : since Redis is pretty fast, an outside user can try up to</span><br><span class="line">1 million passwords per second against a modern box. This means that you</span><br><span class="line">should use very strong passwords, otherwise they will be very easy to break.</span><br><span class="line">Note that because the password is really a shared secret between the client</span><br><span class="line">and the server, and should not be memorized by any human, the password</span><br><span class="line">can be easily a long string from /dev/urandom or whatever, so by using a</span><br><span class="line">long and unguessable password no brute force attack will be possible.</span><br><span class="line"><span class="comment"># 警告：由于Redis的速度非常快，因此外部用户每秒可以在一个现代机器上尝试最多100万个密码。这意味着您应该使用非常安全的密码，否则密码很容易破解。</span></span><br><span class="line"><span class="comment"># 请注意，由于该密码实际上是客户端和服务器之间的共享机密，并且不应被任何人记住，因此该密码可以很容易地是来自devurandom或其他任何形式的长字符串，因此使用长而毫无疑问的密码不会造成暴力攻击是可能的</span></span><br><span class="line">Redis ACL users are defined in the following format :</span><br><span class="line"></span><br><span class="line">user &lt;username&gt; ... acl rules ...</span><br><span class="line"></span><br><span class="line">For example :</span><br><span class="line"></span><br><span class="line">user worker +@list +@connection ~jobs : * on &gt;ffa9203c493aa99</span><br><span class="line"></span><br><span class="line">The special username &quot;default&quot; is used for new connections. If this user</span><br><span class="line">has the &quot;nopass&quot; rule, then new connections will be immediately authenticated</span><br><span class="line">as the &quot;default&quot; user without the need of any password provided via the</span><br><span class="line">AUTH command. Otherwise if the &quot;default&quot; user is not flagged with &quot;nopass&quot;</span><br><span class="line">the connections will start in not authenticated state, and will require</span><br><span class="line">AUTH (or the HELLO command AUTH option) in order to be authenticated and</span><br><span class="line">start to work.</span><br><span class="line"><span class="comment"># 特殊的用户名“默认”用于新连接。如果该用户具有“ nopass”规则，则新连接将立即被认证为“默认”用户，而不需要通过AUTH命令提供的任何密码。否则，如果未将“默认”用户标记为“ nopass”，则连接将以未认证状态启动，并且需要AUTH（或HELLO命令AUTH选项）才能进行认证并开始工作</span></span><br><span class="line">The ACL rules that describe what a user can do are the following :</span><br><span class="line"></span><br><span class="line">on           Enable the user : it is possible to authenticate as this user.</span><br><span class="line">off          Disable the user : it&#x27;s no longer possible to authenticate</span><br><span class="line">                                with this user, however the already authenticated connections</span><br><span class="line">                                will still work.</span><br><span class="line">+&lt;command&gt;   Allow the execution of that command</span><br><span class="line">-&lt;command&gt;   Disallow the execution of that command</span><br><span class="line">+@&lt;category&gt; Allow the execution of all the commands in such category</span><br><span class="line">with valid categories are like @admin, @set, @sortedset, ...</span><br><span class="line">and so forth, see the full list in the server.c file where</span><br><span class="line">the Redis command table is described and defined.</span><br><span class="line">The special category @all means all the commands, but currently</span><br><span class="line">present in the server, and that will be loaded in the future</span><br><span class="line">via modules.</span><br><span class="line">+&lt;command&gt;|subcommand    Allow a specific subcommand of an otherwise</span><br><span class="line">disabled command. Note that this form is not</span><br><span class="line">allowed as negative like -DEBUG|SEGFAULT, but</span><br><span class="line">only additive starting with &quot;+&quot;.</span><br><span class="line">allcommands  Alias for +@all. Note that it implies the ability to execute</span><br><span class="line">all the future commands loaded via the modules system.</span><br><span class="line">nocommands   Alias for -@all.</span><br><span class="line">~&lt;pattern&gt;   Add a pattern of keys that can be mentioned as part of</span><br><span class="line">commands. For instance ~* allows all the keys. The pattern</span><br><span class="line">is a glob-style pattern like the one of KEYS.</span><br><span class="line">It is possible to specify multiple patterns.</span><br><span class="line">allkeys      Alias for ~*</span><br><span class="line">resetkeys    Flush the list of allowed keys patterns.</span><br><span class="line">&gt;&lt;password&gt;  Add this password to the list of valid password for the user.</span><br><span class="line">For example &gt;mypass will add &quot;mypass&quot; to the list.</span><br><span class="line">This directive clears the &quot;nopass&quot; flag (see later).</span><br><span class="line">&lt;&lt;password&gt;  Remove this password from the list of valid passwords.</span><br><span class="line">nopass       All the set passwords of the user are removed, and the user</span><br><span class="line">is flagged as requiring no password : it means that every</span><br><span class="line">password will work against this user. If this directive is</span><br><span class="line">used for the default user, every new connection will be</span><br><span class="line">immediately authenticated with the default user without</span><br><span class="line">any explicit AUTH command required. Note that the &quot;resetpass&quot;</span><br><span class="line">directive will clear this condition.</span><br><span class="line">resetpass    Flush the list of allowed passwords. Moreover removes the</span><br><span class="line">&quot;nopass&quot; status. After &quot;resetpass&quot; the user has no associated</span><br><span class="line">passwords and there is no way to authenticate without adding</span><br><span class="line">some password (or setting it as &quot;nopass&quot; later).</span><br><span class="line">reset        Performs the following actions : resetpass, resetkeys, off,</span><br><span class="line">-@all. The user returns to the same state it has immediately</span><br><span class="line">after its creation.</span><br><span class="line"></span><br><span class="line">ACL rules can be specified in any order : for instance you can start with</span><br><span class="line">                                          passwords, then flags, or key patterns. However note that the additive</span><br><span class="line">                                          and subtractive rules will CHANGE MEANING depending on the ordering.</span><br><span class="line">                                          For instance see the following example :</span><br><span class="line"></span><br><span class="line">                                          user alice on +@all -DEBUG ~* &gt;somepassword</span><br><span class="line"></span><br><span class="line">                                          This will allow &quot;alice&quot; to use all the commands with the exception of the</span><br><span class="line">                                          DEBUG command, since +@all added all the commands to the set of the commands</span><br><span class="line">                                          alice can use, and later DEBUG was removed. However if we invert the order</span><br><span class="line">                                          of two ACL rules the result will be different:</span><br><span class="line">                                          <span class="comment"># 这将允许“ alice”使用除DEBUG命令之外的所有命令，因为+ @ all将所有命令添加到了alice可以使用的命令集中，并且后来删除了DEBUG。但是，如果我们颠倒两个ACL规则的顺序，结果将有所不同</span></span><br><span class="line">                                          user alice on -DEBUG +@all ~* &gt;somepassword</span><br><span class="line"></span><br><span class="line">                                          Now DEBUG was removed when alice had yet no commands in the set of allowed</span><br><span class="line">                                          commands, later all the commands are added, so the user will be able to</span><br><span class="line">                                          execute everything.</span><br><span class="line"></span><br><span class="line">                                          Basically ACL rules are processed left-to-right.</span><br><span class="line"></span><br><span class="line">                                          For more information about ACL configuration please refer to</span><br><span class="line">                                          the Redis web site at https : //redis.io/topics/acl</span><br><span class="line"></span><br><span class="line">ACL LOG</span><br><span class="line"></span><br><span class="line">The ACL Log tracks failed commands and authentication events associated</span><br><span class="line">with ACLs. The ACL Log is useful to troubleshoot failed commands blocked</span><br><span class="line">by ACLs. The ACL Log is stored in memory. You can reclaim memory with</span><br><span class="line">ACL LOG RESET. Define the maximum entry length of the ACL Log below.</span><br><span class="line">acllog-max-len 128</span><br><span class="line"><span class="comment"># ACL日志跟踪与ACL关联的失败命令和身份验证事件。 ACL日志可用于对ACL阻止的失败命令进行故障排除。 ACL日志存储在内存中。您可以使用ACL LOG RESET回收内存。在下面定义ACL日志的最大输入长度。 acllog-max-len 128</span></span><br><span class="line">Using an external ACL file</span><br><span class="line"></span><br><span class="line">Instead of configuring users here in this file, it is possible to use</span><br><span class="line">a stand-alone file just listing users. The two methods cannot be mixed :</span><br><span class="line">if you configure users here and at the same time you activate the external</span><br><span class="line">ACL file, the server will refuse to start.</span><br><span class="line"><span class="comment"># 除了在此文件中配置用户之外，还可以使用仅列出用户的独立文件。两种方法不能混用：如果您在此处配置用户并同时激活外部ACL文件，则服务器将拒绝启动</span></span><br><span class="line">The format of the external ACL user file is exactly the same as the</span><br><span class="line">format that is used inside redis.conf to describe users.</span><br><span class="line"></span><br><span class="line">aclfile /etc/redis/users.acl</span><br><span class="line"></span><br><span class="line">IMPORTANT NOTE : starting with Redis 6 &quot;requirepass&quot; is just a compatibility</span><br><span class="line">layer on top of the new ACL system. The option effect will be just setting</span><br><span class="line">the password for the default user. Clients will still authenticate using</span><br><span class="line">AUTH &lt;password&gt; as usually, or more explicitly with AUTH default &lt;password&gt;</span><br><span class="line">if they follow the new protocol : both will work.</span><br><span class="line"><span class="comment"># 重要说明：从Redis 6开始，“ requirepass”只是新ACL系统之上的兼容性层。选项效果将只是为默认用户设置密码。客户端仍将照常使用AUTH &lt;password&gt;进行身份验证，如果遵循新协议，则仍将使用AUTH default &lt;password&gt;进行更明确的身份验证</span></span><br><span class="line">requirepass foobared</span><br><span class="line"></span><br><span class="line">Command renaming (DEPRECATED).</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">WARNING : avoid using this option if possible. Instead use ACLs to remove</span><br><span class="line">commands from the default user, and put them only in some admin user you</span><br><span class="line">create for administrative purposes.</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># 警告：尽可能避免使用此选项。而是使用ACL从默认用户中删除命令，并将其仅放置在您出于管理目的而创建的某些admin用户中</span></span><br><span class="line">It is possible to change the name of dangerous commands in a shared</span><br><span class="line">environment. For instance the CONFIG command may be renamed into something</span><br><span class="line">hard to guess so that it will still be available for internal-use tools</span><br><span class="line">but not available for general clients.</span><br><span class="line"><span class="comment"># 可以在共享环境中更改危险命令的名称。例如，CONFIG命令可能会重命名为一些难以猜测的名称，因此它仍可用于内部使用的工具，但不适用于一般客户</span></span><br><span class="line">Example :</span><br><span class="line"></span><br><span class="line">rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="line"></span><br><span class="line">It is also possible to completely kill a command by renaming it into</span><br><span class="line">an empty string :</span><br><span class="line"></span><br><span class="line">rename-command CONFIG &quot;&quot;</span><br><span class="line"></span><br><span class="line">Please note that changing the name of commands that are logged into the</span><br><span class="line">AOF file or transmitted to replicas may cause problems.</span><br><span class="line"><span class="comment"># 注意，更改登录到AOF文件或传输到副本的命令的名称可能会导致问题</span></span><br></pre></td></tr></table></figure>
<p>rename-command：命令重命名，对于一些危险命令例如：</p>
<ul>
<li>
<p>flushdb（清空数据库）</p>
</li>
<li>
<p>flushall（清空所有记录）</p>
</li>
<li>
<p>config（客户端连接后可配置服务器）</p>
</li>
<li>
<p>keys（客户端连接后可查看所有存在的键）</p>
</li>
</ul>
<blockquote>
<p>作为服务端redis-server，常常需要禁用以上命令来使得服务器更加安全，禁用的具体做法是是：</p>
<p>rename-command FLUSHALL “”</p>
</blockquote>
<p>也可以保留命令但是不能轻易使用，重命名这个命令即可：</p>
<ul>
<li>rename-command FLUSHALL abcdefg 这样，重启服务器后则需要使用新命令来执行操作，否则服务器会报错unknown<br />
command。</li>
</ul>
<p><strong>requirepass:设置redis连接密码</strong></p>
<p>比如: requirepass 123456 表示redis的连接密码为123456.</p>
<h2 id="clients"><a class="markdownIt-Anchor" href="#clients"></a> CLIENTS</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLIENTS </span><br><span class="line"></span><br><span class="line">Set the max number of connected clients at the same time. By default</span><br><span class="line">this limit is set to 10000 clients, however if the Redis server is not</span><br><span class="line">able to configure the process file limit to allow for the specified limit</span><br><span class="line">the max number of allowed clients is set to the current file limit</span><br><span class="line">minus 32 (as Redis reserves a few file descriptors for internal uses).</span><br><span class="line"># 同时设置最大连接客户端数。默认情况下，此限制设置为10000个客户端，但是，如果Redis服务器无法将进程文件限制配置为允许指定的限制，则允许的最大客户端数设置为当前文件限制减去32（因为Redis保留了内部使用的几个文件描述符）</span><br><span class="line">Once the limit is reached Redis will close all the new connections sending</span><br><span class="line">an error &#x27;max number of clients reached&#x27;.</span><br><span class="line"># 达到限制后，Redis将关闭所有新连接，并发送错误消息“已达到最大客户端数”。</span><br><span class="line">IMPORTANT: When Redis Cluster is used, the max number of connections is also</span><br><span class="line">shared with the cluster bus: every node in the cluster will use two</span><br><span class="line">connections, one incoming and another outgoing. It is important to size the</span><br><span class="line">limit accordingly in case of very large clusters.</span><br><span class="line"># 重要信息：使用Redis群集时，最大连接数也与群集总线共享：群集中的每个节点将使用两个连接，一个进入，另一个向外。在群集非常大的情况下，相应地调整限制大小非常重要</span><br><span class="line">maxclients 10000</span><br></pre></td></tr></table></figure>
<p>maxclients ：设置客户端最大并发连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件。<br />
描述符数-32（redis server自身会使用一些），如果设置 maxclients为0<br />
。表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients<br />
reached错误信息</p>
<h2 id="memory-management"><a class="markdownIt-Anchor" href="#memory-management"></a> MEMORY MANAGEMENT</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">MEMORY MANAGEMENT</span><br><span class="line"></span><br><span class="line">Set a memory usage limit to the specified amount of bytes.</span><br><span class="line">When the memory limit is reached Redis will try to remove keys</span><br><span class="line">according to the eviction policy selected (see maxmemory-policy).</span><br><span class="line"><span class="comment"># 将内存使用限制设置为指定的字节数。当达到内存限制时，Redis将尝试根据所选的逐出策略来删除密钥</span></span><br><span class="line">If Redis can&#x27;t remove keys according to the policy, or if the policy is</span><br><span class="line">set to &#x27;noeviction&#x27;, Redis will start to reply with errors to commands</span><br><span class="line">that would use more memory, like SET, LPUSH, and so on, and will continue</span><br><span class="line">to reply to read-only commands like GET.</span><br><span class="line"><span class="comment"># 如果Redis无法根据该策略删除密钥，或者如果该策略设置为&#x27;noeviction&#x27;，则Redis将开始对将使用更多内存的命令（例如SET，LPUSH等）进行错误答复，并将继续回复诸如GET之类的只读命令</span></span><br><span class="line">This option is usually useful when using Redis as an LRU or LFU cache, or to</span><br><span class="line">set a hard memory limit for an instance (using the &#x27;noeviction&#x27; policy).</span><br><span class="line"><span class="comment"># 当将Redis用作LRU或LFU缓存，或为实例设置硬盘限制时，此选项通常很有用</span></span><br><span class="line">WARNING : If you have replicas attached to an instance with maxmemory on,</span><br><span class="line">the size of the output buffers needed to feed the replicas are subtracted</span><br><span class="line">from the used memory count, so that network problems / resyncs will</span><br><span class="line">not trigger a loop where keys are evicted, and in turn the output</span><br><span class="line">buffer of replicas is full with DELs of keys evicted triggering the deletion</span><br><span class="line">of more keys, and so forth until the database is completely emptied.</span><br><span class="line"><span class="comment"># 警告：如果您将副本附加到实例上且maxmemory处于打开状态，则从使用的内存计数中减去提供副本所需的输出缓冲区的大小，以便网络问题重新同步将不会触发逐出密钥的循环。使副本的输出缓冲区已满，其中有被驱逐的键DEL触发了更多键的删除，依此类推，直到数据库完全清空</span></span><br><span class="line">In short... if you have replicas attached it is suggested that you set a lower</span><br><span class="line">limit for maxmemory so that there is some free RAM on the system for replica</span><br><span class="line">output buffers (but this is not needed if the policy is &#x27;noeviction&#x27;).</span><br><span class="line"><span class="comment"># 简而言之...如果您附加了副本，建议您为maxmemory设置一个下限，以便系统上有一些可用的RAM用于副本输出缓冲区（但是如果策略为“ noeviction”，则不需要这样做）</span></span><br><span class="line">maxmemory &lt;bytes&gt;</span><br><span class="line"></span><br><span class="line">MAXMEMORY POLICY : how Redis will select what to remove when maxmemory</span><br><span class="line">is reached. You can select one from the following behaviors :</span><br><span class="line"><span class="comment"># MAXMEMORY POLICY：达到maxmemory后，Redis将如何选择要删除的内容。您可以从以下行为中选择一种</span></span><br><span class="line">volatile-lru -&gt; Evict using approximated LRU, only keys with an expire set.</span><br><span class="line">allkeys-lru -&gt; Evict any key using approximated LRU.</span><br><span class="line">volatile-lfu -&gt; Evict using approximated LFU, only keys with an expire set.    <span class="comment"># 使用近似的LRU驱逐，仅使用已过期的密钥</span></span><br><span class="line">allkeys-lfu -&gt; Evict any key using approximated LFU.                           <span class="comment"># 使用近似的LFU退出任何密钥</span></span><br><span class="line">volatile-random -&gt; Remove a random key having an expire set.                   <span class="comment"># 删除具有过期设置的随机密钥</span></span><br><span class="line">allkeys-random -&gt; Remove a random key, any key.                                <span class="comment"># 删除随机密钥，任何密钥</span></span><br><span class="line">volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)        <span class="comment"># 取出最接近到期时间（较小的TTL）的密钥</span></span><br><span class="line">noeviction -&gt; Don&#x27;t evict anything, just return an error on write operations.  <span class="comment"># 不驱逐任何东西，仅在写操作时返回错误</span></span><br><span class="line"></span><br><span class="line">LRU means Least Recently Used       <span class="comment"># LRU表示最近最少使用   LFU表示最少使用</span></span><br><span class="line">LFU means Least Frequently Used</span><br><span class="line"></span><br><span class="line">Both LRU, LFU and volatile-ttl are implemented using approximated</span><br><span class="line">randomized algorithms.</span><br><span class="line"><span class="comment"># LRU，LFU和volatile-ttl均使用近似随机算法实现</span></span><br><span class="line"></span><br><span class="line">Note : with any of the above policies, Redis will return an error on write</span><br><span class="line">       operations, when there are no suitable keys for eviction.</span><br><span class="line"></span><br><span class="line">       At the date of writing these commands are: set setnx setex append</span><br><span class="line">       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span><br><span class="line">       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span><br><span class="line">       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span><br><span class="line">       getset mset msetnx exec sort</span><br><span class="line"><span class="comment"># 注意：使用上述任何策略时，如果没有合适的退出键，Redis将在写入操作中返回错误。在撰写本文时，这些命令是：</span></span><br><span class="line"><span class="comment"># set setnx setex append incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd interinterstore sunion </span></span><br><span class="line"><span class="comment"># sunionstore sdiff sdiffstore zadd zincrby zunionstore zinterstore hset hsetnx hmset hincrby mcrby deby byby</span></span><br><span class="line">The default is :</span><br><span class="line"></span><br><span class="line">maxmemory-policy noeviction</span><br><span class="line"></span><br><span class="line">LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated</span><br><span class="line">algorithms (in order to save memory), so you can tune it for speed or</span><br><span class="line">accuracy. By default Redis will check five keys and pick the one that was</span><br><span class="line">used least recently, you can change the sample size using the following</span><br><span class="line">configuration directive.</span><br><span class="line"><span class="comment"># LRU，LFU和最小TTL算法不是精确算法，而是近似算法（以节省内存），因此您可以针对速度或准确性进行调整。默认情况下，Redis将检查五个键并选择最近使用最少的键，您可以使用以下配置指令更改样本大小</span></span><br><span class="line">The default of 5 produces good enough results. 10 Approximates very closely</span><br><span class="line">true LRU but costs more CPU. 3 is faster but not very accurate.</span><br><span class="line"><span class="comment"># 默认值为5会产生足够好的结果。 10非常接近真实的LRU，但是会花费更多的CPU。 3更快但不是很准确</span></span><br><span class="line">maxmemory-samples 5</span><br><span class="line"></span><br><span class="line">Starting from Redis 5, by default a replica will ignore its maxmemory setting</span><br><span class="line">(unless it is promoted to master after a failover or manually). It means</span><br><span class="line">that the eviction of keys will be just handled by the master, sending the</span><br><span class="line">DEL commands to the replica as keys evict in the master side.</span><br><span class="line"><span class="comment"># 从Redis 5开始，默认情况下，副本将忽略其maxmemory设置（除非在故障转移后或手动提升为主副本）。这意味着密钥的移出将仅由主服务器处理，将DEL命令作为副本在主计算机侧逐出，将DEL命令发送到副本</span></span><br><span class="line">This behavior ensures that masters and replicas stay consistent, and is usually</span><br><span class="line">what you want, however if your replica is writable, or you want the replica</span><br><span class="line">to have a different memory setting, and you are sure all the writes performed</span><br><span class="line">to the replica are idempotent, then you may change this default (but be sure</span><br><span class="line">to understand what you are doing).</span><br><span class="line"><span class="comment"># 此行为可确保主副本和副本始终保持一致，这通常是您想要的，但是，如果副本是可写的，或者您希望副本具有不同的内存设置，并且您确定对副本执行的所有写操作都是幂等的，那么您可以更改此默认设置（但请务必了解您在做什么）</span></span><br><span class="line">Note that since the replica by default does not evict, it may end using more</span><br><span class="line">memory than the one set via maxmemory (there are certain buffers that may</span><br><span class="line">be larger on the replica, or data structures may sometimes take more memory</span><br><span class="line">and so forth). So make sure you monitor your replicas and make sure they</span><br><span class="line">have enough memory to never hit a real out-of-memory condition before the</span><br><span class="line">master hits the configured maxmemory setting.</span><br><span class="line"><span class="comment"># 请注意，由于默认情况下该副本不会退出，因此它可能会结束使用比通过maxmemory设置的内存更多的内存（某些缓冲区在副本上可能会更大，或者数据结构有时会占用更多的内存，依此类推）。因此，请确保您监视副本，并确保副本具有足够的内存，以便在主副本达到配置的最大内存设置之前永远不会遇到真正的内存不足情况</span></span><br><span class="line">replica-ignore-maxmemory yes</span><br><span class="line"></span><br><span class="line">Redis reclaims expired keys in two ways : upon access when those keys are</span><br><span class="line">found to be expired, and also in background, in what is called the</span><br><span class="line">&quot;active expire key&quot;. The key space is slowly and interactively scanned</span><br><span class="line">looking for expired keys to reclaim, so that it is possible to free memory</span><br><span class="line">of keys that are expired and will never be accessed again in a short time.</span><br><span class="line"><span class="comment"># Redis通过两种方式回收过期的密钥：访问时发现这些密钥已过期，以及在后台，称为“活动的过期密钥”。缓慢地，交互地扫描密钥空间，以查找要回收的过期密钥，以便可以释放已过期且不久之后将不再访问的密钥的内存</span></span><br><span class="line">The default effort of the expire cycle will try to avoid having more than</span><br><span class="line">ten percent of expired keys still in memory, and will try to avoid consuming</span><br><span class="line">more than 25% of total memory and to add latency to the system. However</span><br><span class="line">it is possible to increase the expire &quot;effort&quot; that is normally set to</span><br><span class="line">&quot;1&quot;, to a greater value, up to the value &quot;10&quot;. At its maximum value the</span><br><span class="line">system will use more CPU, longer cycles (and technically may introduce</span><br><span class="line">more latency), and will tolerate less already expired keys still present</span><br><span class="line">in the system. It&#x27;s a tradeoff between memory, CPU and latency.</span><br><span class="line"><span class="comment"># 到期周期的默认工作将尝试避免在内存中保留超过百分之十的过期密钥，并且将尝试避免消耗超过总内存的25％并增加系统延迟。但是，可以将通常设置为“ 1”的过期“努力”增加到更大的值，直到值“ 10”。系统将以其最大值使用更多的CPU，更长的周期（并且从技术上讲可能会引入更多的延迟），并且将容忍更少的系统中仍然存在的已过期密钥。在内存，CPU和延迟之间进行权衡</span></span><br><span class="line">active-expire-effort 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>LRU是Least Recently Used的缩写，即最近最少使用<br />
LFU（Least Frequently Used ，最近最少使用算法）也是一种常见的缓存算法</p>
</blockquote>
<p>maxmemory：设置Redis的最大内存，如果设置为0 。表示不作限制。通常是配合下面介绍的maxmemory-policy参数一起使用。</p>
<p>maxmemory-policy ：当内存使用达到maxmemory设置的最大值时，redis使用的内存清除策略。有以下几种可以选择：</p>
<p>1）volatile-lru 利用LRU算法移除设置过过期时间的key</p>
<p>2）allkeys-lru 利用LRU算法移除任何key</p>
<p>3）volatile-random 移除设置过过期时间的随机key</p>
<p>4）allkeys-random 移除随机ke</p>
<p>5）volatile-ttl 移除即将过期的key(minor TTL)</p>
<p>6）noeviction noeviction 不移除任何key，只是返回一个写错误 ，默认选项</p>
<p>maxmemory-samples ：LRU 和 minimal TTL 算法都不是精准的算法，但是相对精确的算法(为了节省内存)<br />
。随意你可以选择样本大小进行检，redis默认选择5个样本进行检测，你可以通过maxmemory-samples进行设置样本数。</p>
<h2 id="lazy-freeing"><a class="markdownIt-Anchor" href="#lazy-freeing"></a> LAZY FREEING</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">LAZY FREEING</span><br><span class="line"></span><br><span class="line">Redis has two primitives to delete keys. One is called DEL and is a blocking</span><br><span class="line">deletion of the object. It means that the server stops processing new commands</span><br><span class="line">in order to reclaim all the memory associated with an object in a synchronous</span><br><span class="line">way. If the key deleted is associated with a small object, the time needed</span><br><span class="line">in order to execute the DEL command is very small and comparable to most other</span><br><span class="line">O(1) or O(log_N) commands in Redis. However if the key is associated with an</span><br><span class="line">aggregated value containing millions of elements, the server can block for</span><br><span class="line">a long time (even seconds) in order to complete the operation.</span><br><span class="line"><span class="comment"># Redis有两个删除键的原语。一种称为DEL，它是对象的阻塞删除。这意味着服务器停止处理新命令，以便以同步方式回收与对象关联的所有内存。如果删除的键与一个小对象相关联，则执行DEL命令所需的时间非常短，可与Redis中的大多数其他O（1）或O（log_N）命令相提并论。但是，如果键与包含数百万个元素的聚合值相关联，则服务器可能会阻塞很长时间（甚至几秒钟）以完成操作</span></span><br><span class="line">For the above reasons Redis also offers non blocking deletion primitives</span><br><span class="line">such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and</span><br><span class="line">FLUSHDB commands, in order to reclaim memory in background. Those commands</span><br><span class="line">are executed in constant time. Another thread will incrementally free the</span><br><span class="line">object in the background as fast as possible.</span><br><span class="line"><span class="comment"># 由于上述原因，Redis还提供了非阻塞删除原语，例如UNLINK（非阻塞DEL）以及FLUSHALL和FLUSHDB命令的ASYNC选项，以便在后台回收内存。这些命令在固定时间内执行。另一个线程将尽可能快地在后台逐渐释放对象</span></span><br><span class="line">DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.</span><br><span class="line">It&#x27;s up to the design of the application to understand when it is a good</span><br><span class="line">idea to use one or the other. However the Redis server sometimes has to</span><br><span class="line">delete keys or flush the whole database as a side effect of other operations.</span><br><span class="line">Specifically Redis deletes objects independently of a user call in the</span><br><span class="line">following scenarios :</span><br><span class="line"><span class="comment"># 用户可以控制FLUSHALL和FLUSHDB的DEL，UNLINK和ASYNC选项。由应用程序的设计来决定何时使用一个或另一个是一个好主意。但是，Redis服务器有时必须删除键或刷新整个数据库，这是其他操作的副作用。特别是在以下情况下，Redis会独立于用户调用而删除对象</span></span><br><span class="line">1) On eviction, because of the maxmemory and maxmemory policy configurations,</span><br><span class="line">in order to make room for new data, without going over the specified</span><br><span class="line">memory limit.</span><br><span class="line">2) Because of expire : when a key with an associated time to live (see the</span><br><span class="line">EXPIRE command) must be deleted from memory.</span><br><span class="line">3) Because of a side effect of a command that stores data on a key that may</span><br><span class="line">already exist. For example the RENAME command may delete the old key</span><br><span class="line">content when it is replaced with another one. Similarly SUNIONSTORE</span><br><span class="line">or SORT with STORE option may delete existing keys. The SET command</span><br><span class="line">itself removes any old content of the specified key in order to replace</span><br><span class="line">it with the specified string.</span><br><span class="line">4) During replication, when a replica performs a full resynchronization with</span><br><span class="line">its master, the content of the whole database is removed in order to</span><br><span class="line">load the RDB file just transferred.</span><br><span class="line"></span><br><span class="line">In all the above cases the default is to delete objects in a blocking way,</span><br><span class="line">like if DEL was called. However you can configure each case specifically</span><br><span class="line">in order to instead release memory in a non-blocking way like if UNLINK</span><br><span class="line">was called, using the following configuration directives.</span><br><span class="line"><span class="comment"># 在上述所有情况下，默认设置都是以阻塞方式删除对象，就像调用DEL一样。但是，可以使用以下配置指令专门配置每种情况，以便以非阻塞方式释放内存，例如是否调用了UNLINK。</span></span><br><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del no</span><br><span class="line">replica-lazy-flush no</span><br><span class="line"></span><br><span class="line">It is also possible, for the case when to replace the user code DEL calls</span><br><span class="line">with UNLINK calls is not easy, to modify the default behavior of the DEL</span><br><span class="line">command to act exactly like UNLINK, using the following configuration</span><br><span class="line">directive :</span><br><span class="line"><span class="comment"># 对于用UNLINK调用替换用户代码DEL调用不容易的情况，也可以使用以下配置指令将DEL命令的默认行为修改为与UNLINK完全一样</span></span><br><span class="line">lazyfree-lazy-user-del no</span><br></pre></td></tr></table></figure>
<h2 id="threaded-io"><a class="markdownIt-Anchor" href="#threaded-io"></a> THREADED I/O</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">THREADED I/O</span><br><span class="line"></span><br><span class="line">Redis is mostly single threaded, however there are certain threaded</span><br><span class="line">operations such as UNLINK, slow I/O accesses and other things that are</span><br><span class="line">performed on side threads.</span><br><span class="line"><span class="comment"># Redis大多是单线程的，但是有一些线程操作，例如UNLINK，缓慢的IO访问和其他在侧线程上执行的操作</span></span><br><span class="line">Now it is also possible to handle Redis clients socket reads and writes</span><br><span class="line">in different I/O threads. Since especially writing is so slow, normally</span><br><span class="line">Redis users use pipelining in order to speed up the Redis performances per</span><br><span class="line">core, and spawn multiple instances in order to scale more. Using I/O</span><br><span class="line">threads it is possible to easily speedup two times Redis without resorting</span><br><span class="line">to pipelining nor sharding of the instance.</span><br><span class="line"><span class="comment"># 现在，还可以在不同的IO线程中处理Redis客户端套接字的读写。由于特别慢的写入速度，通常Redis用户使用流水线来加快每个内核的Redis性能，并生成多个实例以扩展规模。使用IO线程，可以轻松地将Redis加速两次，而无需求助于实例的流水线处理或分片</span></span><br><span class="line">By default threading is disabled, we suggest enabling it only in machines</span><br><span class="line">that have at least 4 or more cores, leaving at least one spare core.</span><br><span class="line">Using more than 8 threads is unlikely to help much. We also recommend using</span><br><span class="line">threaded I/O only if you actually have performance problems, with Redis</span><br><span class="line">instances being able to use a quite big percentage of CPU time, otherwise</span><br><span class="line">there is no point in using this feature.</span><br><span class="line"><span class="comment"># 默认情况下，线程是禁用的，我们建议仅在具有至少4个或更多内核的计算机上启用它，而至少保留一个备用内核。使用8个以上的线程不太可能有很大帮助。我们还建议仅在实际存在性能问题时才使用线程IO，Redis实例可以使用很大一部分CPU时间，否则使用此功能毫无意义。</span></span><br><span class="line">So for instance if you have a four cores boxes, try to use 2 or 3 I/O</span><br><span class="line">threads, if you have a 8 cores, try to use 6 threads. In order to</span><br><span class="line">enable I/O threads use the following configuration directive :</span><br><span class="line"><span class="comment"># 因此，例如，如果您有四个核的盒子，请尝试使用2个或3个IO线程，如果您有8个核，请尝试使用6个线程。为了启用IO线程，请使用以下配置指令</span></span><br><span class="line">io-threads 4</span><br><span class="line"></span><br><span class="line">Setting io-threads to 1 will just use the main thread as usual.</span><br><span class="line">When I/O threads are enabled, we only use threads for writes, that is</span><br><span class="line">to thread the write(2) syscall and transfer the client buffers to the</span><br><span class="line">socket. However it is also possible to enable threading of reads and</span><br><span class="line">protocol parsing using the following configuration directive, by setting</span><br><span class="line">it to yes :</span><br><span class="line"><span class="comment"># 将io-threads设置为1只会照常使用主线程。启用IO线程后，我们仅使用线程进行写操作，即对write（2）系统调用进行线程化，并将客户端缓冲区传输到套接字。但是，也可以使用以下配置指令，通过将其设置为yes，来启用读取线程和协议解析</span></span><br><span class="line">io-threads-do-reads no</span><br><span class="line"></span><br><span class="line">Usually threading reads doesn&#x27;t help much.</span><br><span class="line"><span class="comment"># 通常线程读取并没有多大帮助</span></span><br><span class="line">NOTE 1 : This configuration directive cannot be changed at runtime via</span><br><span class="line">CONFIG SET. Aso this feature currently does not work when SSL is</span><br><span class="line">enabled.</span><br><span class="line"><span class="comment"># 注意1：无法在运行时通过CONFIG SET更改此配置指令。启用SSL后，该功能目前也无法使用。</span></span><br><span class="line">NOTE 2 : If you want to test the Redis speedup using redis-benchmark, make</span><br><span class="line">sure you also run the benchmark itself in threaded mode, using the</span><br><span class="line">--threads option to match the number of Redis threads, otherwise you&#x27;ll not</span><br><span class="line">be able to notice the improvements.</span><br><span class="line"><span class="comment"># 注意2：如果要使用redis-benchmark测试Redis加速，请确保还使用--threads选项匹配Redis线程数，在线程模式下运行基准测试本身，否则将无法注意改进</span></span><br></pre></td></tr></table></figure>
<h2 id="kernel-oom-control"><a class="markdownIt-Anchor" href="#kernel-oom-control"></a> KERNEL OOM CONTROL</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">KERNEL OOM CONTROL <span class="comment"># 内核OOM控制</span></span><br><span class="line"></span><br><span class="line">On Linux, it is possible to hint the kernel OOM killer on what processes</span><br><span class="line">should be killed first when out of memory.</span><br><span class="line"><span class="comment"># 在Linux上，可以向内核OOM杀手提示内存不足时应首先终止哪些进程</span></span><br><span class="line">Enabling this feature makes Redis actively control the oom_score_adj value</span><br><span class="line">for all its processes, depending on their role. The default scores will</span><br><span class="line">attempt to have background child processes killed before all others, and</span><br><span class="line">replicas killed before masters.</span><br><span class="line"><span class="comment"># 启用此功能可使Redis根据其进程主动控制其所有进程的oom_score_adj值。默认分数将尝试使后台子进程在所有其他进程之前被杀死，副本在主数据库之前被杀死</span></span><br><span class="line">oom-score-adj no</span><br><span class="line"></span><br><span class="line">When oom-score-adj is used, this directive controls the specific values used</span><br><span class="line">for master, replica and background child processes. Values range -1000 to</span><br><span class="line">1000 (higher means more likely to be killed).</span><br><span class="line"><span class="comment"># 使用oom-score-adj时，此伪指令控制用于主，副本和后台子进程的特定值。值范围-1000至1000（值越高，表示被杀死的可能性越高）</span></span><br><span class="line">Unprivileged processes (not root, and without CAP_SYS_RESOURCE capabilities)</span><br><span class="line">can freely increase their value, but not decrease it below its initial</span><br><span class="line">settings.</span><br><span class="line"><span class="comment"># 无特权的进程（不是root进程，并且没有CAP_SYS_RESOURCE功能）可以自由地增加其值，但不能将其降低到其初始设置以下</span></span><br><span class="line">Values are used relative to the initial value of oom_score_adj when the server</span><br><span class="line">starts. Because typically the initial value is 0, they will often match the</span><br><span class="line">absolute values.</span><br><span class="line"></span><br><span class="line">oom-score-adj-values 0 200 800</span><br></pre></td></tr></table></figure>
<h2 id="append-only-mode重要"><a class="markdownIt-Anchor" href="#append-only-mode重要"></a> APPEND ONLY MODE(重要)</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">APPEND ONLY MODE</span><br><span class="line"></span><br><span class="line">By default Redis asynchronously dumps the dataset on disk. This mode is</span><br><span class="line">good enough in many applications, but an issue with the Redis process or</span><br><span class="line">a power outage may result into a few minutes of writes lost (depending on</span><br><span class="line">the configured save points).</span><br><span class="line"><span class="comment"># 服务器启动时，使用相对于oom_score_adj初始值的值。因为通常初始值为0，所以它们通常会与绝对值匹配。</span></span><br><span class="line">The Append Only File is an alternative persistence mode that provides</span><br><span class="line">much better durability. For instance using the default data fsync policy</span><br><span class="line">(see later in the config file) Redis can lose just one second of writes in a</span><br><span class="line">dramatic event like a server power outage, or a single write if something</span><br><span class="line">wrong with the Redis process itself happens, but the operating system is</span><br><span class="line">still running correctly.</span><br><span class="line"><span class="comment"># 仅附加文件是一种替代的持久性模式，可提供更好的持久性。例如，使用默认数据fsync策略（请参阅配置文件中的稍后内容），Redis在严重的事件（例如服务器断电）中仅会丢失一秒钟的写入，如果Redis进程本身发生问题，则可能会丢失一次写入，但是操作系统仍在正常运行</span></span><br><span class="line">AOF and RDB persistence can be enabled at the same time without problems.</span><br><span class="line">If the AOF is enabled on startup Redis will load the AOF, that is the file</span><br><span class="line">with the better durability guarantees.</span><br><span class="line"><span class="comment"># 可以同时启用AOF和RDB持久性，而不会出现问题。如果在启动时启用了AOF，则Redis将加载AOF，即具有更好持久性的文件</span></span><br><span class="line">Please check http : //redis.io/topics/persistence for more information.</span><br><span class="line"></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line">The name of the append only file (default : &quot;appendonly.aof&quot;)</span><br><span class="line"></span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line">The fsync() call tells the Operating System to actually write data on disk</span><br><span class="line">instead of waiting for more data in the output buffer. Some OS will really flush</span><br><span class="line">data on disk, some other OS will just try to do it ASAP.</span><br><span class="line"><span class="comment"># fsync（）调用告诉操作系统将数据实际写入磁盘，而不是等待输出缓冲区中的更多数据。某些操作系统确实会刷新磁盘上的数据，而另一些操作系统会尽快尝试</span></span><br><span class="line">Redis supports three different modes :</span><br><span class="line"></span><br><span class="line">no : don&#x27;t fsync, just let the OS flush the data when it wants. Faster.</span><br><span class="line">always : fsync after every write to the append only log. Slow, Safest.</span><br><span class="line">everysec : fsync only one time every second. Compromise.</span><br><span class="line"></span><br><span class="line">The default is &quot;everysec&quot;, as that&#x27;s usually the right compromise between</span><br><span class="line">speed and data safety. It&#x27;s up to you to understand if you can relax this to</span><br><span class="line">&quot;no&quot; that will let the operating system flush the output buffer when</span><br><span class="line">it wants, for better performances (but if you can live with the idea of</span><br><span class="line">some data loss consider the default persistence mode that&#x27;s snapshotting),</span><br><span class="line">or on the contrary, use &quot;always&quot; that&#x27;s very slow but a bit safer than</span><br><span class="line">everysec.</span><br><span class="line"></span><br><span class="line">More details please check the following article :</span><br><span class="line">http : //antirez.com/post/redis-persistence-demystified.html</span><br><span class="line"></span><br><span class="line">If unsure, use &quot;everysec&quot;.</span><br><span class="line"></span><br><span class="line">appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line">appendfsync no</span><br><span class="line"></span><br><span class="line">When the AOF fsync policy is set to always or everysec, and a background</span><br><span class="line">saving process (a background save or AOF log background rewriting) is</span><br><span class="line">performing a lot of I/O against the disk, in some Linux configurations</span><br><span class="line">Redis may block too long on the fsync() call. Note that there is no fix for</span><br><span class="line">this currently, as even performing fsync in a different thread will block</span><br><span class="line">our synchronous write(2) call.</span><br><span class="line"><span class="comment"># 当AOF fsync策略设置为always或everysec，并且后台保存进程（后台保存或AOF日志后台重写）对磁盘执行大量IO时，在某些Linux配置中，Redis可能会在fsync上阻塞太长时间（ ）致电。请注意，目前尚无此修复程序，因为即使在其他线程中执行fsync也将阻塞我们的同步write（2）调用</span></span><br><span class="line">In order to mitigate this problem it&#x27;s possible to use the following option</span><br><span class="line">that will prevent fsync() from being called in the main process while a</span><br><span class="line">BGSAVE or BGREWRITEAOF is in progress.</span><br><span class="line"><span class="comment"># 为了减轻此问题，可以使用以下选项来防止在BGSAVE或BGREWRITEAOF进行时在主进程中调用fsync（）</span></span><br><span class="line">This means that while another child is saving, the durability of Redis is</span><br><span class="line">the same as &quot;appendfsync none&quot;. In practical terms, this means that it is</span><br><span class="line">possible to lose up to 30 seconds of log in the worst scenario (with the</span><br><span class="line">default Linux settings).</span><br><span class="line"><span class="comment"># 这意味着当另一个子线程正在保存时，Redis的持久性与“ appendfsync none”相同。实际上，这意味着在最坏的情况下（使用默认的Linux设置）可能会丢失多达30秒的日志</span></span><br><span class="line">If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as</span><br><span class="line">&quot;no&quot; that is the safest pick from the point of view of durability.</span><br><span class="line"><span class="comment"># 如果您有延迟问题，请将其设置为“是”。否则，从耐用性的角度出发，将其保留为“ no”是最安全的选择</span></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line">Automatic rewrite of the append only file.</span><br><span class="line">Redis is able to automatically rewrite the log file implicitly calling</span><br><span class="line">BGREWRITEAOF when the AOF log size grows by the specified percentage.</span><br><span class="line"><span class="comment"># 自动重写仅附加文件。当AOF日志大小增加指定百分比时，Redis能够自动重写日志文件，隐式调用BGREWRITEAOF</span></span><br><span class="line">This is how it works : Redis remembers the size of the AOF file after the</span><br><span class="line">latest rewrite (if no rewrite has happened since the restart, the size of</span><br><span class="line">the AOF at startup is used).</span><br><span class="line"><span class="comment"># 它是这样工作的：Redis在最近一次重写之后会记住AOF文件的大小（如果自重新启动以来未发生任何重写，则使用启动时AOF的大小）。</span></span><br><span class="line">This base size is compared to the current size. If the current size is</span><br><span class="line">bigger than the specified percentage, the rewrite is triggered. Also</span><br><span class="line">you need to specify a minimal size for the AOF file to be rewritten, this</span><br><span class="line">is useful to avoid rewriting the AOF file even if the percentage increase</span><br><span class="line">is reached but it is still pretty small.</span><br><span class="line"><span class="comment"># 将此基本大小与当前大小进行比较。如果当前大小大于指定的百分比，则触发重写。另外，您需要指定要重写的AOF文件的最小大小，这对于避免重写AOF文件很有用，即使达到百分比增加，但它仍然很小</span></span><br><span class="line">Specify a percentage of zero in order to disable the automatic AOF</span><br><span class="line">rewrite feature.</span><br><span class="line"><span class="comment"># 指定零百分比以禁用自动AOF重写功能</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line">An AOF file may be found to be truncated at the end during the Redis</span><br><span class="line">startup process, when the AOF data gets loaded back into memory.</span><br><span class="line">This may happen when the system where Redis is running</span><br><span class="line">crashes, especially when an ext4 filesystem is mounted without the</span><br><span class="line"><span class="attr">data</span> = ordered option (however this can<span class="string">&#x27;t happen when Redis itself</span></span><br><span class="line"><span class="string">crashes or aborts but the operating system still works correctly).</span></span><br><span class="line"><span class="string"># 当AOF数据重新加载回内存时，在Redis启动过程中可能会发现AOF文件在末尾被截断。当运行Redis的系统崩溃时，尤其是在没有data = ordered选项的情况下挂载ext4文件系统时，可能会发生这种情况（但是，当Redis本身崩溃或中止，但操作系统仍然可以正常运行时，就不会发生这种情况）</span></span><br><span class="line"><span class="string">Redis can either exit with an error when this happens, or load as much</span></span><br><span class="line"><span class="string">data as possible (the default now) and start if the AOF file is found</span></span><br><span class="line"><span class="string">to be truncated at the end. The following option controls this behavior.</span></span><br><span class="line"><span class="string"># 发生这种情况时，Redis可能会退出并显示错误，也可以加载尽可能多的数据（当前为默认值），如果发现AOF文件最后被截断，则Redis会开始。以下选项控制此行为</span></span><br><span class="line"><span class="string">If aof-load-truncated is set to yes, a truncated AOF file is loaded and</span></span><br><span class="line"><span class="string">the Redis server starts emitting a log to inform the user of the event.</span></span><br><span class="line"><span class="string">Otherwise if the option is set to no, the server aborts with an error</span></span><br><span class="line"><span class="string">and refuses to start. When the option is set to no, the user requires</span></span><br><span class="line"><span class="string">to fix the AOF file using the &quot;redis-check-aof&quot; utility before to restart</span></span><br><span class="line"><span class="string">the server.</span></span><br><span class="line"><span class="string"># 如果aof-load-truncated设置为yes，则将加载截短的AOF文件，并且Redis服务器将开始发出日志以将事件通知用户。否则，如果该选项设置为no，则服务器将中止并显示错误并拒绝启动。如果该选项设置为no，则用户需要在重新启动服务器之前使用“ redis-check-aof”实用程序修复AOF文件</span></span><br><span class="line"><span class="string">Note that if the AOF file will be found to be corrupted in the middle</span></span><br><span class="line"><span class="string">the server will still exit with an error. This option only applies when</span></span><br><span class="line"><span class="string">Redis will try to read more data from the AOF file but not enough bytes</span></span><br><span class="line"><span class="string">will be found.</span></span><br><span class="line"><span class="string"># 请注意，如果在中间发现AOF文件已损坏，则服务器仍将退出并出现错误。仅当Redis尝试从AOF文件读取更多数据但找不到足够的字节时，此选项才适用。</span></span><br><span class="line"><span class="string">aof-load-truncated yes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">When rewriting the AOF file, Redis is able to use an RDB preamble in the</span></span><br><span class="line"><span class="string">AOF file for faster rewrites and recoveries. When this option is turned</span></span><br><span class="line"><span class="string">on the rewritten AOF file is composed of two different stanzas :</span></span><br><span class="line"><span class="string"># 重写AOF文件时，Redis可以使用AOF文件中的RDB前同步码来更快地进行重写和恢复。启用此选项后，重写的AOF文件由两个不同的节组成</span></span><br><span class="line"><span class="string">[RDB file] [AOF tail]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            When loading, Redis recognizes that the AOF file starts with the &quot;REDIS&quot;</span></span><br><span class="line"><span class="string">            string and loads the prefixed RDB file, then continues loading the AOF</span></span><br><span class="line"><span class="string">tail.</span></span><br><span class="line"><span class="string"># 加载时，Redis会识别AOF文件以“ REDIS”字符串开头并加载带前缀的RDB文件，然后继续加载AOF尾部。</span></span><br><span class="line"><span class="string">aof-use-rdb-preamble yes</span></span><br></pre></td></tr></table></figure>
<p>appendonly（AOF）是一种替代的持久性模式，可提供更好的持久性。例如，使用默认数据fsync策略（请参阅配置文件中的稍后内容），Redis在严重的事件（例如服务器断电）中仅会丢失一秒钟的写入，如果Redis进程本身发生问题，则可能会丢失一次写入，但是操作系统仍在正常运行</p>
<p>可以同时启用AOF和RDB持久性，而不会出现问题。如果在启动时启用了AOF，则Redis将加载AOF，即具有更好持久性的文件</p>
<p>appendonly（AOF）默认是关闭的，我们可以<code>appendonly yes</code>打开，默认文件名为<code>appendonly.aof</code></p>
<blockquote>
<p>默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append<br />
Only File是另一种持久化方式，<br />
可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入appendonly.aof文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。默认值为no</p>
</blockquote>
<p>appendonly（AOF）的启动参数有三个：默认使用appendfsync everysec</p>
<blockquote>
<p>appendfsync always<br />
appendfsync everysec<br />
appendfsync no</p>
</blockquote>
<p>aof持久化策略的配置；no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快；always表示每次写入都执行fsync，以保证数据同步到磁盘；everysec表示每秒执行一次fsync，可能会导致丢失这1s数据</p>
<p>在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。<br />
设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。Linux的默认fsync策略是30秒。可能丢失30秒数据。默认值为no。</p>
<blockquote>
<p>如果您有延迟问题，请将其设置为“是”。否则，从耐用性的角度出发，将其保留为“ no”是最安全的选择</p>
</blockquote>
<p>auto-aof-rewrite-percentage：默认值为100。aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。</p>
<p>auto-aof-rewrite-min-size：64mb。设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写。</p>
<p>aof-load-truncated：aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data=ordered选项，出现这种现象<br />
redis宕机或者异常终止不会造成尾部不完整现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。默认值为<br />
yes</p>
<h2 id="lua-scripting"><a class="markdownIt-Anchor" href="#lua-scripting"></a> LUA SCRIPTING</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">LUA SCRIPTING</span><br><span class="line"></span><br><span class="line">Max execution time of a Lua script in milliseconds.</span><br><span class="line"><span class="comment"># Lua脚本的最大执行时间（以毫秒为单位）。</span></span><br><span class="line">If the maximum execution time is reached Redis will log that a script is</span><br><span class="line">still in execution after the maximum allowed time and will start to</span><br><span class="line">reply to queries with an error.</span><br><span class="line"><span class="comment"># 如果达到了最大执行时间，Redis将记录脚本在允许的最大时间后仍在执行中，并将开始以错误答复查询</span></span><br><span class="line">When a long running script exceeds the maximum execution time only the</span><br><span class="line">SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be</span><br><span class="line">used to stop a script that did not yet call any write commands. The second</span><br><span class="line">is the only way to shut down the server in the case a write command was</span><br><span class="line">already issued by the script but the user doesn&#x27;t want to wait for the natural</span><br><span class="line">termination of the script.</span><br><span class="line"><span class="comment"># 如果长时间运行的脚本超过了最大执行时间，则只有“ SCRIPT KILL”和“ SHUTDOWN NOSAVE”命令可用。第一个可用于停止尚未调用任何写命令的脚本。第二种是在脚本已经发出写命令但用户不想等待脚本自然终止的情况下关闭服务器的唯一方法</span></span><br><span class="line">Set it to 0 or a negative value for unlimited execution without warnings.</span><br><span class="line"><span class="comment"># 将其设置为0或负值可无警告地无限执行</span></span><br><span class="line">lua-time-limit 5000</span><br></pre></td></tr></table></figure>
<p>lua-time-limit：一个lua脚本执行的最大时间，单位为ms。默认值为5000</p>
<h2 id="redis-cluster重要"><a class="markdownIt-Anchor" href="#redis-cluster重要"></a> REDIS CLUSTER(重要)</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">REDIS CLUSTER</span><br><span class="line"></span><br><span class="line">Normal Redis instances can&#x27;t be part of a Redis Cluster<span class="comment">; only nodes that are</span></span><br><span class="line">started as cluster nodes can. In order to start a Redis instance as a</span><br><span class="line">cluster node enable the cluster support uncommenting the following :</span><br><span class="line"><span class="comment"># 普通Redis实例不能属于Redis集群；只有作为群集节点启动的节点可以。为了将Redis实例启动为集群节点，请启用集群支持</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"></span><br><span class="line">Every cluster node has a cluster configuration file. This file is not</span><br><span class="line">intended to be edited by hand. It is created and updated by Redis nodes.</span><br><span class="line">Every Redis Cluster node requires a different cluster configuration file.</span><br><span class="line">Make sure that instances running in the same system do not have</span><br><span class="line">overlapping cluster configuration file names.</span><br><span class="line"><span class="comment"># 每个群集节点都有一个群集配置文件。该文件不适合手工编辑。它由Redis节点创建和更新。每个Redis群集节点都需要一个不同的群集配置文件。确保在同一系统上运行的实例没有重叠的集群配置文件名</span></span><br><span class="line">cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line">Cluster node timeout is the amount of milliseconds a node must be unreachable</span><br><span class="line">for it to be considered in failure state.</span><br><span class="line">Most other internal time limits are a multiple of the node timeout.</span><br><span class="line"><span class="comment"># 群集节点超时是一个节点必须不可达的毫秒数，才能将其视为故障状态。其他大多数内部时间限制是节点超时的倍数</span></span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line">A replica of a failing master will avoid to start a failover if its data</span><br><span class="line">looks too old.</span><br><span class="line"><span class="comment"># 如果发生故障的主副本的数据看起来太旧，它将避免启动故障转移。</span></span><br><span class="line">There is no simple way for a replica to actually have an exact measure of</span><br><span class="line">its &quot;data age&quot;, so the following two checks are performed :</span><br><span class="line"><span class="comment"># 没有一种简单的方法可以使副本实际上具有其“数据年龄”的准确度量，因此执行以下两项检查</span></span><br><span class="line">1) If there are multiple replicas able to failover, they exchange messages</span><br><span class="line">in order to try to give an advantage to the replica with the best</span><br><span class="line">replication offset (more data from the master processed).</span><br><span class="line">Replicas will try to get their rank by offset, and apply to the start</span><br><span class="line">of the failover a delay proportional to their rank.</span><br><span class="line"><span class="comment"># # 如果存在多个能够进行故障转移的副本，则它们会交换消息，以便尝试利用具有最佳复制偏移量的副本（已处理来自主数据库的更多数据）来获得优势。副本将尝试按偏移量获得其排名，并将故障切换延迟按其排名成比例地应用于故障转移的开始</span></span><br><span class="line">2) Every single replica computes the time of the last interaction with</span><br><span class="line">its master. This can be the last ping or command received (if the master</span><br><span class="line">is still in the &quot;connected&quot; state), or the time that elapsed since the</span><br><span class="line">disconnection with the master (if the replication link is currently down).</span><br><span class="line">If the last interaction is too old, the replica will not try to failover</span><br><span class="line">at all.</span><br><span class="line"><span class="comment"># 每个单个副本都会计算与其主副本之间最后一次交互的时间。这可以是最后收到的ping或命令（如果主服务器仍处于“已连接”状态），也可以是自从与主服务器断开连接以来经过的时间（如果复制链接当前已关闭）。如果最后一次交互太旧，则副本将完全不会尝试故障转移</span></span><br><span class="line">The point &quot;2&quot; can be tuned by user. Specifically a replica will not perform</span><br><span class="line">the failover if, since the last interaction with the master, the time</span><br><span class="line">elapsed is greater than :</span><br><span class="line"><span class="comment"># 用户可以调整点“ 2”。特别是，如果自从上次与主服务器进行交互以来，如果经过的时间大于或等于一个副本，则副本将不执行故障转移。</span></span><br><span class="line">(node-timeout * cluster-replica-validity-factor) + repl-ping-replica-period</span><br><span class="line"><span class="comment"># （节点超时 * 集群副本有效性因子）+ 复制周期</span></span><br><span class="line">So for example if node-timeout is 30 seconds, and the cluster-replica-validity-factor</span><br><span class="line">is 10, and assuming a default repl-ping-replica-period of 10 seconds, the</span><br><span class="line">replica will not try to failover if it was not able to talk with the master</span><br><span class="line">for longer than 310 seconds.</span><br><span class="line"><span class="comment"># 因此，例如，如果节点超时为30秒，并且集群副本有效期因子为10，并且假设默认的repl-ping-replica-period为10秒，则副本将无法尝试进行故障转移，如果它不能与主人交谈超过310秒</span></span><br><span class="line">A large cluster-replica-validity-factor may allow replicas with too old data to failover</span><br><span class="line">a master, while a too small value may prevent the cluster from being able to</span><br><span class="line">elect a replica at all.</span><br><span class="line"><span class="comment"># 较大的群集副本有效性因素可能会使数据过旧的副本无法对主副本进行故障转移，而值太小可能会使群集根本无法选择副本</span></span><br><span class="line">For maximum availability, it is possible to set the cluster-replica-validity-factor</span><br><span class="line">to a value of 0, which means, that replicas will always try to failover the</span><br><span class="line">master regardless of the last time they interacted with the master.</span><br><span class="line">(However they&#x27;ll always try to apply a delay proportional to their</span><br><span class="line">offset rank).</span><br><span class="line"><span class="comment"># 为了获得最大可用性，可以将cluster-replica-validity-factor设置为0，这意味着，无论副本上次与主服务器交互是什么，副本将始终尝试对主服务器进行故障转移。 （但是，他们将始终尝试按与其偏移等级成比例的方式应用延迟）</span></span><br><span class="line">Zero is the only value able to guarantee that when all the partitions heal</span><br><span class="line">the cluster will always be able to continue.</span><br><span class="line"><span class="comment"># 零是唯一能够确保当所有分区恢复正常时群集将始终能够继续运行的值</span></span><br><span class="line">cluster-replica-validity-factor 10</span><br><span class="line"></span><br><span class="line">Cluster replicas are able to migrate to orphaned masters, that are masters</span><br><span class="line">that are left without working replicas. This improves the cluster ability</span><br><span class="line">to resist to failures as otherwise an orphaned master can&#x27;t be failed over</span><br><span class="line">in case of failure if it has no working replicas.</span><br><span class="line"><span class="comment"># 群集副本能够迁移到孤立的主数据库，即那些没有工作副本的主数据库。这提高了群集抵抗故障的能力，否则如果孤立的主节点没有可用的副本，则该主节点在发生故障的情况下无法进行故障转移</span></span><br><span class="line">Replicas migrate to orphaned masters only if there are still at least a</span><br><span class="line">given number of other working replicas for their old master. This number</span><br><span class="line">is the &quot;migration barrier&quot;. A migration barrier of 1 means that a replica</span><br><span class="line">will migrate only if there is at least 1 other working replica for its master</span><br><span class="line">and so forth. It usually reflects the number of replicas you want for every</span><br><span class="line">master in your cluster.</span><br><span class="line"><span class="comment"># 仅当旧的主副本仍存在至少给定数量的其他工作副本时，副本副本才会迁移到孤立的主副本。这个数字是“移民壁垒”。迁移屏障为1意味着，仅当副本数据库的主副本中至少有1个其他工作副本时，副本副本才会迁移。它通常反映出集群中每个主数据库所需的副本数</span></span><br><span class="line">Default is 1 (replicas migrate only if their masters remain with at least</span><br><span class="line">one replica). To disable migration just set it to a very large value.</span><br><span class="line">A value of 0 can be set but is useful only for debugging and dangerous</span><br><span class="line">in production.</span><br><span class="line"><span class="comment"># 缺省值为1（仅当其主副本保留至少一个副本副本时，副本副本才会迁移）。要禁用迁移，只需将其设置为非常大的值即可。可以设置为0，但仅用于调试和生产危险</span></span><br><span class="line">cluster-migration-barrier 1</span><br><span class="line"></span><br><span class="line">By default Redis Cluster nodes stop accepting queries if they detect there</span><br><span class="line">is at least a hash slot uncovered (no available node is serving it).</span><br><span class="line">This way if the cluster is partially down (for example a range of hash slots</span><br><span class="line">are no longer covered) all the cluster becomes, eventually, unavailable.</span><br><span class="line">It automatically returns available as soon as all the slots are covered again.</span><br><span class="line"><span class="comment"># 默认情况下，如果Redis Cluster节点检测到至少发现一个哈希槽（没有可用的节点正在为其提供服务），它们将停止接受查询。这样，如果集群部分关闭（例如，不再覆盖哈希槽范围），则所有集群最终将变得不可用。再次覆盖所有插槽后，它将自动返回可用状态</span></span><br><span class="line">However sometimes you want the subset of the cluster which is working,</span><br><span class="line">to continue to accept queries for the part of the key space that is still</span><br><span class="line">covered. In order to do so, just set the cluster-require-full-coverage</span><br><span class="line">option to no.</span><br><span class="line"><span class="comment"># 但是，有时您希望正在运行的集群子集继续接受对仍覆盖的部分键空间的查询。为此，只需将cluster-require-full-coverage选项设置为no</span></span><br><span class="line"></span><br><span class="line">cluster-require-full-coverage yes</span><br><span class="line"></span><br><span class="line">This option, when set to yes, prevents replicas from trying to failover its</span><br><span class="line">master during master failures. However the master can still perform a</span><br><span class="line">manual failover, if forced to do so.</span><br><span class="line"><span class="comment"># 设置为yes时，此选项可防止副本在主服务器发生故障时尝试对其主服务器进行故障转移。但是，主服务器仍然可以执行手动故障转移（如果被迫执行）</span></span><br><span class="line">This is useful in different scenarios, especially in the case of multiple</span><br><span class="line">data center operations, where we want one side to never be promoted if not</span><br><span class="line">in the case of a total DC failure.</span><br><span class="line"><span class="comment"># 这在不同的情况下很有用，尤其是在多个数据中心操作的情况下，在这种情况下，如果完全DC失败，我们希望不升级一侧。</span></span><br><span class="line">cluster-replica-no-failover no</span><br><span class="line"></span><br><span class="line">This option, when set to yes, allows nodes to serve read traffic while the</span><br><span class="line">the cluster is in a down state, as long as it believes it owns the slots.</span><br><span class="line"><span class="comment"># 设置为yes时，此选项允许节点在群集处于关闭状态时为其提供读取流量，只要它认为自己拥有插槽即可</span></span><br><span class="line">This is useful for two cases.  The first case is for when an application</span><br><span class="line">doesn&#x27;t require consistency of data during node failures or network partitions.</span><br><span class="line">One example of this is a cache, where as long as the node has the data it</span><br><span class="line">should be able to serve it.</span><br><span class="line"><span class="comment"># 这对于两种情况很有用。第一种情况是在节点故障或网络分区期间应用程序不需要数据一致性时。一个示例是高速缓存，只要节点具有数据，它就应该能够为其服务</span></span><br><span class="line">The second use case is for configurations that don&#x27;t meet the recommended</span><br><span class="line">three shards but want to enable cluster mode and scale later. A</span><br><span class="line">master outage in a 1 or 2 shard configuration causes a read/write outage to the</span><br><span class="line">entire cluster without this option set, with it set there is only a write outage.</span><br><span class="line">Without a quorum of masters, slot ownership will not change automatically.</span><br><span class="line"><span class="comment"># 第二个用例是针对不符合建议的三个分片但希望启用集群模式并在以后扩展的配置。如果没有设置此选项，则在1或2分片配置中的主服务器中断会导致整个集群的读写中断。如果没有法定人数的主持人，则插槽所有权不会自动更改</span></span><br><span class="line">cluster-allow-reads-when-down no</span><br><span class="line"></span><br><span class="line">In order to setup your cluster make sure to read the documentation</span><br><span class="line">available at http : //redis.io web site.</span><br></pre></td></tr></table></figure>
<p>cluster-enabled：集群开关，默认是不开启集群模式。</p>
<p>cluster-config-file：集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。<br />
这个文件并不需要手动配置，这个配置文件有Redis生成并更新，每个Redis集群节点需要一个单独的配置文件。请确保与实例运行的系统中配置文件名称不冲突。默认配置为nodes-6379.conf</p>
<p>cluster-node-timeout ：可以配置值为15000。节点互连超时的阀值，集群节点超时毫秒数</p>
<p>cluster-slave-validity-factor ：可以配置值为10。在进行故障转移的时候，全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了，<br />
导致数据过于陈旧，这样的slave不应该被提升为master。该参数就是用来判断slave节点与master断线的时间是否过长。</p>
<blockquote>
<p>判断方法是：比较slave断开连接的时间和(node-timeout * slave-validity-factor) +<br />
repl-ping-slave-period 如果节点超时时间为三十秒,<br />
并且slave-validity-factor为10,假设默认的repl-ping-slave-period是10秒，即如果超过310秒slave将不会尝试进行故障转移</p>
</blockquote>
<p>cluster-migration-barrier ：可以配置值为1。master的slave数量大于该值，slave才能迁移到其他孤立master上，如这个参数若被设为2，那么只有当一个主节点拥有2<br />
个可工作的从节点时，它的一个从节点会尝试迁移。</p>
<p>cluster-require-full-coverage：默认情况下，集群全部的slot有节点负责，集群状态才为ok，才能提供服务。<br />
设置为no，可以在slot没有全部分配的时候提供服务。不建议打开该配置，这样会造成分区的时候，小分区的master一直在接受写请求，而造成很长时间数据不一致。</p>
<h2 id="cluster-dockernat-support"><a class="markdownIt-Anchor" href="#cluster-dockernat-support"></a> CLUSTER DOCKER/NAT support</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">CLUSTER DOCKER/NAT support</span><br><span class="line"></span><br><span class="line">In certain deployments, Redis Cluster nodes address discovery fails, because</span><br><span class="line">addresses are NAT-ted or because ports are forwarded (the typical case is</span><br><span class="line">Docker and other containers).</span><br><span class="line"><span class="comment"># 在某些部署中，Redis群集节点地址发现失败，这是因为地址经过NAT限制或端口已转发（典型情况是Docker和其他容器）</span></span><br><span class="line">In order to make Redis Cluster working in such environments, a static</span><br><span class="line">configuration where each node knows its public address is needed. The</span><br><span class="line">following two options are used for this scope, and are :</span><br><span class="line"><span class="comment"># 为了使Redis Cluster在这样的环境中工作，需要一个静态配置，其中每个节点都知道其公共地址。以下两个选项用于此范围，分别是</span></span><br><span class="line">* cluster-announce-ip</span><br><span class="line">* cluster-announce-port</span><br><span class="line">* cluster-announce-bus-port</span><br><span class="line"></span><br><span class="line">Each instructs the node about its address, client port, and cluster message</span><br><span class="line">bus port. The information is then published in the header of the bus packets</span><br><span class="line">so that other nodes will be able to correctly map the address of the node</span><br><span class="line">publishing the information.</span><br><span class="line"><span class="comment"># 每个节点都向节点指示其地址，客户端端口和群集消息总线端口。然后将信息发布在总线数据包的标题中，以便其他节点将能够正确映射发布信息的节点的地址</span></span><br><span class="line">If the above options are not used, the normal Redis Cluster auto-detection</span><br><span class="line">will be used instead.</span><br><span class="line"><span class="comment"># 如果未使用上述选项，则将使用常规的Redis群集自动检测</span></span><br><span class="line">Note that when remapped, the bus port may not be at the fixed offset of</span><br><span class="line">clients port + 10000, so you can specify any port and bus-port depending</span><br><span class="line">on how they get remapped. If the bus-port is not set, a fixed offset of</span><br><span class="line">10000 will be used as usual.</span><br><span class="line"><span class="comment"># 请注意，重新映射时，总线端口可能不在客户端端口+ 10000的固定偏移处，因此您可以根据重新映射的方式指定任何端口和总线端口。如果未设置总线端口，则将照常使用10000的固定偏移量</span></span><br><span class="line">Example :</span><br><span class="line"></span><br><span class="line">cluster-announce-ip 10.1.1.5</span><br><span class="line">cluster-announce-port 6379</span><br><span class="line">cluster-announce-bus-port 6380</span><br></pre></td></tr></table></figure>
<p>在某些部署中，Redis群集节点寻址失败，这是因为地址经过NAT限制或端口已转发（典型情况是Docker和其他容器），为了使Redis<br />
Cluster在这样的环境中工作，需要一个静态配置，其中每个节点都知道其公共地址。以下两个选项用于此范围，分别是</p>
<ul>
<li>cluster-announce-ip</li>
<li>cluster-announce-port</li>
<li>cluster-announce-bus-port</li>
</ul>
<h2 id="slow-log"><a class="markdownIt-Anchor" href="#slow-log"></a> SLOW LOG</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">SLOW LOG</span><br><span class="line"></span><br><span class="line">The Redis Slow Log is a system to log queries that exceeded a specified</span><br><span class="line">execution time. The execution time does not include the I/O operations</span><br><span class="line">like talking with the client, sending the reply and so forth,</span><br><span class="line">but just the time needed to actually execute the command (this is the only</span><br><span class="line">stage of command execution where the thread is blocked and can not serve</span><br><span class="line">other requests in the meantime).</span><br><span class="line"><span class="comment"># Redis Slow Log是一个用于记录超过指定执行时间的查询的系统。执行时间不包括与客户端交谈，发送回复等IO操作，而仅包括实际执行命令所需的时间（这是命令执行的唯一阶段，在该阶段线程被阻塞并且无法服务同时提出其他要求）</span></span><br><span class="line">You can configure the slow log with two parameters : one tells Redis</span><br><span class="line">what is the execution time, in microseconds, to exceed in order for the</span><br><span class="line">command to get logged, and the other parameter is the length of the</span><br><span class="line">slow log. When a new command is logged the oldest one is removed from the</span><br><span class="line">queue of logged commands.</span><br><span class="line"><span class="comment"># 您可以使用以下两个参数配置慢速日志：一个告诉Redis，为了使命令被记录下来，执行时间要超过多少微秒，而另一个参数是慢速日志的长度。记录新命令时，最早的命令将从记录的命令队列中删除</span></span><br><span class="line">The following time is expressed in microseconds, so 1000000 is equivalent</span><br><span class="line">to one second. Note that a negative number disables the slow log, while</span><br><span class="line">a value of zero forces the logging of every command.</span><br><span class="line"><span class="comment"># 时间以微秒为单位，因此1000000等于一秒。请注意，负数将禁用慢速日志记录，而零值将强制记录每个命令</span></span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line">There is no limit to this length. Just be aware that it will consume memory.</span><br><span class="line">You can reclaim memory used by the slow log with SLOWLOG RESET.</span><br><span class="line">slowlog-max-len 128</span><br><span class="line"><span class="comment"># 该长度没有限制。请注意，它将消耗内存。您可以使用SLOWLOG RESET回收慢日志使用的内存</span></span><br></pre></td></tr></table></figure>
<p>Slowlog-log-slower-than: 默认值为10000，其中1000000等于1秒（负数将禁用慢速日志记录，而零值将强制记录每个命令）</p>
<p>slowlog-max-len: 日志的长度默认值为128，新日志将追加。就日志将从前删除。</p>
<h2 id="latency-monitor"><a class="markdownIt-Anchor" href="#latency-monitor"></a> LATENCY MONITOR</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">LATENCY MONITOR</span><br><span class="line"></span><br><span class="line">The Redis latency monitoring subsystem samples different operations</span><br><span class="line">at runtime in order to collect data related to possible sources of</span><br><span class="line">latency of a Redis instance.</span><br><span class="line"><span class="comment"># Redis延迟监视子系统在运行时对不同的操作进行采样，以便收集与Redis实例的潜在延迟源相关的数据</span></span><br><span class="line">Via the LATENCY command this information is available to the user that can</span><br><span class="line">print graphs and obtain reports.</span><br><span class="line"><span class="comment"># 通过LATENCY命令，该信息可供打印，获取报告的用户使用</span></span><br><span class="line">The system only logs operations that were performed in a time equal or</span><br><span class="line">greater than the amount of milliseconds specified via the</span><br><span class="line">latency-monitor-threshold configuration directive. When its value is set</span><br><span class="line">to zero, the latency monitor is turned off.</span><br><span class="line"><span class="comment"># 系统仅记录在等于或大于通过delay-monitor-threshold配置指令指定的毫秒量的时间内执行的操作。当其值设置为零时，等待时间监视器将关闭</span></span><br><span class="line">By default latency monitoring is disabled since it is mostly not needed</span><br><span class="line">if you don&#x27;t have latency issues, and collecting data has a performance</span><br><span class="line">impact, that while very small, can be measured under big load. Latency</span><br><span class="line">monitoring can easily be enabled at runtime using the command</span><br><span class="line">&quot;CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;&quot; if needed.</span><br><span class="line"><span class="comment"># 默认情况下，延迟监视是禁用的，因为如果您没有延迟问题，通常不需要它，并且收集数据会对性能产生影响，尽管影响很小，但是可以在大负载下进行测量。如果需要，可以在运行时使用命令“ CONFIG SET delay-monitor-threshold &lt;milliseconds&gt;”轻松启用延迟监视</span></span><br><span class="line">latency-monitor-threshold 0</span><br></pre></td></tr></table></figure>
<h2 id="event-notification"><a class="markdownIt-Anchor" href="#event-notification"></a> EVENT NOTIFICATION</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">EVENT NOTIFICATION</span><br><span class="line"></span><br><span class="line">Redis can notify Pub/Sub clients about events happening in the key space.</span><br><span class="line">This feature is documented at http : //redis.io/topics/notifications</span><br><span class="line"><span class="comment"># Redis可以通知PubSub客户端关键空间中发生的事件</span></span><br><span class="line">For instance if keyspace events notification is enabled, and a client</span><br><span class="line">performs a DEL operation on key &quot;foo&quot; stored in the Database 0, two</span><br><span class="line">messages will be published via Pub/Sub :</span><br><span class="line"><span class="comment"># 例如，如果启用了键空间事件通知，并且客户端对存储在数据库0中的键“ foo”执行了DEL操作，则将通过PubSub发布两条消息</span></span><br><span class="line">PUBLISH __keyspace@0__ : foo del</span><br><span class="line">PUBLISH __keyevent@0__ : del foo</span><br><span class="line"></span><br><span class="line">It is possible to select the events that Redis will notify among a set</span><br><span class="line">of classes. Every class is identified by a single character :</span><br><span class="line"><span class="comment"># 可以在一组类中选择Redis将通知的事件。每个类别都由单个字符标识</span></span><br><span class="line">K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.             <span class="comment"># 空键事件，以__keyspace @ &lt;db&gt; __前缀发布</span></span><br><span class="line">E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.             <span class="comment"># 按键事件，以__keyevent @ &lt;db&gt; __前缀发布</span></span><br><span class="line">g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...    <span class="comment"># 通用命令（非类型专用），例如DEL，EXPIRE，RENAME</span></span><br><span class="line">$     String commands                                                       <span class="comment"># 字符串命令</span></span><br><span class="line">l     List commands                                                         <span class="comment"># 列表命令</span></span><br><span class="line">s     Set commands                                                          <span class="comment"># 集合命令</span></span><br><span class="line">h     Hash commands                                                         <span class="comment"># 哈希命令</span></span><br><span class="line">z     Sorted set commands                                                   <span class="comment"># 有序集合命令</span></span><br><span class="line">x     Expired events (events generated every time a key expires)            <span class="comment"># 过期事件（每次密钥过期时生成的事件）</span></span><br><span class="line">e     Evicted events (events generated when a key is evicted for maxmemory) <span class="comment"># 驱逐事件（将密钥驱逐到最大内存时生成的事件）</span></span><br><span class="line">t     Stream commands                                                       <span class="comment"># 流命令</span></span><br><span class="line">m     Key-miss events (Note : It is not included in the &#x27;A&#x27; class)           <span class="comment"># 键丢失事件（注意：它不包含在“ A”类中）</span></span><br><span class="line">A     Alias for g$lshzxet, so that the &quot;AKE&quot; string means all the events    <span class="comment"># glshzxet的别名，因此“ AKE”字符串表示所有事件</span></span><br><span class="line">(Except key-miss events which are excluded from &#x27;A&#x27; due to their</span><br><span class="line">unique nature).</span><br><span class="line"></span><br><span class="line">The &quot;notify-keyspace-events&quot; takes as argument a string that is composed</span><br><span class="line">of zero or multiple characters. The empty string means that notifications</span><br><span class="line">are disabled.</span><br><span class="line"><span class="comment"># “ notify-keyspace-events”将由零个或多个字符组成的字符串作为参数。空字符串表示已禁用通知</span></span><br><span class="line">Example : to enable list and generic events, from the point of view of the</span><br><span class="line">event name, use :</span><br><span class="line"></span><br><span class="line">notify-keyspace-events Elg</span><br><span class="line"></span><br><span class="line">Example 2 : to get the stream of the expired keys subscribing to channel</span><br><span class="line">name __keyevent@0__ : expired use:</span><br><span class="line"></span><br><span class="line">notify-keyspace-events Ex</span><br><span class="line"></span><br><span class="line">By default all notifications are disabled because most users don&#x27;t need</span><br><span class="line">this feature and the feature has some overhead. Note that if you don&#x27;t</span><br><span class="line">specify at least one of K or E, no events will be delivered.</span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line"><span class="comment"># 默认情况下，所有通知都被禁用，因为大多数用户不需要此功能，并且该功能有一些开销。请注意，如果您未指定K或E中的至少一个，则不会传递任何事件。 notify-keyspace-events</span></span><br></pre></td></tr></table></figure>
<h2 id="gopher-server"><a class="markdownIt-Anchor" href="#gopher-server"></a> GOPHER SERVER</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GOPHER SERVER </span><br><span class="line"></span><br><span class="line">Redis contains an implementation of the Gopher protocol, as specified in</span><br><span class="line">the RFC 1436 (https://www.ietf.org/rfc/rfc1436.txt).</span><br><span class="line"># Redis包含RFC 1436（https：www.ietf.orgrfcrfc1436.txt）中指定的Gopher协议的实现。</span><br><span class="line">The Gopher protocol was very popular in the late &#x27;90s. It is an alternative</span><br><span class="line">to the web, and the implementation both server and client side is so simple</span><br><span class="line">that the Redis server has just 100 lines of code in order to implement this</span><br><span class="line">support.</span><br><span class="line"># Gopher协议在90年代后期非常流行。它是Web的替代方法，服务器和客户端的实现是如此简单，以至于Redis服务器只有100行代码才能实现这种支持</span><br><span class="line">What do you do with Gopher nowadays? Well Gopher never *really* died, and</span><br><span class="line">lately there is a movement in order for the Gopher more hierarchical content</span><br><span class="line">composed of just plain text documents to be resurrected. Some want a simpler</span><br><span class="line">internet, others believe that the mainstream internet became too much</span><br><span class="line">controlled, and it&#x27;s cool to create an alternative space for people that</span><br><span class="line">want a bit of fresh air.</span><br><span class="line"># 您现在如何使用Gopher？好吧，Gopher从未真正死过，最近出现了一种运动，目的是使Gopher具有更多层次的内容（由纯文本文档组成）得以复活。有些人想要一个更简单的互联网，另一些人则认为主流互联网变得过于受控，为想要一点新鲜空气的人们创造一个替代空间很酷。</span><br><span class="line">Anyway for the 10nth birthday of the Redis, we gave it the Gopher protocol</span><br><span class="line">as a gift.</span><br><span class="line"># 无论如何，在Redis十岁生日的时候，我们给了它Gopher协议作为礼物</span><br><span class="line">--- HOW IT WORKS? ---</span><br><span class="line"></span><br><span class="line">The Redis Gopher support uses the inline protocol of Redis, and specifically</span><br><span class="line">two kind of inline requests that were anyway illegal: an empty request</span><br><span class="line">or any request that starts with &quot;/&quot; (there are no Redis commands starting</span><br><span class="line">with such a slash). Normal RESP2/RESP3 requests are completely out of the</span><br><span class="line">path of the Gopher protocol implementation and are served as usual as well.</span><br><span class="line"># Redis Gopher支持使用Redis的内联协议，特别是两种仍然非法的内联请求：空请求或任何以“”开头的请求（没有以这样的斜杠开头的Redis命令）。正常的RESP2RESP3请求完全超出了Gopher协议实现的路径，并且也照常使用</span><br><span class="line">If you open a connection to Redis when Gopher is enabled and send it</span><br><span class="line">a string like &quot;/foo&quot;, if there is a key named &quot;/foo&quot; it is served via the</span><br><span class="line">Gopher protocol.</span><br><span class="line"># 如果在启用Gopher时打开与Redis的连接，并向其发送“ foo”之类的字符串，则如果存在名为“ foo”的密钥，则会通过Gopher协议为其提供服务</span><br><span class="line">In order to create a real Gopher &quot;hole&quot; (the name of a Gopher site in Gopher</span><br><span class="line">talking), you likely need a script like the following:</span><br><span class="line"></span><br><span class="line">https://github.com/antirez/gopher2redis</span><br><span class="line"></span><br><span class="line">--- SECURITY WARNING ---</span><br><span class="line"></span><br><span class="line">If you plan to put Redis on the internet in a publicly accessible address</span><br><span class="line">to server Gopher pages MAKE SURE TO SET A PASSWORD to the instance.</span><br><span class="line">Once a password is set:</span><br><span class="line"></span><br><span class="line">1. The Gopher server (when enabled, not by default) will still serve</span><br><span class="line">  content via Gopher.</span><br><span class="line">2. However other commands cannot be called before the client will</span><br><span class="line">  authenticate.</span><br><span class="line"></span><br><span class="line">So use the &#x27;requirepass&#x27; option to protect your instance.</span><br><span class="line"></span><br><span class="line">Note that Gopher is not currently supported when &#x27;io-threads-do-reads&#x27;</span><br><span class="line">is enabled.</span><br><span class="line"></span><br><span class="line">To enable Gopher support, uncomment the following line and set the option</span><br><span class="line">from no (the default) to yes.</span><br><span class="line"></span><br><span class="line">gopher-enabled no</span><br></pre></td></tr></table></figure>
<h2 id="advanced-config"><a class="markdownIt-Anchor" href="#advanced-config"></a> ADVANCED CONFIG</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">ADVANCED CONFIG</span><br><span class="line"></span><br><span class="line">Hashes are encoded using a memory efficient data structure when they have a</span><br><span class="line">small number of entries, and the biggest entry does not exceed a given</span><br><span class="line">threshold. These thresholds can be configured using the following directives.</span><br><span class="line"><span class="comment"># 当哈希条目只有少量条目且最大条目未超过给定阈值时，将使用内存高效的数据结构对其进行编码。可以使用以下指令配置这些阈值</span></span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line">Lists are also encoded in a special way to save a lot of space.</span><br><span class="line">The number of entries allowed per internal list node can be specified</span><br><span class="line">as a fixed maximum size or a maximum number of elements.</span><br><span class="line"><span class="comment"># 列表也以特殊方式编码，以节省大量空间。每个内部列表节点允许的条目数可以指定为固定的最大大小或最大元素数</span></span><br><span class="line">For a fixed maximum size, use -5 through -1, meaning :</span><br><span class="line"><span class="comment"># 对于固定的最大大小，请使用-5到-1，表示</span></span><br><span class="line">-5 : max size: 64 Kb  &lt;-- not recommended for normal workloads</span><br><span class="line">-4 : max size: 32 Kb  &lt;-- not recommended</span><br><span class="line">-3 : max size: 16 Kb  &lt;-- probably not recommended</span><br><span class="line">-2 : max size: 8 Kb   &lt;-- good</span><br><span class="line">-1 : max size: 4 Kb   &lt;-- good</span><br><span class="line">Positive numbers mean store up to _exactly_ that number of elements</span><br><span class="line">per list node.</span><br><span class="line"><span class="comment"># 正数表示每个列表节点最多可存储_exactly_个元素</span></span><br><span class="line">The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),</span><br><span class="line">but if your use case is unique, adjust the settings as necessary.</span><br><span class="line"><span class="comment"># 最高性能的选项通常是-2（8 Kb大小）或-1（4 Kb大小），但是如果您的用例是唯一的，请根据需要调整设置</span></span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line"></span><br><span class="line">Lists may also be compressed.   <span class="comment"># 列表也可以被压缩。</span></span><br><span class="line">Compress depth is the number of quicklist ziplist nodes from *each* side of</span><br><span class="line">the list to *exclude* from compression.  The head and tail of the list</span><br><span class="line">are always uncompressed for fast push/pop operations.  Settings are :</span><br><span class="line"><span class="comment"># 压缩深度是列表的每侧要从压缩中排除的快速列表ziplist节点的数量。列表的开头和结尾始终是未压缩的，以便快速进行pushpop操作。设置是</span></span><br><span class="line">0 : disable all list compression <span class="comment"># 禁用所有列表压缩</span></span><br><span class="line">1 : depth 1 means &quot;don&#x27;t start compressing until after 1 node into the list,</span><br><span class="line">going from either the head or tail&quot; <span class="comment"># 深度1表示“直到列表中有1个节点之后，才开始压缩，从头到尾</span></span><br><span class="line">So : <span class="section">[head]</span>-&gt;node-&gt;node-&gt;...-&gt;node-&gt;<span class="section">[tail]</span></span><br><span class="line"><span class="section">[head]</span>, <span class="section">[tail]</span> will always be uncompressed<span class="comment">; inner nodes will compress.</span></span><br><span class="line">                                          2 : <span class="section">[head]</span>-&gt;<span class="section">[next]</span>-&gt;node-&gt;node-&gt;...-&gt;node-&gt;<span class="section">[prev]</span>-&gt;<span class="section">[tail]</span></span><br><span class="line">                                          2 here means : don&#x27;t compress head or head-&gt;next or tail-&gt;prev or tail,</span><br><span class="line">                                          but compress all nodes between them.</span><br><span class="line">                                          3 : <span class="section">[head]</span>-&gt;<span class="section">[next]</span>-&gt;<span class="section">[next]</span>-&gt;node-&gt;node-&gt;...-&gt;node-&gt;<span class="section">[prev]</span>-&gt;<span class="section">[prev]</span>-&gt;<span class="section">[tail]</span></span><br><span class="line">        etc.</span><br><span class="line">        list-compress-depth 0</span><br><span class="line"></span><br><span class="line">        Sets have a special encoding in just one case : when a set is composed</span><br><span class="line">        of just strings that happen to be integers in radix 10 in the range</span><br><span class="line">        of 64 bit signed integers.</span><br><span class="line">        The following configuration setting sets the limit in the size of the</span><br><span class="line">        set in order to use this special memory saving encoding.</span><br><span class="line">        <span class="comment"># 在仅一种情况下，集合具有特殊的编码：当集合仅由恰好是基数10中整数（在64位有符号整数范围内）的字符串组成时。以下配置设置设置了大小限制，以便使用此特殊的内存节省编码</span></span><br><span class="line">        set-max-intset-entries 512</span><br><span class="line"></span><br><span class="line">        Similarly to hashes and lists, sorted sets are also specially encoded in</span><br><span class="line">        order to save a lot of space. This encoding is only used when the length and</span><br><span class="line">        elements of a sorted set are below the following limits :</span><br><span class="line">        <span class="comment"># 与哈希表和列表类似，对排序集也进行了特殊编码，以节省大量空间。仅当排序集的长度和元素低于以下限制时，才使用此编码</span></span><br><span class="line">        zset-max-ziplist-entries 128</span><br><span class="line">        zset-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line">        HyperLogLog sparse representation bytes limit. The limit includes the</span><br><span class="line">        16 bytes header. When an HyperLogLog using the sparse representation crosses</span><br><span class="line">        this limit, it is converted into the dense representation.</span><br><span class="line">        <span class="comment"># HyperLogLog稀疏表示形式的字节数限制。限制包括16个字节的标头。当使用稀疏表示的HyperLogLog超过此限制时，它将转换为密集表示</span></span><br><span class="line">        A value greater than 16000 is totally useless, since at that point the</span><br><span class="line">        dense representation is more memory efficient.</span><br><span class="line">        <span class="comment"># 大于16000的值是完全没有用的，因为在那一点上，密集表示的存储效率更高</span></span><br><span class="line">        The suggested value is ~ 3000 in order to have the benefits of</span><br><span class="line">        the space efficient encoding without slowing down too much PFADD,</span><br><span class="line">        which is O(N) with the sparse encoding. The value can be raised to</span><br><span class="line">        ~ 10000 when CPU is not a concern, but space is, and the data set is</span><br><span class="line">        composed of many HyperLogLogs with cardinality in the 0 - 15000 range.</span><br><span class="line">        <span class="comment"># 建议值约为3000，以便在不减慢过多PFADD的情况下获得节省空间编码的好处，而PFADD的稀疏编码为O（N）。当不关心CPU但有空间时，该值可以提高到10000，并且数据集由基数在0-15000范围内的许多HyperLogLog组成</span></span><br><span class="line">        hll-sparse-max-bytes 3000</span><br><span class="line"></span><br><span class="line">        Streams macro node max size / items. The stream data structure is a radix</span><br><span class="line">        tree of big nodes that encode multiple items inside. Using this configuration</span><br><span class="line">        it is possible to configure how big a single node can be in bytes, and the</span><br><span class="line">        maximum number of items it may contain before switching to a new node when</span><br><span class="line">        appending new stream entries. If any of the following settings are set to</span><br><span class="line">        zero, the limit is ignored, so for instance it is possible to set just a</span><br><span class="line">        max entires limit by setting max-bytes to 0 and max-entries to the desired</span><br><span class="line">        value.</span><br><span class="line">        <span class="comment"># 流宏节点最大大小的项目。流数据结构是一个大节点的基数树，它对内部的多个项目进行编码。使用此配置，可以配置单个节点的大小（以字节为单位），以及在添加新的流条目时切换到新节点之前它可能包含的最大项目数。如果以下任何设置被设置为零，则该限制将被忽略，例如，可以通过将max-bytes设置为0并将max-entries设置为所需的值来仅设置最大整数限制</span></span><br><span class="line">        stream-node-max-bytes 4096</span><br><span class="line">        stream-node-max-entries 100</span><br><span class="line"></span><br><span class="line">        Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in</span><br><span class="line">        order to help rehashing the main Redis hash table (the one mapping top-level</span><br><span class="line">        keys to values). The hash table implementation Redis uses (see dict.c)</span><br><span class="line">        performs a lazy rehashing : the more operation you run into a hash table</span><br><span class="line">        that is rehashing, the more rehashing &quot;steps&quot; are performed, so if the</span><br><span class="line">        server is idle the rehashing is never complete and some more memory is used</span><br><span class="line">        by the hash table.</span><br><span class="line">        <span class="comment"># 活动重新哈希处理每100毫秒CPU时间使用1毫秒，以帮助重新哈希主Redis哈希表（将顶级键映射到值的一个哈希表）。 Redis使用的哈希表实现（请参阅dict.c）执行一次懒惰的重新哈希处理：您在要进行哈希处理的哈希表中运行的操作越多，执行的哈希处理“步骤”就越多，因此，如果服务器空闲，则哈希处理将永远不会完成哈希表使用了更多的内存</span></span><br><span class="line">        The default is to use this millisecond 10 times every second in order to</span><br><span class="line">        actively rehash the main dictionaries, freeing memory when possible.</span><br><span class="line">        <span class="comment"># 默认值是每秒使用10毫秒的毫秒数来主动重新哈希主字典，并在可能的情况下释放内存</span></span><br><span class="line">        If unsure :</span><br><span class="line">        use &quot;activerehashing no&quot; if you have hard latency requirements and it is</span><br><span class="line">        not a good thing in your environment that Redis can reply from time to time</span><br><span class="line">        to queries with 2 milliseconds delay.</span><br><span class="line">        <span class="comment"># 如果不确定：如果您有严格的延迟要求，则使用“ activehashing no”，并且在您的环境中，Redis可以不时地以2毫秒的延迟答复查询不是一件好事</span></span><br><span class="line"></span><br><span class="line">        use &quot;activerehashing yes&quot; if you don&#x27;t have such hard requirements but</span><br><span class="line">        want to free memory asap when possible.</span><br><span class="line">        <span class="comment"># 如果您没有如此严格的要求，但想在可能的情况下尽快释放内存，请使用“ activerehashing yes”</span></span><br><span class="line">        activerehashing yes</span><br><span class="line"></span><br><span class="line">        The client output buffer limits can be used to force disconnection of clients</span><br><span class="line">        that are not reading data from the server fast enough for some reason (a</span><br><span class="line">        common reason is that a Pub/Sub client can&#x27;t consume messages as fast as the</span><br><span class="line">        publisher can produce them).</span><br><span class="line"><span class="comment"># 客户端输出缓冲区限制可用于出于某些原因强制断开那些没有足够快地从服务器读取数据的客户端（常见原因是PubSub客户端不能像发布者产生消息那样快地消耗消息）</span></span><br><span class="line">The limit can be set differently for the three different classes of clients :</span><br><span class="line"><span class="comment"># 可以为三种不同类别的客户设置不同的限制</span></span><br><span class="line">normal -&gt; normal clients including MONITOR clients  <span class="comment"># 普通客户，包括MONITOR客户</span></span><br><span class="line">replica  -&gt; replica clients                         <span class="comment"># 复制客户端</span></span><br><span class="line">pubsub -&gt; clients subscribed to at least one pubsub channel or pattern  <span class="comment"># 客户订阅了至少一个pubsub频道或模式</span></span><br><span class="line"></span><br><span class="line">The syntax of every client-output-buffer-limit directive is the following :</span><br><span class="line"><span class="comment"># 每个client-output-buffer-limit指令的语法如下</span></span><br><span class="line">client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br><span class="line"></span><br><span class="line">A client is immediately disconnected once the hard limit is reached, or if</span><br><span class="line">the soft limit is reached and remains reached for the specified number of</span><br><span class="line">seconds (continuously).</span><br><span class="line">So for instance if the hard limit is 32 megabytes and the soft limit is</span><br><span class="line">16 megabytes / 10 seconds, the client will get disconnected immediately</span><br><span class="line">if the size of the output buffers reach 32 megabytes, but will also get</span><br><span class="line">disconnected if the client reaches 16 megabytes and continuously overcomes</span><br><span class="line">the limit for 10 seconds.</span><br><span class="line"><span class="comment"># 一旦达到硬限制，或者达到软限制并在指定的秒数内（连续）保持达到此限制，客户端将立即断开连接。因此，例如，如果硬限制为32兆字节，软限制为16兆字节10秒，则如果输出缓冲区的大小达到32兆字节，客户端将立即断开连接，但是如果客户端达到16兆字节并连续不断，连接也会断开连接超过极限10秒</span></span><br><span class="line">By default normal clients are not limited because they don&#x27;t receive data</span><br><span class="line">without asking (in a push way), but just after a request, so only</span><br><span class="line">asynchronous clients may create a scenario where data is requested faster</span><br><span class="line">than it can read.</span><br><span class="line"><span class="comment"># 默认情况下，普通客户端不受限制，因为它们不会在不询问的情况下（以推送方式）接收数据，而是在请求之后才接收数据，因此，只有异步客户端才可能创建这样的场景：请求数据的速度比读取数据的速度快</span></span><br><span class="line">Instead there is a default limit for pubsub and replica clients, since</span><br><span class="line">subscribers and replicas receive data in a push fashion.</span><br><span class="line"><span class="comment"># 而是对pubsub和副本客户端有默认限制，因为订阅者和副本以推送方式接收数据</span></span><br><span class="line">Both the hard or the soft limit can be disabled by setting them to zero.</span><br><span class="line"><span class="comment"># 硬限制或软限制都可以通过将其设置为零来禁用</span></span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit replica 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line"></span><br><span class="line">Client query buffers accumulate new commands. They are limited to a fixed</span><br><span class="line">amount by default in order to avoid that a protocol desynchronization (for</span><br><span class="line">instance due to a bug in the client) will lead to unbound memory usage in</span><br><span class="line">the query buffer. However you can configure it here if you have very special</span><br><span class="line">needs, such us huge multi/exec requests or alike.</span><br><span class="line"><span class="comment"># 客户端查询缓冲区会累积新命令。默认情况下，它们被限制为固定数量，以避免协议不同步（例如，由于客户端中的错误）将导致查询缓冲区中的未绑定内存使用。但是，如果您有非常特殊的需求（例如我们巨大的multiexec请求等），则可以在此处进行配置。</span></span><br><span class="line">client-query-buffer-limit 1gb</span><br><span class="line"></span><br><span class="line">In the Redis protocol, bulk requests, that are, elements representing single</span><br><span class="line">strings, are normally limited to 512 mb. However you can change this limit</span><br><span class="line">here, but must be 1mb or greater</span><br><span class="line"><span class="comment"># 在Redis协议中，批量请求（即表示单个字符串的元素）通常限制为512 mb。但是，您可以在此处更改此限制，但必须为1mb或更大</span></span><br><span class="line">proto-max-bulk-len 512mb</span><br><span class="line"></span><br><span class="line">Redis calls an internal function to perform many background tasks, like</span><br><span class="line">closing connections of clients in timeout, purging expired keys that are</span><br><span class="line">never requested, and so forth.</span><br><span class="line"><span class="comment"># Redis调用内部函数来执行许多后台任务，例如在超时时关闭客户端连接，清除从未请求的过期密钥等</span></span><br><span class="line">Not all tasks are performed with the same frequency, but Redis checks for</span><br><span class="line">tasks to perform according to the specified &quot;hz&quot; value.</span><br><span class="line"><span class="comment"># 并非所有任务都以相同的频率执行，但是Redis会根据指定的“ hz”值检查要执行的任务</span></span><br><span class="line">By default &quot;hz&quot; is set to 10. Raising the value will use more CPU when</span><br><span class="line">Redis is idle, but at the same time will make Redis more responsive when</span><br><span class="line">there are many keys expiring at the same time, and timeouts may be</span><br><span class="line">handled with more precision.</span><br><span class="line"><span class="comment"># 默认情况下，“ hz”设置为10。提高该值将在Redis空闲时使用更多的CPU，但是同时当有多个键同时到期时，它将使Redis的响应速度更快，并且可以使用更多的超时来处理精确</span></span><br><span class="line">The range is between 1 and 500, however a value over 100 is usually not</span><br><span class="line">a good idea. Most users should use the default of 10 and raise this up to</span><br><span class="line">100 only in environments where very low latency is required.</span><br><span class="line"><span class="comment"># 范围在1到500之间，但是值通常不超过100。大多数用户应该使用默认值10，并且仅在要求非常低延迟的环境中才将其提高到100</span></span><br><span class="line">hz 10</span><br><span class="line"></span><br><span class="line">Normally it is useful to have an HZ value which is proportional to the</span><br><span class="line">number of clients connected. This is useful in order, for instance, to</span><br><span class="line">avoid too many clients are processed for each background task invocation</span><br><span class="line">in order to avoid latency spikes.</span><br><span class="line"><span class="comment"># 通常，具有与连接的客户端数量成比例的HZ值很有用。例如，这有助于避免每次后台任务调用处理过多的客户端，从而避免延迟高峰</span></span><br><span class="line">Since the default HZ value by default is conservatively set to 10, Redis</span><br><span class="line">offers, and enables by default, the ability to use an adaptive HZ value</span><br><span class="line">which will temporarily raise when there are many connected clients.</span><br><span class="line"><span class="comment"># 由于默认的默认HZ值保守地设置为10，因此Redis提供并默认启用了使用自适应HZ值的能力，当有许多连接的客户端时，该值会暂时升高</span></span><br><span class="line">When dynamic HZ is enabled, the actual configured HZ will be used</span><br><span class="line">as a baseline, but multiples of the configured HZ value will be actually</span><br><span class="line">used as needed once more clients are connected. In this way an idle</span><br><span class="line">instance will use very little CPU time while a busy instance will be</span><br><span class="line">more responsive.</span><br><span class="line"><span class="comment"># 启用动态HZ后，实际配置的HZ将用作基准，但是一旦连接了更多客户端，实际将使用配置的HZ值的倍数。这样，空闲实例将占用很少的CPU时间，而忙碌的实例将具有更快的响应能力</span></span><br><span class="line">dynamic-hz yes</span><br><span class="line"></span><br><span class="line">When a child rewrites the AOF file, if the following option is enabled</span><br><span class="line">the file will be fsync-ed every 32 MB of data generated. This is useful</span><br><span class="line">in order to commit the file to the disk more incrementally and avoid</span><br><span class="line">big latency spikes.</span><br><span class="line"><span class="comment"># 当孩子重写AOF文件时，如果启用了以下选项，则每生成32 MB的数据，文件就会进行同步处理。这对于将文件更多地提交到磁盘并避免大的延迟峰值很有用。</span></span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line"></span><br><span class="line">When redis saves RDB file, if the following option is enabled</span><br><span class="line">the file will be fsync-ed every 32 MB of data generated. This is useful</span><br><span class="line">in order to commit the file to the disk more incrementally and avoid</span><br><span class="line">big latency spikes.</span><br><span class="line"><span class="comment"># 当redis保存RDB文件时，如果启用以下选项，则每生成32 MB数据将对文件进行fsync处理。这对于将文件更多地提交到磁盘并避免大的延迟峰值很有用。</span></span><br><span class="line">rdb-save-incremental-fsync yes</span><br><span class="line"></span><br><span class="line">Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good</span><br><span class="line">idea to start with the default settings and only change them after investigating</span><br><span class="line">how to improve the performances and how the keys LFU change over time, which</span><br><span class="line">is possible to inspect via the OBJECT FREQ command.</span><br><span class="line"><span class="comment"># 可以调整Redis LFU逐出（请参阅maxmemory设置）。但是，最好从默认设置开始，仅在研究了如何提高性能以及LFU密钥随时间变化后才进行更改，可以通过OBJECT FREQ命令进行检查。</span></span><br><span class="line">There are two tunable parameters in the Redis LFU implementation : the</span><br><span class="line">counter logarithm factor and the counter decay time. It is important to</span><br><span class="line">understand what the two parameters mean before changing them.</span><br><span class="line"><span class="comment"># Redis LFU实现中有两个可调参数：计数器对数因子和计数器衰减时间。重要的是在更改它们之前了解两个参数的含义</span></span><br><span class="line">The LFU counter is just 8 bits per key, it&#x27;s maximum value is 255, so Redis</span><br><span class="line">uses a probabilistic increment with logarithmic behavior. Given the value</span><br><span class="line">of the old counter, when a key is accessed, the counter is incremented in</span><br><span class="line">this way :</span><br><span class="line"><span class="comment"># LFU计数器每个密钥只有8位，最大值是255，因此Redis使用具有对数行为的概率增量。给定旧计数器的值，当访问键时，计数器以这种方式递增</span></span><br><span class="line">1. A random number R between 0 and 1 is extracted.</span><br><span class="line">2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).</span><br><span class="line">3. The counter is incremented only if R &lt; P.</span><br><span class="line"></span><br><span class="line">The default lfu-log-factor is 10. This is a table of how the frequency</span><br><span class="line">counter changes with a different number of accesses with different</span><br><span class="line">logarithmic factors :</span><br><span class="line"></span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| 0      | 104        | 255        | 255        | 255        | 255        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| 1      | 18         | 49         | 255        | 255        | 255        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| 10     | 10         | 18         | 142        | 255        | 255        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| 100    | 8          | 11         | 49         | 143        | 255        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line"></span><br><span class="line">NOTE : The above table was obtained by running the following commands:</span><br><span class="line"></span><br><span class="line">redis-benchmark -n 1000000 incr foo</span><br><span class="line">redis-cli object freq foo</span><br><span class="line"></span><br><span class="line">NOTE 2: The counter initial value is 5 in order to give new objects a chance</span><br><span class="line">      to accumulate hits.</span><br><span class="line"></span><br><span class="line">      The counter decay time is the time, in minutes, that must elapse in order</span><br><span class="line">      for the key counter to be divided by two (or decremented if it has a value</span><br><span class="line">      less &lt; = 10).</span><br><span class="line"></span><br><span class="line">      The default value for the lfu-decay-time is 1. A special value of 0 means to</span><br><span class="line">      decay the counter every time it happens to be scanned.</span><br><span class="line"></span><br><span class="line">lfu-log-factor 10</span><br><span class="line">lfu-decay-time 1</span><br></pre></td></tr></table></figure>
<h2 id="active-defragmentation"><a class="markdownIt-Anchor" href="#active-defragmentation"></a> ACTIVE DEFRAGMENTATION</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">ACTIVE DEFRAGMENTATION</span><br><span class="line"></span><br><span class="line">What is active defragmentation?</span><br><span class="line">-------------------------------</span><br><span class="line"></span><br><span class="line">Active (online) defragmentation allows a Redis server to compact the</span><br><span class="line">spaces left between small allocations and deallocations of data in memory,</span><br><span class="line">thus allowing to reclaim back memory.</span><br><span class="line"><span class="comment"># 通过主动（在线）碎片整理，Redis服务器可以压缩内存中小量分配和释放数据之间剩余的空间，从而允许回收内存</span></span><br><span class="line">Fragmentation is a natural process that happens with every allocator (but</span><br><span class="line">less so with Jemalloc, fortunately) and certain workloads. Normally a server</span><br><span class="line">restart is needed in order to lower the fragmentation, or at least to flush</span><br><span class="line">away all the data and create it again. However thanks to this feature</span><br><span class="line">implemented by Oran Agra for Redis 4.0 this process can happen at runtime</span><br><span class="line">in a &quot;hot&quot; way, while the server is running.</span><br><span class="line"><span class="comment"># 碎片是每个分配器（幸运的是，Jemalloc发生的情况）和某些工作负载都会发生的自然过程。通常，需要重新启动服务器以减少碎片，或者至少清除所有数据并重新创建。但是，由于Oran Agra为Redis 4.0实现了此功能，因此在服务器运行时，此过程可以在运行时以“热”方式进行</span></span><br><span class="line">Basically when the fragmentation is over a certain level (see the</span><br><span class="line">configuration options below) Redis will start to create new copies of the</span><br><span class="line">values in contiguous memory regions by exploiting certain specific Jemalloc</span><br><span class="line">features (in order to understand if an allocation is causing fragmentation</span><br><span class="line">and to allocate it in a better place), and at the same time, will release the</span><br><span class="line">old copies of the data. This process, repeated incrementally for all the keys</span><br><span class="line">will cause the fragmentation to drop back to normal values.</span><br><span class="line"><span class="comment"># 基本上，当碎片超过一定级别时（请参阅下面的配置选项），Redis将开始通过利用某些特定的Jemalloc功能在连续的内存区域中创建值的新副本（以便了解分配是否导致碎片并进行分配更好的位置），同时将释放数据的旧副本。对于所有键，以增量方式重复此过程将导致碎片恢复到正常值</span></span><br><span class="line">Important things to understand :</span><br><span class="line"></span><br><span class="line">1. This feature is disabled by default, and only works if you compiled Redis</span><br><span class="line">to use the copy of Jemalloc we ship with the source code of Redis.</span><br><span class="line">This is the default with Linux builds.</span><br><span class="line"><span class="comment"># 默认情况下，此功能是禁用的，并且仅当您编译Redis以使用我们随Redis的源代码提供的Jemalloc副本时才可用。这是Linux构建的默认设置</span></span><br><span class="line">2. You never need to enable this feature if you don&#x27;t have fragmentation</span><br><span class="line">issues.</span><br><span class="line"><span class="comment"># 如果没有碎片问题，则无需启用此功能</span></span><br><span class="line">3. Once you experience fragmentation, you can enable this feature when</span><br><span class="line">needed with the command &quot;CONFIG SET activedefrag yes&quot;.</span><br><span class="line"><span class="comment"># 遇到碎片之后，可以在需要时使用命令“ CONFIG SET activedefrag yes”启用此功能。</span></span><br><span class="line">The configuration parameters are able to fine tune the behavior of the</span><br><span class="line">defragmentation process. If you are not sure about what they mean it is</span><br><span class="line">a good idea to leave the defaults untouched.</span><br><span class="line"><span class="comment"># 配置参数能够微调碎片整理过程的行为。如果您不确定它们的含义，最好不要更改默认值</span></span><br><span class="line">Enabled active defragmentation</span><br><span class="line">activedefrag no</span><br><span class="line"></span><br><span class="line">Minimum amount of fragmentation waste to start active defrag</span><br><span class="line"><span class="comment"># 启动主动碎片整理的最小碎片废物量</span></span><br><span class="line">active-defrag-ignore-bytes 100mb</span><br><span class="line"></span><br><span class="line">Minimum percentage of fragmentation to start active defrag</span><br><span class="line"><span class="comment"># 启动主动碎片整理的最小碎片百分比</span></span><br><span class="line">active-defrag-threshold-lower 10</span><br><span class="line"></span><br><span class="line">Maximum percentage of fragmentation at which we use maximum effort</span><br><span class="line"><span class="comment"># 我们在最大程度地使用碎片的最大百分比</span></span><br><span class="line">active-defrag-threshold-upper 100</span><br><span class="line"></span><br><span class="line">Minimal effort for defrag in CPU percentage, to be used when the lower</span><br><span class="line">threshold is reached</span><br><span class="line"><span class="comment"># 达到下限阈值时使用的最小的CPU碎片整理工作</span></span><br><span class="line">active-defrag-cycle-min 1</span><br><span class="line"></span><br><span class="line">Maximal effort for defrag in CPU percentage, to be used when the upper</span><br><span class="line">threshold is reached</span><br><span class="line"><span class="comment"># 达到上限时使用的最大的CPU碎片整理工作</span></span><br><span class="line">active-defrag-cycle-max 25</span><br><span class="line"></span><br><span class="line">Maximum number of set/hash/zset/list fields that will be processed from</span><br><span class="line">the main dictionary scan</span><br><span class="line"><span class="comment"># 主字典扫描将处理的sethashzsetlist字段的最大数目</span></span><br><span class="line">active-defrag-max-scan-fields 1000</span><br><span class="line"></span><br><span class="line">Jemalloc background thread for purging will be enabled by default</span><br><span class="line"><span class="comment"># 默认情况下，将启用用于清除的Jemalloc后台线程</span></span><br><span class="line">jemalloc-bg-thread yes</span><br><span class="line"></span><br><span class="line">It is possible to pin different threads and processes of Redis to specific</span><br><span class="line">CPUs in your system, in order to maximize the performances of the server.</span><br><span class="line">This is useful both in order to pin different Redis threads in different</span><br><span class="line">CPUs, but also in order to make sure that multiple Redis instances running</span><br><span class="line">in the same host will be pinned to different CPUs.</span><br><span class="line"><span class="comment"># 可以将Redis的不同线程和进程固定到系统中的特定CPU，以最大化服务器的性能。这不仅有助于将不同的Redis线程固定在不同的CPU中，而且还可以确保将在同一主机中运行的多个Redis实例固定到不同的CPU。</span></span><br><span class="line"></span><br><span class="line">Normally you can do this using the &quot;taskset&quot; command, however it is also</span><br><span class="line">possible to this via Redis configuration directly, both in Linux and FreeBSD.</span><br><span class="line"><span class="comment"># 通常，您可以使用“ taskset”命令来执行此操作，但是在Linux和FreeBSD中，也可以直接通过Redis配置来执行此操作</span></span><br><span class="line">You can pin the server/IO threads, bio threads, aof rewrite child process, and</span><br><span class="line">the bgsave child process. The syntax to specify the cpu list is the same as</span><br><span class="line">the taskset command :</span><br><span class="line"><span class="comment"># 您可以固定serverIO线程，bio线程，aof重写子进程和bgsave子进程。指定cpu列表的语法与taskset命令相同</span></span><br><span class="line">Set redis server/io threads to cpu affinity 0,2,4,6 :</span><br><span class="line">server_cpulist 0-7 : 2</span><br><span class="line"></span><br><span class="line">Set bio threads to cpu affinity 1,3 :</span><br><span class="line"><span class="comment"># 将生物线程设置为cpu亲和力1,3</span></span><br><span class="line">bio_cpulist 1,3</span><br><span class="line"></span><br><span class="line">Set aof rewrite child process to cpu affinity 8,9,10,11 :</span><br><span class="line"><span class="comment"># 将aof重写子进程设置为cpu亲和力8,9,10,11</span></span><br><span class="line">aof_rewrite_cpulist 8-11</span><br><span class="line"></span><br><span class="line">Set bgsave child process to cpu affinity 1,10,11</span><br><span class="line"><span class="comment"># 将bgsave子进程设置为cpu亲和力1,10,11</span></span><br><span class="line">bgsave_cpulist 1,10-11</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>基本上，当碎片超过一定级别时（请参阅下面的配置选项），Redis将开始通过利用某些特定的Jemalloc功能在连续的内存区域中创建值的新副本（以便了解分配是否导致碎片并进行分配更好的位置），同时将释放数据的旧副本。对于所有键，以增量方式重复此过程将导致碎片恢复到正常值，默认情况下，此功能是禁用的，并且仅当您编译Redis以使用我们随Redis的源代码提供的Jemalloc副本时才可用。这是Linux构建的默认设置。如果没有碎片问题，则无需启用此功能</p>
<p>遇到碎片之后，可以在需要时使用命令“ CONFIG SET activedefrag yes”启用此功能。</p>
<p>Activedefrag 配置参数能够微调碎片整理过程的行为，默认为No active-defrag-ignore-bytes<br />
启动主动碎片整理的最小碎片废物量默认100mb active-defrag-threshold-lower:<br />
启动主动碎片整理的最小碎片百分比，默认10 active-defrag-cycle-min：达到下限阈值时使用的最小的CPU碎片整理工作，默认1<br />
active-defrag-cycle-max：达到上限时使用的最大的CPU碎片整理工作，默认25 active-defrag-max-scan-fields<br />
主字典扫描将处理的sethashzsetlist字段的最大数目，默认1000<br />
active-defrag-cycle-min：达到下限阈值时使用的最小的CPU碎片整理工作，默认1x</p>
]]></content>
      <categories>
        <category>redis</category>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>说透数据分析-DataAnalysis</title>
    <url>/39365.html</url>
    <content><![CDATA[<p>数据分析是一种研究数据的方法，它涉及到从数据中提取有用信息从而支持决策见解的过程。它包括*<br />
<em>数据收集、数据清洗、数据分析、数据可视化和结果报告</em>*。</p>
<blockquote>
<p>所有这些不同的方法主要基于两个核心思路：定量和定性分析。</p>
</blockquote>
<h2 id="数据分析的重要性"><a class="markdownIt-Anchor" href="#数据分析的重要性"></a> 数据分析的重要性</h2>
<p>明智的决策：从管理的角度来看，可以从分析数据中受益，因为它可以根据事实而不是简单的直觉做出决策。例如，您可以了解在哪里投资资金，检测增长机会，预测收入或在不常见的情况成为问题之前解决它们。<br /><br />
降本增效:<br />
借助预测分析等先进技术，企业可以发现数据中的改进机会、趋势和模式，并相应地规划策略。随着时间的推移，这将节省实施错误策略的资金和资源。不仅如此，通过预测销售和需求等不同场景，可以预测生产和供应。<br /><br />
更好的解决问题的方法：明智的决策更有可能成为成功的决策。数据为企业提供信息。可以看到这种进展正在走向何方。数据分析可帮助企业做出正确的选择并避免代价高昂的陷阱。<br /><br />
更准确的数据：如果您想做出明智的决策，需要数据，但还有更多。相关数据必须准确。数据分析可帮助企业获取相关、准确的信息，适合制定未来的营销策略、业务计划以及重新调整公司的愿景或使命。</p>
<h2 id="数据分析的对象"><a class="markdownIt-Anchor" href="#数据分析的对象"></a> 数据分析的对象</h2>
<p>按照数据的类型划分：文字、图片、音频、视频、元数据<br />按照数据的体量划分：大数据与小数据<br /><br />
按照数据的时间划分：实时数据与离线数据<br />按照数据的来源划分：机器数据与生物数据</p>
<h2 id="数据分析的类型"><a class="markdownIt-Anchor" href="#数据分析的类型"></a> 数据分析的类型</h2>
<h3 id="诊断分析"><a class="markdownIt-Anchor" href="#诊断分析"></a> 诊断分析</h3>
<blockquote>
<p>诊断分析回答“为什么会发生这种情况？”</p>
</blockquote>
<p>利用从统计分析中获得的见解，分析师使用诊断分析来识别数据中的模式。理想情况下，分析师会发现过去存在的类似模式，因此，使用这些解决方案有望解决当前的挑战。</p>
<h3 id="预测分析"><a class="markdownIt-Anchor" href="#预测分析"></a> 预测分析</h3>
<blockquote>
<p>预测分析回答“最有可能发生什么？”</p>
</blockquote>
<p>通过使用在旧数据和当前事件中发现的模式，分析师可以预测未来事件。虽然没有100%准确的预测，但如果分析师拥有大量详细信息和彻底研究它的纪律，那么几率就会提高。</p>
<h3 id="统计分析"><a class="markdownIt-Anchor" href="#统计分析"></a> 统计分析</h3>
<blockquote>
<p>统计分析回答“发生了什么？”</p>
</blockquote>
<p>此分析涵盖使用仪表板的数据收集、分析、建模、解释和演示。统计分析分为两个子类别：</p>
<ul>
<li>描述性：描述性统计分析适用于汇总数值数据的完整或精选。它说明了连续数据中的均值和偏差以及分类数据中的百分比和频率。</li>
<li>推理：推理分析适用于从完整数据派生的样本。分析师只需选择不同的抽样，就可以从相同的综合数据集中得</li>
<li>出不同的结论</li>
</ul>
<h3 id="文本分析"><a class="markdownIt-Anchor" href="#文本分析"></a> 文本分析</h3>
<p>它将原始数据转换为有用的业务信息。文本分析可以说是最直接、最直接的数据分析方法。</p>
<h3 id="规范性分析"><a class="markdownIt-Anchor" href="#规范性分析"></a> 规范性分析</h3>
<p>混合从其他数据分析类型中获得的所有见解，即可进行规范性分析。有时，仅使用一种分析类型无法解决问题，而是需要多个见解。</p>
<h2 id="数据分析的过程"><a class="markdownIt-Anchor" href="#数据分析的过程"></a> 数据分析的过程</h2>
<h3 id="提出与界限问题"><a class="markdownIt-Anchor" href="#提出与界限问题"></a> 提出与界限问题</h3>
<blockquote>
<p>问问自己为什么要进行此分析，要使用到的数据种类以及计划分析的数据。</p>
</blockquote>
<p>在数据分析之始，首先需要确定为什么需要它，需要它做什么。例如，客户对我们品牌的看法如何？或者哪种类型的包装对我们的潜在客户更具吸引力？概述问题后，您就可以进行下一步了。</p>
<h3 id="收集与采集数据"><a class="markdownIt-Anchor" href="#收集与采集数据"></a> 收集与采集数据</h3>
<blockquote>
<p>这里需要注意的是，在定量和定性方案中，您收集信息的方式会有所不同。</p>
</blockquote>
<p>收集来源包括案例研究、调查、访谈、问卷、直接观察和焦点小组。确保组织收集的数据进行分析。</p>
<h3 id="数据分析"><a class="markdownIt-Anchor" href="#数据分析"></a> 数据分析</h3>
<p>使用数据分析软件和其他工具来帮助您解释和理解数据并得出结论</p>
<ul>
<li>分析数据与验证数据</li>
<li>提出假设与验证假设</li>
<li>提出结论</li>
</ul>
<h3 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h3>
<p>解析数据分析结果，并提出最佳行动方案</p>
<h2 id="数据分析方法"><a class="markdownIt-Anchor" href="#数据分析方法"></a> 数据分析方法</h2>
<p>尽管有许多可用的数据分析方法，但它们都属于两种主要类型之一：定性分析与定量分析</p>
<h3 id="定性数据分析"><a class="markdownIt-Anchor" href="#定性数据分析"></a> 定性数据分析</h3>
<blockquote>
<p>通过文字、符号、图片和观察来获取数据。此方法不使用统计信息。最常见的定性方法包括：</p>
</blockquote>
<ul>
<li>内容分析，用于分析行为和语言数据。</li>
<li>叙事分析，用于处理从访谈、日记、调查中挑选的数据。</li>
<li>扎根理论，通过研究和推断一个或多个过去的案例来发展给定事件的因果解释。</li>
</ul>
<blockquote>
<p>演绎法。这种分析方法被已经对样本总体的可能输入有理论或预定想法的工程师师使用。演绎方法旨在收集能够有条不紊地准确地支持理论或假设的数据。<br />
归纳方法。在这种方法中，对样本总体结果知之甚少的工程师师收集有关感兴趣主题的适当和适当数量的数据。然后调查数据以寻找模式。目的是发展一种理论来解释数据中发现的模式。</p>
</blockquote>
<h3 id="定量数据分析"><a class="markdownIt-Anchor" href="#定量数据分析"></a> 定量数据分析</h3>
<blockquote>
<p>统计数据分析方法收集原始数据并将其处理成数值数据。定量分析方法包括：</p>
</blockquote>
<ul>
<li>假设检验，用于评估数据集或人口统计的给定假设或理论的真实性。</li>
<li>平均值或平均值通过将数字列表的总和除以列表中的项目数来确定主题的整体趋势。</li>
<li>样本量测定使用从较大人群中抽取并进行分析的小样本。所获得的结果被认为代表了整个机构。</li>
</ul>
<h3 id="常用数据分析方法"><a class="markdownIt-Anchor" href="#常用数据分析方法"></a> 常用数据分析方法</h3>
<p>聚类分析、同期群分析、回归分析、因子分析、神经网络<br />数据挖掘、文本分析、时间序列分析、决策树、联合分析</p>
<h2 id="数据分析质量标准"><a class="markdownIt-Anchor" href="#数据分析质量标准"></a> 数据分析质量标准</h2>
<blockquote>
<p>如何衡量结果的质量和有效性呢？</p>
</blockquote>
<h3 id="内部有效性"><a class="markdownIt-Anchor" href="#内部有效性"></a> 内部有效性</h3>
<p>如果调查结果衡量了他们应该衡量的内容，从而提供可信的结果，那么调查结果在内部是有效的。换句话说，内部有效性衡量结果的可信度，以及它们如何受到研究设计、操作定义、变量测量方式等因素的影响。例如，假设您正在接受采访，询问人们是否每天刷牙两次。虽然他们中的大多数人会回答是肯定的，但您仍然可以注意到他们的答案与社会可接受的答案相对应，即每天至少刷牙两次。在这种情况下，你不能100%确定受访者是否真的每天刷牙两次，或者他们只是说他们刷牙，因此，这次采访的内部有效性非常低。</p>
<h3 id="外部有效性"><a class="markdownIt-Anchor" href="#外部有效性"></a> 外部有效性</h3>
<p>从本质上讲，外部有效性是指研究结果可以应用于更广泛背景的程度。它基本上旨在证明研究结果可以应用于现实世界。如果研究可以应用于其他环境、个人和时代，那么外部有效性就很高。</p>
<h3 id="可靠性"><a class="markdownIt-Anchor" href="#可靠性"></a> 可靠性</h3>
<p>如果研究是可靠的，这意味着它可以被复制。如果在相同条件下重复测量，则会产生类似的结果。这意味着测量仪器始终如一地产生可靠的结果。</p>
<p>例如，假设医生构建了一份症状问卷来检测患者的特定疾病。然后，其他各种医生使用此问卷，但最终诊断出患有不同病情的同一患者。这意味着问卷对于检测初始疾病并不可靠。这里另一个重要的注意事项是，为了使您的研究可靠，它还需要客观。如果研究结果相同，与评估或解释它们的人无关，该研究可以被认为是可靠的。现在让我们更详细地了解客观性标准。</p>
<h3 id="客观性"><a class="markdownIt-Anchor" href="#客观性"></a> 客观性</h3>
<p>在数据科学中，客观性意味着研究人员在分析时需要保持完全客观。研究结果需要受到客观标准的影响，而不是受研究人员的信仰、个性或价值观的影响。当您收集数据时，需要确保客观性<br /></p>
<p>例如，在采访个人时，需要以不影响结果的方式提出问题。除此之外，在解释数据时还需要考虑客观性。如果不同的研究人员得出相同的结论，那么这项研究是客观的。对于最后一点，您可以设置预定义的标准来解释结果，以确保所有研究人员都遵循相同的步骤。</p>
<h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3>
<p>质量标准主要涵盖定量背景下的潜在影响。定性研究中的分析默认具有额外的主观影响，必须以不同的方式进行控制。因此，这类研究还有其他质量标准，例如可信度、可转移性、可靠性和可确认性。</p>
<h2 id="数据分析的限制与障碍"><a class="markdownIt-Anchor" href="#数据分析的限制与障碍"></a> 数据分析的限制与障碍</h2>
<blockquote>
<p>分析数据并非易事。需要应用许多步骤和技术才能从研究中提取有用的信息。虽然执行良好的分析可以为您的组织带来各种好处，但它并非没有限制。</p>
</blockquote>
<h3 id="客观性-2"><a class="markdownIt-Anchor" href="#客观性-2"></a> 客观性</h3>
<p>在研究中进行数据分析的最大障碍之一是保持客观。当试图证明一个假设时，研究人员可能会发现自己有意或无意地将结果引向他们想要的结果。为避免这种情况，请始终质疑假设，避免将事实与观点混淆。还可以向研究合作伙伴或外部人员展示您的发现，以确认结果是客观的</p>
<h3 id="有缺陷的相关性"><a class="markdownIt-Anchor" href="#有缺陷的相关性"></a> 有缺陷的相关性</h3>
<p>误导性的统计数据会严重损害研究。当两个变量看起来彼此相关但事实并非如此时，就会发生有缺陷的相关性。将相关性与因果关系混淆会导致对结果的错误解释，从而导致制定错误的策略和资源损失，因此，识别不同的解释错误并避免它们非常重要。</p>
<h3 id="隐私问题"><a class="markdownIt-Anchor" href="#隐私问题"></a> 隐私问题</h3>
<p>在某些情况下，数据收集可能受到隐私法规的约束。企业从客户那里收集各种信息，从购买行为到地址和电话号码。如果由于违规行为而落入坏人之手，则可能会影响客户的安全性和机密性。为避免此问题，只需收集研究所需的数据，如果您使用的是敏感事实，请将其匿名，以便保护客户。滥用客户数据会严重损害企业的声誉，因此密切关注隐私非常重要。</p>
<h3 id="团队之间缺乏沟通"><a class="markdownIt-Anchor" href="#团队之间缺乏沟通"></a> 团队之间缺乏沟通</h3>
<p>在业务层面进行数据分析时，每个部门和团队很可能会有不同的目标和策略。但是，他们都在为同一个共同目标而努力，即帮助业务顺利运行并保持增长。当团队没有联系和相互沟通时，它会直接影响一般策略的构建方式。为了避免这些问题，数据仪表板等工具使团队能够以视觉上吸引人的方式通过数据保持联系。</p>
<h2 id="附录数据分析工具"><a class="markdownIt-Anchor" href="#附录数据分析工具"></a> 附录：数据分析工具</h2>
<p>Excel、Python、R、Spark、SAS、SPSS、Sequentum<br />
Enterprise、Datapine、Looker、KNIME、Lexalytics、RapidMiner、OpenRefine、Talend、NodeXL</p>
<blockquote>
<p>未说但重要，数据提取工具，譬如SQL</p>
</blockquote>
<h2 id="refer"><a class="markdownIt-Anchor" href="#refer"></a> Refer</h2>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2ltcGxpbGVhcm4uY29tL2RhdGEtYW5hbHlzaXMtbWV0aG9kcy1wcm9jZXNzLXR5cGVzLWFydGljbGU=">What is Data Analysis? Methods, Process and Types Explained<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGF0YXBpbmUuY29tL2Jsb2cvZGF0YS1hbmFseXNpcy1tZXRob2RzLWFuZC10ZWNobmlxdWVz">Your Modern Business Guide To Data Analysis Methods And Techniques<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>数据科学</category>
        <category>Data-Analysis</category>
        <category>Data-Science</category>
      </categories>
      <tags>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>调试与反调试</title>
    <url>/30883.html</url>
    <content><![CDATA[<h1 id="调试与反调试"><a class="markdownIt-Anchor" href="#调试与反调试"></a> 调试与反调试</h1>
<p>相信各位如果从事爬虫开发、反爬虫开发、逆向工程师及相关岗位的开发，一定逃不开调试、反调试。那调试与反调是什么呢？以下为浏览器为例</p>
<p>调试：自然就是为了分析获取某关键加密参数，便对于目标网站的JS进行分析。</p>
<p>反调试：为了参数更加安全，更加难以破解。在合适处增加障碍增强调试难度</p>
<p>简单来说调试就是为了获取对应的加密参数，而反调试是为了不那么容易调试，增加调试难度。</p>
<p>反调试可以分为调试检测、调试陷阱，而反反调试是伪装，是绕过。</p>
<span id="more"></span>
<h2 id="反调试常见手段"><a class="markdownIt-Anchor" href="#反调试常见手段"></a> 反调试常见手段</h2>
<p>反调试无论具体实现何种方法进行反调试 如无限debugger、内存爆破、投毒、删文件、脏话等。这都离不开一入口—— *<br />
<em>调试检测</em>*<br />
，反过来思考反调试是为了区分正常用户与开发者人员都一种方式，那么如果可以检测到开发者调试那么就可以对其进行相关的操作。</p>
<h3 id="调试检测"><a class="markdownIt-Anchor" href="#调试检测"></a> 调试检测</h3>
<p>调试检测的方案有很多，只要一经出发便可反制调试者。常用的检测方案如下</p>
<h4 id="控制台检测"><a class="markdownIt-Anchor" href="#控制台检测"></a> 控制台检测</h4>
<h5 id="检测控制台检测的原理"><a class="markdownIt-Anchor" href="#检测控制台检测的原理"></a> 检测控制台检测的原理</h5>
<ul>
<li>
<p>隐式的调用元素id</p>
</li>
<li>
<p>隐式的调用RegExp的tostring方法</p>
</li>
<li>
<p>console，打开控制台console运行，否则不执行</p>
</li>
<li>
<p>浏览器窗口内外高度差</p>
</li>
</ul>
<blockquote>
<p>打开内置的chrome devtools 将造成高度差不一致</p>
</blockquote>
<h4 id="格式化检测"><a class="markdownIt-Anchor" href="#格式化检测"></a> 格式化检测</h4>
<p>格式化检测也很实现原理也很简单，调用RegExp匹配相关部分代码</p>
<blockquote>
<p>一般情况下目标服务器下发的JS为经过压缩。而调试者为了便于调试一般会对代码进行格式化，一旦检测点被格式化便可被RegExp检测</p>
</blockquote>
<h3 id="hook检测"><a class="markdownIt-Anchor" href="#hook检测"></a> Hook检测</h3>
<p>函数检测：采集调用 toString 方法对内容进行校验（伪造 toString 方法即可绕过）</p>
<p>对象检测：通过 <code>Object.defineProperty</code> 方法修改属性是不可更改的（可复写 debugger 即可）</p>
<h3 id="浏览器与浏览器指纹检测"><a class="markdownIt-Anchor" href="#浏览器与浏览器指纹检测"></a> 浏览器与浏览器指纹检测</h3>
<p>浏览器与浏览器指纹检测可检测的范围更广，更细致。具体请参考浏览器的相关api。</p>
<h4 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h4>
<p>调用时间差检测</p>
<blockquote>
<p>调试离不开debugger、断点，调用时间过长可视为被调试</p>
</blockquote>
<p>栈检测(在浏览器中可以使用caller获取调用栈)</p>
<blockquote>
<p>调试会打乱原有的调用栈</p>
</blockquote>
<p>tostings检测</p>
<blockquote>
<p>调试的时候难免遇到函数，习惯性的将鼠标放置在上面。hook Function toString可实现检测</p>
</blockquote>
<p>一切与“正常”执行相悖的都可作为检测点，也就是经常说的埋雷</p>
<h4 id="蜜罐"><a class="markdownIt-Anchor" href="#蜜罐"></a> 蜜罐</h4>
<p><strong>蜜罐</strong> 也就是咱们所常听见的蜜罐。简单来说就是给予或引导调试者进入虚假的环境</p>
<p>蜜罐相对较于以上<strong>被动的检测</strong>拥有更多的灵活性，相对来说更加主动，更加激进。且蜜罐更一种实现思路，具体实现具体情况具体分析</p>
<h2 id="调试陷阱"><a class="markdownIt-Anchor" href="#调试陷阱"></a> 调试陷阱</h2>
<p>当检测到开发者正在调试，那么下一步就是抵御。实现思路一般有三种</p>
<ol>
<li>拦截：</li>
</ol>
<h3 id="预防调试"><a class="markdownIt-Anchor" href="#预防调试"></a> 预防调试</h3>
<p>主要目的为防止调试者继续或者进入下一步调试，常见的方式有引入僵尸代码、控制流等方式。</p>
<h3 id="阻断调试"><a class="markdownIt-Anchor" href="#阻断调试"></a> 阻断调试</h3>
<p>较于拦截，阻断调试更加简单粗暴。常常伴随着无限循环。常见的实现方式有</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"><span class="keyword">while</span></span><br><span class="line">  <span class="keyword">while</span> (ture)</span><br><span class="line">    <span class="keyword">while</span> (大于<span class="number">0</span>的数)</span><br><span class="line">      <span class="keyword">while</span> (!![])</span><br><span class="line"></span><br><span class="line">          #</span><br><span class="line"><span class="keyword">for</span></span><br><span class="line">  <span class="keyword">for</span> (; ;)</span><br></pre></td></tr></table></figure>
<p>递归</p>
<p>多函数死循环互调等实现内存爆破</p>
<h3 id="破坏调试"><a class="markdownIt-Anchor" href="#破坏调试"></a> 破坏调试</h3>
<p>相对于阻断调试，会更加极端的手段，一方面对调试者信息进行采集、攻击调试者。例如删除文件、重置电脑、甚至释放病毒等</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>本节详细了解了检测与反调试，检测核心原理为区分代码运行环境是否一致、是否合理从而区分为正常运行还是调试运行。检测到后进行反调试，反调试一般主要体现在预防、阻断、破坏。而绕过的方案自然从检测入手，模拟环境、模拟运行时，从而进行绕过。</p>
]]></content>
      <categories>
        <category>spider</category>
        <category>crawler</category>
      </categories>
      <tags>
        <tag>data-acquisition</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈生活中那些与学习的事儿</title>
    <url>/32262.html</url>
    <content><![CDATA[<p>前几天有个公众号的小伙伴找到我，问到我<code>大佬大佬，你是怎么学习的啊</code><br />
，我的回答是<code>老大哥，俺也不知道啊。应该是先这样在这样然后在这样</code>(男性同胞啊)<br />
。那到底那样啊？说实话我真不知道，我还真的不晓得什么样的学习方法、为人处事，等等是正确的。如果你问我“有没有一招KO所有”，那我只能回答你“想啥呢？如果真的有为什么只能你会，对不对？”。有时候选择比努力更加重要，方法比努力重要。没有方向所有的风都是逆风，一个个的大佬叫着，说真的很多时候我比谁都尴尬，如履薄冰。害怕你问的问题，我也不会。毕竟俺也是挺平凡的一个靓仔(<br />
“呸，丑东西～”)</p>
<span id="more"></span>
<p>偏了偏了，咱们回到正题上其实说到学习方法、高效率有什么非常非常好的方法，说真的似乎还真的有。不过我想将我现目前所认知的所有告诉你，</p>
<p>说到这些我按照我目前所认知的归纳为三大部分，<code>高效率</code>、<code>时间管理</code>、<code>学习方法</code>、<code>如何分析</code><br />
，来吧来吧，看看我到底想对你说些什么呢？</p>
<h2 id="谈谈高效率"><a class="markdownIt-Anchor" href="#谈谈高效率"></a> 谈谈高效率</h2>
<blockquote>
<p>你所浪费的今天，是昨天死去的人奢望的明天。</p>
<p>你所厌恶的现在，正是未来的你回不去的曾经。</p>
</blockquote>
<p>时间总是公平的，你我的一天都只有24hour，一分不多一秒不少，如何合理的利用，高效的利用。高额的产出就成了我们都想突破思考的问题。那位独秀同学请先坐下，哥的容貌就比你帅一点点。这个是认真的，嘻嘻～。</p>
<p>首先我们来看这样的一个物理公式，效率 =<br />
输入功除以输出功，也就是投入与产出的比值。理论上讲一分耕耘一分收获。但实际上却并不一定是这样。阻挡我们“高产”的东西有很多，例如生活中的各种琐事、各种朋友圈、短视频、等等等等都耗费着那宝贵的时间</p>
<h4 id="全身心投入是高效率的开始"><a class="markdownIt-Anchor" href="#全身心投入是高效率的开始"></a> 全身心投入是高效率的开始</h4>
<p>说到全身心的投入，那自然离不开控制自己了。正因为生活中的琐事等等真的非常的多，以至于我们无法较为投入。我分享我几个感觉不错的建议</p>
<ul>
<li>放下手机</li>
<li>安静的环境</li>
<li>适宜的氛围</li>
</ul>
<p>放下手机，很好理解。手机静音，把手机放在不太容易看的见的地方，从而抑制看手机、玩手机的想法。将思维定在此时此刻想做的事上。朋友圈上隔壁王阿姨家的猫又生了几个崽，等下又去吃什么好吃的。微信上又有个小姐姐好漂亮，好可爱，怎么办，怎么办好喜欢，怎么办。关你什么事儿？做到雨女无瓜。对吧，有这样的感觉就nice。</p>
<p>选择、制造安静的环境，很多朋友啊真的是稍微有点动静就心猿意马，然后一大堆的想法就出来了。然后就似脱缰野马，未有归途。然后就没有然后了呗。脑子一想，这几分钟就过去了，眼睛一睁一闭着一天就过去了，眼睛一睁不闭这辈子就过去了。不知道你们是不是这样的，我就是了。所以控制不住自己受环境所影响的，那就选择，或者制造相对应的环境。让自己能够全身心投入那伟大神圣的事业</p>
<h3 id="人脑规律是高效率的进阶"><a class="markdownIt-Anchor" href="#人脑规律是高效率的进阶"></a> 人脑规律是高效率的进阶</h3>
<p>说到这个真的是玄之又玄的东西，早晨记忆力更好，下午思维逻辑更清晰。不知道你们是什么样的情况。我的脑子基本是符合这个神圣的定律。就比如我早晨的时候会看一些，技术文档、大佬的公众号、等等这些。效果真的非常不错。下午的话我会去攻克难题，无论上是项目上的，还是等等。如果在这“最清醒”的状态都搞不出来，那么平时也别想。当然每个人都情况会有所不同，具体视情况而定</p>
<h3 id="手脚并用是高效率的高阶"><a class="markdownIt-Anchor" href="#手脚并用是高效率的高阶"></a> 手脚并用是高效率的高阶</h3>
<p>这个其实说’五到’<br />
会更加适合，而并不是仅仅是手脚并用。你以为跑步呢。腿撒开跑，手撒开摇。这个并不是这样的。借用鲁迅先生的思想“五到”，眼到，口到，心到，手到，脑到。其实最重要的还是人到（手动狗头～）</p>
<p>眼到：集中在目标，不可看别处。</p>
<p>口到：认真读书，有感情。</p>
<p>心到：最重要便是心，用心去看去学，不可三心二意。</p>
<p>手到：做做批注，实际操作一下，在有感受后旁边写上自己的体会。</p>
<p>脑到：提出不懂的问题，善于思考,追根求源。</p>
<h2 id="谈谈学习方法"><a class="markdownIt-Anchor" href="#谈谈学习方法"></a> 谈谈学习方法</h2>
<p>说到非常可行的学习方法，其实真的很简单。相信大家也都听说过无数次了。<code>预习</code>，<code>学习</code>，<code>复习</code>。是不是so<br />
easy？哇唔，大道至简，我会了。</p>
<blockquote>
<p>屌丝逆袭，赢取白富美，出任CEO，走向人生巅峰的小手在向我召唤。我等下一不小心就成功了怎么办？</p>
<p>那我又只能告诉你，快醒醒。你以为你是万年难得一见的骨骼惊奇，头铁是吧？这才哪到哪啊，八字还没一撇呢，更别说捺了</p>
</blockquote>
<p>其实做到以上三点并不看起来的那么简单，真的是那种咫尺天涯，知易行难。</p>
<p>那么怎么样的学习方法才是较为正确，且高效率的呢？接下来让我们去了解一下“十步学习法”，真真实实的将预习、学习、复习精准落实起来。我个人感觉挺高效的，不过事先说明“十步学习法”并不是我发现、我创建的。不过我确实从中受益良多，话不多见，开干～</p>
<h3 id="十步学习法"><a class="markdownIt-Anchor" href="#十步学习法"></a> 十步学习法</h3>
<p><img data-src="https://img-blog.csdnimg.cn/20201025051513142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d6cDcwODE=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /></p>
<p>对于“十步学习法”的前六个步骤，我们需要集中精力完成足够多的前期调研，确保自己明确知道要学哪些内容，以及如何确认自己已达成目标。这六个步骤只需要针对将要学习的每个主题做一次。第<br />
7 步到第 10 步则要针对在第 5<br />
步所制定的学习计划中的每个模块重复。</p>
<p>虽然前六个步骤只需要做一次，但它们却是最重要的，因为它们将对我们未来的成败起决定性作用。在这六个步骤中，我们需要为自己实际的学习主题做好一切准备。</p>
<h4 id="第一步了解全局"><a class="markdownIt-Anchor" href="#第一步了解全局"></a> 第一步：了解全局</h4>
<p>我们要做的就是了解将要学习的主题的全局。这个主题宏观上是什么样的？</p>
<p>我们能够从中学到足够丰富的知识以了解自己认知以外的, 以及我们自己认知之外的有多少？</p>
<p>要完成这一步，对想要学的内容做一些基础性了解。</p>
<blockquote>
<p>关键词:广泛</p>
</blockquote>
<h4 id="第二步确定范围"><a class="markdownIt-Anchor" href="#第二步确定范围"></a> 第二步：确定范围</h4>
<p>当我们对自己所要学习的主题及其相关的知识都有了一个大致的了解后，此时需要集中精力去明确自己到底要学什么?</p>
<p>明确具体的范围是至关重要的，唯有这样才能了解项目的全局，以求做好相应的准备。</p>
<blockquote>
<p>关键词: 深度</p>
</blockquote>
<h4 id="第三步定义目标"><a class="markdownIt-Anchor" href="#第三步定义目标"></a> 第三步：定义目标</h4>
<p>在开始学习前，明确“成功”的<br />
含义极为重要。如果不知道成功是什么，很难找准目标，也很难知道自己什么时候已经真正达到目标。在尝试学习任何东西之前，我们都应该清晰清除的明白,完成之后我能完成什么样的事情?<br />
当知道自己的目标是什么的时候，就可以更轻松地使用倒推的方式，明确实现目标所需的步骤。</p>
<p>这一步的目标是形成一份简明清晰的陈述，勾勒出学习后的成功图景。好的成功标准应该是具体的，无二义性的.<br />
根据一\二步制定,绘出自己<code>成功</code>将能达到的实际效果.</p>
<blockquote>
<p>关键词: 具体</p>
</blockquote>
<h4 id="第四步寻找资源"><a class="markdownIt-Anchor" href="#第四步寻找资源"></a> 第四步：寻找资源</h4>
<p>要尝试收集到多种多样的资源以帮助我们学习，以求更加深入的了解此知识或技术</p>
<p>需要找到尽可能多的与自己所选主题相关的资源，此时可无需考虑这些资源的质量。</p>
<p>信息来源(不分先后)：</p>
<ul>
<li>
<p>专家</p>
</li>
<li>
<p>图书</p>
</li>
<li>
<p>源代码</p>
</li>
<li>
<p>示例项目</p>
</li>
<li>
<p>博客文章</p>
</li>
<li>
<p>在线视频</p>
</li>
<li>
<p>在线文档</p>
</li>
<li>
<p>… …</p>
</li>
</ul>
<blockquote>
<p>关键词: 尋找</p>
</blockquote>
<h4 id="第五步创建学习计划"><a class="markdownIt-Anchor" href="#第五步创建学习计划"></a> 第五步：创建学习计划</h4>
<p>此時需创建相對應学习規劃。可以把学习路径类比成写书时的<strong>大纲</strong>。</p>
<p>打造自己的学习计划，一个好办法就是观察别人是如何教我们感兴趣的主题的。可以参考在第四步中搜集到的图书目录，如果<br />
5 位 以上的作者都把内容分解为相同的模块和顺序，那么就可以遵循这样的方法制订自己的学习计划。</p>
<blockquote>
<p>关键词: 大綱</p>
</blockquote>
<h4 id="第六步筛选资源"><a class="markdownIt-Anchor" href="#第六步筛选资源"></a> 第六步：筛选资源</h4>
<p>此時已经知道了要学什么及以什么顺序学，</p>
<p>將第四步中收集的全部资源瀏覽\篩選，找出哪些内容能够覆盖我们的学习计划，还应当看看评论，试着找出品质最高的资源。</p>
<blockquote>
<p>关键词: 篩選</p>
</blockquote>
<h4 id="第七步开始学习浅尝辄止"><a class="markdownIt-Anchor" href="#第七步开始学习浅尝辄止"></a> 第七步：开始学习，浅尝辄止</h4>
<p>大多数情況下在过程中会犯两类相對错误：</p>
<ul>
<li>第一类错误是在知之不多的情况下就盲目开始，即行动太快；</li>
<li>第二类错误是在行动之前准备太多，即行动太晚。</li>
</ul>
<p>要想在这两者之间取得平衡，我们掌握的知识要恰到好处，足以能够开始学习，但又不会多到让人无力探索，这样的学习效果是最佳的。</p>
<p>目标為获得足够多与所学主题相关的信息，从而能让我们可以开始学习，并在下一步中动手操作。</p>
<blockquote>
<p>关键词: 節奏</p>
</blockquote>
<h4 id="第八步动手操作边玩边学"><a class="markdownIt-Anchor" href="#第八步动手操作边玩边学"></a> 第八步：动手操作，边玩边学</h4>
<p>这一步中我们无需提前了解全部内容，要做的首要的一件事就是亲自操作和亲身体验。采用这种方法，可以通过探索和实践进行学习。</p>
<p>在操作过程中，我们的大脑自然地会产生各种问题：</p>
<ul>
<li>
<p>它是如何工作的？</p>
</li>
<li>
<p>如果我这么做，可能会发生什么？</p>
</li>
<li>
<p>我该如何解决这个问题？</p>
</li>
</ul>
<p>这些问题能够引导我们走向真正重要的方向。当我们回过头寻找问题的答案时，不只是这些问题迎刃而解，而且我们记得的东西要比学习的东西多很多.</p>
<blockquote>
<p>关键词: 思考</p>
</blockquote>
<h4 id="第九步全面掌握学以致用"><a class="markdownIt-Anchor" href="#第九步全面掌握学以致用"></a> 第九步：全面掌握，学以致用</h4>
<p>好奇心是学习特别是自学的重要组成部分。</p>
<p>这一步的目标就是让我们找回好奇心驱动的学习。在这一步，我们依然没有必要把收集到的所有资料都仔细地看一遍。只需要阅读或观看与当前所学相关的知识。最后，试着把自己正在学习的内容与最终目标关联起来。我们掌握的每个模块，都应该以某种方式推动你向着终极目标前进。</p>
<blockquote>
<p>關鍵詞:全面</p>
</blockquote>
<h4 id="第十步乐为人师融会贯通"><a class="markdownIt-Anchor" href="#第十步乐为人师融会贯通"></a> 第十步：乐为人师，融会贯通</h4>
<p>三人行,必有我師</p>
<p>走出自己的舒适区，将所学到的教给别人,爭取教會。要想确定你确实掌握了某些知识，这是唯一的办法；同时，在将自己所学介绍给他人时，这也是查缺补漏的好办法。</p>
<blockquote>
<p>關鍵詞: 學教</p>
</blockquote>
<h2 id="谈谈描述问题与解决问题"><a class="markdownIt-Anchor" href="#谈谈描述问题与解决问题"></a> 谈谈描述问题与解决问题</h2>
<p>其实描述问题我这个“八何分析法”是个非常不错的思路结构，如果你能够清晰的描述你的问题，无论是对于自己还是需要得到有效的帮助去解决问题都会事半功倍</p>
<h3 id="描述问题八何分析法"><a class="markdownIt-Anchor" href="#描述问题八何分析法"></a> 描述问题(八何分析法)</h3>
<p>What，Where，When，Who，Why，How，How much，How feel</p>
<ul>
<li>
<p>Why：为何----为什么要做？为什么要如此做（有没有更好的办法）？（做这项工作的原因或理由）</p>
</li>
<li>
<p>What：何事----什么事？做什么？准备什么？（即明确工作的内容和要达成的目标）</p>
</li>
<li>
<p>Where：何处----在何处着手进行最好？在哪里做？（工作发生的地点）？</p>
</li>
<li>
<p>When：何时----什么时候开始？什么时候完成？ 什么时候检查？（时间）</p>
</li>
<li>
<p>Who：何人----谁去做？ （由谁来承担、执行？）谁负责？谁来完成？（参加人、负责人）？</p>
</li>
<li>
<p>How：如何----如何做？如何提高效率？如何实施？方法怎样？（用什么方法进行）？</p>
</li>
<li>
<p>How much：何价----成本如何？达到怎样的效果（做到什么程度）？ 数量如果？质量水平如何？费用产出如何？</p>
</li>
<li>
<p>How feel：感觉–体验如何？开发者、使用者、领导最终的体验是否满意？</p>
</li>
</ul>
<p>概括：即为什么？是什么？何处？何时？由谁做？怎样做？成本多少？结果会怎样？也就是：要明确工作/任务的原因、内容、空间位置、时间、执行对象、方法、成本。加上工作结果（how<br />
do you feel）：工作结果预测，就成为5W3H。</p>
<p>这样可能会更加符合人脑记忆，时间(when)、地点（where）、人物（who）、what、why，How，How much，How feel</p>
<h3 id="问题分割及解决之道"><a class="markdownIt-Anchor" href="#问题分割及解决之道"></a> 问题分割及解决之道</h3>
<p>在能够清晰的描述问题之后，相信你对于问题出现的地方就有个大概的定位，那么接下来就是分割问题。剖析大问题成一个个小问题，解决一个个最后这个问题就能能够轻松的被解决。同时找到最佳解决方案。</p>
<p>比如我需要做个简单的学生管理系统，那么我们就可以分解出这样几个小问题。</p>
<ol>
<li>学生信息</li>
<li>管理账号</li>
<li>菜单栏目</li>
<li>实现功能
<ol>
<li>查看</li>
<li>添加</li>
<li>修改</li>
<li>删除</li>
<li>退出</li>
</ol>
</li>
</ol>
<p>这样是不是比完成学生管理系统好实现的多。那么我们只需要一个个实现以上几个功能就可以实现一个简单的学生管理系统了。so<br />
easy。当然这样还不足以上线，只能在本地跑一跑，玩一玩。那么如果真的做成项目的话。只需要一个个扩宽就可以了。</p>
<p>比如</p>
<p>学生信息,那么我们自然而然的想到数据库，又由于这写之间的关系。我个人是建议使用SQL数据库。后面数据量大了之后在进行分库分表，甚至SQL集群等等。这项目不就慢慢起来了么</p>
<p>菜单栏，这个就是个展示的面板嘛，抛到前端(主要是前端了)。然后在分割成什么主页啊，信息页啊。等等，这样是不是越来越大了</p>
<p>然后顺着这种思路，自然而然的从一个小的case到项目了</p>
<h2 id="谈谈如何规划"><a class="markdownIt-Anchor" href="#谈谈如何规划"></a> 谈谈如何规划</h2>
<p>说了那么多终于到了这里也终于到了取舍分离的阶段，一生中有很多事，大事小事。等等，那么如果做个区分，相信你我在未来的道路上会更加清晰明了。那么我们谈谈该如何规划、制定吧。</p>
<p>说到这个就不得不提一下，“四象限分析法”，如下图所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1gm7j0i3g5jj30cs0cs3yf.jpg" alt="" /></p>
<h3 id="界限"><a class="markdownIt-Anchor" href="#界限"></a> 界限</h3>
<p>第一象限</p>
<p>这个象限包含的是一些紧急而重要的事情，这一类的事情具有时间的紧迫性和影响的重要性，无法回避也不能拖延，必须首先处理优先解决。它表现为重大项目的谈判，重要的会议工作等。</p>
<p>第二象限</p>
<p>第二象限包含的事件是那些紧急但不重要的事情，这些事情很紧急但并不重要，因此这一象限的事件具有很大的欺骗性。很多人认识上有误区，认为紧急的事情都显得重要，实际上，像无谓的电话、附和别人期望的事、打麻将三缺一等事件都并不重要。这些不重要的事件往往因为它紧急，就会占据人们的很多宝贵时间。</p>
<p>第三象限</p>
<p>第三象限的事件大多是些琐碎的杂事，没有时间的紧迫性，没有任何的重要性，这种事件与时间的结合纯粹是在扼杀时间，是在浪费生命。发呆、上网、闲聊、游逛，这是饱食终日无所事事的人的生活方式。</p>
<p>第四象限</p>
<p>第四象限不同于第一象限，这一象限的事件不具有时间上的紧迫性，但是，它具有重大的影响，对于个人或者企业的存在和发展以及周围环境的建立维护，都具有重大的意义。</p>
<h3 id="关系"><a class="markdownIt-Anchor" href="#关系"></a> 关系</h3>
<p>1.优先解决第一象限</p>
<p>首先要有准确的判断能力，确定是既紧急又重要的事情，然后优先处理。</p>
<p>2.区分一二象限</p>
<p>第一象限和第二象限难以区分，第二象限对人们的欺骗性是最大的，它很紧急的事实造成了它很重要的假象，耗费了人们大量的时间。依据紧急与否是很难区分这两个象限的，要区分它们就必须借助另一标准，看这件事是否重要。也就是按照自己的人生目标和人生规划来衡量这件事的重要性。如果它重要就属于第一象限的内容；如果它不重要，就属于第二象限的内容。</p>
<p>3.投资第四象限</p>
<p>第一象限的事情重要而且紧急，由于时间原因人们往往不能做得很好。第四象限的事情很重要，而且会有充足的时间去准备，有充足的时间去做好。可见，投资第四象限，它的回报才是最大的。</p>
<p>4.放弃第三象限</p>
<p>第三象限都是既不重要也不紧急的琐事，但它们往往使人们难以脱身，所以人们经常会跌进第三象限而无法自拔。例如，玩游戏、看娱乐视频等，只要一玩起来就很难脱身，而且要耗费很长的时间才能达成结果。</p>
<h3 id="策略"><a class="markdownIt-Anchor" href="#策略"></a> 策略</h3>
<ol>
<li>马上做：如果你总是有紧急又重要的事情要做，说明你在时间管理上存在问题，设法减少它。</li>
<li>计划做：尽可能地把时间花在重要但不紧急（第四象限）的事情上，这样才能减少第一象限的工作量。</li>
<li>授权做：对于紧急但不重要的事情的处理原则是授权，让别人去做。</li>
<li>减少做：不重要也不紧急的事情尽量少做。</li>
</ol>
<p>其实说实话，很多东西都不是自己的，自己也是做一个总结吧。希望你我在人生的道路上一路高歌猛进，加油～</p>
<p>积跬Coder敬上 致辞</p>
]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
      <tags>
        <tag>技术杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>逆商</title>
    <url>/27329.html</url>
    <content><![CDATA[<h2 id="应对逆境时候的能力"><a class="markdownIt-Anchor" href="#应对逆境时候的能力"></a> – 应对逆境时候的能力</h2>
<p><strong>最害怕死亡的人是那些知道自己从未真正活过的人</strong>. – 梭罗</p>
<p><strong>一个人知道自己为什么而活，就可以忍受任何一种生活.</strong> --尼采</p>
<h2 id="什么是逆商"><a class="markdownIt-Anchor" href="#什么是逆商"></a> 什么是逆商？</h2>
<p>一种测量工具，可以让你相较于周围的人。一套哲学，一种生活方式。怎么样看待、应对“逆境”？</p>
<h3 id="core维度"><a class="markdownIt-Anchor" href="#core维度"></a> CORE维度</h3>
<ul>
<li>Control 掌控感</li>
<li>Ownership 担当力</li>
<li>Reach 影响度</li>
<li>Endurance 持续性</li>
</ul>
<p><strong>Control 掌控感</strong></p>
<p>所谓掌控感，是你对自己能力的确信。面对逆境时，你是否会变得束手无策？一旦你拥有掌控感，你会发现，无论遇到什么困难你都会抓住自己能够掌控的一部分。想拥有掌控感，首先就要坚信“没有什么做不到的事情”。有了这种想法，我们才会给大脑发出积极的信号，从而促进我们对问题采取措施，而不是手忙脚乱，陷入僵局。</p>
<p><strong>Ownership 担当力</strong></p>
<p>所谓担当力，是一个人对责任的担当能力。敢于主动担当责任的人往往具有更高的行动力。在遇到困境时，勇于担当责任的人更善于直面困境，寻找解决办法。责任意识让他们必须采取恰当的行动。也正因为如此，具有高担当力的人有更强的战胜逆境的能力。</p>
<p><strong>Reach 影响度</strong></p>
<p>所谓影响度，是困境对我们生活产生的影响。一个人逆商的高低，很大程度上取决于人处于困境时，是否被消磨斗志，丧失动力。逆商低的人会无限放大一件微不足道的小事，不断给大脑消极的暗示，甚至对自己的能力和产生怀疑。长时间处于这种思维状态中，日常生活会受到严重侵蚀，甚至产生心理疾病。</p>
<p><strong>Endurance 持续性</strong></p>
<p>所谓持续性，是逆境对于个体来说会持续多久。对于高逆商的人来说，一时处于困境之中并无大碍，他们永远相信，今天过去，明天会更美好。而低逆商的人会持续受到一次打击的影响，长时间活在逆境造成的阴影下。他们把失败的原因归结为一些不可变因素，如认定自己智力不如他人，从而放弃挣扎。久而久之，人会变得低迷懈怠，陷入死循环中。</p>
<h3 id="三大支柱"><a class="markdownIt-Anchor" href="#三大支柱"></a> 三大支柱</h3>
<ul>
<li>
<p>认知心理：ABCDE、</p>
<ul>
<li>习得性无助</li>
<li>归因理论和乐观精神</li>
<li>心理韧性</li>
<li>内外控倾向</li>
</ul>
</li>
<li>
<p>健康新论（心理神经免疫学）：传递情绪化学物质会影响人的身体健康</p>
</li>
<li>
<p>脑科学：习惯的神奇力量</p>
</li>
</ul>
<h2 id="为什么需要逆商"><a class="markdownIt-Anchor" href="#为什么需要逆商"></a> 为什么需要逆商？</h2>
<p><strong>人生不断的攀越逆境</strong></p>
<p>面对逆境的<strong>三种人</strong></p>
<ul>
<li>放弃者：只需要安逸</li>
<li>扎营者：努力过后的安逸</li>
<li>攀登者：一直前进</li>
</ul>
<h3 id="逆境来源"><a class="markdownIt-Anchor" href="#逆境来源"></a> 逆境来源</h3>
<p>社会、职场、个人</p>
<h3 id="危险的岔道"><a class="markdownIt-Anchor" href="#危险的岔道"></a> 危险的岔道</h3>
<p>停止努力，安于现状</p>
<p>寄托于科技</p>
<p>打击鸡血</p>
<p>无助 <code>- &gt;</code> 无望的绝望循环</p>
<h2 id="如何提高逆商"><a class="markdownIt-Anchor" href="#如何提高逆商"></a> 如何提高逆商？</h2>
<h3 id="lead工具"><a class="markdownIt-Anchor" href="#lead工具"></a> LEAD工具</h3>
<blockquote>
<p>利用LEAD工具增强掌控感，击退消极情绪</p>
</blockquote>
<p>LEAD是什么？</p>
<ul>
<li><strong>L</strong>isten 聆听（自己的逆境的反应）</li>
<li><strong>E</strong>xplore 探究（对结果的担当）</li>
<li><strong>A</strong>nalyze 分析</li>
<li><strong>D</strong>o 做点事情</li>
</ul>
<p>漏斗法：引导自己抵抗重大挫折 <code>-&gt;</code>  避开受害者心态 <code>-&gt;</code>  障碍物</p>
<p>分心法：停止恶化与蔓延  <code>-&gt;</code>  关注不相关的事物 <code>-&gt;</code>  弹走负面思想 <code>-&gt;</code>  积极干扰 <code>-&gt;</code>  运动改变状态</p>
<p>重塑法：明确目标 <code>-&gt;</code>  渺小化问题 <code>-&gt;</code>  帮助他人</p>
<h3 id="abcde"><a class="markdownIt-Anchor" href="#abcde"></a> <strong>ABCDE</strong></h3>
<p>A：Activating event</p>
<p>B：Belief</p>
<p>C：Consequence</p>
<p>D：Disputation</p>
<p>E：Energization</p>
]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
      <tags>
        <tag>技术杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑与思维</title>
    <url>/7487.html</url>
    <content><![CDATA[<ul>
<li>“你讲话要有逻辑！”</li>
<li>“你这逻辑不对！”</li>
<li>“你的底层逻辑是什么？”</li>
<li>“说说你的逻辑思维能力体现在哪儿？”</li>
</ul>
<p>见字如面, 我是Payne。在日常交流中，我们会频繁的使用“逻辑”这个词。但能够清晰的说出逻辑的定义（逻辑是什么）却少之又少，能够正确的掌握逻辑推理的人就更少了。<br />
对于大部分人来说，逻辑更像是一个“熟悉的陌生人”。</p>
<p>不得不说，逻辑学是一门非常复杂的学科，光《逻辑学导论》就有近千页，系统的介绍逻辑学并不是本次的目的，本次的主要目的是逻辑知识科普，旨在唤起大家的理性意识，<br />
能够掌握一些逻辑学的基本知识，具备一些逻辑思维能力。</p>
<ul>
<li>在面对“杠精”的时候，能发现对方的逻辑谬误</li>
<li>在思考问题的时候，能尽量做到逻辑完整</li>
<li>在沟通表达的时候，能尽量做到逻辑清晰</li>
<li>在获取信息的时候，能尽量做到去伪存真</li>
</ul>
<h2 id="逻辑的定义"><a class="markdownIt-Anchor" href="#逻辑的定义"></a> 逻辑的定义</h2>
<p>逻辑（logic），源自古典希腊语逻各斯（logos），最初的意思是“词语”或“言语”，（引申出意思“思维”或“推理”）。逻各斯，是古希腊哲学家赫拉克利特最早引入的<br />
哲学概念，古希腊哲学从探求世界本原问题开始，从泰勒斯的水本原（具象），认为水是万物之源，到赫拉克利特的逻各斯（抽象），再到柏拉图的理念论，完成了自然哲学到形而上学的发展。</p>
<p>简而言之，逻各斯是指可理解的一切规律，<strong>逻辑是指思维的规律和规则</strong>。</p>
<p>逻辑除了指思维规律，狭义上，也有逻辑学的含义，按照《逻辑学导论》中的定义，逻辑学是研究用于区分正确推理（inference）与不正确推理的方法和原理的学问。</p>
<p>相比较上面的教科书定义，我觉得芝本秀德在《深度思考法》中对逻辑的定义要更容易理解，书中这样写道“逻辑就是关系”。</p>
<p>我们说某人逻辑性太差，其实正是因为他们没有在想<strong>表达东西之间建立关系</strong><br />
。例如，对方说“今天的天气真不错。”我们认为，诸如“是啊，天气太好了”或者“天气让人心情都变好了”这样的回答是有逻辑性的。<br />
可是如果回答是“我肚子好饿啊”，那么这种答非所问，就完全不符合逻辑。</p>
<p><strong>所以说无逻辑就是没有建立起事物之间的正确关系，换句话说有逻辑就是能建立事物之间的正确关系。</strong></p>
<p>这个表述有一定的道理，因为逻辑学就是研究多个语句（sentence）之间推理是否正确的学问，所以从这个意义上来说，逻辑学就是研究语句之间关系的学问。不过，<br />
这个“关系”并不是都像“天气好”和“心情好”这样的显而易见，有些关系很复杂，有些关系很隐蔽，这就要借助更多逻辑学的知识来分析他们的有效性了。</p>
<p>不管怎样，从理解的角度来说，记住“逻辑就是关系”还是很有用的。</p>
<h3 id="古典逻辑"><a class="markdownIt-Anchor" href="#古典逻辑"></a> 古典逻辑</h3>
<p>古典逻辑（亚里斯多德逻辑）主要处理的是不同对象的类之间关系的论证。类是指共有某种特定属性的对象的汇集。 类与类之间的三种关联方式：</p>
<ul>
<li>全包含（wholly included）例如狗的类和哺乳动物的类。</li>
<li>部分包含（partially included）例如运动员的类和女人的类。</li>
<li>互斥（exclude），例如三角形的类和圆形的类。</li>
</ul>
<p>基于类和类之间的关系，有四种直言命题：</p>
<ul>
<li>全称肯定命题。所有S是P。例如所有政客都是说谎者。也叫A命题。</li>
<li>全称否定命题。没有S是P。例如没有政客是说谎者。叫E命题。</li>
<li>特称肯定命题。有S是P。例如有政客是说谎者。叫I命题。</li>
<li>特称否定命题。有S不是P。例如有政客不是说谎者。叫O命题。</li>
</ul>
<p>基于这些命题和谓项，组成了很多形式。古典逻辑学家很细致的研究了这些形式，总结出15个有效的三段论形式。</p>
<p>例如下面的论证：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">没有富人是游民，（E命题）</span><br><span class="line">所有律师都是富人，（A命题）</span><br><span class="line">所以，没有律师是游民。（E命题）</span><br></pre></td></tr></table></figure>
<p>因为这个论证形式是EAE-1，而EAE-1是15个有效论证形式之一，所以是一个有效论证。又因为其前提是真的，所以结论也是真的。</p>
<h3 id="符号逻辑"><a class="markdownIt-Anchor" href="#符号逻辑"></a> 符号逻辑</h3>
<p><strong>符号逻辑就是利用符号来表示逻辑中的各种概念与关系</strong>。1847年，英国数学家布尔发表了《逻辑的数学分析》，建立了“布尔代数”，并创造一套符号系统。布尔建立了<br />
一系列的运算法则，利用代数的方法研究逻辑问题，初步奠定了数理逻辑的基础。</p>
<p>目前，符号逻辑已经超出逻辑学的范畴，成为数学的一个分支，同时也是计算机科学的基础。</p>
<p>逻辑代数也叫做开关代数，它的基本运算是逻辑加、逻辑乘和逻辑非，也就是命题演算中的“或”、“与”、“非”，运算对象只有两个数 0和<br />
1，相当于命题演算中的“真”和“假”。逻辑代数的运算特点如同电路分析中的开和关、高电位和低电位、导电和截止等现象完全一样，都只有两种不同的状态，因此，它在电路分析中得到广泛的应用。</p>
<p>通过符号化和公式化，我们就可以对逻辑命题进行数学演算，比如符号~代表否定，因此 p=q 和 p=~~q<br />
是等价的，即双重否定等于肯定。同样，我们在计算机中的逻辑运算（与、或、非）也是完全符合符号逻辑的。</p>
<h2 id="逻辑思维"><a class="markdownIt-Anchor" href="#逻辑思维"></a> 逻辑思维</h2>
<p>逻辑思维包含基础三要素：</p>
<ul>
<li>概念</li>
<li>判断（在逻辑学中，也叫命题，英文是proposition）</li>
<li>推理（在逻辑学中，也叫论证，英文是argument）</li>
</ul>
<p>概念是思维的基本单位；通过概念对事物是否具有某种属性进行肯定或否定的回答，这就是判断；由一个或几个判断推出另一判断的思维形式，就是推理。</p>
<p>实际上一本书的逻辑也是包含这三个要素，如果你看过《如何阅读一本书》，里面提到的分析阅读，说的就是如何通过提炼一本书的关键字词（概念），关键句子（判断），<br />
以及关键论述（推理）来分析一本书的主旨。</p>
<p>所以逻辑思维的要义，就在于正确运用概念、判断、推理的思维形式。想要正确掌握逻辑思维，就必须从这三方面学起。</p>
<h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3>
<blockquote>
<p>概念是思维的基本单位，是反映事物本质属性或特有属性的思维形式。</p>
</blockquote>
<p>这个世界有很多事物，都是通过我们的思维去赋予它们意思或意义的，然后通过语言符号呈现出来。所以说，*<br />
<em>这些意思或意义，就是概念的思维内显形式。语言是概念的外显形式</em>*。</p>
<p>明晰概念可以说是我们了解事物的第一步。是我们学习、研究和讨论的基础。可以说认知水平越高的人，越能认识到概念的重要性。</p>
<p>在《批判性思维》中作者说学习一门课程应该从理解课程的最<strong>基本概念</strong>开始。<br />
比如在经济学中，“稀缺”是经济学中的基本概念，其它经济学概念都与这一中心概念有关：稀缺意味着我们任何一个人都不可能拥有所有想要的资源（稀缺的事实），我们<br />
想要得到一些东西必须先放弃另一些东西。</p>
<p>同样，在2016年11月9日下午，在北京举办的“朗润·格政”国家发展研究院论坛上，两位著名经济学家林毅夫和张维迎在北京大学朗润园进行了一场可以写入历史的辩论。</p>
<p>他们辩论的主题是“产业政策”。在辩论的开始很有意味，林毅夫首先开讲，在说完客套话后接着说：<br />
“在准备这个报告的时候，他们给我一个任务，**你在讲你的看法之前先定义一下什么是产业政策，我想定义是非常重要的，不然会各说各话，谈论过程当中就没有激情<br />
**”</p>
<blockquote>
<p>所以，提高我们的逻辑思维能力，要从懂清楚每一个概念所表达的具体内容（内涵和外延）开始。</p>
</blockquote>
<h3 id="判断"><a class="markdownIt-Anchor" href="#判断"></a> 判断</h3>
<blockquote>
<p>判断（也叫命题）是推理的建筑基块，一个判断就是一个断言（Assert），它断定了一个事情是这样或者不是这样。因此，每一个判断都是或真或假的。</p>
</blockquote>
<p>一个问题没有断言任何东西，就不是判断。“你知道下象棋吗？”这的确是一个句子，但没有做出关于这个世界的断定。一个命令（“快点！”）或者感叹（“我的天哪！”）也<br />
不是判断。 因为这些问题、命令和感叹都是非真且非假的。</p>
<p>判断一般都是用陈述句作为表达的，如“世界上的所有人都是善良的”。这是一句肯定判定。只要该判断符合对象的实际情况，这就是真的，反之就是假的。</p>
<p>判断是概念的展开，没有判断，就不能揭示和说明概念。同时，判断也是推理的前提，是正确运用各种推理的必要条件。</p>
<p>试想一下，“世界上的所有人都是善良的”这个判断，我们都知道是假的，否则这个世界就没有违法犯罪的人了。</p>
<p>由此，我们可以得出判断的两个重要特征：</p>
<ul>
<li>判断有肯定或者否定之分，可以有肯定判断和否定判断；</li>
<li>判断有真假之分，一个判断要么真要么假，不能非真非假；</li>
</ul>
<p>准确的运用判断，我们才能够进行正确的思考。而思考的形式，就是推理了。</p>
<h3 id="逻辑推理"><a class="markdownIt-Anchor" href="#逻辑推理"></a> 逻辑推理</h3>
<p>逻辑就是关系。所谓的推理，就是研究语句、判断、命题之间相互关系的学问</p>
<h2 id="逻辑推理方法"><a class="markdownIt-Anchor" href="#逻辑推理方法"></a> 逻辑推理方法</h2>
<p>逻辑推理方式多种多样，但也万变不离。简单可以分为演绎推理、归纳推理、溯因推理、类比推理、统计推理、因果推理、模拟推理等，这些推理方法各有特点，适用于不同的情境。</p>
<h3 id="演绎推理"><a class="markdownIt-Anchor" href="#演绎推理"></a> 演绎推理</h3>
<p>演绎推理旨在阐明前提和结论之间的关系，为评估演绎论证是否有效提供方法。 演绎推理是从一般原则出发，推导出特殊结论的过程。<br />
例如三段论、数学归纳法、反证法等。演绎推理属于必然性推理，即前提真且推理形式正确，则结论必然真。</p>
<p>例如，根据三段论，我们可以得出以下推理：所有人都会死亡（前提一），苏格拉底是人（前提二），因此苏格拉底会死亡（结论）。这个推理过程就是演绎推理。</p>
<h4 id="演绎推理局限性"><a class="markdownIt-Anchor" href="#演绎推理局限性"></a> 演绎推理局限性</h4>
<p>演绎推理的局限性在于它所依赖的前提必须是真实的。演绎推理是从一般原则出发，推导出特殊结论的过程。**如果前提是真实的，且推理形式正确，则结论必然真<br />
**。但是，如果前提不真实，那么演绎推理所得出的结论就可能不正确。</p>
<p>例如，根据三段论，我们可以得出以下推理：所有人都会死亡（前提一），苏格拉底是人（前提二），因此苏格拉底会死亡（结论）。这个推理过程是正确的，因为它<br />
所依赖的前提都是真实的。但是，如果我们改变前提一为“所有人都不会正常死亡”，那么演绎推理所得出的结论就不正确了。</p>
<p>因此，演绎推理所得出的结论的正确性取决于它所依赖的前提是否真实。</p>
<h4 id="提高演绎推理可靠性"><a class="markdownIt-Anchor" href="#提高演绎推理可靠性"></a> 提高演绎推理可靠性</h4>
<p>要提高演绎推理的可靠性，首先需要确保演绎推理所依赖的前提是真实的。可以通过观察、实验、查阅资料等方式来验证前提的真实性。<br />
其次，需要确保推理形式正确。可以使用逻辑学中的推理规则来检查推理形式是否正确。如果不确定推理形式是否正确，可以寻求专业人士的帮助。</p>
<p>此外，可以多做练习来提高演绎推理能力。通过不断练习，可以更好地掌握演绎推理的方法和技巧，从而提高演绎推理的可靠性。</p>
<p>总之，要提高演绎推理的可靠性，需要确保<strong>前提真实、推理形式正确，并且不断练习</strong>。</p>
<h4 id="演绎推理适用场景"><a class="markdownIt-Anchor" href="#演绎推理适用场景"></a> 演绎推理适用场景</h4>
<p>演绎推理适用于从一般原则推导出特殊结论的场景。它常用于数学、逻辑学、哲学等领域，也可以用于日常生活中的推理。<br />
例如，在数学中，我们可以使用演绎推理来证明定理。我们先假设定理的前提成立，然后根据已知的公理和定理，通过演绎推理推导出定理的结论。</p>
<p>在日常生活中，我们也可以使用演绎推理来解决问题。例如，如果我们知道所有的苹果都是水果（前提一），并且红富士是一种苹果（前提二），那么我们就可以通过演绎推理得出结论：红富士是一种水果。</p>
<p>总之，演绎推理适用于从一般原则推导出特殊结论的场景，可以帮助我们更好地理解和解决问题。</p>
<h3 id="归纳推理"><a class="markdownIt-Anchor" href="#归纳推理"></a> 归纳推理</h3>
<p>归纳推理是从特殊事实出发，总结出一般原则的过程。归纳是从特殊到一般的过程，属于合情推理。例如经验公式、物理学原理等。归纳推理属于或然性推理，即<br />
<strong>前提真且推理形式正确，但结论未必真</strong>。</p>
<p>例如，如果我们观察到许多只乌鸦都是黑色的，我们就可以通过归纳推理得出结论：所有的乌鸦都是黑色的。但是这个结论并不一定正确，因为我们并没有观察到所有的乌鸦，也许存在一只不是黑色的乌鸦。</p>
<h4 id="归纳推理的局限性"><a class="markdownIt-Anchor" href="#归纳推理的局限性"></a> 归纳推理的局限性</h4>
<p>归纳推理的局限性在于它所得出的结论并不一定正确。归纳推理是从特殊事实出发，总结出一般原则的过程。但是，由于我们无法观察到所有的特殊事实，所以归纳推理所得出的结论并不一定正确。</p>
<p>例如，如果我们观察到许多只乌鸦都是黑色的，我们就可以通过归纳推理得出结论：所有的乌鸦都是黑色的。但是这个结论并不一定正确，因为我们并没有观察到所有的乌鸦，也许存在一只不是黑色的乌鸦。</p>
<p>因此，归纳推理所得出的结论只能作为一个假设，需要进一步验证。归纳推理属于或然性推理，即前提真且推理形式正确，但结论未必真。</p>
<h4 id="提高归纳推理的可靠性"><a class="markdownIt-Anchor" href="#提高归纳推理的可靠性"></a> 提高归纳推理的可靠性</h4>
<p>要提高归纳推理的可靠性，可以采取以下几种方法：</p>
<ul>
<li>增加观察样本数量：归纳推理是从特殊事实出发，总结出一般原则的过程。因此，观察样本数量越多，归纳推理所得出的结论就越可靠。</li>
<li>确保观察样本具有代表性：观察样本应该具有代表性，能够反映整体情况。如果观察样本不具有代表性，那么归纳推理所得出的结论就可能不正确。</li>
<li>排除干扰因素：在进行归纳推理时，应该排除干扰因素的影响。如果存在干扰因素，那么归纳推理所得出的结论就可能不正确。</li>
<li>多角度观察：可以从多个角度进行观察，以获得更全面、更准确的信息。这样可以提高归纳推理的可靠性。</li>
</ul>
<p>总之，要提高归纳推理的可靠性，需要增加观察样本数量、确保观察样本具有代表性、排除干扰因素并且多角度观察。</p>
<h4 id="归纳推理适用场景"><a class="markdownIt-Anchor" href="#归纳推理适用场景"></a> 归纳推理适用场景</h4>
<p>归纳推理适用于从特殊事实总结出一般原则的场景。它常用于科学研究、统计分析、市场调查等领域，也可以用于日常生活中的推理。</p>
<p>例如，在科学研究中，我们可以通过观察大量的实验数据，使用归纳推理来总结出一般性规律。在统计分析中，我们可以通过分析大量的数据，使用归纳推理来总结出统计规律。</p>
<p>在日常生活中，我们也可以使用归纳推理来解决问题。例如，如果我们观察到许多只乌鸦都是黑色的，我们就可以通过归纳推理得出结论：所有的乌鸦都是黑色的。</p>
<p>总之，归纳推理适用于从特殊事实总结出一般原则的场景，可以帮助我们更好地理解和解决问题。</p>
<h3 id="溯因推理"><a class="markdownIt-Anchor" href="#溯因推理"></a> 溯因推理</h3>
<p>溯因推理是一种推理，涉及形成假设或解释来解释一组观察结果或事实。 它是为一组给定的数据生成可能的最佳解释的过程，即使该解释不一定被证明是正确的。<br />
与从一般原理或理论开始并从中得出特定结论的演绎和从特定观察开始并从中得出一般原理或理论的归纳相反，溯因推理从不完整或模棱两可的数据开始并试图填补空白<br />
通过构建一个合理的解释。</p>
<p>溯因推理常用于科学研究和调查，它可以帮助科学家根据有限或不完整的数据产生新的假设和理论。<br />
它还用于执法等领域，在这些领域中，调查人员可以根据现有证据使用绑架来生成有关犯罪的理论。</p>
<p>总的来说，溯因推理在帮助我们理解世界方面发挥着重要作用，它使我们能够对我们遇到的观察结果和事实做出合理的解释。</p>
<p>例如，当你早晨起来发现马路变湿了，你就会去寻找马路湿的原因。可能是昨晚下雨了，也可能是被洒水车淋湿的，这就是溯因推理。然后你会想到如果是下雨，那么房<br />
顶也会湿，然后观察房顶果然湿了，所以认为是下雨导致马路湿了。</p>
<blockquote>
<p>溯因推理是一种从事实推理到最佳解释的过程，可以帮助我们更好地理解和解决问题。</p>
</blockquote>
<h4 id="溯因推理局限性"><a class="markdownIt-Anchor" href="#溯因推理局限性"></a> 溯因推理局限性</h4>
<p>溯因推理的局限性在于它所得出的结论并不一定正确。溯因推理是从事实推理到最佳解释的过程，但是这个最佳解释并不一定是正确的。因为可能存在多种解释，而我们<br />
只能根据现有的信息选择最合适的解释。</p>
<p>例如，当你早晨起来发现马路变湿了，你就会去寻找马路湿的原因。可能是昨晚下雨了，也可能是被洒水车淋湿的，这就是溯因推理。然后你会想到如果是下雨，那么房<br />
顶也会湿，然后观察房顶果然湿了，所以认为是下雨导致马路湿了。但是这个结论并不一定正确，因为也许房顶湿是由于其他原因造成的。</p>
<p>因此，溯因推理所得出的结论只能作为一个假设，需要进一步验证。溯因推理属于或然性推理，即前提真且推理形式正确，但结论未必真。</p>
<h4 id="溯因推理适用场景"><a class="markdownIt-Anchor" href="#溯因推理适用场景"></a> 溯因推理适用场景</h4>
<p>溯因推理适用于从事实推理到最佳解释的场景。它常用于科学研究、医学诊断、刑侦推理等领域，也可以用于日常生活中的推理。</p>
<p>例如，在科学研究中，我们可以通过观察实验现象，使用溯因推理来推导出最佳解释。在医学诊断中，医生可以根据病人的症状，使用溯因推理来推断病因。</p>
<p>在日常生活中，我们也可以使用溯因推理来解决问题。例如，当你早晨起来发现马路变湿了，你就会去寻找马路湿的原因。可能是昨晚下雨了，也可能是被洒水车淋湿的，这就是溯因推理。</p>
<p>总之，溯因推理适用于从事实推理到最佳解释的场景，可以帮助我们更好地理解和解决问题。</p>
<h4 id="提高溯因推理的可靠性"><a class="markdownIt-Anchor" href="#提高溯因推理的可靠性"></a> 提高溯因推理的可靠性</h4>
<p>提高溯因推理的可靠性，可以采取以下措施：</p>
<ul>
<li>确保所分析的事件之间确实存在因果关系。</li>
<li>确保分析过程严谨，遵循逻辑规则。</li>
<li>检查推断出的原因是否与已知事实相符。</li>
</ul>
<h3 id="演绎推理与归纳推理的区别与联系"><a class="markdownIt-Anchor" href="#演绎推理与归纳推理的区别与联系"></a> 演绎推理与归纳推理的区别与联系</h3>
<p>归纳推理和演绎推理是两种不同的推理方法，它们之间既有区别又有联系。</p>
<ul>
<li>归纳推理是从特殊事实出发，总结出一般原则的过程。它属于或然性推理，即前提真且推理形式正确，但结论未必真。归纳推理常用于科学研究、统计分析、市场调查等领域。</li>
<li>演绎推理是从一般原则出发，推导出特殊结论的过程。它属于必然性推理，即前提真且推理形式正确，则结论必然真。演绎推理常用于数学、逻辑学、哲学等领域。</li>
</ul>
<p>归纳推理和演绎推理之间既有区别又有联系。它们都是推理方法，都可以帮助我们更好地理解和解决问题。但是它们的推理过程不同，适用于不同的情境。在实际应用中，归纳推理和演绎推理往往相辅相成，共同帮助我们更好地解决问题。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>无论是演绎推理还是归纳推理,亦或者溯因分析。将其放在结构化思维中体现形式无非是自顶向下亦或者自顶向上。从简至繁，由繁入简。</p>
<p>非常感谢你的阅读，更多精彩内容，欢迎我的公众号「积跬Coder」与我一起成长。</p>
]]></content>
      <categories>
        <category>逻辑</category>
        <category>思维</category>
        <category>推理</category>
      </categories>
      <tags>
        <tag>逻辑</tag>
        <tag>思维</tag>
        <tag>推理</tag>
      </tags>
  </entry>
  <entry>
    <title>雷电模拟器抓包配置</title>
    <url>/37065.html</url>
    <content><![CDATA[<h2 id="雷电模拟器抓包配置"><a class="markdownIt-Anchor" href="#雷电模拟器抓包配置"></a> 雷电模拟器抓包配置</h2>
<p>爬虫免不了抓包分析，当然也免不了中间转发相关的便捷操作。如果有一个稳定的、妥善的抓包环境。相信在爬虫开发中一定会事半功倍。</p>
<p>有真机当然是最好的，同时如果爬虫开发者并没有真机。那么模拟器变成为了不二之选。当然如果支持多开的话那就更好了。</p>
<p>业界比较知名的有</p>
<p>MuMu模拟器:<span class="exturl" data-url="aHR0cHM6Ly9tdW11LjE2My5jb20v">https://mumu.163.com/<i class="fa fa-external-link-alt"></i></span></p>
<p>雷电模拟器：<span class="exturl" data-url="aHR0cHM6Ly93d3cubGRtbnEuY29tLw==">https://www.ldmnq.com/<i class="fa fa-external-link-alt"></i></span></p>
<p>夜神模拟器：<span class="exturl" data-url="aHR0cHM6Ly93d3cueWVzaGVuLmNvbS8=">https://www.yeshen.com/<i class="fa fa-external-link-alt"></i></span></p>
<p>在开发爬虫的时候，我个人使用的比较多的的是雷电模拟器，因为他支持多开（虽然这之间有限制），以及抓包也有些问题。但奈何，它支持多开啊。配合 <span class="exturl" data-url="aHR0cHM6Ly93d3cubWl0bXByb3h5Lm9yZy8=">Mitmproxy<i class="fa fa-external-link-alt"></i></span><br />
的组件譬如<code>Mitmdump</code><br />
简直不要太舒服。</p>
<h3 id="雷电模拟器的安装"><a class="markdownIt-Anchor" href="#雷电模拟器的安装"></a> 雷电模拟器的安装</h3>
<p>首先进入官网， 如下图所示，<span class="exturl" data-url="aHR0cHM6Ly93d3cubGRtbnEuY29tLw==">https://www.ldmnq.com/<i class="fa fa-external-link-alt"></i></span></p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1lclkmpbjj224n0u0wu4.jpg" alt="image-20220425015741050" /></p>
<p>选择<span class="exturl" data-url="aHR0cHM6Ly93d3cubGRtbnEuY29tL290aGVyL3ZlcnNpb24taGlzdG9yeS1hbmQtcmVsZWFzZS1ub3Rlcy5odG1s">更新日志<i class="fa fa-external-link-alt"></i></span><br />
，寻找历史版本。笔者这里使用的是3.74 较为稳定。以及支持网桥。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1lcopronuj20gy0a4wen.jpg" alt="image-20220425020045161" /></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kbC5zb2Z0bWdyLnFxLmNvbS9vcmlnaW5hbC9nYW1lL2xkaW5zdF8zLjc0LjAuZXhl">https://dl.softmgr.qq.com/original/game/ldinst_3.74.0.exe<i class="fa fa-external-link-alt"></i></span></p>
<p>选择3.74版本，主要是由于新版本的网桥这个bug在修复。以及完善度如何，至今不敢恭维。so，就选择较为稳定的它。</p>
<blockquote>
<p>必须需要支持网桥，否则无法抓包。</p>
</blockquote>
<h2 id="抓包工具安装"><a class="markdownIt-Anchor" href="#抓包工具安装"></a> 抓包工具安装</h2>
<p>抓包工具这里没什么好讲的，常规常见的都都行。</p>
<p>fiddle：<span class="exturl" data-url="aHR0cHM6Ly93d3cudGVsZXJpay5jb20vZG93bmxvYWQvZmlkZGxlcg==">https://www.telerik.com/download/fiddler<i class="fa fa-external-link-alt"></i></span></p>
<p>Charles： <span class="exturl" data-url="aHR0cHM6Ly93d3cuY2hhcmxlc3Byb3h5LmNvbS8=">https://www.charlesproxy.com/<i class="fa fa-external-link-alt"></i></span></p>
<p>mitmproxy：<span class="exturl" data-url="aHR0cHM6Ly93d3cubWl0bXByb3h5Lm9yZy8=">https://www.mitmproxy.org/<i class="fa fa-external-link-alt"></i></span></p>
<p>都比较不错，具体选择那个请你酌情考虑。</p>
<h2 id="雷电模拟器抓包配置-2"><a class="markdownIt-Anchor" href="#雷电模拟器抓包配置-2"></a> 雷电模拟器抓包配置</h2>
<p>首先新建一个雷电模拟器，如下图所示。以及网桥设置如下。</p>
<p><strong>当然记得安装桥接的驱动</strong>。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1lcw8lt5wj20ui0u0juc.jpg" alt="image-20220425020758810" /></p>
<p>完成后，如下所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1lcy8j46pj20o60dygma.jpg" alt="image-20220425020954288" /></p>
<p>以Mitmproxy的证书为例子，如下</p>
<p>首先需要安装mitmproxy,执行如下命令（在此之前需要有Python环境）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install mitmproxy</span><br></pre></td></tr></table></figure>
<p>如果配置了环境变量的话，首次执行一下mitmproxy相关的命令（由于非Uinux，是没有mitmrpoxy的），所以执行<code>mitmweb</code>,<br />
我个人建议是添加对应的端口。命令如下所示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mitmweb -p 8088</span><br></pre></td></tr></table></figure>
<p>当然，我建议是8088，我习惯给他配置为mitm相关的抓包的端口。当然你可以选择其他的端口，当然后续操作就可能会有些许出入。</p>
<p>此时，进入<code>~.mitmproxy</code> 目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># windows</span></span><br><span class="line"><span class="built_in">cd</span> ~\.\.mitmproxy\</span><br><span class="line"><span class="comment"># mac or Linux</span></span><br><span class="line"><span class="built_in">cd</span> ~/.mitmproxy/</span><br></pre></td></tr></table></figure>
<p>使用<code>ls</code> 命令即可查看到相关的证书了！。我建议是**<span class="exturl" data-url="aHR0cDovL3huLS1taXRtLTRuNWZ0NHJuM2prNGp4d28xdzNlNDUwYWhqa205ZnV5di5pdA==">在这里寻找到证书而非mitm.it<i class="fa fa-external-link-alt"></i></span>,因为在手机上很有可能上不去<br />
**</p>
<h3 id="配置代理"><a class="markdownIt-Anchor" href="#配置代理"></a> 配置代理</h3>
<p>在配置证书前，我强烈建议你先配置好代理端口。这将大大到降低与简化后续的操作。由于模拟器都是采用的自生的网络。直接配置WI-FI即可。如下</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ldabzy52j20oa0rwdgj.jpg" alt="image-20220425022132093" /></p>
<p>点击修改网络，以及高级配置，同时将代理选择为手动。如下图所示</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ldaxdedej20la10a75t.jpg" alt="image-20220425022206837" /></p>
<p>端口在这里我设置为<code>8088</code>, 代理服务器主机名。你可以在终端中的<code>ifconfig</code> 或者<code>ipconfig</code>,中获取。在此便不再过多赘述。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ldbqbtpqj20kq0dk3z5.jpg" alt="image-20220425022253389" /></p>
<h3 id="配置证书"><a class="markdownIt-Anchor" href="#配置证书"></a> 配置证书</h3>
<p>在<code>~.mitmproxy</code>下将昵称为<code>mitmproxy-ca-cert.pem</code>的文件拖入到雷电模拟器中，如下图所示</p>
<blockquote>
<p>将该文件移动屏幕内，即可跳转到该目录</p>
</blockquote>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1lddqsvxpj21l20u0n25.jpg" alt="image-20220425022448328" /></p>
<p>开始配置证书，打开设置-&gt; 安全-&gt; 从SD卡安装 选择证书所在的目录。双击即可安装</p>
<p>在终端中运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mitmweb -p 8088</span><br></pre></td></tr></table></figure>
<p>浏览百度</p>
<p><img data-src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ldj2cgkdj21b80u0k22.jpg" alt="image-20220425022954673" /></p>
<p>至此，证书就已经安装完成啦</p>
<h3 id="android-7-及以上的版本抓包"><a class="markdownIt-Anchor" href="#android-7-及以上的版本抓包"></a> Android 7 及以上的版本抓包</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">mount -o rw,remount /system</span><br><span class="line"><span class="built_in">cp</span> /data/misc/user/0/cacerts-added/269953fb.0 /system/etc/security/cacerts/</span><br></pre></td></tr></table></figure>
<h2 id="referer"><a class="markdownIt-Anchor" href="#referer"></a> Referer</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhbG1lcjkvYXJ0aWNsZS9kZXRhaWxzLzExOTA2MjY2MA==">Android(4) Android7.0 配置系统证书<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>spider</category>
        <category>crawler</category>
      </categories>
      <tags>
        <tag>data-acquisition</tag>
      </tags>
  </entry>
  <entry>
    <title>风控概要</title>
    <url>/26693.html</url>
    <content><![CDATA[<h2 id="风控由来"><a class="markdownIt-Anchor" href="#风控由来"></a> 风控由来</h2>
<p>风险控制(简称&quot;风控&quot;)是个抽象的概念。风控最开始由趋利避害的需求主导，是为了规避不确定的风险而诞生得一种经验。这种经验通过和<br />
科学知识结合逐渐形成标准化、体系化的方法。</p>
<h2 id="何为风控"><a class="markdownIt-Anchor" href="#何为风控"></a> 何为风控</h2>
<p>在了解风控之前，非常有必要先了解风险。 从具体表现来看，风险又分为&quot;狭义风险&quot;和&quot;广义风险&quot;。</p>
<ul>
<li>狭义风险：损失的不确定性，说明风险只能表现出损失，没有从风控中获利得可能性</li>
<li>广义风险：成本或代价不确定，最终风险结果会出现损失、盈利、盈亏的可能</li>
</ul>
<p>风控则是指风险管理者采取各种措施和方法，减少或者消灭<strong>风险事件发生</strong>的各种可能性，减少风险事件发生时造成的损失。<br />
有效的风险控制，可以通过清晰地识别风险类型，采取多维的控制措施和方法，尽可能地避免风险的发生,并且减少风险发生造成的损失。</p>
<h2 id="风控目标"><a class="markdownIt-Anchor" href="#风控目标"></a> 风控目标</h2>
<p>风险控制是风险管理的一个流程，也是一种方法。任何风控行为都有一个特定的目标。很多时候风控目标都是以结果去定量的，认为能够减少损失的风控就是优秀的风控，显然这样的理解是狭隘的。<br />
风控的效力可以通过风控结果去定量，但是并不是减少损失的风控就是优秀的风控。风险和收益是紧密相关的，风控如果只考虑控制风险，忽略了权衡收益，最终可能本末倒置。很多投资、金融风险的控制就是如此，</p>
<h2 id="风控主要流程"><a class="markdownIt-Anchor" href="#风控主要流程"></a> 风控主要流程</h2>
<p>常用风险控制流程主要包括：风险识别、风险分析、风险决策、风险监控、风险优化</p>
<h3 id="风险识别"><a class="markdownIt-Anchor" href="#风险识别"></a> 风险识别</h3>
<p>在风险控制之前，必须先识别出风险事件才能对风险进行控制。识别风险就是对风险进行收集，需要明确风险的类型，风险在什么时候、什么地点发生，风险发生的机制，风险发生的条件等要素。</p>
<h3 id="风险分析"><a class="markdownIt-Anchor" href="#风险分析"></a> 风险分析</h3>
<p>风险识别完成之后，可以进行风险分析。风险分析是对未知风险事件的定位、可能性判断以及风险结果的确认。风险分析方法主要包括定性分析和定量分析，涉及两个维度：一是风险发生概率的分析，二是风险结果的分析。</p>
<ul>
<li>按照风险发生概率的高低，对风险发生可能性进行等级划分，可分为很易发生、较易发生、可能发生、较不易发生、不易发生。</li>
<li></li>
</ul>
<p>按照风险影响的大小，对风险结果进行等级划分，可分为影响特别大、影响大、影响较大、影响一般、影响小。结合风险发生概率、风险结果影响，运用风险的定性和定量分析，通过矩阵分析确认风险等级。表1-1是风险等级矩阵分析表。</p>
<p><img data-src="https://p.ipic.vip/n5gvaq.jpg" alt="图1-1 风险等级矩阵" /></p>
<h3 id="风险决策"><a class="markdownIt-Anchor" href="#风险决策"></a> 风险决策</h3>
<p>风险决策是指在将风险识别出来并且分析评估后，制定风险预防和缓解方案，发起风险降低行动。风险决策是风险控制的关键，优秀的风险预防、缓解方案可以很好地减少风险带来的损失。</p>
<h3 id="风险监控"><a class="markdownIt-Anchor" href="#风险监控"></a> 风险监控</h3>
<p>把风险决策投入降低风险行动中，就能够控制风险吗？风险控制的效果到底怎么样呢？为了评估风险控制的效果需要引入风险监控。风险监控是指对风险决策的能效和作用结果进行回溯，提炼出能够评估风险决策稳定性和作用质量的指标。例如在信贷风控业务中，对风控模型的监控是通过“首期逾期比例”“连续逾期超过90天”等指标进行判断的。</p>
<h3 id="风险优化"><a class="markdownIt-Anchor" href="#风险优化"></a> 风险优化</h3>
<p>风控优化是在成熟风险控制的前提下，对通过风险监控反馈出来的风控决策效果进行风控决策方案的优化调整，实现风险控制的循环迭代和持续优化。</p>
<h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2>
<p>在本文中，分别对风控得概念、目的、流程进行一一阐述。相信你对风控也有所了解了吧。虽说落地在实际中那就是另外的工作了，但万变不离其宗。</p>
<p>以终为始，方得始终。</p>
]]></content>
      <categories>
        <category>sec</category>
      </categories>
      <tags>
        <tag>sec</tag>
      </tags>
  </entry>
</search>
